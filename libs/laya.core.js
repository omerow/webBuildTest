window.Laya = (function (exports) {
    'use strict';

    class Config {
    }
    Config.isAntialias = true;
    Config.useWebGL2 = true;
    Config.matUseUBO = true;
    Config.enableUniformBufferObject = true;
    Config.FPS = 60;
    Config.useRetinalCanvas = false;
    Config.animationInterval = 50;
    Config.webGL2D_MeshAllocMaxMem = true;
    Config.defaultFontSize = 12;
    Config.defaultFont = "Arial";
    Config.isAlpha = false;
    Config.isDepth = false;
    Config.isfailIfMajorPerformanceCaveat = false;
    Config.powerPreference = "default";
    Config.premultipliedAlpha = true;
    Config.isStencil = true;
    Config.preserveDrawingBuffer = false;
    Config.printWebglOrder = false;
    Config.fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" };
    Config.fixedFrames = true;
    Config.destroyResourceImmediatelyDefault = true;
    Config.audioBufferCacheMaxSize = 5 * 1024 * 1024;
    const PlayerConfig = {};

    class MathUtils3D {
        static isZero(v) {
            return Math.abs(v) < MathUtils3D.zeroTolerance;
        }
        static nearEqual(n1, n2) {
            if (MathUtils3D.isZero(n1 - n2))
                return true;
            return false;
        }
        static fastInvSqrt(value) {
            if (MathUtils3D.isZero(value))
                return value;
            return 1.0 / Math.sqrt(value);
        }
    }
    MathUtils3D.zeroTolerance = 1e-6;
    MathUtils3D.MaxValue = 3.40282347e+38;
    MathUtils3D.MinValue = -3.40282347e+38;
    MathUtils3D.Deg2Rad = Math.PI / 180;

    class Vector4 {
        constructor(x = 0, y = 0, z = 0, w = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
            this.w = arr[offset + 3];
            return this;
        }
        toArray() {
            return [this.x, this.y, this.z, this.w];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
            arr[offset + 3] = this.w;
            return this;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
            return destObject;
        }
        clone() {
            var destVector4 = new Vector4();
            this.cloneTo(destVector4);
            return destVector4;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z, aw = a.w;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
            out.w = aw + t * (b.w - aw);
        }
        static transformByM4x4(vector4, m4x4, out) {
            var vx = vector4.x;
            var vy = vector4.y;
            var vz = vector4.z;
            var vw = vector4.w;
            var me = m4x4.elements;
            out.x = vx * me[0] + vy * me[4] + vz * me[8] + vw * me[12];
            out.y = vx * me[1] + vy * me[5] + vz * me[9] + vw * me[13];
            out.z = vx * me[2] + vy * me[6] + vz * me[10] + vw * me[14];
            out.w = vx * me[3] + vy * me[7] + vz * me[11] + vw * me[15];
        }
        static equals_(a, b) {
            return MathUtils3D.nearEqual(Math.abs(a.x), Math.abs(b.x)) && MathUtils3D.nearEqual(Math.abs(a.y), Math.abs(b.y)) && MathUtils3D.nearEqual(Math.abs(a.z), Math.abs(b.z)) && MathUtils3D.nearEqual(Math.abs(a.w), Math.abs(b.w));
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z) && MathUtils3D.nearEqual(a.w, b.w);
        }
        equal(value) {
            return Vector4.equals(this, value);
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        static normalize(s, out) {
            var len = s.length();
            if (len > 0) {
                var inverse = 1.0 / len;
                out.x = s.x * inverse;
                out.y = s.y * inverse;
                out.z = s.z * inverse;
                out.w = s.w * inverse;
            }
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            out.w = a.w + b.w;
        }
        static subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
            out.w = a.w - b.w;
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
            out.w = a.w * b.w;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
            out.w = a.w * b;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var w = value.w;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var mineW = min.w;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            var maxeW = max.w;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            w = (w > maxeW) ? maxeW : w;
            w = (w < mineW) ? mineW : w;
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
        }
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return (x * x) + (y * y) + (z * z) + (w * w);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            var w = value1.w - value2.w;
            return Math.sqrt((x * x) + (y * y) + (z * z) + (w * w));
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w);
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
            out.w = Math.min(a.w, b.w);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
            out.w = Math.max(a.w, b.w);
        }
    }
    Vector4.ZERO = new Vector4();
    Vector4.ONE = new Vector4(1.0, 1.0, 1.0, 1.0);
    Vector4.UnitX = new Vector4(1.0, 0.0, 0.0, 0.0);
    Vector4.UnitY = new Vector4(0.0, 1.0, 0.0, 0.0);
    Vector4.UnitZ = new Vector4(0.0, 0.0, 1.0, 0.0);
    Vector4.UnitW = new Vector4(0.0, 0.0, 0.0, 1.0);
    Vector4.TEMP = new Vector4(0.0, 0.0, 0.0, 0.0);

    class Vector3 {
        static distanceSquared(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return (x * x) + (y * y) + (z * z);
        }
        static distance(value1, value2) {
            var x = value1.x - value2.x;
            var y = value1.y - value2.y;
            var z = value1.z - value2.z;
            return Math.sqrt((x * x) + (y * y) + (z * z));
        }
        static min(a, b, out) {
            out.x = Math.min(a.x, b.x);
            out.y = Math.min(a.y, b.y);
            out.z = Math.min(a.z, b.z);
        }
        static max(a, b, out) {
            out.x = Math.max(a.x, b.x);
            out.y = Math.max(a.y, b.y);
            out.z = Math.max(a.z, b.z);
        }
        static transformQuat(source, rotation, out) {
            var x = source.x, y = source.y, z = source.z, qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static scalarLength(a) {
            var x = a.x, y = a.y, z = a.z;
            return Math.sqrt(x * x + y * y + z * z);
        }
        static scalarLengthSquared(a) {
            var x = a.x, y = a.y, z = a.z;
            return x * x + y * y + z * z;
        }
        static normalize(s, out) {
            var x = s.x, y = s.y, z = s.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
                out.z = z * len;
            }
        }
        static multiply(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
            out.z = a.z * b;
        }
        static lerp(a, b, t, out) {
            var ax = a.x, ay = a.y, az = a.z;
            out.x = ax + t * (b.x - ax);
            out.y = ay + t * (b.y - ay);
            out.z = az + t * (b.z - az);
        }
        static transformV3ToV3(vector, transform, result) {
            Vector3.transformV3ToV4(vector, transform, _tempVector4);
            result.x = _tempVector4.x;
            result.y = _tempVector4.y;
            result.z = _tempVector4.z;
        }
        static transformV3ToV4(vector, transform, result) {
            var vectorX = vector.x;
            var vectorY = vector.y;
            var vectorZ = vector.z;
            var transformElem = transform.elements;
            result.x = (vectorX * transformElem[0]) + (vectorY * transformElem[4]) + (vectorZ * transformElem[8]) + transformElem[12];
            result.y = (vectorX * transformElem[1]) + (vectorY * transformElem[5]) + (vectorZ * transformElem[9]) + transformElem[13];
            result.z = (vectorX * transformElem[2]) + (vectorY * transformElem[6]) + (vectorZ * transformElem[10]) + transformElem[14];
            result.w = (vectorX * transformElem[3]) + (vectorY * transformElem[7]) + (vectorZ * transformElem[11]) + transformElem[15];
        }
        static TransformNormal(normal, transform, result) {
            var normalX = normal.x;
            var normalY = normal.y;
            var normalZ = normal.z;
            var transformElem = transform.elements;
            result.x = (normalX * transformElem[0]) + (normalY * transformElem[4]) + (normalZ * transformElem[8]);
            result.y = (normalX * transformElem[1]) + (normalY * transformElem[5]) + (normalZ * transformElem[9]);
            result.z = (normalX * transformElem[2]) + (normalY * transformElem[6]) + (normalZ * transformElem[10]);
        }
        static transformCoordinate(coordinate, transform, result) {
            var coordinateX = coordinate.x;
            var coordinateY = coordinate.y;
            var coordinateZ = coordinate.z;
            var transformElem = transform.elements;
            var w = coordinateX * transformElem[3] + coordinateY * transformElem[7] + coordinateZ * transformElem[11] + transformElem[15];
            result.x = (coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8] + transformElem[12]) / w;
            result.y = (coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9] + transformElem[13]) / w;
            result.z = (coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10] + transformElem[14]) / w;
        }
        static Clamp(value, min, max, out) {
            var x = value.x;
            var y = value.y;
            var z = value.z;
            var mineX = min.x;
            var mineY = min.y;
            var mineZ = min.z;
            var maxeX = max.x;
            var maxeY = max.y;
            var maxeZ = max.z;
            x = (x > maxeX) ? maxeX : x;
            x = (x < mineX) ? mineX : x;
            y = (y > maxeY) ? maxeY : y;
            y = (y < mineY) ? mineY : y;
            z = (z > maxeZ) ? maxeZ : z;
            z = (z < mineZ) ? mineZ : z;
            out.x = x;
            out.y = y;
            out.z = z;
        }
        static add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
        }
        static subtract(a, b, o) {
            o.x = a.x - b.x;
            o.y = a.y - b.y;
            o.z = a.z - b.z;
        }
        static cross(a, b, o) {
            var ax = a.x, ay = a.y, az = a.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y) + (a.z * b.z);
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y) && MathUtils3D.nearEqual(a.z, b.z);
        }
        constructor(x = 0, y = 0, z = 0) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        equal(value) {
            return Vector3.equals(this, value);
        }
        setValue(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        set(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        }
        fromArray(arr, offset = 0) {
            this.x = arr[offset + 0];
            this.y = arr[offset + 1];
            this.z = arr[offset + 2];
        }
        toArray() {
            return [this.x, this.y, this.z];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.x;
            arr[offset + 1] = this.y;
            arr[offset + 2] = this.z;
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        lengthSquared() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        vsub(b, out) {
            out.x = this.x - b.x;
            out.y = this.y - b.y;
            out.z = this.z - b.z;
            return out;
        }
        vadd(b, out) {
            out.x = this.x + b.x;
            out.y = this.y + b.y;
            out.z = this.z + b.z;
            return out;
        }
        scale(s, out) {
            out.x = this.x * s;
            out.y = this.y * s;
            out.z = this.z * s;
            return out;
        }
        normalize() {
            let x = this.x, y = this.y, z = this.z;
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                this.x = x * len;
                this.y = y * len;
                this.z = z * len;
            }
            return this;
        }
        dot(b) {
            return (this.x * b.x) + (this.y * b.y) + (this.z * b.z);
        }
        cross(b, o) {
            var ax = this.x, ay = this.y, az = this.z, bx = b.x, by = b.y, bz = b.z;
            o.x = ay * bz - az * by;
            o.y = az * bx - ax * bz;
            o.z = ax * by - ay * bx;
            return o;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            return destObject;
        }
        clone() {
            var destVector3 = new Vector3();
            this.cloneTo(destVector3);
            return destVector3;
        }
        toDefault() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
        }
    }
    Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
    Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
    Vector3.NegativeUnitX = new Vector3(-1, 0, 0);
    Vector3.UnitX = new Vector3(1, 0, 0);
    Vector3.UnitY = new Vector3(0, 1, 0);
    Vector3.UnitZ = new Vector3(0, 0, 1);
    Vector3.ForwardRH = new Vector3(0, 0, -1);
    Vector3.ForwardLH = new Vector3(0, 0, 1);
    Vector3.Up = new Vector3(0, 1, 0);
    Vector3.TEMP = new Vector3();
    const _tempVector4 = new Vector4();

    class Config3D {
        static setResolution(width, height) {
            Config3D.customResolution = true;
            Config3D._resoluWidth = width;
            Config3D._resoluHeight = height;
        }
    }
    Config3D.enableDynamicBatch = true;
    Config3D.enableStaticBatch = true;
    Config3D.pixelRatio = 1;
    Config3D.customResolution = false;
    Config3D.defaultCacheRTMemory = 256;
    Config3D.defaultPhysicsMemory = 16;
    Config3D.enableMultiLight = true;
    Config3D.maxLightCount = 32;
    Config3D.lightClusterCount = new Vector3(12, 12, 12);
    Config3D.maxMorphTargetCount = 32;
    Config3D.useBVHCull = false;
    Config3D.BVH_max_SpatialCount = 7;
    Config3D.BVH_limit_size = 32;
    Config3D.BVH_Min_Build_nums = 10;
    Config3D._resoluWidth = -1;
    Config3D._resoluHeight = -1;
    Config3D.debugFrustumCulling = false;

    class ILaya {
    }
    ILaya.Laya = null;
    ILaya.Loader = null;
    ILaya.Context = null;
    ILaya.InputManager = null;
    ILaya.Scene3D = null;
    ILaya.Laya3D = null;
    ILaya.loader = null;
    ILaya.timer = null;
    ILaya.systemTimer = null;
    ILaya.physicsTimer = null;
    ILaya.stage = null;

    class Pool {
        static getPoolBySign(sign) {
            return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
        }
        static clearBySign(sign) {
            if (Pool._poolDic[sign])
                Pool._poolDic[sign].length = 0;
        }
        static recover(sign, item) {
            if (item[Pool.POOLSIGN])
                return;
            item[Pool.POOLSIGN] = true;
            Pool.getPoolBySign(sign).push(item);
        }
        static recoverByClass(instance) {
            if (instance) {
                var className = instance["__className"] || instance.constructor._$gid;
                if (className)
                    Pool.recover(className, instance);
            }
        }
        static _getClassSign(cla) {
            var className = cla["__className"] || cla["_$gid"];
            if (!className) {
                cla["_$gid"] = className = Pool._CLSID + "";
                Pool._CLSID++;
            }
            return className;
        }
        static createByClass(cls) {
            return Pool.getItemByClass(Pool._getClassSign(cls), cls);
        }
        static getItemByClass(sign, cls) {
            let rst;
            let pool = Pool.getPoolBySign(sign);
            if (pool.length)
                rst = pool.pop();
            else
                rst = new cls();
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItemByCreateFun(sign, createFun, caller = null) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : createFun.call(caller);
            rst[Pool.POOLSIGN] = false;
            return rst;
        }
        static getItem(sign) {
            var pool = Pool.getPoolBySign(sign);
            var rst = pool.length ? pool.pop() : null;
            if (rst) {
                rst[Pool.POOLSIGN] = false;
            }
            return rst;
        }
        static createPool(type, init, reset) {
            let p = new SimplePool();
            p._ct = type;
            p._init = init;
            p._reset = reset;
            return p;
        }
        static createPool2(create, init, reset) {
            let p = new SimplePool();
            p._create = create;
            p._init = init;
            p._reset = reset;
            return p;
        }
    }
    Pool._CLSID = 0;
    Pool.POOLSIGN = "__InPool";
    Pool._poolDic = {};
    class SimplePool {
        constructor() {
            this.pool = [];
        }
        take(...args) {
            let ret;
            if (this.pool.length > 0)
                ret = this.pool.pop();
            else if (this._create)
                ret = this._create();
            else
                ret = new this._ct();
            if (this._init)
                this._init(ret, ...args);
            return ret;
        }
        recover(element) {
            if (Array.isArray(element)) {
                for (let i = 0, n = element.length; i < n; i++) {
                    let e = element[i];
                    if (this._reset)
                        this._reset(e);
                    this.pool.push(e);
                }
                element.length = 0;
            }
            else {
                if (this._reset)
                    this._reset(element);
                this.pool.push(element);
            }
        }
    }

    class Point {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        static create() {
            return Pool.getItemByClass("Point", Point);
        }
        setTo(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        reset() {
            this.x = this.y = 0;
            return this;
        }
        recover() {
            Pool.recover("Point", this.reset());
        }
        distance(x, y) {
            return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
        }
        toString() {
            return this.x + "," + this.y;
        }
        normalize() {
            var d = Math.sqrt(this.x * this.x + this.y * this.y);
            if (d > 0) {
                var id = 1.0 / d;
                this.x *= id;
                this.y *= id;
            }
        }
        copy(point) {
            return this.setTo(point.x, point.y);
        }
    }
    Point.TEMP = new Point();
    Point.EMPTY = new Point();

    class Event {
        static isMouseEvent(type) {
            return MOUSE_EVENTS.has(type);
        }
        constructor() {
            this.touchId = 0;
            this.delta = 0;
            this.button = 0;
            this.touchPos = new Point();
        }
        setTo(type, currentTarget, target) {
            this.type = type;
            this.currentTarget = currentTarget;
            this.target = target;
            return this;
        }
        stopPropagation() {
            this._stopped = true;
        }
        preventDefault() {
            this._defaultPrevented = true;
        }
        get touches() {
            return this._touches;
        }
        get altKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.altKey;
        }
        get ctrlKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.ctrlKey;
        }
        get shiftKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.shiftKey;
        }
        get metaKey() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.metaKey;
        }
        get key() {
            return this.nativeEvent.key;
        }
        get keyCode() {
            return this.nativeEvent.keyCode;
        }
        get charCode() {
            var _a;
            return (_a = this.nativeEvent) === null || _a === void 0 ? void 0 : _a.code;
        }
        get keyLocation() {
            if (this.nativeEvent)
                return this.nativeEvent.location || this.nativeEvent.keyLocation;
            else
                return 0;
        }
        get stageX() {
            return this.touchPos.x;
        }
        get stageY() {
            return this.touchPos.y;
        }
    }
    Event.EMPTY = new Event();
    Event.MOUSE_DOWN = "mousedown";
    Event.MOUSE_UP = "mouseup";
    Event.RIGHT_MOUSE_DOWN = "rightmousedown";
    Event.RIGHT_MOUSE_UP = "rightmouseup";
    Event.CLICK = "click";
    Event.RIGHT_CLICK = "rightclick";
    Event.MOUSE_MOVE = "mousemove";
    Event.MOUSE_OVER = "mouseover";
    Event.MOUSE_OUT = "mouseout";
    Event.MOUSE_WHEEL = "mousewheel";
    Event.ROLL_OVER = "mouseover";
    Event.ROLL_OUT = "mouseout";
    Event.DOUBLE_CLICK = "doubleclick";
    Event.MOUSE_DRAG = "mousedrag";
    Event.MOUSE_DRAG_END = "mousedragend";
    Event.DRAG_START = "dragstart";
    Event.DRAG_MOVE = "dragmove";
    Event.DRAG_END = "dragend";
    Event.DROP = "drop";
    Event.KEY_DOWN = "keydown";
    Event.KEY_PRESS = "keypress";
    Event.KEY_UP = "keyup";
    Event.CHANGE = "change";
    Event.CHANGED = "changed";
    Event.MOVED = "moved";
    Event.WILL_RESIZE = "willResize";
    Event.RESIZE = "resize";
    Event.ADDED = "added";
    Event.REMOVED = "removed";
    Event.DISPLAY = "display";
    Event.UNDISPLAY = "undisplay";
    Event.ERROR = "error";
    Event.COMPLETE = "complete";
    Event.LOADED = "loaded";
    Event.READY = "ready";
    Event.PROGRESS = "progress";
    Event.INPUT = "input";
    Event.RENDER = "render";
    Event.OPEN = "open";
    Event.MESSAGE = "message";
    Event.CLOSE = "close";
    Event.FRAME = "enterframe";
    Event.ENTER = "enter";
    Event.SELECT = "select";
    Event.BLUR = "blur";
    Event.FOCUS = "focus";
    Event.VISIBILITY_CHANGE = "visibilitychange";
    Event.ORIENTATION_CHANGE = "orientationchange";
    Event.FOCUS_CHANGE = "focuschange";
    Event.PLAYED = "played";
    Event.PAUSED = "paused";
    Event.STOPPED = "stopped";
    Event.START = "start";
    Event.END = "end";
    Event.LINK = "link";
    Event.LABEL = "label";
    Event.FULL_SCREEN_CHANGE = "fullscreenchange";
    Event.DEVICE_LOST = "devicelost";
    Event.TRANSFORM_CHANGED = "transformchanged";
    Event.LAYER_CHANGE = "layerChange";
    Event.STATIC_MASK = "staticMask";
    Event.TRIGGER_ENTER = "triggerenter";
    Event.TRIGGER_STAY = "triggerstay";
    Event.TRIGGER_EXIT = "triggerexit";
    Event.COLLISION_ENTER = "collisionenter";
    Event.COLLISION_STAY = "collisionstay";
    Event.COLLISION_EXIT = "collisionexit";
    Event.JOINT_BREAK = "jointbreak";
    Event.UPDATE_PHY_EVENT_FILTER = "physics3dEventFilter";
    const MOUSE_EVENTS = new Set([
        Event.MOUSE_DOWN, Event.MOUSE_UP, Event.MOUSE_MOVE, Event.CLICK, Event.DOUBLE_CLICK,
        Event.RIGHT_CLICK, Event.RIGHT_MOUSE_DOWN, Event.RIGHT_MOUSE_UP,
        Event.MOUSE_OVER, Event.MOUSE_OUT, Event.MOUSE_WHEEL, Event.MOUSE_DRAG, Event.MOUSE_DRAG_END
    ]);

    class LayaEnv {
    }
    LayaEnv.version = "3.3.0-beta.4";
    LayaEnv.isPlaying = true;
    LayaEnv.isPreview = false;
    LayaEnv.isConch = window ? (window.conch != null) : false;
    LayaEnv.isEditor = false;

    class LayaGL {
    }

    const ColorMap = {
        "purple": 0x800080,
        "orange": 0xffa500,
        "white": 0xFFFFFF,
        "red": 0xFF0000,
        "green": 0x00FF00,
        "blue": 0x0000FF,
        "black": 0x000000,
        "yellow": 0xFFFF00,
        "gray": 0x808080
    };
    class Color {
        static hexToString(color) {
            tmpColor$1.parse(color);
            return tmpColor$1.toString();
        }
        static stringToHex(value) {
            tmpColor$1.parse(value);
            return tmpColor$1.getRGB();
        }
        static gammaToLinearSpace(value) {
            if (value <= 0.04045)
                return value / 12.92;
            else if (value < 1.0)
                return Math.pow((value + 0.055) / 1.055, 2.4);
            else
                return Math.pow(value, 2.4);
        }
        static linearToGammaSpace(value) {
            if (value <= 0.0)
                return 0.0;
            else if (value <= 0.0031308)
                return 12.92 * value;
            else if (value <= 1.0)
                return 1.055 * Math.pow(value, 0.41666) - 0.055;
            else
                return Math.pow(value, 0.41666);
        }
        constructor(r = 1, g = 1, b = 1, a = 1) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        equal(c) {
            if (!c)
                return false;
            const toFIxed = (a, b) => {
                var delta = 1e-5;
                return -delta < a - b && a - b < delta;
            };
            return toFIxed(c.r, this.r) && toFIxed(c.g, this.g) && toFIxed(c.b, this.b) && toFIxed(c.a, this.a);
        }
        parse(value) {
            if (value == null)
                value = 0;
            if (typeof value === 'number') {
                if (value < 0 || isNaN(value))
                    value = 0;
                this.setRGB(value);
            }
            else if (value.indexOf("rgba(") >= 0 || value.indexOf("rgb(") >= 0) {
                let p1 = value.indexOf("(");
                let p2 = value.indexOf(")");
                if (p1 == -1 || p2 == -1) {
                    this.setValue(0, 0, 0, 1);
                    return this;
                }
                value = value.substring(p1 + 1, p2);
                let arr = value.split(",");
                let len = arr.length;
                for (let i = 0; i < len; i++) {
                    arr[i] = parseFloat(arr[i]);
                    if (isNaN(arr[i]))
                        arr[i] = 0;
                }
                this.r = arr[0] / 255;
                this.g = arr[1] / 255;
                this.b = arr[2] / 255;
                if (arr.length == 4)
                    this.a = arr[3];
                else
                    this.a = 1;
            }
            else {
                if (value.charAt(0) === '#')
                    value = value.substring(1);
                else {
                    let rgb = ColorMap[value];
                    if (rgb) {
                        this.setRGB(rgb);
                        return this;
                    }
                }
                let len = value.length;
                if (len === 3 || len === 4) {
                    let temp = "";
                    for (let i = 0; i < len; i++) {
                        temp += (value[i] + value[i]);
                    }
                    value = temp;
                }
                let rgb;
                let a = 1;
                if (len == 8) {
                    rgb = parseInt(value.substring(0, 6), 16);
                    a = parseInt(value.substring(6, 8), 16) / 255;
                }
                else {
                    rgb = parseInt(value, 16);
                    a = 1;
                }
                this.setRGB(rgb);
                this.a = a;
            }
            return this;
        }
        toLinear(out) {
            out.r = Color.gammaToLinearSpace(this.r);
            out.g = Color.gammaToLinearSpace(this.g);
            out.b = Color.gammaToLinearSpace(this.b);
            out.a = this.a;
        }
        toGamma(out) {
            out.r = Color.linearToGammaSpace(this.r);
            out.g = Color.linearToGammaSpace(this.g);
            out.b = Color.linearToGammaSpace(this.b);
            out.a = this.a;
        }
        cloneTo(destObject) {
            destObject.r = this.r;
            destObject.g = this.g;
            destObject.b = this.b;
            destObject.a = this.a;
        }
        scale(value) {
            this.r = this.r * value;
            this.g = this.g * value;
            this.b = this.b * value;
            return this;
        }
        setValue(r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        }
        fromArray(array, offset = 0) {
            this.r = array[offset + 0];
            this.g = array[offset + 1];
            this.b = array[offset + 2];
            this.a = array[offset + 3];
        }
        toArray() {
            return [this.r, this.g, this.b, this.a];
        }
        writeTo(arr, offset = 0) {
            arr[offset + 0] = this.r;
            arr[offset + 1] = this.g;
            arr[offset + 2] = this.b;
            arr[offset + 3] = this.a;
        }
        clone() {
            var dest = new Color();
            this.cloneTo(dest);
            return dest;
        }
        getRGB() {
            return (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
        }
        setRGB(value) {
            this.r = ((value >> 16) & 0xFF) / 255;
            this.g = ((value >> 8) & 0xFF) / 255;
            this.b = (value & 0xFF) / 255;
            this.a = 1;
        }
        getARGB() {
            return (Math.round(this.a * 255) << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255);
        }
        getABGR() {
            return (Math.round(this.a * 255) << 24) + (Math.round(this.b * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.r * 255);
        }
        toString() {
            let str = this.getRGB().toString(16);
            while (str.length < 6)
                str = "0" + str;
            return "#" + str;
        }
        getStyleString() {
            if (this.a == 1)
                return this.toString();
            else
                return "rgba(" + Math.round(this.r * 255) + "," + Math.round(this.g * 255) + "," + Math.round(this.b * 255) + "," + this.a + ")";
        }
    }
    Color.RED = new Color(1, 0, 0, 1);
    Color.GREEN = new Color(0, 1, 0, 1);
    Color.BLUE = new Color(0, 0, 1, 1);
    Color.CYAN = new Color(0, 1, 1, 1);
    Color.YELLOW = new Color(1, 0.92, 0.016, 1);
    Color.MAGENTA = new Color(1, 0, 1, 1);
    Color.GRAY = new Color(0.5, 0.5, 0.5, 1);
    Color.WHITE = new Color(1, 1, 1, 1);
    Color.BLACK = new Color(0, 0, 0, 1);
    Color.CLEAR = new Color(0, 0, 0, 0);
    const tmpColor$1 = new Color();

    exports.RenderTargetFormat = void 0;
    (function (RenderTargetFormat) {
        RenderTargetFormat[RenderTargetFormat["None"] = -1] = "None";
        RenderTargetFormat[RenderTargetFormat["R8G8B8"] = 0] = "R8G8B8";
        RenderTargetFormat[RenderTargetFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        RenderTargetFormat[RenderTargetFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        RenderTargetFormat[RenderTargetFormat["R32G32B32"] = 30] = "R32G32B32";
        RenderTargetFormat[RenderTargetFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        RenderTargetFormat[RenderTargetFormat["R16G16B16"] = 31] = "R16G16B16";
        RenderTargetFormat[RenderTargetFormat["DEPTH_16"] = 35] = "DEPTH_16";
        RenderTargetFormat[RenderTargetFormat["STENCIL_8"] = 36] = "STENCIL_8";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_8"] = 37] = "DEPTHSTENCIL_24_8";
        RenderTargetFormat[RenderTargetFormat["DEPTH_32"] = 38] = "DEPTH_32";
        RenderTargetFormat[RenderTargetFormat["DEPTHSTENCIL_24_Plus"] = 39] = "DEPTHSTENCIL_24_Plus";
    })(exports.RenderTargetFormat || (exports.RenderTargetFormat = {}));

    exports.TextureDimension = void 0;
    (function (TextureDimension) {
        TextureDimension[TextureDimension["Tex2D"] = 0] = "Tex2D";
        TextureDimension[TextureDimension["Cube"] = 1] = "Cube";
        TextureDimension[TextureDimension["Tex3D"] = 2] = "Tex3D";
        TextureDimension[TextureDimension["Texture2DArray"] = 3] = "Texture2DArray";
        TextureDimension[TextureDimension["CubeArray"] = 4] = "CubeArray";
        TextureDimension[TextureDimension["Unkonw"] = 5] = "Unkonw";
        TextureDimension[TextureDimension["None"] = 6] = "None";
    })(exports.TextureDimension || (exports.TextureDimension = {}));

    exports.HDREncodeFormat = void 0;
    (function (HDREncodeFormat) {
        HDREncodeFormat[HDREncodeFormat["NONE"] = 0] = "NONE";
        HDREncodeFormat[HDREncodeFormat["RGBM"] = 1] = "RGBM";
        HDREncodeFormat[HDREncodeFormat["RGBD"] = 2] = "RGBD";
    })(exports.HDREncodeFormat || (exports.HDREncodeFormat = {}));

    exports.TextureFormat = void 0;
    (function (TextureFormat) {
        TextureFormat[TextureFormat["R8G8B8"] = 0] = "R8G8B8";
        TextureFormat[TextureFormat["R8G8B8A8"] = 1] = "R8G8B8A8";
        TextureFormat[TextureFormat["R5G6B5"] = 16] = "R5G6B5";
        TextureFormat[TextureFormat["Alpha8"] = 2] = "Alpha8";
        TextureFormat[TextureFormat["DXT1"] = 3] = "DXT1";
        TextureFormat[TextureFormat["DXT3"] = 29] = "DXT3";
        TextureFormat[TextureFormat["DXT5"] = 4] = "DXT5";
        TextureFormat[TextureFormat["ETC1RGB"] = 5] = "ETC1RGB";
        TextureFormat[TextureFormat["ETC2RGB"] = 6] = "ETC2RGB";
        TextureFormat[TextureFormat["ETC2RGBA"] = 7] = "ETC2RGBA";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha8"] = 8] = "ETC2SRGB_Alpha8";
        TextureFormat[TextureFormat["ETC2SRGB"] = 28] = "ETC2SRGB";
        TextureFormat[TextureFormat["ETC2RGB_Alpha1"] = 32] = "ETC2RGB_Alpha1";
        TextureFormat[TextureFormat["ETC2SRGB_Alpha1"] = 33] = "ETC2SRGB_Alpha1";
        TextureFormat[TextureFormat["PVRTCRGB_2BPPV"] = 9] = "PVRTCRGB_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_2BPPV"] = 10] = "PVRTCRGBA_2BPPV";
        TextureFormat[TextureFormat["PVRTCRGB_4BPPV"] = 11] = "PVRTCRGB_4BPPV";
        TextureFormat[TextureFormat["PVRTCRGBA_4BPPV"] = 12] = "PVRTCRGBA_4BPPV";
        TextureFormat[TextureFormat["R32G32B32A32"] = 15] = "R32G32B32A32";
        TextureFormat[TextureFormat["R32G32B32"] = 30] = "R32G32B32";
        TextureFormat[TextureFormat["R16G16B16A16"] = 17] = "R16G16B16A16";
        TextureFormat[TextureFormat["R16G16B16"] = 31] = "R16G16B16";
        TextureFormat[TextureFormat["ASTC4x4"] = 18] = "ASTC4x4";
        TextureFormat[TextureFormat["ASTC4x4SRGB"] = 23] = "ASTC4x4SRGB";
        TextureFormat[TextureFormat["ASTC6x6"] = 19] = "ASTC6x6";
        TextureFormat[TextureFormat["ASTC6x6SRGB"] = 24] = "ASTC6x6SRGB";
        TextureFormat[TextureFormat["ASTC8x8"] = 20] = "ASTC8x8";
        TextureFormat[TextureFormat["ASTC8x8SRGB"] = 25] = "ASTC8x8SRGB";
        TextureFormat[TextureFormat["ASTC10x10"] = 21] = "ASTC10x10";
        TextureFormat[TextureFormat["ASTC10x10SRGB"] = 26] = "ASTC10x10SRGB";
        TextureFormat[TextureFormat["ASTC12x12"] = 22] = "ASTC12x12";
        TextureFormat[TextureFormat["ASTC12x12SRGB"] = 27] = "ASTC12x12SRGB";
        TextureFormat[TextureFormat["KTXTEXTURE"] = -1] = "KTXTEXTURE";
        TextureFormat[TextureFormat["PVRTEXTURE"] = -2] = "PVRTEXTURE";
    })(exports.TextureFormat || (exports.TextureFormat = {}));

    const ITEM_LAYOUT = 4;
    class Delegate {
        constructor() {
            this._flag = 0;
            this._items = [];
        }
        add(callback, target, args) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 1;
            }
            else
                arr.push(callback, target, args, 1);
        }
        once(callback, target, args) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                arr[index + 2] = args;
                arr[index + 3] = 2;
            }
            else
                arr.push(callback, target, args, 2);
        }
        remove(callback, target) {
            target = target || null;
            let arr = this._items;
            let index = arr.findIndex((value, index, arr) => value === callback && arr[index + 1] === target);
            if (index != -1) {
                if (this._flag != 0) {
                    arr[index + 3] = 0;
                    this._flag = 2;
                }
                else
                    arr.splice(index, ITEM_LAYOUT);
            }
        }
        clear() {
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if (index % ITEM_LAYOUT === 3)
                    arr[index] = 0; });
                this._flag = 2;
            }
            else {
                arr.length = 0;
            }
        }
        clearForTarget(target) {
            if (!target)
                return;
            let arr = this._items;
            if (this._flag != 0) {
                arr.forEach((value, index, arr) => { if ((index % ITEM_LAYOUT === 1) && arr[index] === target)
                    arr[index + 2] = 0; });
                this._flag = 2;
            }
            else {
                let i = arr.length - ITEM_LAYOUT;
                while (i >= 0) {
                    if (arr[i + 1] === target)
                        arr.splice(i, ITEM_LAYOUT);
                    i -= ITEM_LAYOUT;
                }
            }
        }
        get count() {
            return this._items.length / ITEM_LAYOUT;
        }
        invoke(...args) {
            if (this._flag != 0)
                return;
            this._flag = 1;
            let arr = this._items;
            let cnt = arr.length;
            for (let i = 0; i < cnt; i += ITEM_LAYOUT) {
                if (arr[i + 3] === 0)
                    continue;
                let fixedArgs = arr[i + 2];
                try {
                    if (fixedArgs != null)
                        arr[i].call(arr[i + 1], ...fixedArgs, ...args);
                    else
                        arr[i].call(arr[i + 1], ...args);
                }
                catch (err) {
                    console.error(err);
                }
                if (arr[i + 3] === 2) {
                    arr[i + 3] = 0;
                    this._flag = 2;
                }
            }
            if (this._flag === 2) {
                let cnt = arr.length;
                let i = 0;
                while (i < cnt) {
                    if (arr[i + 3] === 0) {
                        arr.splice(i, ITEM_LAYOUT);
                        cnt -= ITEM_LAYOUT;
                        continue;
                    }
                    else
                        i += ITEM_LAYOUT;
                }
            }
            this._flag = 0;
        }
    }

    const eventPool = [];
    class EventDispatcher {
        onStartListeningToType(type) {
        }
        hasListener(type) {
            let listeners = this._events && this._events[type];
            return !!listeners && listeners.count > 0;
        }
        event(type, data) {
            let listeners = this._events && this._events[type];
            if (!listeners)
                return false;
            let ret = listeners.count > 0;
            if (Array.isArray(data))
                listeners.invoke(...data);
            else if (data !== undefined)
                listeners.invoke(data);
            else if (data === Event.EMPTY) {
                let ev = eventPool.length > 0 ? eventPool.pop() : new Event();
                listeners.invoke(ev.setTo(type, this, this));
                ev.target = ev.currentTarget = null;
                eventPool.push(ev);
            }
            else
                listeners.invoke();
            return ret;
        }
        on(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.add(listener, caller, args);
            return this;
        }
        once(type, caller, listener, args) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            if (!this._events)
                this._events = {};
            let listeners = this._events[type];
            if (!listeners) {
                this.onStartListeningToType(type);
                this._events[type] = listeners = new Delegate();
            }
            listeners.once(listener, caller, args);
            return this;
        }
        off(type, caller, listener) {
            if (arguments.length == 2) {
                listener = caller;
                caller = null;
            }
            let listeners = this._events && this._events[type];
            if (listeners)
                listeners.remove(listener, caller);
            return this;
        }
        offAll(type) {
            if (!this._events)
                return this;
            if (type == null) {
                for (let type in this._events)
                    this._events[type].clear();
            }
            else {
                let listeners = this._events[type];
                if (listeners)
                    listeners.clear();
            }
            return this;
        }
        offAllCaller(caller) {
            if (caller && this._events) {
                for (let type in this._events)
                    this._events[type].clearForTarget(caller);
            }
            return this;
        }
    }

    var _idCounter$2 = 0;
    var _disposingCounter = 0;
    var _clearRetry = 0;
    class Resource extends EventDispatcher {
        static get cpuMemory() {
            return Resource._cpuMemory;
        }
        static get gpuMemory() {
            return Resource._gpuMemory;
        }
        static _addCPUMemory(size) {
            Resource._cpuMemory += size;
        }
        static _addGPUMemory(size) {
            Resource._gpuMemory += size;
        }
        static _addMemory(cpuSize, gpuSize) {
            Resource._cpuMemory += cpuSize;
            Resource._gpuMemory += gpuSize;
        }
        static destroyUnusedResources() {
            _disposingCounter = 0;
            _clearRetry = 0;
            if (!ILaya.loader.loading)
                Resource._destroyUnusedResources(true);
            else
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
        }
        static _destroyUnusedResources(force) {
            if (!force && ILaya.loader.loading)
                return;
            ILaya.timer.clear(Resource, Resource._destroyUnusedResources);
            let destroyCnt = 0;
            for (let k in Resource._idResourcesMap) {
                let res = Resource._idResourcesMap[k];
                if (!res.lock && res._referenceCount === 0) {
                    res.destroy();
                    destroyCnt++;
                }
            }
            if (Resource.DEBUG && destroyCnt > 0)
                console.debug(`destroyUnusedResources(${destroyCnt})`);
            if (destroyCnt > 0 && _clearRetry < 5) {
                _clearRetry++;
                ILaya.timer.frameLoop(1, Resource, Resource._destroyUnusedResources);
            }
        }
        get id() {
            return this._id;
        }
        get cpuMemory() {
            return this._cpuMemory;
        }
        get gpuMemory() {
            return this._gpuMemory;
        }
        get destroyed() {
            return this._destroyed;
        }
        get obsolute() {
            return this._obsolute;
        }
        set obsolute(value) {
            if (this._obsolute != value) {
                this._obsolute = value;
                if (value && !LayaEnv.isPlaying)
                    this.event("obsolute");
            }
        }
        get deps() {
            return this._deps;
        }
        get referenceCount() {
            return this._referenceCount;
        }
        constructor(managed) {
            super();
            this._cpuMemory = 0;
            this._gpuMemory = 0;
            this._id = 0;
            this._referenceCount = 0;
            this._id = ++_idCounter$2;
            this._destroyed = false;
            this._referenceCount = 0;
            if (managed == null || managed)
                Resource._idResourcesMap[this._id] = this;
            this.lock = false;
            this.destroyedImmediately = true;
            this._deps = [];
            this._traceDeps = false;
        }
        _setCPUMemory(value) {
            var offsetValue = value - this._cpuMemory;
            this._cpuMemory = value;
            Resource._addCPUMemory(offsetValue);
        }
        _setGPUMemory(value) {
            var offsetValue = value - this._gpuMemory;
            this._gpuMemory = value;
            Resource._addGPUMemory(offsetValue);
        }
        _setCreateURL(url, uuid) {
            this.url = url;
            this.uuid = uuid;
        }
        isCreateFromURL(url) {
            return this.uuid && url.length === this.uuid.length + 6 && url.endsWith(this.uuid)
                || this.url === url;
        }
        _addReference(count = 1) {
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            this._referenceCount -= count;
            if (_disposingCounter > 0 && this._referenceCount <= 0 && !this.lock && this.destroyedImmediately) {
                this.destroy();
            }
        }
        _clearReference() {
            this._referenceCount = 0;
        }
        addDep(res) {
            if (res instanceof Resource) {
                res._addReference();
                this._deps.push(res);
                if (!LayaEnv.isPlaying && res._traceDeps)
                    res.on("obsolute", this, this.onDepObsolute);
            }
        }
        addDeps(resArr) {
            for (let res of resArr) {
                if (res instanceof Resource) {
                    res._addReference();
                    this._deps.push(res);
                    if (!LayaEnv.isPlaying && res._traceDeps)
                        res.on("obsolute", this, this.onDepObsolute);
                }
            }
        }
        onDepObsolute() {
            this.obsolute = true;
        }
        _disposeResource() {
        }
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this.lock = false;
            _disposingCounter++;
            this._disposeResource();
            for (let res of this._deps) {
                res._removeReference();
                if (!LayaEnv.isPlaying && res._traceDeps)
                    res.off("obsolute", this, this.onDepObsolute);
            }
            _disposingCounter--;
            this.offAll();
            delete Resource._idResourcesMap[this.id];
            if (this.url) {
                if (Resource.DEBUG)
                    console.debug(`destroy ${Object.getPrototypeOf(this).constructor.name} ${this.url}`);
                ILaya.loader.clearRes(this.url, this);
            }
        }
    }
    Resource._idResourcesMap = {};
    Resource._cpuMemory = 0;
    Resource._gpuMemory = 0;
    Resource.DEBUG = false;

    class BaseTexture extends Resource {
        get width() {
            return this._width;
        }
        set width(width) {
            this._width = width;
        }
        get height() {
            return this._height;
        }
        set height(height) {
            this._height = height;
        }
        get dimension() {
            return this._dimension;
        }
        get format() {
            return this._format;
        }
        get mipmap() {
            return this._texture.mipmap;
        }
        get mipmapCount() {
            return this._texture.mipmapCount;
        }
        get anisoLevel() {
            return this._texture.anisoLevel;
        }
        set anisoLevel(value) {
            this._texture.anisoLevel = value;
        }
        get filterMode() {
            return this._texture.filterMode;
        }
        set filterMode(value) {
            this._texture.filterMode = value;
        }
        get wrapModeU() {
            return this._texture.wrapU;
        }
        set wrapModeU(value) {
            this._texture.wrapU = value;
        }
        get wrapModeV() {
            return this._texture.wrapV;
        }
        set wrapModeV(value) {
            this._texture.wrapV = value;
        }
        get wrapModeW() {
            return this._texture.wrapW;
        }
        set wrapModeW(value) {
            this._texture.wrapW = value;
        }
        get compareMode() {
            return this._texture.compareMode;
        }
        set compareMode(value) {
            this._texture.compareMode = LayaGL.textureContext.setTextureCompareMode(this._texture, value);
        }
        get gammaCorrection() {
            return this._texture.gammaCorrection;
        }
        get baseMipmapLevel() {
            return this._texture.baseMipmapLevel;
        }
        set baseMipmapLevel(value) {
            this._texture.baseMipmapLevel = value;
        }
        get maxMipmapLevel() {
            return this._texture.maxMipmapLevel;
        }
        set maxMipmapLevel(value) {
            this._texture.maxMipmapLevel = value;
        }
        get gammaSpace() {
            return this._texture.useSRGBLoad || this._texture.gammaCorrection > 1;
        }
        constructor(width, height, format) {
            super();
            this._gammaSpace = false;
            this._width = width;
            this._height = height;
            this._format = format;
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
            this.hdrEncodeFormat = exports.HDREncodeFormat.NONE;
        }
        gpuCompressFormat() {
            let format = this._format;
            switch (format) {
                case exports.TextureFormat.R8G8B8:
                case exports.TextureFormat.R8G8B8A8:
                case exports.TextureFormat.R16G16B16:
                case exports.TextureFormat.R16G16B16A16:
                case exports.TextureFormat.R32G32B32:
                case exports.TextureFormat.R32G32B32A32:
                case exports.TextureFormat.R5G6B5:
                case exports.TextureFormat.Alpha8:
                    return false;
                case exports.TextureFormat.DXT1:
                case exports.TextureFormat.DXT3:
                case exports.TextureFormat.DXT5:
                case exports.TextureFormat.ETC1RGB:
                case exports.TextureFormat.ETC2RGB:
                case exports.TextureFormat.ETC2RGBA:
                case exports.TextureFormat.ETC2SRGB_Alpha8:
                case exports.TextureFormat.ETC2SRGB:
                case exports.TextureFormat.ETC2RGB_Alpha1:
                case exports.TextureFormat.ETC2SRGB_Alpha1:
                case exports.TextureFormat.PVRTCRGB_2BPPV:
                case exports.TextureFormat.PVRTCRGBA_2BPPV:
                case exports.TextureFormat.PVRTCRGB_4BPPV:
                case exports.TextureFormat.PVRTCRGBA_4BPPV:
                case exports.TextureFormat.ASTC4x4:
                case exports.TextureFormat.ASTC4x4SRGB:
                case exports.TextureFormat.ASTC6x6:
                case exports.TextureFormat.ASTC6x6SRGB:
                case exports.TextureFormat.ASTC8x8:
                case exports.TextureFormat.ASTC8x8SRGB:
                case exports.TextureFormat.ASTC10x10:
                case exports.TextureFormat.ASTC10x10SRGB:
                case exports.TextureFormat.ASTC12x12:
                case exports.TextureFormat.ASTC12x12SRGB:
                    return true;
                default:
                    return false;
            }
        }
        _getFormatByteCount() {
            switch (this._format) {
                case exports.TextureFormat.R8G8B8:
                    return 3;
                case exports.TextureFormat.R8G8B8A8:
                    return 4;
                case exports.TextureFormat.R5G6B5:
                    return 1;
                case exports.TextureFormat.Alpha8:
                    return 1;
                case exports.TextureFormat.R16G16B16A16:
                    return 2;
                case exports.TextureFormat.R32G32B32A32:
                    return 4;
                default:
                    throw "Texture2D: unknown format.";
            }
        }
        _getSource() {
            return this._texture.resource;
        }
        get defaultTexture() {
            throw "defaulte";
        }
        _disposeResource() {
            this._texture.dispose();
        }
    }

    exports.DepthTextureMode = void 0;
    (function (DepthTextureMode) {
        DepthTextureMode[DepthTextureMode["None"] = 0] = "None";
        DepthTextureMode[DepthTextureMode["Depth"] = 1] = "Depth";
        DepthTextureMode[DepthTextureMode["DepthNormals"] = 2] = "DepthNormals";
        DepthTextureMode[DepthTextureMode["DepthAndDepthNormals"] = 3] = "DepthAndDepthNormals";
        DepthTextureMode[DepthTextureMode["MotionVectors"] = 4] = "MotionVectors";
    })(exports.DepthTextureMode || (exports.DepthTextureMode = {}));
    class RenderTexture extends BaseTexture {
        static createFromPool(width, height, colorFormat, depthFormat, mipmap = false, multiSamples = 1, depthTexture = false, sRGB = false) {
            mipmap = mipmap && (width & (width - 1)) === 0 && (height & (height - 1)) === 0;
            let n = RenderTexture._pool.length;
            for (let index = 0; index < n; index++) {
                let rt = RenderTexture._pool[index];
                if (rt.width == width && rt.height == height && rt.colorFormat == colorFormat && rt.depthStencilFormat == depthFormat && rt._generateMipmap == mipmap && rt.multiSamples == multiSamples && rt.generateDepthTexture == depthTexture && rt._gammaSpace == sRGB) {
                    rt._inPool = false;
                    let end = RenderTexture._pool[n - 1];
                    RenderTexture._pool[index] = end;
                    RenderTexture._pool.length -= 1;
                    RenderTexture._poolMemory -= (rt._renderTarget.gpuMemory / 1024 / 1024);
                    return rt;
                }
            }
            let rt = new RenderTexture(width, height, colorFormat, depthFormat, mipmap, multiSamples, depthTexture, sRGB);
            rt.lock = true;
            return rt;
        }
        static recoverToPool(rt) {
            if (rt._inPool || rt.destroyed)
                return;
            RenderTexture._pool.push(rt);
            RenderTexture._poolMemory += (rt._renderTarget.gpuMemory / 1024 / 1024);
            rt._inPool = true;
        }
        static clearPool() {
            if (RenderTexture._poolMemory < Config3D.defaultCacheRTMemory) {
                return;
            }
            for (var i in RenderTexture._pool) {
                RenderTexture._pool[i].destroy();
            }
            RenderTexture._pool = [];
            RenderTexture._poolMemory = 0;
        }
        static get bindCanvasRender() {
            return RenderTexture._bindCanvasRender;
        }
        static set bindCanvasRender(value) {
            if (value != this._bindCanvasRender)
                this._bindCanvasRender = value;
        }
        get generateDepthTexture() {
            return this._generateDepthTexture;
        }
        set generateDepthTexture(value) {
            if (this.depthStencilFormat == exports.RenderTargetFormat.None) {
                this._generateDepthTexture = false;
                return;
            }
            if (value && !this._depthStencilTexture) {
                this._depthStencilTexture = new BaseTexture(this.width, this.height, this.depthStencilFormat);
                this._depthStencilTexture._dimension = exports.TextureDimension.Tex2D;
                this._depthStencilTexture._texture = LayaGL.textureContext.createRenderTargetDepthTexture(this._renderTarget, exports.TextureDimension.Tex2D, this.width, this.height);
            }
            this._generateDepthTexture = value;
        }
        get depthStencilTexture() {
            return this._depthStencilTexture;
        }
        get colorFormat() {
            return this._renderTarget.colorFormat;
        }
        get depthStencilFormat() {
            return this._renderTarget.depthStencilFormat;
        }
        get multiSamples() {
            return this._renderTarget._samples;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        constructor(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false) {
            super(width, height, colorFormat);
            this._inPool = false;
            this._isCameraTarget = false;
            this._generateDepthTexture = false;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._createRenderTarget();
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Tex2D;
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._generateMipmap = this._renderTarget._generateMipmap;
            if (this._renderTarget._texturesResolve)
                this._texture = this._renderTarget._texturesResolve[0];
            else
                this._texture = this._renderTarget._textures[0];
            this.generateDepthTexture = this._generateDepthTexture;
        }
        recreate(width, height, colorFormat, depthFormat, generateMipmap = false, multiSamples = 1, generateDepthTexture = false, sRGB = false) {
            this._width = width;
            this._height = height;
            this._format = colorFormat;
            this._gammaSpace = sRGB;
            this._depthStencilFormat = (depthFormat == null ? exports.RenderTargetFormat.None : depthFormat);
            this._generateMipmap = generateMipmap;
            this._multiSamples = multiSamples;
            this._generateDepthTexture = generateDepthTexture;
            this._disposeResource();
            this._createRenderTarget();
        }
        getData(xOffset, yOffset, width, height, out) {
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, xOffset, yOffset, width, height, out);
            return out;
        }
        getDataAsync(xOffset, yOffset, width, height, out) {
            return LayaGL.textureContext.readRenderTargetPixelDataAsync(this._renderTarget, xOffset, yOffset, width, height, out);
        }
        _disposeResource() {
            var _a;
            this._renderTarget.dispose();
            this._renderTarget = null;
            (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.destroy();
            this._depthStencilTexture = null;
        }
    }
    RenderTexture._pool = [];
    RenderTexture._poolMemory = 0;

    const PlatformAdapterNames = ["browser", "fs", "storage", "font", "textInput", "media", "device"];
    class PAL {
        static __init__() {
            for (let key of PlatformAdapterNames) {
                let cls = PAL._classes[key];
                if (cls)
                    PAL[key] = new cls();
            }
        }
        static register(name, cls) {
            if (LayaEnv.isPlaying)
                PAL._classes[name] = cls;
        }
        static warnIncompatibility(name) {
            if (!warned.has(name)) {
                warned.add(name);
                console.warn(`${name} is not supported in this platform.`);
            }
        }
    }
    PAL.g = null;
    PAL._classes = {};
    const warned = new Set();

    class Browser {
        static createElement(tagName) {
            return PAL.browser.createElement(tagName);
        }
        static getElementById(id) {
            return Browser.document.getElementById(id);
        }
        static removeElement(ele) {
            if (ele && ele.parentNode)
                ele.parentNode.removeChild(ele);
        }
        static now() {
            return Date.now();
        }
        static get clientWidth() {
            if (this._clientWidth != null)
                return this._clientWidth;
            else
                return PAL.browser.getClientWidth();
        }
        static set clientWidth(value) {
            Browser._clientWidth = value;
        }
        static get clientHeight() {
            if (this._clientHeight != null)
                return this._clientHeight;
            else
                return PAL.browser.getClientHeight();
        }
        static set clientHeight(value) {
            Browser._clientHeight = value;
        }
        static get width() {
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
        }
        static get height() {
            return ((ILaya.stage && ILaya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
        }
        static get pixelRatio() {
            return PAL.browser.getPixelRatio();
        }
        static get container() {
            return Browser.mainCanvas.source.parentElement || document.body;
        }
        static getQueryString(name) {
            if (!Browser.window.location || !Browser.window.location.search)
                return null;
            let reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
            let r = Browser.window.location.search.substring(1).match(reg);
            if (r != null)
                return unescape(r[2]);
            return null;
        }
        static loadLib(src, async) {
            return new Promise((resolve, reject) => {
                let script = document.createElement('script');
                script.onload = function () {
                    resolve();
                };
                script.onerror = function () {
                    reject(`load ${src} failed`);
                };
                if (async != null)
                    script.async = async;
                script.src = URL.postFormatURL(URL.formatURL(src));
                Browser.document.body.appendChild(script);
            });
        }
    }
    Browser.platform = 0;
    Browser.platformName = "";
    Browser.PLATFORM_PC = 0;
    Browser.PLATFORM_ANDROID = 1;
    Browser.PLATFORM_IOS = 2;
    Browser.isDomSupported = true;
    Browser.systemVersion = "";
    Browser.SDKVersion = "";
    Browser.bundles = new Map();
    Browser.window = typeof window !== undefined ? window : null;
    Browser.document = typeof document !== undefined ? document : null;
    let win = window;
    win.__getBundle_ = function (bundleId) {
        let bun = Browser.bundles.get(bundleId);
        if (!bun)
            Browser.bundles.set(bundleId, bun = {});
        return bun;
    };
    win.__setBundle_ = function (bundleId, bun, globalName) {
        let existing = Browser.bundles.get(bundleId);
        if (existing)
            copyProps(existing, bun, "default");
        Browser.bundles.set(bundleId, bun);
        if (globalName)
            win[globalName] = bun;
    };
    function copyProps(to, from, except) {
        var desc;
        if (from && typeof from === "object" || typeof from === "function") {
            for (let key of Object.getOwnPropertyNames(from))
                if (!to.hasOwnProperty(key) && key !== except)
                    Object.defineProperty(to, key, { get: () => from[key], enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable });
        }
        return to;
    }

    var _gid = 1;
    const _pi = 180 / Math.PI;
    const _pi2 = Math.PI / 180;
    class Utils {
        static toRadian(angle) {
            return angle * _pi2;
        }
        static toAngle(radian) {
            return radian * _pi;
        }
        static toHexColor(color) {
            return Color.hexToString(color);
        }
        static fromStringColor(value) {
            return Color.stringToHex(value);
        }
        static getGID(target, method) {
            let cid = target ? (target[objUidKey] || (target[objUidKey] = _gid++)) : 0;
            let mid = method ? (typeof (method) === "string" ? method : (method[objUidKey] || (method[objUidKey] = _gid++))) : 0;
            return cid + "_" + mid;
        }
        static copyArray(source, array) {
            source || (source = []);
            if (!array)
                return source;
            source.length = array.length;
            var len = array.length;
            for (let i = 0; i < len; i++) {
                source[i] = array[i];
            }
            return source;
        }
        static parseInt(str, radix = 0) {
            var result = parseInt(str, radix);
            if (isNaN(result))
                return 0;
            return result;
        }
        static getBaseName(path) {
            let i = path.lastIndexOf("/");
            if (i != -1)
                path = path.substring(i + 1);
            i = path.indexOf("?");
            if (i != -1)
                path = path.substring(0, i);
            return path;
        }
        static getFileExtension(path) {
            let i = path.lastIndexOf(".");
            if (i != -1) {
                let ext = path.substring(i + 1).toLowerCase();
                let j = ext.indexOf("?");
                if (j != -1)
                    ext = ext.substring(0, j);
                if (ext === "ls") {
                    let k = path.lastIndexOf(".", i - 1);
                    if (k != -1) {
                        let ext2 = path.substring(k + 1, i + 1) + ext;
                        if (ext2 === "lanit.ls" || ext2 === "ltcb.ls")
                            return ext2;
                    }
                }
                return ext;
            }
            else
                return "";
        }
        static replaceFileExtension(path, newExt, excludeDot) {
            if (!path)
                return path;
            let i = path.lastIndexOf(".");
            if (newExt.length > 0 && !excludeDot)
                newExt = "." + newExt;
            if (i != -1) {
                let j = path.indexOf("?", i);
                if (j != -1)
                    return path.substring(0, i) + newExt + path.substring(j);
                else
                    return path.substring(0, i) + newExt;
            }
            else
                return path + newExt;
        }
        static isUUID(str) {
            return str && str.length >= 36 && str.charCodeAt(8) === 45 && str.charCodeAt(13) === 45;
        }
        static uint8ArrayToArrayBuffer(rendertexture) {
            let pixelArray;
            const width = rendertexture.width;
            const height = rendertexture.height;
            const pixelCount = width * height * 4;
            const colorFormat = (rendertexture instanceof RenderTexture) ? rendertexture.colorFormat : rendertexture.getColorFormat();
            switch (colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not surpprt " + rendertexture.format.toString() + "format Material";
            }
            LayaGL.textureContext.readRenderTargetPixelData(rendertexture._renderTarget, 0, 0, width, height, pixelArray);
            if (colorFormat === exports.RenderTargetFormat.R16G16B16A16) {
                const ori = pixelArray;
                const trans = new Uint8Array(pixelCount);
                for (let i = 0, n = ori.length; i < n; i++) {
                    trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                }
                pixelArray = trans;
            }
            const pixels = pixelArray;
            const canvas = Browser.createElement("canvas");
            canvas.height = height;
            canvas.width = width;
            const ctx2d = canvas.getContext('2d');
            const imgdata = ctx2d.createImageData(width, height);
            imgdata.data.set(new Uint8ClampedArray(pixels));
            ctx2d.putImageData(imgdata, 0, 0);
            const base64String = canvas.toDataURL();
            canvas.remove();
            return base64String;
        }
        static uint8ArrayToArrayBufferAsync(rendertexture) {
            let pixelArray;
            const width = rendertexture.width;
            const height = rendertexture.height;
            const pixelCount = width * height * 4;
            const colorFormat = (rendertexture instanceof RenderTexture) ? rendertexture.colorFormat : rendertexture.getColorFormat();
            switch (colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not surpprt " + rendertexture.format.toString() + "format Material";
            }
            return rendertexture.getDataAsync(0, 0, width, height, pixelArray).then(() => {
                if (colorFormat === exports.RenderTargetFormat.R16G16B16A16) {
                    const ori = pixelArray;
                    const trans = new Uint8Array(pixelCount);
                    for (let i = 0, n = ori.length; i < n; i++) {
                        trans[i] = Math.min(Math.floor(ori[i] * 255), 255);
                    }
                    pixelArray = trans;
                }
                const pixels = pixelArray;
                const canvas = Browser.createElement("canvas");
                canvas.height = height;
                canvas.width = width;
                const ctx2d = canvas.getContext('2d');
                const imgdata = ctx2d.createImageData(width, height);
                imgdata.data.set(new Uint8ClampedArray(pixels));
                ctx2d.putImageData(imgdata, 0, 0);
                const base64String = canvas.toDataURL();
                canvas.remove();
                return Promise.resolve(base64String);
            });
        }
        static parseTemplate(template, vars) {
            let pos1 = 0, pos2, pos3;
            let tag;
            let value;
            let result = "";
            while ((pos2 = template.indexOf("{", pos1)) != -1) {
                if (pos2 > 0 && template.charCodeAt(pos2 - 1) == 92) {
                    result += template.substring(pos1, pos2 - 1);
                    result += "{";
                    pos1 = pos2 + 1;
                    continue;
                }
                result += template.substring(pos1, pos2);
                pos1 = pos2;
                pos2 = template.indexOf("}", pos1);
                if (pos2 == -1)
                    break;
                if (pos2 == pos1 + 1) {
                    result += template.substring(pos1, pos1 + 2);
                    pos1 = pos2 + 1;
                    continue;
                }
                tag = template.substring(pos1 + 1, pos2);
                pos3 = tag.indexOf("=");
                if (pos3 != -1) {
                    value = vars[tag.substring(0, pos3)];
                    if (value == null)
                        result += tag.substring(pos3 + 1);
                    else
                        result += value;
                }
                else {
                    value = vars[tag];
                    if (value != null)
                        result += value;
                }
                pos1 = pos2 + 1;
            }
            if (pos1 < template.length)
                result += template.substring(pos1);
            return result;
        }
        static sleep(ms) {
            if (ms < 1)
                return Promise.resolve();
            else
                return new Promise((resolve) => setTimeout(resolve, ms));
        }
        static until(predicate, timeoutInMs) {
            if (predicate())
                return Promise.resolve();
            return new Promise((resolve) => {
                let start = performance.now();
                function timer() {
                    if (predicate())
                        resolve();
                    else if (timeoutInMs != null && performance.now() - start > timeoutInMs)
                        resolve();
                    else
                        setTimeout(timer, 10);
                }
                setTimeout(timer, 10);
            });
        }
        static runTasks(datas, numParallelTasks, taskFunc, abortToken) {
            let limitFunc;
            if (typeof (numParallelTasks) !== "number") {
                limitFunc = numParallelTasks;
                numParallelTasks = 0;
            }
            let total = datas.length;
            if (numParallelTasks >= total) {
                return Promise.all(datas.map((value, index) => {
                    if (abortToken && abortToken.aborted)
                        return Promise.reject("aborted");
                    else
                        return taskFunc(value, index);
                }));
            }
            const results = new Array(total);
            const executing = [];
            let i = 0;
            function processNext() {
                if (i >= total || (abortToken === null || abortToken === void 0 ? void 0 : abortToken.aborted)) {
                    return Promise.resolve();
                }
                const j = i++;
                const item = datas[j];
                const p = Promise.resolve().then(() => {
                    if (abortToken === null || abortToken === void 0 ? void 0 : abortToken.aborted) {
                        return Promise.reject("aborted");
                    }
                    return taskFunc(item, j);
                }).then((result) => {
                    results[j] = result;
                    executing.splice(executing.indexOf(p), 1);
                });
                executing.push(p);
                if (limitFunc ? limitFunc(executing.length) : executing.length >= numParallelTasks) {
                    return Promise.race(executing).then(processNext);
                }
                else {
                    return processNext();
                }
            }
            const initialPromises = [];
            const initialCount = Math.min(numParallelTasks, total);
            for (let i = 0; i < initialCount; i++) {
                initialPromises.push(processNext());
            }
            return Promise.all(initialPromises)
                .then(() => {
                if (executing.length > 0)
                    return Promise.all(executing);
                else
                    return null;
            }).then(() => results);
        }
        static runAllTasks(datas, numParallelTasks, taskFunc, abortToken) {
            let limitFunc;
            if (typeof (numParallelTasks) !== "number") {
                limitFunc = numParallelTasks;
                numParallelTasks = 0;
            }
            let total = datas.length;
            if (numParallelTasks >= total) {
                return Promise.allSettled(datas.map((value, index) => Promise.resolve().then(() => {
                    if (abortToken && abortToken.aborted)
                        return Promise.reject("aborted");
                    else
                        return taskFunc(value, index);
                })));
            }
            const results = new Array(total);
            const executing = [];
            let i = 0;
            function processNext() {
                if (i >= total || (abortToken === null || abortToken === void 0 ? void 0 : abortToken.aborted)) {
                    return Promise.resolve();
                }
                const j = i++;
                const item = datas[j];
                const p = Promise.resolve().then(() => {
                    if (abortToken && abortToken.aborted)
                        return Promise.reject("aborted");
                    else
                        return taskFunc(item, j);
                }).then((result) => {
                    results[j] = { status: "fulfilled", value: result };
                    executing.splice(executing.indexOf(p), 1);
                }).catch((reason) => {
                    results[j] = { status: "rejected", reason };
                    executing.splice(executing.indexOf(p), 1);
                });
                executing.push(p);
                if (limitFunc ? limitFunc(executing.length) : executing.length >= numParallelTasks) {
                    return Promise.race(executing).then(processNext);
                }
                else {
                    return processNext();
                }
            }
            const initialPromises = [];
            const initialCount = Math.min(numParallelTasks, total);
            for (let i = 0; i < initialCount; i++) {
                initialPromises.push(processNext());
            }
            return Promise.allSettled(initialPromises)
                .then(() => {
                if (executing.length > 0)
                    return Promise.allSettled(executing);
                else
                    return null;
            }).then(() => results);
        }
        static compareVersion(ver1, ver2) {
            let v1 = ver1.split('.');
            let v2 = ver2.split('.');
            const len = Math.max(v1.length, v2.length);
            while (v1.length < len) {
                v1.push('0');
            }
            while (v2.length < len) {
                v2.push('0');
            }
            for (let i = 0; i < len; i++) {
                const num1 = parseInt(v1[i]);
                const num2 = parseInt(v2[i]);
                if (num1 > num2) {
                    return 1;
                }
                else if (num1 < num2) {
                    return -1;
                }
            }
            return 0;
        }
    }
    const objUidKey = Symbol();

    class AssetDb {
        constructor() {
            this.uuidMap = {};
            this.shaderNameMap = {};
            this.metaMap = {};
            this.i18nUrlMap = {};
        }
        UUID_to_URL(uuid) {
            return this.uuidMap[uuid];
        }
        UUID_to_URL_async(uuid) {
            return Promise.resolve(null);
        }
        URL_to_UUID_async(url) {
            return Promise.resolve(null);
        }
        resolveURL(url, onResolve) {
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                return AssetDb.inst.UUID_to_URL_async(uuid).then(url => {
                    if (onResolve)
                        onResolve(url);
                    return url;
                });
            }
            else {
                if (onResolve)
                    onResolve(url);
                return Promise.resolve(url);
            }
        }
        shaderName_to_URL(shaderName) {
            return this.shaderNameMap[shaderName];
        }
        shaderName_to_URL_async(shaderName) {
            return Promise.resolve(null);
        }
        getMeta(url, uuid) {
            return Promise.resolve(null);
        }
        getSubAssetURL(url, uuid, subAssetName, subAssetExt) {
            if (subAssetName)
                return `${Utils.replaceFileExtension(url, "")}@${subAssetName}.${subAssetExt}`;
            else
                return url;
        }
        getI18nSettingsURL(id) {
            return this.i18nUrlMap[id];
        }
    }
    AssetDb.inst = new AssetDb();

    class URL {
        static initMiniGameExtensionOverrides() {
            if (LayaEnv.isPreview)
                return;
            Object.assign(this.overrideFileExts, this.safeFileExtConversionMap, PlayerConfig.safeFileExtConversionMap);
            this.hasExtOverrides = true;
            this.usingSafeFileExts = true;
        }
        constructor(url) {
            this._url = URL.formatURL(url);
            this._path = URL.getPath(url);
        }
        get url() {
            return this._url;
        }
        get path() {
            return this._path;
        }
        static get rootPath() {
            return URL.basePaths["~/"];
        }
        static set rootPath(value) {
            URL.basePaths["~/"] = value;
        }
        static formatURL(url, base) {
            if (!url)
                return base || URL.basePath || "";
            if (url.startsWith("res://")) {
                let uuid = url.substring(6);
                let url2 = AssetDb.inst.UUID_to_URL(uuid);
                if (!url2)
                    return url;
                url = url2;
            }
            if (url.indexOf(":") == -1 && url.charCodeAt(0) !== 47) {
                if (URL.customFormat != null)
                    url = URL.customFormat(url);
                let ver = URL.version[url];
                if (ver != null) {
                    let i = url.lastIndexOf(".");
                    url = url.substring(0, i) + "-" + ver + url.substring(i);
                }
                if (base == null) {
                    base = URL.basePath;
                    for (let k in URL.basePaths) {
                        if (url.startsWith(k)) {
                            if (k.charCodeAt(0) === 126)
                                url = url.substring(k.length);
                            base = URL.basePaths[k];
                            break;
                        }
                    }
                }
                url = URL.join(base, url);
            }
            return url;
        }
        static postFormatURL(url) {
            if (URL.hasExtOverrides) {
                let extold = Utils.getFileExtension(url);
                let ext = URL.overrideFileExts[extold];
                if (ext != null)
                    url = Utils.replaceFileExtension(url, ext);
            }
            return url;
        }
        static normalize(url) {
            if (url.indexOf("./") == -1)
                return url;
            let parts = url.split("/");
            let len = parts.length;
            let i = 0;
            while (i < len) {
                if (parts[i] == ".") {
                    parts.splice(i, 1);
                    len--;
                    continue;
                }
                else if (parts[i] == '..') {
                    let index = i - 1;
                    if (index >= 0 && parts[index] !== '..') {
                        parts.splice(index, 2);
                        len -= 2;
                        i--;
                        continue;
                    }
                }
                i++;
            }
            parts.length = len;
            return parts.join('/');
        }
        static getResURLByUUID(url) {
            if (Utils.isUUID(url))
                return "res://" + url;
            else
                return url;
        }
        static join(base, path) {
            if (!path)
                return "";
            if (path.indexOf(":") > 0)
                return path;
            if (base) {
                let char1 = path.charCodeAt(0);
                if (char1 !== 126 && char1 !== 47) {
                    if (base.charCodeAt(base.length - 1) !== 47)
                        path = base + "/" + path;
                    else
                        path = base + path;
                }
            }
            return URL.normalize(path);
        }
        static getPath(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(0, ofs + 1) : "";
        }
        static getFileName(url) {
            var ofs = url.lastIndexOf('/');
            return ofs > 0 ? url.substring(ofs + 1) : url;
        }
        static getURLVerion(url) {
            var index = url.indexOf("?");
            return index >= 0 ? url.substring(index) : null;
        }
        static overrideExtension(originalExts, targetExt, miniGameOnly) {
            if (miniGameOnly) {
                if (!URL.usingSafeFileExts) {
                    for (let ext of originalExts)
                        URL.safeFileExtConversionMap[ext] = targetExt;
                    return;
                }
            }
            for (let ext of originalExts)
                URL.overrideFileExts[ext] = targetExt;
            URL.hasExtOverrides = true;
        }
    }
    URL.version = {};
    URL.basePath = "";
    URL.basePaths = {};
    URL.overrideFileExts = {};
    URL.hasExtOverrides = false;
    URL.usingSafeFileExts = false;
    URL.safeFileExtConversionMap = {
        "rendertexture": "rt.json",
        "videotexture": "rt.json",
        "controller": "controller.json",
        "mc": "mc.bin",
        "mcc": "mcc.json",
        "shader": "shader.txt",
        "fui": "fui.json",
        "glsl": "glsl.txt",
        "skel": "skel.bin",
        "lavm": "lavm.json",
        "bp": "bp.json",
        "tres": "tres.json"
    };
    URL.customFormat = function (url) {
        return url;
    };

    class Rectangle {
        constructor(x = 0, y = 0, width = 0, height = 0) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        get right() {
            return this.x + this.width;
        }
        set right(value) {
            this.width = value - this.x;
        }
        get bottom() {
            return this.y + this.height;
        }
        set bottom(value) {
            this.height = value - this.y;
        }
        setTo(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            return this;
        }
        reset() {
            this.x = this.y = this.width = this.height = 0;
            return this;
        }
        recover() {
            if (this == Rectangle.TEMP || this == Rectangle.EMPTY) {
                return;
            }
            Pool.recover("Rectangle", this.reset());
        }
        static create() {
            return Pool.getItemByClass("Rectangle", Rectangle);
        }
        copyFrom(source) {
            this.x = source.x;
            this.y = source.y;
            this.width = source.width;
            this.height = source.height;
            return this;
        }
        contains(x, y) {
            if (this.width <= 0 || this.height <= 0)
                return false;
            if (x >= this.x && x < this.right) {
                if (y >= this.y && y < this.bottom) {
                    return true;
                }
            }
            return false;
        }
        intersects(rect) {
            return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
        }
        intersection(rect, out) {
            if (!this.intersects(rect))
                return null;
            let x = Math.max(this.x, rect.x);
            let y = Math.max(this.y, rect.y);
            let width = Math.min(this.right, rect.right) - x;
            let height = Math.min(this.bottom, rect.bottom) - y;
            out || (out = new Rectangle());
            return out.setTo(x, y, width, height);
        }
        union(source, out) {
            let x = source.x;
            let y = source.y;
            let width = source.width;
            let height = source.height;
            out || (out = new Rectangle());
            this.cloneTo(out);
            if (width <= 0 || height <= 0)
                return out;
            if (this.width <= 0 || this.height <= 0)
                return out.setTo(x, y, width, height);
            out.addPoint(x, y);
            out.addPoint(x + width, y + height);
            return out;
        }
        scale(scaleX, scaleY) {
            this.x *= scaleX;
            this.y *= scaleY;
            this.width *= scaleX;
            this.height *= scaleY;
            return this;
        }
        toString() {
            return this.x + "," + this.y + "," + this.width + "," + this.height;
        }
        equals(rect) {
            if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height)
                return false;
            return true;
        }
        addPoint(x, y) {
            this.x > x && (this.width += this.x - x, this.x = x);
            this.y > y && (this.height += this.y - y, this.y = y);
            if (this.width < x - this.x)
                this.width = x - this.x;
            if (this.height < y - this.y)
                this.height = y - this.y;
            return this;
        }
        getBoundPoints(out) {
            out = out || [];
            if (this.width == 0 || this.height == 0)
                return out;
            out.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
            return out;
        }
        static _getWrapRec(points, out) {
            out = out || new Rectangle();
            if (!points || points.length < 1)
                return out.setTo(0, 0, 0, 0);
            let i, len = points.length, minX, maxX, minY, maxY;
            minX = minY = 99999;
            maxX = maxY = -minX;
            for (i = 0; i < len; i += 2) {
                let tx = points[i];
                let ty = points[i + 1];
                minX = minX < tx ? minX : tx;
                minY = minY < ty ? minY : ty;
                maxX = maxX > tx ? maxX : tx;
                maxY = maxY > ty ? maxY : ty;
            }
            return out.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        static minMaxRect(minX, minY, maxX, maxY, out) {
            out = out || new Rectangle();
            return out.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        isEmpty() {
            return this.width <= 0 || this.height <= 0;
        }
        clone(out) {
            out || (out = new Rectangle());
            this.cloneTo(out);
            return out;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.width = this.width;
            destObject.height = this.height;
        }
    }
    Rectangle.EMPTY = new Rectangle();
    Rectangle.TEMP = new Rectangle();

    class Matrix {
        constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0, nums = 0) {
            this._bTransform = false;
            if (Matrix._createFun != null) {
                return Matrix._createFun(a, b, c, d, tx, ty, nums);
            }
            this.a = a;
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
            this._checkTransform();
        }
        identity() {
            this.a = this.d = 1;
            this.b = this.tx = this.ty = this.c = 0;
            this._bTransform = false;
            return this;
        }
        _checkTransform() {
            return this._bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
        }
        setTranslate(x, y) {
            this.tx = x;
            this.ty = y;
            return this;
        }
        translate(x, y) {
            this.tx += x;
            this.ty += y;
            return this;
        }
        scale(x, y) {
            this.a *= x;
            this.d *= y;
            this.c *= x;
            this.b *= y;
            this.tx *= x;
            this.ty *= y;
            this._bTransform = true;
            return this;
        }
        rotate(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var a1 = this.a;
            var c1 = this.c;
            var tx1 = this.tx;
            this.a = a1 * cos - this.b * sin;
            this.b = a1 * sin + this.b * cos;
            this.c = c1 * cos - this.d * sin;
            this.d = c1 * sin + this.d * cos;
            this.tx = tx1 * cos - this.ty * sin;
            this.ty = tx1 * sin + this.ty * cos;
            this._bTransform = true;
            return this;
        }
        skew(x, y) {
            var sinx = Math.sin(x);
            var cosx = Math.cos(x);
            var siny = Math.sin(y);
            var cosy = Math.cos(y);
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = cosy * a + sinx * this.b;
            this.b = siny * a + cosx * this.b;
            this.c = cosy * c + sinx * this.d;
            this.d = siny * c + cosx * this.d;
            this.tx = cosy * tx + sinx * this.ty;
            this.ty = siny * tx + cosx * this.ty;
            this._bTransform = true;
            return this;
        }
        invertTransformPoint(out) {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            var a2 = d1 / n;
            var b2 = -b1 / n;
            var c2 = -c1 / n;
            var d2 = a1 / n;
            var tx2 = (c1 * this.ty - d1 * tx1) / n;
            var ty2 = -(a1 * this.ty - b1 * tx1) / n;
            return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
        }
        transformPoint(out) {
            return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
        }
        transformPointN(out) {
            return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
        }
        getScaleX() {
            return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
        }
        getScaleY() {
            return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
        }
        invert() {
            var a1 = this.a;
            var b1 = this.b;
            var c1 = this.c;
            var d1 = this.d;
            var tx1 = this.tx;
            var n = a1 * d1 - b1 * c1;
            this.a = d1 / n;
            this.b = -b1 / n;
            this.c = -c1 / n;
            this.d = a1 / n;
            this.tx = (c1 * this.ty - d1 * tx1) / n;
            this.ty = -(a1 * this.ty - b1 * tx1) / n;
            return this;
        }
        setTo(a, b, c, d, tx, ty) {
            this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
            return this;
        }
        concat(matrix) {
            var a = this.a;
            var c = this.c;
            var tx = this.tx;
            this.a = a * matrix.a + this.b * matrix.c;
            this.b = a * matrix.b + this.b * matrix.d;
            this.c = c * matrix.a + this.d * matrix.c;
            this.d = c * matrix.b + this.d * matrix.d;
            this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
            this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
            return this;
        }
        static mul(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out.a = aa * ba + ab * bc;
                out.b = aa * bb + ab * bd;
                out.c = ac * ba + ad * bc;
                out.d = ac * bb + ad * bd;
                out.tx = ba * atx + bc * aty + btx;
                out.ty = bb * atx + bd * aty + bty;
            }
            else {
                out.a = aa * ba;
                out.b = ab * bd;
                out.c = ac * ba;
                out.d = ad * bd;
                out.tx = ba * atx + btx;
                out.ty = bd * aty + bty;
            }
            return out;
        }
        static mul16(m1, m2, out) {
            var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
            var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
            if (bb !== 0 || bc !== 0) {
                out[0] = aa * ba + ab * bc;
                out[1] = aa * bb + ab * bd;
                out[4] = ac * ba + ad * bc;
                out[5] = ac * bb + ad * bd;
                out[12] = ba * atx + bc * aty + btx;
                out[13] = bb * atx + bd * aty + bty;
            }
            else {
                out[0] = aa * ba;
                out[1] = ab * bd;
                out[4] = ac * ba;
                out[5] = ad * bd;
                out[12] = ba * atx + btx;
                out[13] = bd * aty + bty;
            }
            return out;
        }
        scaleEx(x, y) {
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = x * ba;
                this.b = x * bb;
                this.c = y * bc;
                this.d = y * bd;
            }
            else {
                this.a = x * ba;
                this.b = 0 * bd;
                this.c = 0 * ba;
                this.d = y * bd;
            }
            this._bTransform = true;
        }
        rotateEx(angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
            if (bb !== 0 || bc !== 0) {
                this.a = cos * ba + sin * bc;
                this.b = cos * bb + sin * bd;
                this.c = -sin * ba + cos * bc;
                this.d = -sin * bb + cos * bd;
            }
            else {
                this.a = cos * ba;
                this.b = sin * bd;
                this.c = -sin * ba;
                this.d = cos * bd;
            }
            this._bTransform = true;
        }
        clone() {
            var dec = new Matrix();
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        copyTo(dec) {
            dec.a = this.a;
            dec.b = this.b;
            dec.c = this.c;
            dec.d = this.d;
            dec.tx = this.tx;
            dec.ty = this.ty;
            dec._bTransform = this._bTransform;
            return dec;
        }
        setMatrix(x, y, sx, sy, rotation, skewX, skewY, pivotx, pivoty) {
            rotation = Utils.toRadian(rotation);
            skewX = Utils.toRadian(skewX);
            skewY = Utils.toRadian(skewY);
            const cosr = Math.cos(rotation);
            const sinr = Math.sin(rotation);
            const coskx = Math.cos(skewX);
            const sinkx = Math.sin(skewX);
            const cosky = Math.cos(skewY);
            const sinky = Math.sin(skewY);
            this.a = (cosr * cosky - sinr * sinky) * sx;
            this.b = (sinr * cosky + cosr * sinky) * sx;
            this.c = (cosr * sinkx - sinr * coskx) * sy;
            this.d = (sinr * sinkx + cosr * coskx) * sy;
            this.tx = x - this.a * pivotx - this.c * pivoty;
            this.ty = y - this.b * pivotx - this.d * pivoty;
            this._checkTransform();
            return this;
        }
        toString() {
            return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
        }
        destroy() {
            this.recover();
        }
        recover() {
            Pool.recover("Matrix", this.identity());
        }
        static create() {
            return Pool.getItemByClass("Matrix", Matrix);
        }
    }
    Matrix.EMPTY = new Matrix();
    Matrix.TEMP = new Matrix();
    Matrix._createFun = null;

    class NotImplementedError extends Error {
        constructor() {
            super('Not implemented.');
        }
    }
    class OutOfRangeError extends Error {
        constructor(index) {
            super(`Index out of range: ${index}`);
        }
    }
    class NotReadableError extends Error {
        constructor() {
            super("readable flag need to be true.");
        }
    }
    function getErrorMsg(err) {
        if (err != null && typeof err === "object") {
            let str;
            for (let k in errorFields) {
                str = err[errorFields[k]];
                if (str != null)
                    return parseError(str);
            }
        }
        return parseError(err);
    }
    function parseError(err) {
        if (typeof (err) === "number")
            return `error code=${err}`;
        else if (typeof (err) !== "string")
            return "error! " + err;
        else
            return err;
    }
    const errorFields = ["errMsg", "errorMessage", "message", "reason", "error", "errCode", "statusCode"];

    class Byte {
        static getSystemEndian() {
            if (!Byte._sysEndian) {
                var buffer = new ArrayBuffer(2);
                new DataView(buffer).setInt16(0, 256, true);
                Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
            }
            return Byte._sysEndian;
        }
        constructor(data) {
            this._xd_ = true;
            this._allocated_ = 8;
            this._pos_ = 0;
            this._length = 0;
            if (data) {
                this._u8d_ = new Uint8Array(data);
                this._d_ = new DataView(this._u8d_.buffer);
                this._length = this._d_.byteLength;
            }
            else {
                this._resizeBuffer(this._allocated_);
            }
        }
        get buffer() {
            let rstBuffer = this._d_.buffer;
            if (rstBuffer.byteLength === this._length)
                return rstBuffer;
            else
                return rstBuffer.slice(0, this._length);
        }
        get rawBuffer() {
            return this._d_.buffer;
        }
        __getBuffer() {
            return this._d_.buffer;
        }
        get endian() {
            return this._xd_ ? Byte.LITTLE_ENDIAN : Byte.BIG_ENDIAN;
        }
        set endian(value) {
            this._xd_ = (value === Byte.LITTLE_ENDIAN);
        }
        set length(value) {
            if (this._allocated_ < value)
                this._resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
            else if (this._allocated_ > value)
                this._resizeBuffer(this._allocated_ = value);
            this._length = value;
        }
        get length() {
            return this._length;
        }
        _resizeBuffer(len) {
            try {
                var newByteView = new Uint8Array(len);
                if (this._u8d_ != null) {
                    if (this._u8d_.length <= len)
                        newByteView.set(this._u8d_);
                    else
                        newByteView.set(this._u8d_.subarray(0, len));
                }
                this._u8d_ = newByteView;
                this._d_ = new DataView(newByteView.buffer);
            }
            catch (err) {
                throw "Invalid typed array length:" + len;
            }
        }
        getString() {
            return this.readString();
        }
        readString() {
            return this._rUTF(this.getUint16());
        }
        getFloat32Array(start, len) {
            return this.readFloat32Array(start, len);
        }
        readFloat32Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Float32Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getUint8Array(start, len) {
            return this.readUint8Array(start, len);
        }
        readUint8Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Uint8Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getInt16Array(start, len) {
            return this.readInt16Array(start, len);
        }
        readInt16Array(start, len) {
            var end = start + len;
            end = (end > this._length) ? this._length : end;
            var v = new Int16Array(this._d_.buffer.slice(start, end));
            this._pos_ = end;
            return v;
        }
        getFloat32() {
            return this.readFloat32();
        }
        readFloat32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var v = this._d_.getFloat32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        getFloat64() {
            return this.readFloat64();
        }
        readFloat64() {
            if (this._pos_ + 8 > this._length)
                throw new OutOfRangeError(this._pos_ + 8);
            var v = this._d_.getFloat64(this._pos_, this._xd_);
            this._pos_ += 8;
            return v;
        }
        writeFloat32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setFloat32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeFloat64(value) {
            this._ensureWrite(this._pos_ + 8);
            this._d_.setFloat64(this._pos_, value, this._xd_);
            this._pos_ += 8;
        }
        getInt32() {
            return this.readInt32();
        }
        readInt32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var float = this._d_.getInt32(this._pos_, this._xd_);
            this._pos_ += 4;
            return float;
        }
        getUint32() {
            return this.readUint32();
        }
        readUint32() {
            if (this._pos_ + 4 > this._length)
                throw new OutOfRangeError(this._pos_ + 4);
            var v = this._d_.getUint32(this._pos_, this._xd_);
            this._pos_ += 4;
            return v;
        }
        writeInt32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setInt32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        writeUint32(value) {
            this._ensureWrite(this._pos_ + 4);
            this._d_.setUint32(this._pos_, value, this._xd_);
            this._pos_ += 4;
        }
        getInt16() {
            return this.readInt16();
        }
        readInt16() {
            if (this._pos_ + 2 > this._length)
                throw new OutOfRangeError(this._pos_ + 2);
            var us = this._d_.getInt16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        getUint16() {
            return this.readUint16();
        }
        readUint16() {
            if (this._pos_ + 2 > this._length)
                throw new OutOfRangeError(this._pos_ + 2);
            var us = this._d_.getUint16(this._pos_, this._xd_);
            this._pos_ += 2;
            return us;
        }
        writeUint16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setUint16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        writeInt16(value) {
            this._ensureWrite(this._pos_ + 2);
            this._d_.setInt16(this._pos_, value, this._xd_);
            this._pos_ += 2;
        }
        getUint8() {
            return this.readUint8();
        }
        readUint8() {
            if (this._pos_ + 1 > this._length)
                throw new OutOfRangeError(this._pos_ + 1);
            return this._u8d_[this._pos_++];
        }
        writeUint8(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setUint8(this._pos_, value);
            this._pos_++;
        }
        _getMatrix() {
            return this._readMatrix();
        }
        _readMatrix() {
            var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
            return rst;
        }
        _rUTF(len) {
            let max = this._pos_ + len, c, c2, c3, f = String.fromCharCode;
            let u = this._u8d_;
            let strs = [];
            let n = 0;
            strs.length = 1000;
            while (this._pos_ < max) {
                c = u[this._pos_++];
                if (c < 0x80) {
                    if (c != 0)
                        strs[n++] = f(c);
                }
                else if (c < 0xE0) {
                    strs[n++] = f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else if (c < 0xF0) {
                    c2 = u[this._pos_++];
                    strs[n++] = f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
                }
                else {
                    c2 = u[this._pos_++];
                    c3 = u[this._pos_++];
                    const _code = ((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 & 0x7F) << 6) | (u[this._pos_++] & 0x7F);
                    if (_code >= 0x10000) {
                        const _offset = _code - 0x10000;
                        const _lead = 0xd800 | (_offset >> 10);
                        const _trail = 0xdc00 | (_offset & 0x3ff);
                        strs[n++] = f(_lead);
                        strs[n++] = f(_trail);
                    }
                    else {
                        strs[n++] = f(_code);
                    }
                }
            }
            strs.length = n;
            return strs.join('');
        }
        getCustomString(len) {
            return this.readCustomString(len);
        }
        readCustomString(len) {
            var v = "", ulen = 0, c, c2, f = String.fromCharCode;
            var u = this._u8d_;
            while (len > 0) {
                c = u[this._pos_];
                if (c < 0x80) {
                    v += f(c);
                    this._pos_++;
                    len--;
                }
                else {
                    ulen = c - 0x80;
                    this._pos_++;
                    len -= ulen;
                    while (ulen > 0) {
                        c = u[this._pos_++];
                        c2 = u[this._pos_++];
                        v += f((c2 << 8) | c);
                        ulen--;
                    }
                }
            }
            return v;
        }
        get pos() {
            return this._pos_;
        }
        set pos(value) {
            this._pos_ = value;
        }
        get bytesAvailable() {
            return this._length - this._pos_;
        }
        clear() {
            this._pos_ = 0;
            this.length = 0;
        }
        writeUTFBytes(value) {
            value = value + "";
            for (var i = 0, sz = value.length; i < sz; i++) {
                var c = value.charCodeAt(i);
                if (c <= 0x7F) {
                    this.writeByte(c);
                }
                else if (c <= 0x7FF) {
                    this._ensureWrite(this._pos_ + 2);
                    this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 2;
                }
                else if (c >= 0xD800 && c <= 0xDBFF) {
                    i++;
                    const c2 = value.charCodeAt(i);
                    if (!Number.isNaN(c2) && c2 >= 0xDC00 && c2 <= 0xDFFF) {
                        const _p1 = (c & 0x3FF) + 0x40;
                        const _p2 = c2 & 0x3FF;
                        const _b1 = 0xF0 | ((_p1 >> 8) & 0x3F);
                        const _b2 = 0x80 | ((_p1 >> 2) & 0x3F);
                        const _b3 = 0x80 | ((_p1 & 0x3) << 4) | ((_p2 >> 6) & 0xF);
                        const _b4 = 0x80 | (_p2 & 0x3F);
                        this._ensureWrite(this._pos_ + 4);
                        this._u8d_.set([_b1, _b2, _b3, _b4], this._pos_);
                        this._pos_ += 4;
                    }
                }
                else if (c <= 0xFFFF) {
                    this._ensureWrite(this._pos_ + 3);
                    this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 3;
                }
                else {
                    this._ensureWrite(this._pos_ + 4);
                    this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
                    this._pos_ += 4;
                }
            }
        }
        writeUTFString(value) {
            var tPos = this.pos;
            this.writeUint16(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 2;
            this._d_.setUint16(tPos, dPos, this._xd_);
        }
        writeUTFString32(value) {
            var tPos = this.pos;
            this.writeUint32(1);
            this.writeUTFBytes(value);
            var dPos = this.pos - tPos - 4;
            this._d_.setUint32(tPos, dPos, this._xd_);
        }
        readUTFString() {
            return this.readUTFBytes(this.getUint16());
        }
        readUTFString32() {
            return this.readUTFBytes(this.getUint32());
        }
        getUTFString() {
            return this.readUTFString();
        }
        readUTFBytes(len = -1) {
            if (len === 0)
                return "";
            var lastBytes = this.bytesAvailable;
            if (len > lastBytes)
                throw new OutOfRangeError(this._pos_ + len);
            len = len > 0 ? len : lastBytes;
            return this._rUTF(len);
        }
        getUTFBytes(len = -1) {
            return this.readUTFBytes(len);
        }
        writeByte(value) {
            this._ensureWrite(this._pos_ + 1);
            this._d_.setInt8(this._pos_, value);
            this._pos_ += 1;
        }
        readByte() {
            if (this._pos_ + 1 > this._length)
                throw new OutOfRangeError(this._pos_ + 1);
            return this._d_.getInt8(this._pos_++);
        }
        getByte() {
            return this.readByte();
        }
        _ensureWrite(lengthToEnsure) {
            if (this._length < lengthToEnsure)
                this._length = lengthToEnsure;
            if (this._allocated_ < lengthToEnsure)
                this.length = lengthToEnsure;
        }
        writeArrayBuffer(arraybuffer, offset = 0, length = 0) {
            if (offset < 0 || length < 0)
                throw new OutOfRangeError(offset + length);
            if (length == 0)
                length = arraybuffer.byteLength - offset;
            this._ensureWrite(this._pos_ + length);
            var uint8array = new Uint8Array(arraybuffer);
            this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
            this._pos_ += length;
        }
        readArrayBuffer(length) {
            var rst;
            rst = this._u8d_.buffer.slice(this._pos_, this._pos_ + length);
            this._pos_ = this._pos_ + length;
            return rst;
        }
    }
    Byte.BIG_ENDIAN = "bigEndian";
    Byte.LITTLE_ENDIAN = "littleEndian";
    Byte._sysEndian = null;

    class HalfFloatUtils {
        static __init__() {
            for (var i = 0; i < 256; ++i) {
                var e = i - 127;
                if (e < -27) {
                    _baseTable[i | 0x000] = 0x0000;
                    _baseTable[i | 0x100] = 0x8000;
                    _shiftTable[i | 0x000] = 24;
                    _shiftTable[i | 0x100] = 24;
                }
                else if (e < -14) {
                    _baseTable[i | 0x000] = 0x0400 >> (-e - 14);
                    _baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                    _shiftTable[i | 0x000] = -e - 1;
                    _shiftTable[i | 0x100] = -e - 1;
                }
                else if (e <= 15) {
                    _baseTable[i | 0x000] = (e + 15) << 10;
                    _baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                    _shiftTable[i | 0x000] = 13;
                    _shiftTable[i | 0x100] = 13;
                }
                else if (e < 128) {
                    _baseTable[i | 0x000] = 0x7c00;
                    _baseTable[i | 0x100] = 0xfc00;
                    _shiftTable[i | 0x000] = 24;
                    _shiftTable[i | 0x100] = 24;
                }
                else {
                    _baseTable[i | 0x000] = 0x7c00;
                    _baseTable[i | 0x100] = 0xfc00;
                    _shiftTable[i | 0x000] = 13;
                    _shiftTable[i | 0x100] = 13;
                }
            }
            _mantissaTable[0] = 0;
            for (i = 1; i < 1024; ++i) {
                var m = i << 13;
                e = 0;
                while ((m & 0x00800000) === 0) {
                    e -= 0x00800000;
                    m <<= 1;
                }
                m &= ~0x00800000;
                e += 0x38800000;
                _mantissaTable[i] = m | e;
            }
            for (i = 1024; i < 2048; ++i) {
                _mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
            }
            _exponentTable[0] = 0;
            for (i = 1; i < 31; ++i) {
                _exponentTable[i] = i << 23;
            }
            _exponentTable[31] = 0x47800000;
            _exponentTable[32] = 0x80000000;
            for (i = 33; i < 63; ++i) {
                _exponentTable[i] = 0x80000000 + ((i - 32) << 23);
            }
            _exponentTable[63] = 0xc7800000;
            _offsetTable[0] = 0;
            for (i = 1; i < 64; ++i) {
                if (i === 32) {
                    _offsetTable[i] = 0;
                }
                else {
                    _offsetTable[i] = 1024;
                }
            }
        }
        static roundToFloat16Bits(num) {
            _floatView[0] = num;
            var f = _uint32View[0];
            var e = (f >> 23) & 0x1ff;
            return _baseTable[e] + ((f & 0x007fffff) >> _shiftTable[e]);
        }
        static convertToNumber(float16bits) {
            var m = float16bits >> 10;
            _uint32View[0] = _mantissaTable[_offsetTable[m] + (float16bits & 0x3ff)] + _exponentTable[m];
            return _floatView[0];
        }
    }
    const _buffer = new ArrayBuffer(4);
    const _floatView = new Float32Array(_buffer);
    const _uint32View = new Uint32Array(_buffer);
    const _baseTable = new Uint32Array(512);
    const _shiftTable = new Uint32Array(512);
    const _mantissaTable = new Uint32Array(2048);
    const _exponentTable = new Uint32Array(64);
    const _offsetTable = new Uint32Array(64);

    exports.FilterMode = void 0;
    (function (FilterMode) {
        FilterMode[FilterMode["Point"] = 0] = "Point";
        FilterMode[FilterMode["Bilinear"] = 1] = "Bilinear";
        FilterMode[FilterMode["Trilinear"] = 2] = "Trilinear";
    })(exports.FilterMode || (exports.FilterMode = {}));

    exports.RenderCapable = void 0;
    (function (RenderCapable) {
        RenderCapable[RenderCapable["Element_Index_Uint32"] = 0] = "Element_Index_Uint32";
        RenderCapable[RenderCapable["Element_Index_Uint8"] = 1] = "Element_Index_Uint8";
        RenderCapable[RenderCapable["TextureFormat_R32G32B32A32"] = 2] = "TextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["TextureFormat_R16G16B16A16"] = 3] = "TextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["Texture_anisotropic"] = 4] = "Texture_anisotropic";
        RenderCapable[RenderCapable["RenderTextureFormat_R16G16B16A16"] = 5] = "RenderTextureFormat_R16G16B16A16";
        RenderCapable[RenderCapable["RenderTextureFormat_R32G32B32A32"] = 6] = "RenderTextureFormat_R32G32B32A32";
        RenderCapable[RenderCapable["RenderTextureFormat_Depth"] = 7] = "RenderTextureFormat_Depth";
        RenderCapable[RenderCapable["RenderTextureFormat_ShadowMap"] = 8] = "RenderTextureFormat_ShadowMap";
        RenderCapable[RenderCapable["Vertex_VAO"] = 9] = "Vertex_VAO";
        RenderCapable[RenderCapable["DrawElement_Instance"] = 10] = "DrawElement_Instance";
        RenderCapable[RenderCapable["Shader_TextureLod"] = 11] = "Shader_TextureLod";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC"] = 12] = "COMPRESS_TEXTURE_S3TC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_S3TC_SRGB"] = 13] = "COMPRESS_TEXTURE_S3TC_SRGB";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_PVRTC"] = 14] = "COMPRESS_TEXTURE_PVRTC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC1"] = 15] = "COMPRESS_TEXTURE_ETC1";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ETC"] = 16] = "COMPRESS_TEXTURE_ETC";
        RenderCapable[RenderCapable["COMPRESS_TEXTURE_ASTC"] = 17] = "COMPRESS_TEXTURE_ASTC";
        RenderCapable[RenderCapable["Texture_SRGB"] = 18] = "Texture_SRGB";
        RenderCapable[RenderCapable["MSAA"] = 19] = "MSAA";
        RenderCapable[RenderCapable["UnifromBufferObject"] = 20] = "UnifromBufferObject";
        RenderCapable[RenderCapable["Texture3D"] = 21] = "Texture3D";
        RenderCapable[RenderCapable["Texture_FloatLinearFiltering"] = 22] = "Texture_FloatLinearFiltering";
        RenderCapable[RenderCapable["Texture_HalfFloatLinearFiltering"] = 23] = "Texture_HalfFloatLinearFiltering";
    })(exports.RenderCapable || (exports.RenderCapable = {}));

    const FOURCC_DXT1 = 827611204;
    const FOURCC_DXT3 = 861165636;
    const FOURCC_DXT4 = 877942852;
    const FOURCC_DXT5 = 894720068;
    const DDPF_FOURCC = 0x4;
    const DDPF_RGB = 0x40;
    const DDSCAPS2_CUBEMAP = 0x200;
    const DDPF_LUMINANCE = 0x20000;
    const DDSD_MIPMAPCOUNT = 0x20000;
    const DDS_MAGIC = 0x20534444;
    const DDS_HEADER_LENGTH = 31;
    const DDS_HEADER_MAGIC = 0;
    const DDS_HEADER_SIZE = 1;
    const DDS_HEADER_FLAGS = 2;
    const DDS_HEADER_HEIGHT = 3;
    const DDS_HEADER_WIDTH = 4;
    const DDS_HEADER_MIPMAPCOUNT = 7;
    const DDS_HEADER_PF_FLAGS = 20;
    const DDS_HEADER_PF_FOURCC = 21;
    const DDS_HEADER_PF_CAPS2 = 28;
    const FOURCC_D3DFMT_R16G16B16A16F = 113;
    const FOURCC_D3DFMT_R32G32B32A32F = 116;
    const Int32ToFourCC = (value) => {
        return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
    };
    class DDSTextureInfo {
        constructor(width, height, mipmapCount, isCube, bpp, blockBytes, dataOffset, format, compressed, sourceData) {
            this.width = width;
            this.height = height;
            this.mipmapCount = mipmapCount;
            this.isCube = isCube;
            this.blockBytes = blockBytes;
            this.dataOffset = dataOffset;
            this.format = format;
            this.source = sourceData;
            this.bpp = bpp;
            this.compressed = compressed;
        }
        static getDDSTextureInfo(source) {
            let header = new Int32Array(source, 0, DDS_HEADER_LENGTH);
            let width = header[DDS_HEADER_WIDTH];
            let height = header[DDS_HEADER_HEIGHT];
            let mipmapCount = 1;
            if (header[DDS_HEADER_FLAGS] & DDSD_MIPMAPCOUNT) {
                mipmapCount = Math.max(1, header[DDS_HEADER_MIPMAPCOUNT]);
            }
            let fourCC = header[DDS_HEADER_PF_FOURCC];
            let isFourCC = (header[DDS_HEADER_PF_FLAGS] & DDPF_FOURCC) === DDPF_FOURCC;
            let isRGB = (header[DDS_HEADER_PF_FLAGS] & DDPF_RGB) === DDPF_RGB;
            let isLuminance = (header[DDS_HEADER_PF_FLAGS] & DDPF_LUMINANCE) === DDPF_LUMINANCE;
            let isCube = (header[DDS_HEADER_PF_CAPS2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP;
            let isCompressed = (fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5 || fourCC === FOURCC_DXT4);
            let layaTexFormat = exports.TextureFormat.DXT1;
            let dataOffset = header[DDS_HEADER_SIZE] + 4;
            let blockBytes = 1;
            switch (fourCC) {
                case FOURCC_DXT1:
                    layaTexFormat = exports.TextureFormat.DXT1;
                    blockBytes = 8;
                    break;
                case FOURCC_DXT3:
                    layaTexFormat = exports.TextureFormat.DXT3;
                    blockBytes = 16;
                    break;
                case FOURCC_DXT4:
                case FOURCC_DXT5:
                    layaTexFormat = exports.TextureFormat.DXT5;
                    blockBytes = 16;
                    break;
                case FOURCC_D3DFMT_R16G16B16A16F:
                    layaTexFormat = exports.TextureFormat.R16G16B16A16;
                    blockBytes = 4;
                    break;
                case FOURCC_D3DFMT_R32G32B32A32F:
                    layaTexFormat = exports.TextureFormat.R32G32B32A32;
                    blockBytes = 4;
                    break;
                default:
                    throw "Unsupported format " + Int32ToFourCC(fourCC);
            }
            if (header[DDS_HEADER_MAGIC] !== DDS_MAGIC) {
                throw "Invalid magic number in DDS header";
            }
            if (!isFourCC && !isRGB && !isLuminance) {
                throw "Unsupported format, must contain a FourCC, RGB or LUMINANCE code";
            }
            let ext = LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC) || LayaGL.renderEngine.getCapable(exports.RenderCapable.COMPRESS_TEXTURE_S3TC_SRGB);
            if (isCompressed && !ext) {
                throw "Compressed textures are not supported on this platform.";
            }
            return new DDSTextureInfo(width, height, mipmapCount, isCube, 0, blockBytes, dataOffset, layaTexFormat, isCompressed, source);
        }
    }

    const IdentifierByteSize = 12;
    const HeaderSize = 13;
    const COMPRESSED_RGB_ETC1_WEBGL = 36196;
    const COMPRESSED_RGB8_ETC2 = 37492;
    const COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
    const COMPRESSED_RGBA8_ETC2_EAC = 37496;
    const COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
    const COMPRESSED_SRGB8_ETC2 = 37493;
    const COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
    const COMPRESSED_RGBA_ASTC_4x4_KHR = 37808;
    const COMPRESSED_RGBA_ASTC_6x6_KHR = 37812;
    const COMPRESSED_RGBA_ASTC_8x8_KHR = 37815;
    const COMPRESSED_RGBA_ASTC_10x10_KHR = 37819;
    const COMPRESSED_RGBA_ASTC_12x12_KHR = 37821;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851;
    const COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853;
    const GL_FORMAT_RGBA = 6408;
    const GL_FORMAT_RGB = 6407;
    const GL_FORMAT_RGBA32F = 0x8814;
    const GL_FORMAT_RGB32F = 0x8815;
    const GL_FORMAT_RGBA16F = 0x881A;
    const GL_FORMAT_RGB16F = 0x881B;
    const GL_FORMAT_SRGB8 = 0x8C41;
    const GL_INTERNALFORMAT_RGBA8 = 0x8058;
    const GL_INTERNALFORMAT_RGB8 = 0x8051;
    const GL_INTERNALFORMAT_SRGB8_ALPHA8 = 0x8C43;
    const GL_DATATYPE_UNSIGNED_BYTE = 0x1401;
    const GL_DATATYPE_FLOAT = 0x1406;
    const GL_DATATYPE_HALF_FLOAT = 0x140b;
    class KTXTextureInfo {
        static getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize) {
            if (glFormat == 0) {
                switch (glInternalFormat) {
                    case COMPRESSED_RGB_ETC1_WEBGL:
                        return { format: exports.TextureFormat.ETC1RGB, sRGB: false };
                    case COMPRESSED_RGBA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2RGBA, sRGB: false };
                    case COMPRESSED_RGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha8, sRGB: true };
                    case COMPRESSED_SRGB8_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB, sRGB: true };
                    case COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                        return { format: exports.TextureFormat.ETC2RGB_Alpha1, sRGB: false };
                    case COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:
                        return { format: exports.TextureFormat.ETC2SRGB_Alpha1, sRGB: true };
                    case COMPRESSED_RGBA_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10, sRGB: false };
                    case COMPRESSED_RGBA_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12, sRGB: false };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:
                        return { format: exports.TextureFormat.ASTC4x4SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:
                        return { format: exports.TextureFormat.ASTC6x6SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:
                        return { format: exports.TextureFormat.ASTC8x8SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:
                        return { format: exports.TextureFormat.ASTC10x10SRGB, sRGB: true };
                    case COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:
                        return { format: exports.TextureFormat.ASTC12x12SRGB, sRGB: true };
                    default:
                        throw "KTX: UnSupported Compressed format.";
                }
            }
            else {
                if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_RGBA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_INTERNALFORMAT_SRGB8_ALPHA8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8A8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32A32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGBA && glInternalFormat == GL_FORMAT_RGBA16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16A16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB32F && glType == GL_DATATYPE_FLOAT) {
                    return { format: exports.TextureFormat.R32G32B32, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_RGB16F && glType == GL_DATATYPE_HALF_FLOAT) {
                    return { format: exports.TextureFormat.R16G16B16, sRGB: false };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_FORMAT_SRGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: true };
                }
                else if (glFormat == GL_FORMAT_RGB && glInternalFormat == GL_INTERNALFORMAT_RGB8 && glType == GL_DATATYPE_UNSIGNED_BYTE) {
                    return { format: exports.TextureFormat.R8G8B8, sRGB: false };
                }
                else {
                    throw "ktx: Unsupported UnCompressed image data.";
                }
            }
        }
        static getKTXTextureInfo(source) {
            let FileIdentifier = new Uint8Array(source, 0, 12);
            if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x32 && FileIdentifier[6] === 0x30 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                throw "ktx2 !";
            }
            else if (FileIdentifier[0] === 0xAB && FileIdentifier[1] === 0x4B && FileIdentifier[2] === 0x54 && FileIdentifier[3] === 0x58 && FileIdentifier[4] === 0x20 && FileIdentifier[5] === 0x31 && FileIdentifier[6] === 0x31 && FileIdentifier[7] === 0xBB && FileIdentifier[8] === 0x0D && FileIdentifier[9] === 0x0A && FileIdentifier[10] === 0x1A && FileIdentifier[11] === 0x0A) {
                return KTXTextureInfo.createKTX1Info(source);
            }
            else {
                throw "ktx data wrong, not ktx1 or ktx2 buffer!";
            }
        }
        static createKTX1Info(source) {
            let dataSize = Uint32Array.BYTES_PER_ELEMENT;
            let headerDataView = new DataView(source, IdentifierByteSize, dataSize * HeaderSize);
            let endianness = headerDataView.getUint32(0, true);
            let littleEndian = endianness == 0x04030201;
            let glType = headerDataView.getUint32(1 * dataSize, littleEndian);
            let glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian);
            let glFormat = headerDataView.getUint32(3 * dataSize, littleEndian);
            let glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian);
            headerDataView.getUint32(5 * dataSize, littleEndian);
            let pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian);
            let pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian);
            headerDataView.getUint32(8 * dataSize, littleEndian);
            let numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian);
            let numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian);
            let numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian);
            let bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian);
            let formatInfo = KTXTextureInfo.getLayaFormat(glFormat, glInternalFormat, glType, glTypeSize);
            let layaFormat = formatInfo.format;
            let sRGBData = formatInfo.sRGB;
            let layaDemision = exports.TextureDimension.Tex2D;
            if (numberOfFaces > 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.CubeArray;
            }
            else if (numberOfFaces > 1 && numberOfArrayElements <= 1) {
                layaDemision = exports.TextureDimension.Cube;
            }
            else if (numberOfFaces <= 1 && numberOfArrayElements > 1) {
                layaDemision = exports.TextureDimension.Texture2DArray;
            }
            let headerOffset = IdentifierByteSize + HeaderSize * 4;
            return new KTXTextureInfo(source, glFormat == 0, sRGBData, layaDemision, pixelWidth, pixelHeight, layaFormat, numberOfMipmapLevels || 1, bytesOfKeyValueData, headerOffset);
        }
        constructor(source, compress, sRGB, dimension, width, height, format, mipmapCount, bytesOfKeyValueData, headerOffset) {
            this.source = source;
            this.compress = compress;
            this.sRGB = sRGB;
            this.dimension = dimension;
            this.width = width;
            this.height = height;
            this.format = format;
            this.mipmapCount = mipmapCount;
            this.bytesOfKeyValueData = bytesOfKeyValueData;
            this.headerOffset = headerOffset;
        }
    }

    class Texture2D extends BaseTexture {
        static __init__() {
            var pixels = new Uint8Array(4);
            pixels[0] = 128;
            pixels[1] = 128;
            pixels[2] = 128;
            pixels[3] = 255;
            Texture2D.grayTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.grayTexture.setPixelsData(pixels, false, false);
            Texture2D.grayTexture.lock = true;
            Texture2D.grayTexture.name = "Default_Gray";
            pixels[0] = 255;
            pixels[1] = 255;
            pixels[2] = 255;
            pixels[3] = 255;
            Texture2D.whiteTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.whiteTexture.setPixelsData(pixels, false, false);
            Texture2D.whiteTexture.lock = true;
            Texture2D.whiteTexture.name = "Default_White";
            pixels[0] = 0;
            pixels[1] = 0;
            pixels[2] = 0;
            pixels[3] = 255;
            Texture2D.blackTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false);
            Texture2D.blackTexture.setPixelsData(pixels, false, false);
            Texture2D.blackTexture.lock = true;
            Texture2D.blackTexture.name = "Default_Black";
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                let floatPixle = new Uint16Array(4);
                floatPixle[0] = 14336;
                floatPixle[1] = 14336;
                floatPixle[2] = 15360;
                floatPixle[3] = 15360;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R16G16B16A16, false, false, false);
                Texture2D.normalTexture.setPixelsData(floatPixle, false, false);
            }
            else {
                pixels[0] = 128;
                pixels[1] = 128;
                pixels[2] = 255;
                pixels[3] = 255;
                Texture2D.normalTexture = new Texture2D(1, 1, exports.TextureFormat.R8G8B8A8, false, false, false);
                Texture2D.normalTexture.setPixelsData(pixels, false, false);
            }
            Texture2D.normalTexture.lock = true;
            Texture2D.normalTexture.name = "Default_Normal";
            Texture2D.errorTexture = Texture2D.whiteTexture;
        }
        static _SimpleAnimatorTextureParse(data, propertyParams = null, constructParams = null) {
            var byte = new Byte(data);
            var version = byte.readUTFString();
            var texture;
            var pixelDataArrays;
            var usePixelData;
            switch (version) {
                case "LAYAANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Float32Array(textureWidth * textureWidth * 4);
                    usePixelData = new Float32Array(byte.readArrayBuffer(pixelDataLength * 4));
                    pixelDataArrays.set(usePixelData, 0);
                    var texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                    texture.setPixelsData(pixelDataArrays, false, false);
                    texture.filterMode = exports.FilterMode.Point;
                    break;
                case "LAYACOMPRESSANIMATORTEXTURE:0000":
                    var textureWidth = byte.readInt32();
                    var pixelDataLength = byte.readInt32();
                    pixelDataArrays = new Uint16Array(byte.readArrayBuffer(pixelDataLength * 2));
                    if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R16G16B16A16)) {
                        console.log("The platform does not support 16-bit floating-point textures");
                        if (!LayaGL.renderEngine.getCapable(exports.RenderCapable.TextureFormat_R32G32B32A32))
                            console.error("The platform does not support 32-bit floating-point textures");
                        usePixelData = new Float32Array(textureWidth * textureWidth * 4);
                        for (var i = 0, n = pixelDataArrays.length; i < n; i++) {
                            usePixelData[i] = HalfFloatUtils.convertToNumber(pixelDataArrays[i]);
                        }
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R32G32B32A32, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    else {
                        usePixelData = new Uint16Array(textureWidth * textureWidth * 4);
                        usePixelData.set(pixelDataArrays, 0);
                        texture = new Texture2D(textureWidth, textureWidth, exports.TextureFormat.R16G16B16A16, false, false);
                        texture.setPixelsData(usePixelData, false, false);
                        texture.filterMode = exports.FilterMode.Point;
                    }
                    break;
                default:
                    throw "Laya3D:unknow version.";
            }
            return texture;
        }
        static _parseImage(imageSource, propertyParams = null, constructParams = null) {
            let format = constructParams ? constructParams[2] : exports.TextureFormat.R8G8B8A8;
            let mipmap = constructParams ? constructParams[3] : true;
            let canread = constructParams ? constructParams[4] : false;
            let srgb = constructParams ? constructParams[5] : false;
            let pma = propertyParams ? propertyParams.premultiplyAlpha : false;
            let texture = new Texture2D(imageSource.width, imageSource.height, format, mipmap, canread, srgb, pma);
            if (propertyParams) {
                texture.setImageData(imageSource, pma, false);
                texture.setProperties(propertyParams);
            }
            else
                texture.setImageData(imageSource, false, false);
            if (canread) {
                if (LayaEnv.isConch && imageSource._nativeObj) {
                    texture._pixels = new Uint8Array(imageSource._nativeObj.getImageData(0, 0, imageSource.width, imageSource.height));
                }
                else {
                    Browser.canvas.size(imageSource.width, imageSource.height);
                    Browser.canvas.clear();
                    Browser.context.drawImage(imageSource, 0, 0, imageSource.width, imageSource.height);
                    texture._pixels = new Uint8Array(Browser.context.getImageData(0, 0, imageSource.width, imageSource.height).data.buffer);
                }
            }
            return texture;
        }
        static _parseDDS(data, propertyParams = null, constructParams = null) {
            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
            let sRGB = constructParams ? constructParams[5] : false;
            let texture = new Texture2D(ddsInfo.width, ddsInfo.height, ddsInfo.format, ddsInfo.mipmapCount > 1, false, sRGB);
            texture.setDDSData(ddsInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            return texture;
        }
        static _parseKTX(data, propertyParams = null, constructParams = null) {
            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
            let texture = new Texture2D(ktxInfo.width, ktxInfo.height, ktxInfo.format, ktxInfo.mipmapCount > 1, false, ktxInfo.sRGB);
            texture.setKTXData(ktxInfo);
            if (propertyParams)
                texture.setProperties(propertyParams);
            return texture;
        }
        static _parsePVR(data, propertyParams = null, constructParams = null) {
            throw "pvr !";
        }
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, ILaya.Loader.TEXTURE2D);
        }
        constructor(width, height, format, mipmap = true, canRead, sRGB = false, premultiplyAlpha = false) {
            super(width, height, format);
            this._canRead = false;
            this._premultiplyAlpha = false;
            this._dimension = exports.TextureDimension.Tex2D;
            this._gammaSpace = sRGB;
            this._canRead = canRead;
            this._premultiplyAlpha = premultiplyAlpha;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, width, height, format, mipmap, sRGB, premultiplyAlpha);
            return;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureImageData(texture, source, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTexturePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, width, height, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureKTXData(texture, ktxInfo);
        }
        setHDRData(hdrInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setTextureHDRData(texture, hdrInfo);
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getPixels() {
            if (this._canRead && this._pixels) {
                return this._pixels;
            }
            else {
                throw new Error("Texture2D: must set texture canRead is true.");
            }
        }
        setProperties(propertyParams) {
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    this.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    this.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    this.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    this.anisoLevel = propertyParams.anisoLevel;
            }
        }
    }
    Texture2D.TEXTURE2D = "TEXTURE2D";
    Texture2D.grayTexture = null;
    Texture2D.whiteTexture = null;
    Texture2D.blackTexture = null;
    Texture2D.normalTexture = null;
    Texture2D.errorTexture = null;

    class RenderTexture2D extends BaseTexture {
        static get currentActive() {
            return RenderTexture2D._currentActive;
        }
        get depthStencilFormat() {
            return this._depthStencilFormat;
        }
        get defaultTexture() {
            return Texture2D.grayTexture;
        }
        getIsReady() {
            return true;
        }
        getColorFormat() {
            return this._colorFormat;
        }
        get sourceWidth() {
            return this._width;
        }
        get sourceHeight() {
            return this._height;
        }
        get offsetX() {
            return 0;
        }
        get offsetY() {
            return 0;
        }
        constructor(width, height, format = exports.RenderTargetFormat.R8G8B8, depthStencilFormat = exports.RenderTargetFormat.None) {
            super(width, height, format);
            this._mgrKey = 0;
            this._invertY = false;
            this._colorFormat = format;
            this._depthStencilFormat = depthStencilFormat;
            if (width != 0 && height != 0) {
                this._create();
            }
            this.lock = true;
        }
        get isCube() {
            return this._renderTarget._isCube;
        }
        get samples() {
            return this._renderTarget._samples;
        }
        get generateMipmap() {
            return this._renderTarget._generateMipmap;
        }
        _start() {
            throw new NotImplementedError();
        }
        _end() {
            throw new NotImplementedError();
        }
        _create() {
            this._renderTarget = LayaGL.textureContext.createRenderTargetInternal(this.width, this.height, this._colorFormat, this.depthStencilFormat, false, false, 1);
            this._texture = this._renderTarget._textures[0];
            this._texture.gammaCorrection = 2.2;
        }
        clear(r = 0.0, g = 0.0, b = 0.0, a = 1.0) {
            RenderTexture2D._clearColor.r = r;
            RenderTexture2D._clearColor.g = g;
            RenderTexture2D._clearColor.b = b;
            RenderTexture2D._clearColor.a = a;
            RenderTexture2D._clear = true;
        }
        getData(x, y, width, height) {
            const pixelCount = width * height * 4;
            let pixelArray;
            switch (this._renderTarget.colorFormat) {
                case exports.RenderTargetFormat.R8G8B8:
                case exports.RenderTargetFormat.R8G8B8A8:
                    pixelArray = new Uint8Array(pixelCount);
                    break;
                case exports.RenderTargetFormat.R16G16B16A16:
                    pixelArray = new Float32Array(pixelCount);
                    break;
                default:
                    throw "this function is not surpprt " + this._renderTarget.colorFormat.toString() + "format Material";
            }
            LayaGL.textureContext.readRenderTargetPixelData(this._renderTarget, x, y, width, height, pixelArray);
            return pixelArray;
        }
        getDataAsync(xOffset, yOffset, width, height, out) {
            return LayaGL.textureContext.readRenderTargetPixelDataAsync(this._renderTarget, xOffset, yOffset, width, height, out);
        }
        recycle() {
        }
        _disposeResource() {
            this._renderTarget && this._renderTarget.dispose();
        }
    }
    RenderTexture2D._clearColor = new Color(0, 0, 0, 0);
    RenderTexture2D._clear = false;
    RenderTexture2D._clearLinearColor = new Color();
    RenderTexture2D.defuv = [0, 0, 1, 0, 1, 1, 0, 1];
    RenderTexture2D.flipyuv = [0, 1, 1, 1, 1, 0, 0, 0];

    const _rect1 = new Rectangle();
    const _rect2 = new Rectangle();
    class Texture extends Resource {
        static create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0) {
            return Texture._create(source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight);
        }
        static _create(source, x, y, width, height, offsetX = 0, offsetY = 0, sourceWidth = 0, sourceHeight = 0, outTexture = null) {
            var btex = source instanceof Texture;
            var uv = btex ? source.uv : Texture.DEF_UV;
            var bitmap = btex ? source.bitmap : source;
            if (bitmap.width && (x + width) > bitmap.width)
                width = bitmap.width - x;
            if (bitmap.height && (y + height) > bitmap.height)
                height = bitmap.height - y;
            var tex;
            if (outTexture) {
                tex = outTexture;
                tex.setTo(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            else {
                tex = new Texture(bitmap, null, sourceWidth || width, sourceHeight || height);
            }
            tex.width = width;
            tex.height = height;
            tex.offsetX = offsetX;
            tex.offsetY = offsetY;
            var dwidth = 1 / bitmap.width;
            var dheight = 1 / bitmap.height;
            x *= dwidth;
            y *= dheight;
            width *= dwidth;
            height *= dheight;
            var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
            var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
            var oriUV = moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
            tex.uv = new Float32Array([u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight,
                u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight,
                u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight,
                u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight]);
            var bitmapScale = source.scaleRate;
            if (bitmapScale && bitmapScale != 1) {
                tex.sourceWidth /= bitmapScale;
                tex.sourceHeight /= bitmapScale;
                tex.width /= bitmapScale;
                tex.height /= bitmapScale;
                tex.scaleRate = bitmapScale;
                tex.offsetX /= bitmapScale;
                tex.offsetY /= bitmapScale;
            }
            else {
                tex.scaleRate = 1;
            }
            return tex;
        }
        static createFromTexture(texture, x, y, width, height) {
            var texScaleRate = texture.scaleRate;
            if (texScaleRate != 1) {
                x *= texScaleRate;
                y *= texScaleRate;
                width *= texScaleRate;
                height *= texScaleRate;
            }
            var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
            var result = rect.intersection(_rect1.setTo(0, 0, texture.width, texture.height), _rect2);
            if (result) {
                let newTex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
                newTex._sizeGrid = texture._sizeGrid;
                newTex._atlas = texture._atlas;
                return newTex;
            }
            else
                return null;
        }
        get uv() {
            return this._uv;
        }
        set uv(value) {
            this.uvrect[0] = Math.min(value[0], value[2], value[4], value[6]);
            this.uvrect[1] = Math.min(value[1], value[3], value[5], value[7]);
            this.uvrect[2] = Math.max(value[0], value[2], value[4], value[6]) - this.uvrect[0];
            this.uvrect[3] = Math.max(value[1], value[3], value[5], value[7]) - this.uvrect[1];
            this._uv = value;
        }
        get width() {
            if (this._w)
                return this._w;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
        }
        set width(value) {
            this._w = value;
            this.sourceWidth || (this.sourceWidth = value);
        }
        get height() {
            if (this._h)
                return this._h;
            if (!this.bitmap)
                return 0;
            return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
        }
        set height(value) {
            this._h = value;
            this.sourceHeight || (this.sourceHeight = value);
        }
        get bitmap() {
            return this._bitmap;
        }
        set bitmap(value) {
            if (this._bitmap == value)
                return;
            this._bitmap && this._bitmap._removeReference(this._referenceCount);
            this._bitmap = value;
            value && (value._addReference(this._referenceCount));
        }
        constructor(source = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            super(false);
            this.uvrect = [0, 0, 1, 1];
            this._w = 0;
            this._h = 0;
            this.offsetX = 0;
            this.offsetY = 0;
            this.sourceWidth = 0;
            this.sourceHeight = 0;
            this.scaleRate = 1;
            let bitmap = (source instanceof Texture) ? source.bitmap : source;
            this.setTo(bitmap, uv, sourceWidth, sourceHeight);
        }
        _addReference(count = 1) {
            var _a, _b;
            super._addReference(count);
            (_a = this._bitmap) === null || _a === void 0 ? void 0 : _a._addReference(count);
            (_b = this._atlas) === null || _b === void 0 ? void 0 : _b._addReference(count);
        }
        _removeReference(count = 1) {
            var _a, _b;
            (_a = this._bitmap) === null || _a === void 0 ? void 0 : _a._removeReference(count);
            (_b = this._atlas) === null || _b === void 0 ? void 0 : _b._removeReference(count);
            super._removeReference(count);
        }
        _getSource(cb = null) {
            if (this._destroyed || !this._bitmap)
                return null;
            this.recoverBitmap(cb);
            return this._bitmap.destroyed ? null : this.bitmap._getSource();
        }
        setTo(bitmap = null, uv = null, sourceWidth = 0, sourceHeight = 0) {
            this.bitmap = bitmap;
            this.sourceWidth = sourceWidth;
            this.sourceHeight = sourceHeight;
            if (bitmap) {
                this._w = bitmap.width;
                this._h = bitmap.height;
                this.sourceWidth = this.sourceWidth || bitmap.width;
                this.sourceHeight = this.sourceHeight || bitmap.height;
            }
            this.uv = uv || Texture.DEF_UV;
        }
        load(url, complete) {
            if (this._destroyed)
                return Promise.resolve();
            return ILaya.loader.load(url).then((tex) => {
                let bit = tex.bitmap;
                this.bitmap = bit;
                this.sourceWidth = this._w = bit.width;
                this.sourceHeight = this._h = bit.height;
                complete && complete.run();
                this.event(Event.READY, this);
            });
        }
        getTexturePixels(x, y, width, height) {
            var st, dst, i;
            var tex2d = this.bitmap;
            var texw = this._w;
            var texh = this._h;
            var sourceWidth = this.sourceWidth;
            var sourceHeight = this.sourceHeight;
            var tex2dw = tex2d.width;
            var tex2dh = tex2d.height;
            var offsetX = this.offsetX;
            var offsetY = this.offsetY;
            let draww = width;
            let drawh = height;
            if (x + width > texw + offsetX)
                draww -= (x + width) - texw - offsetX;
            if (x + width > sourceWidth)
                width -= (x + width) - sourceWidth;
            if (y + height > texh + offsetY)
                drawh -= (y + height) - texh - offsetY;
            if (y + height > sourceHeight)
                height -= (y + height) - sourceHeight;
            if (width <= 0 || height <= 0)
                return null;
            let marginL = offsetX > x ? offsetX - x : 0;
            let marginT = offsetY > y ? offsetY - y : 0;
            let rePosX = x > offsetX ? x - offsetX : 0;
            let rePosY = y > offsetY ? y - offsetY : 0;
            draww -= marginL;
            drawh -= marginT;
            var wstride = width * 4;
            var pix = null;
            try {
                pix = tex2d.getPixels();
            }
            catch (e) {
            }
            if (pix) {
                if (x == 0 && y == 0 && width == tex2dw && height == tex2dh)
                    return pix;
                let uv = this._uv.slice();
                let atlasPosX = Math.round(uv[0] * tex2dw);
                let atlasPosY = Math.round(uv[1] * tex2dh);
                var ret = new Uint8Array(width * height * 4);
                wstride = tex2dw * 4;
                dst = (atlasPosY + rePosY) * wstride;
                st = atlasPosX * 4 + rePosX * 4 + dst;
                for (i = 0; i < drawh; i++) {
                    ret.set(pix.slice(st, st + draww * 4), width * 4 * (i + marginT) + marginL * 4);
                    st += wstride;
                }
                return ret;
            }
            var ctx = new ILaya.Context();
            ctx.size(width, height);
            let rt = new RenderTexture2D(width, height, exports.RenderTargetFormat.R8G8B8A8);
            ctx.render2D = ctx.render2D.clone(rt);
            var uv = null;
            if (x != 0 || y != 0 || width != tex2dw || height != tex2dh) {
                uv = this._uv.slice();
                var stu = uv[0];
                var stv = uv[1];
                var uvw = uv[2] - stu;
                var uvh = uv[7] - stv;
                var uk = uvw / texw;
                var vk = uvh / texh;
                uv = [stu + rePosX * uk, stv + rePosY * vk,
                    stu + (rePosX + draww) * uk, stv + rePosY * vk,
                    stu + (rePosX + draww) * uk, stv + (rePosY + drawh) * vk,
                    stu + rePosX * uk, stv + (rePosY + drawh) * vk];
            }
            ctx.startRender();
            ctx._drawTextureM(this, marginL, marginT, draww, drawh, null, 1.0, uv, 0xffffffff);
            ctx.endRender();
            var dt = rt.getData(0, 0, width, height);
            ctx.destroy();
            rt.destroy();
            ret = new Uint8Array(width * height * 4);
            st = 0;
            dst = (height - 1) * wstride;
            for (i = height - 1; i >= 0; i--) {
                ret.set(dt.slice(dst, dst + wstride), st);
                st += wstride;
                dst -= wstride;
            }
            return ret;
        }
        getPixels(x, y, width, height) {
            return this.getTexturePixels(x, y, width, height);
        }
        recoverBitmap(callback) {
            var url = this._bitmap.url;
            if (!this._destroyed && (!this._bitmap || this._bitmap.destroyed) && url) {
                ILaya.loader.load(url, "image").then((tex) => {
                    this.bitmap = tex.bitmap;
                    callback && callback();
                });
            }
        }
        disposeBitmap() {
            if (!this._destroyed && this._bitmap) {
                this._bitmap.destroy();
            }
        }
        get valid() {
            return !this._destroyed && this._bitmap && !this._bitmap.destroyed;
        }
        get obsolute() {
            return this._obsolute || !this._bitmap || this._bitmap.destroyed || this._bitmap.obsolute;
        }
        set obsolute(value) {
            this._obsolute = value;
        }
        _disposeResource() {
            let bit = this._bitmap;
            this._bitmap = null;
            if (bit)
                bit._removeReference(this._referenceCount);
            let atlas = this._atlas;
            this._atlas = null;
            if (atlas)
                atlas._removeReference(this._referenceCount);
        }
        getCachedClip(x, y, width, height) {
            if (this.destroyed)
                return null;
            let key = `${x}_${y}_${width}_${height}`;
            if (!this._clipCache)
                this._clipCache = new Map();
            let tex = this._clipCache.get(key);
            if (tex)
                return tex;
            tex = Texture.createFromTexture(this, x, y, width, height);
            if (this._clipCache.size > 100)
                this._clipCache.clear();
            this._clipCache.set(key, tex);
            return tex;
        }
    }
    Texture.DEF_UV = new Float32Array([0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0]);
    Texture.NO_UV = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]);
    Texture.INV_UV = new Float32Array([0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0]);
    function moveUV(offsetX, offsetY, uv) {
        for (var i = 0; i < 8; i += 2) {
            uv[i] += offsetX;
            uv[i + 1] += offsetY;
        }
        return uv;
    }

    class AtlasInfoManager {
        static enable(infoFile, callback = null) {
            ILaya.loader.fetch(infoFile, "json").then(data => {
                if (!data)
                    return;
                AtlasInfoManager.addAtlases(data);
                callback && callback.run();
            });
        }
        static addAtlases(data) {
            let dic = AtlasInfoManager._fileLoadDic;
            for (let key in data) {
                let arr = data[key];
                let prefix = URL.formatURL(arr[0]);
                let frames = arr[1];
                let len = frames.length;
                let entry = { url: key };
                for (let i = 0; i < len; i++) {
                    dic[prefix + frames[i]] = entry;
                }
            }
        }
        static addAtlas(atlasUrl, prefix, frames) {
            prefix = URL.formatURL(prefix);
            let dic = AtlasInfoManager._fileLoadDic;
            let entry = { url: atlasUrl };
            for (let i of frames) {
                dic[prefix + i] = entry;
            }
        }
        static getFileLoadPath(file) {
            return AtlasInfoManager._fileLoadDic[file];
        }
    }
    AtlasInfoManager._fileLoadDic = {};

    class WorkerLoader {
        static workerSupported() {
            return Worker ? true : false;
        }
        static get enable() {
            return WorkerLoader._enable;
        }
        static set enable(value) {
            if (WorkerLoader._enable != value) {
                if (value) {
                    if (!Worker)
                        return;
                    if (!WorkerLoader._worker) {
                        WorkerLoader._worker = new Worker(PlayerConfig.workerLoaderLib || WorkerLoader.workerPath);
                        WorkerLoader._worker.onmessage = WorkerLoader.workerMessage;
                    }
                }
                WorkerLoader._enable = value;
            }
        }
        static load(url, options) {
            let callbacks = WorkerLoader._queue[url];
            if (callbacks) {
                return new Promise((resolve, reject) => {
                    callbacks.push(resolve, reject);
                });
            }
            else {
                WorkerLoader._queue[url] = callbacks = [];
                return new Promise((resolve, reject) => {
                    callbacks.push(resolve, reject);
                    WorkerLoader._worker.postMessage({ url, options });
                });
            }
        }
        static workerMessage(evt) {
            let data = evt.data;
            if (data) {
                switch (data.type) {
                    case "Image":
                        let callbacks = WorkerLoader._queue[data.url];
                        if (callbacks) {
                            delete WorkerLoader._queue[data.url];
                            let param = data.imageBitmap ? data.imageBitmap : data.msg;
                            for (let i = data.imageBitmap ? 0 : 1; i < callbacks.length; i += 2) {
                                callbacks[i](param);
                            }
                        }
                        break;
                }
            }
        }
    }
    WorkerLoader.workerPath = "libs/laya.workerloader.js";
    WorkerLoader._enable = false;
    WorkerLoader._queue = {};

    class AtlasResource extends Resource {
        constructor(dir, textures, frames) {
            super();
            this.dir = dir;
            this.textures = textures;
            this.frames = frames;
            for (let tex of frames) {
                tex._addReference();
                tex._atlas = this;
            }
            for (let tex of textures) {
                tex._addReference();
                tex._atlas = this;
            }
        }
        update(textures, frames) {
            this._disposeResource();
            this.textures.push(...textures);
            this.frames.push(...frames);
            for (let tex of frames) {
                tex._addReference();
                tex._atlas = this;
            }
            for (let tex of textures) {
                tex._addReference();
                tex._atlas = this;
            }
        }
        _disposeResource() {
            for (let tex of this.textures) {
                tex._atlas = null;
                tex._removeReference();
            }
            for (let tex of this.frames) {
                tex._atlas = null;
                tex._removeReference();
            }
            this.frames.length = 0;
            this.textures.length = 0;
        }
    }

    class BatchProgress {
        constructor(callback) {
            this._callback = callback;
            this._items = [];
            this._weights = [];
            this._progress = 0;
        }
        get itemCount() {
            return this._items.length;
        }
        reset() {
            this._items.length = 0;
            this._weights.length = 0;
            this._progress = 0;
        }
        createCallback(weight) {
            let index = this._items.length;
            this._items.push(0);
            if (weight == null)
                this._weights.push(null);
            else
                this._weights.push(Math.max(0, Math.min(weight, 1)));
            return (progress) => this.update(index, progress);
        }
        update(index, value) {
            if (index != -1) {
                this._items[index] = Math.max(0, Math.min(value, 1));
                let np = 0;
                let col = this._items;
                let ws = this._weights;
                let perc = 1 / col.length;
                for (let i = 0; i < col.length; i++) {
                    let p = col[i];
                    let w = ws[i];
                    if (p != null)
                        np += p * (w != null ? w : perc);
                }
                value = np;
                if (value > 1)
                    value = 1;
            }
            if (value > this._progress) {
                this._progress = value;
                this._callback(value);
            }
        }
    }

    class Handler {
        constructor(caller = null, method = null, args = null, once = false) {
            this.once = false;
            this._id = 0;
            this.setTo(caller, method, args, once);
        }
        setTo(caller, method, args, once = false) {
            this._id = Handler._gid++;
            this.caller = caller;
            this.method = method;
            this.args = args;
            this.once = once;
            return this;
        }
        run() {
            if (this.method == null)
                return null;
            var id = this._id;
            var result = this.method.apply(this.caller, this.args);
            this._id === id && this.once && this.recover();
            return result;
        }
        runWith(data) {
            if (this.method == null)
                return null;
            var id = this._id;
            if (data == null)
                var result = this.method.apply(this.caller, this.args);
            else if (!this.args && !data.unshift)
                result = this.method.call(this.caller, data);
            else if (this.args)
                result = this.method.apply(this.caller, this.args.concat(data));
            else
                result = this.method.apply(this.caller, data);
            this._id === id && this.once && this.recover();
            return result;
        }
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
            return this;
        }
        recover() {
            if (this._id > 0) {
                this._id = 0;
                Handler._pool.push(this.clear());
            }
        }
        static create(caller, method, args = null, once = true) {
            if (Handler._pool.length)
                return Handler._pool.pop().setTo(caller, method, args, once);
            return new Handler(caller, method, args, once);
        }
    }
    Handler._pool = [];
    Handler._gid = 1;

    class XMLUtils {
        static decodeString(aSource) {
            let len = aSource.length;
            let sb = "";
            let pos1 = 0, pos2 = 0;
            while (true) {
                pos2 = aSource.indexOf('&', pos1);
                if (pos2 == -1) {
                    sb += aSource.substring(pos1);
                    break;
                }
                sb += aSource.substring(pos1, pos2);
                pos1 = pos2 + 1;
                pos2 = pos1;
                let end = Math.min(len, pos2 + 10);
                for (; pos2 < end; pos2++) {
                    if (aSource[pos2] == ';')
                        break;
                }
                if (pos2 < end && pos2 > pos1) {
                    let entity = aSource.substring(pos1, pos2);
                    let u = 0;
                    if (entity[0] == '#') {
                        if (entity.length > 1) {
                            if (entity[1] == 'x')
                                u = parseInt(entity.substring(2), 16);
                            else
                                u = parseInt(entity.substring(1));
                            sb += String.fromCharCode(u);
                            pos1 = pos2 + 1;
                        }
                        else
                            sb += '&';
                    }
                    else {
                        switch (entity) {
                            case "amp":
                                u = 38;
                                break;
                            case "apos":
                                u = 39;
                                break;
                            case "gt":
                                u = 62;
                                break;
                            case "lt":
                                u = 60;
                                break;
                            case "nbsp":
                                u = 32;
                                break;
                            case "quot":
                                u = 34;
                                break;
                        }
                        if (u > 0) {
                            sb += String.fromCharCode(u);
                            pos1 = pos2 + 1;
                        }
                        else
                            sb += '&';
                    }
                }
                else {
                    sb += '&';
                }
            }
            return sb;
        }
        static encodeString(str) {
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;")
                .replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;");
        }
        static getString(attrs, attrName, defValue) {
            if (attrs == null)
                return defValue == null ? null : defValue;
            let ret = attrs[attrName];
            if (ret != null)
                return "" + ret;
            else
                return defValue == null ? null : defValue;
        }
        static getInt(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value != null && value.length > 0) {
                if (value[value.length - 1] == '%') {
                    let ret = parseInt(value.substring(0, value.length - 1));
                    if (!isNaN(ret))
                        return Math.ceil(ret / 100.0 * defValue);
                }
                else {
                    let ret = parseInt(value);
                    if (!isNaN(ret))
                        return ret;
                }
            }
            return defValue == null ? 0 : defValue;
        }
        static getFloat(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value == null || value.length == 0)
                return defValue == null ? 0 : defValue;
            let ret = parseFloat(value);
            if (isNaN(ret))
                return defValue == null ? 0 : defValue;
            else
                return ret;
        }
        static getBool(attrs, attrName, defValue) {
            let value = this.getString(attrs, attrName);
            if (value == null || value.length == 0)
                return defValue == null ? false : defValue;
            if (value == "true" || value == "1")
                return true;
            else if (value == "false" || value == "0")
                return false;
            else
                return defValue == null ? false : defValue;
        }
    }

    exports.XMLTagType = void 0;
    (function (XMLTagType) {
        XMLTagType[XMLTagType["Start"] = 0] = "Start";
        XMLTagType[XMLTagType["End"] = 1] = "End";
        XMLTagType[XMLTagType["Void"] = 2] = "Void";
        XMLTagType[XMLTagType["CDATA"] = 3] = "CDATA";
        XMLTagType[XMLTagType["Comment"] = 4] = "Comment";
        XMLTagType[XMLTagType["Instruction"] = 5] = "Instruction";
    })(exports.XMLTagType || (exports.XMLTagType = {}));
    const CDATA_START = "<![CDATA[";
    const CDATA_END = "]]>";
    const COMMENT_START = "<!--";
    const COMMENT_END = "-->";
    class XMLIterator {
        static begin(source, lowerCaseName) {
            XMLIterator.source = source;
            XMLIterator.lowerCaseName = lowerCaseName;
            this.sourceLen = source.length;
            this.parsePos = 0;
            this.lastTagEnd = 0;
            this.tagPos = 0;
            this.tagLength = 0;
            this.tagName = null;
        }
        static nextTag() {
            let pos;
            let c;
            let buffer = "";
            this.tagType = exports.XMLTagType.Start;
            this.lastTagEnd = this.parsePos;
            this.attrParsed = false;
            this.lastTagName = this.tagName;
            while ((pos = this.source.indexOf('<', this.parsePos)) != -1) {
                this.parsePos = pos;
                pos++;
                if (pos == this.sourceLen)
                    break;
                c = this.source[pos];
                if (c == '!') {
                    if (this.sourceLen > pos + 7 && this.source.substring(pos - 1, pos + 8) == CDATA_START) {
                        pos = this.source.indexOf(CDATA_END, pos);
                        this.tagType = exports.XMLTagType.CDATA;
                        this.tagName = "";
                        this.tagPos = this.parsePos;
                        if (pos == -1)
                            this.tagLength = this.sourceLen - this.parsePos;
                        else
                            this.tagLength = pos + 3 - this.parsePos;
                        this.parsePos += this.tagLength;
                        return true;
                    }
                    else if (this.sourceLen > pos + 2 && this.source.substring(pos - 1, pos + 3) == COMMENT_START) {
                        pos = this.source.indexOf(COMMENT_END, pos);
                        this.tagType = exports.XMLTagType.Comment;
                        this.tagName = "";
                        this.tagPos = this.parsePos;
                        if (pos == -1)
                            this.tagLength = this.sourceLen - this.parsePos;
                        else
                            this.tagLength = pos + 3 - this.parsePos;
                        this.parsePos += this.tagLength;
                        return true;
                    }
                    else {
                        pos++;
                        this.tagType = exports.XMLTagType.Instruction;
                    }
                }
                else if (c == '/') {
                    pos++;
                    this.tagType = exports.XMLTagType.End;
                }
                else if (c == '?') {
                    pos++;
                    this.tagType = exports.XMLTagType.Instruction;
                }
                for (; pos < this.sourceLen; pos++) {
                    c = this.source[pos];
                    if (' \t\n\r\v'.indexOf(c) != -1 || c == '>' || c == '/')
                        break;
                }
                if (pos == this.sourceLen)
                    break;
                buffer += this.source.substring(this.parsePos + 1, pos);
                if (buffer.length > 0 && buffer[0] == '/')
                    buffer = buffer.substring(1);
                let singleQuoted = false, doubleQuoted = false;
                let possibleEnd = -1;
                for (; pos < this.sourceLen; pos++) {
                    c = this.source[pos];
                    if (c == '"') {
                        if (!singleQuoted)
                            doubleQuoted = !doubleQuoted;
                    }
                    else if (c == '\'') {
                        if (!doubleQuoted)
                            singleQuoted = !singleQuoted;
                    }
                    if (c == '>') {
                        if (!(singleQuoted || doubleQuoted)) {
                            possibleEnd = -1;
                            break;
                        }
                        possibleEnd = pos;
                    }
                    else if (c == '<')
                        break;
                }
                if (possibleEnd != -1)
                    pos = possibleEnd;
                if (pos == this.sourceLen)
                    break;
                if (this.source[pos - 1] == '/')
                    this.tagType = exports.XMLTagType.Void;
                this.tagName = buffer;
                if (this.lowerCaseName)
                    this.tagName = this.tagName.toLowerCase();
                this.tagPos = this.parsePos;
                this.tagLength = pos + 1 - this.parsePos;
                this.parsePos += this.tagLength;
                return true;
            }
            this.tagPos = this.sourceLen;
            this.tagLength = 0;
            this.tagName = null;
            return false;
        }
        static getTagSource() {
            return this.source.substring(this.tagPos, this.tagPos + this.tagLength);
        }
        static getRawText(trim) {
            if (this.lastTagEnd == this.tagPos)
                return "";
            else if (trim) {
                let i = this.lastTagEnd;
                for (; i < this.tagPos; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) == -1)
                        break;
                }
                if (i == this.tagPos)
                    return "";
                else
                    return this.source.substring(i, this.tagPos).trim();
            }
            else
                return this.source.substring(this.lastTagEnd, this.tagPos);
        }
        static getText(trim) {
            if (this.lastTagEnd == this.tagPos)
                return "";
            else if (trim) {
                let i = this.lastTagEnd;
                for (; i < this.tagPos; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) == -1)
                        break;
                }
                if (i == this.tagPos)
                    return "";
                else
                    return XMLUtils.decodeString(this.source.substring(i, this.tagPos)).trimEnd();
            }
            else
                return XMLUtils.decodeString(this.source.substring(this.lastTagEnd, this.tagPos));
        }
        static get attributes() {
            if (!this.attrParsed) {
                for (let key in this._attrs) {
                    delete this._attrs[key];
                }
                this.parseAttributes(this._attrs);
                this.attrParsed = true;
            }
            return this._attrs;
        }
        static getAttribute(attrName) {
            return this.attributes[attrName];
        }
        static parseAttributes(attrs) {
            let attrName;
            let valueStart = 0;
            let valueEnd = 0;
            let waitValue = false;
            let quoted = 0;
            let buffer = "";
            let i = this.tagPos;
            let attrEnd = this.tagPos + this.tagLength;
            if (i < attrEnd && this.source[i] == '<') {
                for (; i < attrEnd; i++) {
                    let c = this.source[i];
                    if (' \t\n\r\v'.indexOf(c) != -1 || c == '>' || c == '/')
                        break;
                }
            }
            for (; i < attrEnd; i++) {
                let c = this.source[i];
                if (c == '=') {
                    valueStart = -1;
                    valueEnd = -1;
                    quoted = 0;
                    for (let j = i + 1; j < attrEnd; j++) {
                        let c2 = this.source[j];
                        if (' \t\n\r\v'.indexOf(c2) != -1) {
                            if (valueStart != -1 && quoted == 0) {
                                valueEnd = j - 1;
                                break;
                            }
                        }
                        else if (c2 == '>') {
                            if (quoted == 0) {
                                valueEnd = j - 1;
                                break;
                            }
                        }
                        else if (c2 == '"') {
                            if (valueStart != -1) {
                                if (quoted != 1) {
                                    valueEnd = j - 1;
                                    break;
                                }
                            }
                            else {
                                quoted = 2;
                                valueStart = j + 1;
                            }
                        }
                        else if (c2 == '\'') {
                            if (valueStart != -1) {
                                if (quoted != 2) {
                                    valueEnd = j - 1;
                                    break;
                                }
                            }
                            else {
                                quoted = 1;
                                valueStart = j + 1;
                            }
                        }
                        else if (valueStart == -1) {
                            valueStart = j;
                        }
                    }
                    if (valueStart != -1 && valueEnd != -1) {
                        attrName = buffer;
                        if (this.lowerCaseName)
                            attrName = attrName.toLowerCase();
                        buffer = "";
                        attrs[attrName] = XMLUtils.decodeString(this.source.substring(valueStart, valueEnd + 1));
                        i = valueEnd + 1;
                    }
                    else
                        break;
                }
                else if (' \t\n\r\v'.indexOf(c) == -1) {
                    if (waitValue || c == '/' || c == '>') {
                        if (buffer.length > 0) {
                            attrName = buffer;
                            if (this.lowerCaseName)
                                attrName = attrName.toLowerCase();
                            attrs[attrName] = "";
                            buffer = "";
                        }
                        waitValue = false;
                    }
                    if (c != '/' && c != '>')
                        buffer += c;
                }
                else {
                    if (buffer.length > 0)
                        waitValue = true;
                }
            }
        }
    }
    XMLIterator._attrs = {};
    if (!String.prototype.trimEnd) {
        String.prototype.trimEnd = function () {
            return this.replace(/\s+$/g, "");
        };
    }

    class XML {
        constructor(XmlString) {
            if (XmlString)
                this.parse(XmlString);
        }
        get attributes() {
            if (!this._attrs)
                this._attrs = {};
            return this._attrs;
        }
        getAttrString(attrName, defValue) {
            return XMLUtils.getString(this._attrs, attrName, defValue);
        }
        getAttrInt(attrName, defValue) {
            return XMLUtils.getInt(this._attrs, attrName, defValue);
        }
        getAttrFloat(attrName, defValue) {
            return XMLUtils.getFloat(this._attrs, attrName, defValue);
        }
        getAttrBool(attrName, defValue) {
            return XMLUtils.getBool(this._attrs, attrName, defValue);
        }
        setAttribute(attrName, attrValue) {
            if (!this._attrs)
                this._attrs = {};
            this._attrs[attrName] = attrValue;
        }
        getNode(selector) {
            if (!this._children)
                return null;
            else
                return this._children.find(value => {
                    return value.name == selector;
                });
        }
        elements(selector) {
            if (!this._children)
                this._children = new Array();
            if (selector)
                return this._children.filter(value => {
                    return value.name == selector;
                });
            else
                return this._children;
        }
        parse(aSource) {
            this.reset();
            let lastOpenNode;
            let nodeStack = new Array();
            XMLIterator.begin(aSource);
            while (XMLIterator.nextTag()) {
                if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                    let childNode;
                    if (lastOpenNode)
                        childNode = new XML();
                    else {
                        if (this.name != null) {
                            this.reset();
                            throw new Error("Invalid xml format - no root node.");
                        }
                        childNode = this;
                    }
                    childNode.name = XMLIterator.tagName;
                    childNode._attrs = Object.assign({}, XMLIterator.attributes);
                    if (lastOpenNode) {
                        if (XMLIterator.tagType != exports.XMLTagType.Void)
                            nodeStack.push(lastOpenNode);
                        if (lastOpenNode._children == null)
                            lastOpenNode._children = new Array();
                        lastOpenNode._children.push(childNode);
                    }
                    if (XMLIterator.tagType != exports.XMLTagType.Void)
                        lastOpenNode = childNode;
                }
                else if (XMLIterator.tagType == exports.XMLTagType.End) {
                    if (lastOpenNode == null || lastOpenNode.name != XMLIterator.tagName) {
                        this.reset();
                        throw new Error("Invalid xml format - <" + XMLIterator.tagName + "> dismatched.");
                    }
                    if (lastOpenNode._children == null || lastOpenNode._children.length == 0) {
                        lastOpenNode.text = XMLIterator.getText();
                    }
                    if (nodeStack.length > 0)
                        lastOpenNode = nodeStack.pop();
                    else
                        lastOpenNode = null;
                }
            }
        }
        reset() {
            this._attrs = null;
            if (this._children != null)
                this._children.length == 0;
            this.text = null;
        }
    }

    class HttpRequest extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._http = new XMLHttpRequest();
        }
        send(url, data = null, method = "get", responseType = "text", headers) {
            this._responseType = responseType;
            this._data = null;
            this._url = url;
            let http = this._http;
            http.open(method, url, true);
            if (data) {
                if (typeof (data) == 'string') {
                    http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
                }
                else {
                    http.setRequestHeader("Content-Type", "application/json");
                    if (!(data instanceof ArrayBuffer))
                        data = JSON.stringify(data);
                }
            }
            else if (Browser.onBLMiniGame && Browser.onAndroid)
                data = {};
            if (headers) {
                for (let i = 0; i < headers.length; i++) {
                    http.setRequestHeader(headers[i++], headers[i]);
                }
            }
            let restype = responseType !== "arraybuffer" ? "text" : "arraybuffer";
            http.responseType = restype;
            if (http.dataType) {
                http.dataType = restype;
            }
            http.onerror = e => this._onError(e);
            http.onabort = e => this._onAbort(e);
            http.onprogress = e => this._onProgress(e);
            http.onload = e => this._onLoad(e);
            http.send(data);
        }
        _onProgress(e) {
            if (e && e.lengthComputable)
                this.event(Event.PROGRESS, e.loaded / e.total);
        }
        _onAbort(e) {
            this.error("Request was aborted by user");
        }
        _onError(e) {
            this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
        }
        _onLoad(e) {
            var http = this._http;
            var status = http.status !== undefined ? http.status : 200;
            if (status === 200 || status === 204 || status === 0) {
                this.complete();
            }
            else {
                this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
            }
        }
        error(message) {
            this.clear();
            this.event(Event.ERROR, message);
        }
        complete() {
            this.clear();
            var flag = true;
            try {
                if (this._responseType === "json") {
                    this._data = JSON.parse(this._http.responseText);
                }
                else if (this._responseType === "xml") {
                    this._data = new XML(this._http.responseText);
                }
                else {
                    this._data = this._http.response || this._http.responseText;
                }
            }
            catch (e) {
                flag = false;
                this.error(e.message);
            }
            flag && this.event(Event.COMPLETE, this._data instanceof Array ? [this._data] : this._data);
        }
        clear() {
            var http = this._http;
            http.onerror = http.onabort = http.onprogress = http.onload = null;
        }
        get url() {
            return this._url;
        }
        get data() {
            return this._data;
        }
        get http() {
            return this._http;
        }
        reset() {
            this.offAll();
            this._data = null;
        }
    }

    class Downloader {
        constructor() {
            this.httpRequestPool = [];
        }
        common(owner, url, originalUrl, contentType, onProgress, onComplete) {
            let http = this.getRequestInst();
            http.on(Event.COMPLETE, () => {
                let data = http.data;
                this.returnRequestInst(http);
                onComplete(data);
            });
            http.on(Event.ERROR, null, (error) => {
                this.returnRequestInst(http);
                onComplete(null, error);
            });
            if (onProgress)
                http.on(Event.PROGRESS, onProgress);
            http.send(url, null, "get", contentType);
            owner.$ref = http;
        }
        image(owner, url, originalUrl, onProgress, onComplete) {
            let image = new Browser.window.Image();
            image.crossOrigin = "";
            image.onload = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(image);
            };
            image.onerror = () => {
                image.onload = null;
                image.onerror = null;
                onComplete(null, "");
            };
            image.src = url;
            owner.$ref = image;
        }
        imageWithBlob(owner, blob, originalUrl, onProgress, onComplete) {
            let url = PAL.browser.createBufferURL(blob);
            if (url)
                this.image(owner, url, originalUrl, onProgress, onComplete);
            else
                onComplete(null, "Blob URL creation not supported.");
        }
        imageWithWorker(owner, url, originalUrl, onProgress, onComplete) {
            WorkerLoader.enable = true;
            if (WorkerLoader.enable) {
                WorkerLoader.load(url, owner.workerLoaderOptions)
                    .then(onComplete)
                    .catch((error) => onComplete(null, error));
            }
            else
                this.image(owner, url, originalUrl, onProgress, onComplete);
        }
        audio(owner, url, originalUrl, onProgress, onComplete) {
            let audio = Browser.createElement("audio");
            audio.crossOrigin = "";
            audio.oncanplaythrough = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(audio);
            };
            audio.onerror = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                onComplete(null, "");
            };
            audio.src = url;
            owner.$ref = audio;
        }
        package(path, onProgress, onComplete) {
            onComplete(null);
        }
        getRequestInst() {
            if (this.httpRequestPool.length == 0
                || Browser.onVVMiniGame || Browser.onHWMiniGame) {
                return new HttpRequest();
            }
            else {
                return this.httpRequestPool.pop();
            }
        }
        returnRequestInst(inst) {
            inst.reset();
            if (this.httpRequestPool.length < 10)
                this.httpRequestPool.push(inst);
        }
    }

    var typeIdCounter = 0;
    const NullURLInfo = { ext: null, typeId: null, main: false, loaderType: null };
    class Loader extends EventDispatcher {
        static registerLoader(exts, cls, type, hotReloadable) {
            let typeEntry;
            if (type) {
                typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    Loader.typeMap[type] = typeEntry = { typeId: typeIdCounter++, loaderType: cls };
                else if (typeEntry.loaderType != cls)
                    typeEntry = { typeId: typeEntry.typeId, loaderType: cls };
            }
            else
                typeEntry = { typeId: typeIdCounter++, loaderType: cls };
            if (hotReloadable)
                Loader.hotReloadableFlags[typeEntry.typeId] = true;
            for (let ext of exts) {
                let entry = Loader.extMap[ext];
                if (entry && type) {
                    let i = entry.findIndex(e => e.typeId == typeEntry.typeId);
                    if (i == -1)
                        entry.push(typeEntry);
                    else
                        entry[i].loaderType = cls;
                }
                else {
                    Loader.extMap[ext] = [typeEntry];
                }
            }
        }
        constructor() {
            super();
            this.retryNum = 1;
            this.retryDelay = 0;
            this.maxLoader = 5;
            this._loadings = new Map();
            this._queue = [];
            this._downloadings = new Set();
        }
        get loading() {
            return this._loadings.size > 0;
        }
        load(url, arg1, arg2, arg3, priority, cache, group, ignoreCache, useWorkerLoader) {
            let complete;
            let type;
            let options = dummyOptions;
            if (arg1 instanceof Handler) {
                complete = arg1;
                type = arg3;
            }
            else if (typeof (arg1) === "string")
                type = arg1;
            else if (arg1 != null) {
                type = arg1.type;
                options = arg1;
            }
            if (priority != null || cache != null || ignoreCache != null || group != null || useWorkerLoader != null) {
                if (options === dummyOptions)
                    options = { priority, cache, ignoreCache, group, useWorkerLoader };
                else
                    options = Object.assign(options, { priority, cache, ignoreCache, group, useWorkerLoader });
            }
            if (options.cache === false)
                options.ignoreCache = true;
            let onProgress;
            if (arg2 instanceof Handler)
                onProgress = (value) => arg2.runWith(value);
            else
                onProgress = arg2;
            let promise;
            if (Array.isArray(url)) {
                let pd;
                if (onProgress)
                    pd = new BatchProgress(onProgress);
                let promises = [];
                for (let i = 0; i < url.length; i++) {
                    let url2 = url[i];
                    if (!url2)
                        continue;
                    if (typeof (url2) === "string") {
                        promises.push(this._load1(url2, type, options, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                    else {
                        promises.push(this._load1(url2.url, url2.type || type, options !== dummyOptions ? Object.assign({}, options, url2) : url2, pd === null || pd === void 0 ? void 0 : pd.createCallback()));
                    }
                }
                promise = Promise.all(promises);
            }
            else if (typeof (url) === "string")
                promise = this._load1(url, type, options, onProgress);
            else
                promise = this._load1(url.url, url.type || type, options !== dummyOptions ? Object.assign({}, options, url) : url, onProgress);
            if (complete)
                return promise.then(result => {
                    complete.runWith(result);
                    return result;
                });
            else
                return promise;
        }
        _load1(url, type, options, onProgress) {
            if (LayaEnv.isPreview) {
                if (url.startsWith("res://")) {
                    let uuid = url.substring(6);
                    return AssetDb.inst.UUID_to_URL_async(uuid).then(url2 => {
                        var _a;
                        if (url2)
                            return this._load2(url2, uuid, type, options, onProgress);
                        else {
                            !options.silent && Loader.warnFailed(url, undefined, (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                            return Promise.resolve(null);
                        }
                    });
                }
                else {
                    return AssetDb.inst.URL_to_UUID_async(url).then(uuid => {
                        return this._load2(url, uuid, type, options, onProgress);
                    });
                }
            }
            else
                return this._load2(url, null, type, options, onProgress);
        }
        _load2(url, uuid, type, options, onProgress) {
            var _a, _b;
            let { ext, typeId, main, loaderType } = Loader.getURLInfo(url, type, options.maybeType);
            if (!loaderType) {
                !options.silent && Loader.warnFailed(url, type ? `unsupported load type:${type}` : !url.startsWith("res://") ? `unsupported suffix` : "", (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                return Promise.resolve(null);
            }
            let formattedUrl = URL.formatURL(url);
            if (options.group) {
                let set = Loader.groupMap[options.group];
                if (!set)
                    set = Loader.groupMap[options.group] = new Set();
                set.add(formattedUrl);
            }
            let obsoluteRes;
            if (!options.ignoreCache) {
                let cacheRes = Loader._getRes(formattedUrl, type);
                if (cacheRes !== undefined) {
                    if (cacheRes == null)
                        return Promise.resolve(null);
                    else {
                        if (!(cacheRes instanceof Resource))
                            return Promise.resolve(cacheRes);
                        if (cacheRes.obsolute)
                            obsoluteRes = cacheRes;
                        if (!obsoluteRes && (!cacheRes.uuid || !uuid || uuid == cacheRes.uuid))
                            return Promise.resolve(cacheRes);
                    }
                }
            }
            let loadingKey = formattedUrl;
            if (!main)
                loadingKey += "@" + typeId;
            let task = this._loadings.get(loadingKey);
            if (task) {
                let p = options.initiator;
                while (p) {
                    if (p === task)
                        return Promise.resolve();
                    p = p.options.initiator;
                }
                if (task.result != null)
                    return task.result;
                if (onProgress)
                    task.onProgress.add(onProgress);
                return new Promise((resolve) => task.onComplete.add(resolve));
            }
            let atlasInfo = AtlasInfoManager.getFileLoadPath(formattedUrl);
            if (atlasInfo) {
                return this.load(atlasInfo.url, { type: Loader.ATLAS, baseUrl: atlasInfo.baseUrl }).then(() => {
                    return Loader.getRes(url, type);
                });
            }
            if (loadTaskPool.length > 0)
                task = loadTaskPool.pop();
            else
                task = new LoadTask();
            task.type = type;
            task.url = url;
            task.uuid = uuid;
            task.ext = ext;
            options = Object.assign(task.options, options);
            delete options.type;
            if (options.priority == null)
                options.priority = 0;
            if (options.useWorkerLoader == null)
                options.useWorkerLoader = WorkerLoader.enable;
            if (onProgress)
                task.onProgress.add(onProgress);
            task.loader = this;
            task.obsoluteInst = obsoluteRes;
            let assetLoader = new loaderType();
            this._loadings.set(loadingKey, task);
            let promise;
            try {
                Loader.LoaderStat_LoaderResourceCount++;
                this._tempTime = performance.now();
                promise = assetLoader.load(task);
            }
            catch (err) {
                !options.silent && Loader.warnFailed(url, err, (_b = options.initiator) === null || _b === void 0 ? void 0 : _b.url);
                promise = Promise.resolve(null);
            }
            return promise.then(content => {
                Loader.LoaderStat_LoadResourceTime += performance.now() - this._tempTime;
                if (content instanceof Resource) {
                    content.obsolute = false;
                    content._setCreateURL(url, uuid);
                }
                if (task.options.cache !== false)
                    Loader._cacheRes(formattedUrl, content, typeId, main);
                if (content != null && assetLoader.postLoad != null) {
                    task.result = content;
                    return assetLoader.postLoad(task, content).then(() => {
                        task.progress.update(-1, 1);
                        task.onComplete.invoke(content);
                        return content;
                    });
                }
                else {
                    task.progress.update(-1, 1);
                    task.onComplete.invoke(content);
                    return content;
                }
            }).catch(error => {
                var _a;
                !options.silent && Loader.warnFailed(url, error, (_a = options.initiator) === null || _a === void 0 ? void 0 : _a.url);
                if (task.options.cache !== false)
                    Loader._cacheRes(formattedUrl, null, typeId, main);
                task.onComplete.invoke(null);
                return null;
            }).then(content => {
                this._loadings.delete(loadingKey);
                task.reset();
                loadTaskPool.push(task);
                if (this._loadings.size == 0)
                    this.event(Event.COMPLETE);
                return content;
            });
        }
        fetch(url, contentType, onProgress, options) {
            var _a;
            options = options || dummyOptions;
            let task = {
                originalUrl: url,
                url: url,
                contentType: contentType,
                priority: (_a = options.priority) !== null && _a !== void 0 ? _a : 1,
                retryCnt: 0,
                onProgress: onProgress,
                onComplete: null,
            };
            if (options.useWorkerLoader) {
                task.useWorkerLoader = true;
                task.workerLoaderOptions = options.workerLoaderOptions;
            }
            if (options.blob)
                task.blob = options.blob;
            if (options.noRetry)
                task.retryCnt = -1;
            if (options.silent)
                task.silent = true;
            return AssetDb.inst.resolveURL(url).then(url => {
                if (url)
                    return new Promise((resolve) => {
                        task.url = URL.formatURL(url);
                        task.onComplete = resolve;
                        this.queueToDownload(task);
                    });
                else
                    return null;
            });
        }
        queueToDownload(item) {
            if (this._downloadings.size < this.maxLoader) {
                this.download(item);
                return;
            }
            let priority = item.priority;
            if (priority == 0)
                this._queue.push(item);
            else {
                let i = this._queue.findIndex(e => e.priority < priority);
                if (i != -1)
                    this._queue.splice(i, 0, item);
                else
                    this._queue.push(item);
            }
        }
        download(item) {
            this._downloadings.add(item);
            Loader.LoaderStat_LoadRequestCount++;
            item.startTime = performance.now();
            let url = URL.postFormatURL(item.url);
            if (item.contentType == "image") {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    if (!(preloadedContent instanceof ArrayBuffer)) {
                        this.completeItem(item, preloadedContent);
                        return;
                    }
                    item.blob = preloadedContent;
                }
                if (item.blob) {
                    Loader.downloader.imageWithBlob(item, item.blob, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data)
                            item.retryCnt = -1;
                        this.completeItem(item, data, error);
                    });
                }
                else if (item.useWorkerLoader) {
                    Loader.downloader.imageWithWorker(item, url, item.originalUrl, item.onProgress, (data, error) => {
                        if (!data) {
                            item.useWorkerLoader = false;
                            if (!item.silent)
                                Loader.warnFailed(item.url, error);
                        }
                        this.completeItem(item, data, error);
                    });
                }
                else {
                    Loader.downloader.image(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
                }
            }
            else if (item.contentType == "sound") {
                Loader.downloader.audio(item, url, item.originalUrl, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
            else {
                let preloadedContent = Loader.preLoadedMap[item.url];
                if (preloadedContent) {
                    this.completeItem(item, preloadedContent);
                    return;
                }
                Loader.downloader.common(item, url, item.originalUrl, item.contentType, item.onProgress, (data, error) => this.completeItem(item, data, error));
            }
        }
        completeItem(item, content, error) {
            this._downloadings.delete(item);
            Loader.LoaderStat_LoadRequestTime += performance.now() - item.startTime;
            if (content) {
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                if (item.onProgress)
                    item.onProgress(1);
                item.onComplete(content);
            }
            else if (item.retryCnt != -1 && item.retryCnt < this.retryNum) {
                item.retryCnt++;
                if (!item.silent)
                    console.debug(`Retry to load ${item.url} (${item.retryCnt})`);
                ILaya.systemTimer.once(this.retryDelay, this, this.queueToDownload, [item], false);
            }
            else {
                !item.silent && Loader.warnFailed(item.url, error);
                if (item.onProgress)
                    item.onProgress(1);
                if (this._downloadings.size < this.maxLoader && this._queue.length > 0)
                    this.download(this._queue.shift());
                item.onComplete(null);
            }
        }
        static getURLInfo(url, type, maybeType) {
            let ext = url.startsWith("data:") ? "png" : Utils.getFileExtension(url);
            let extEntry;
            if (ext.length > 0)
                extEntry = Loader.extMap[ext];
            if (!extEntry && !type)
                type = maybeType;
            let typeId;
            let main;
            let loaderType;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return NullURLInfo;
                typeId = typeEntry.typeId;
                let i = 0;
                if (extEntry) {
                    if (extEntry[0].typeId === typeId
                        || (i = extEntry.findIndex(e => e.typeId === typeId)) != -1) {
                        main = i == 0;
                        loaderType = extEntry[i].loaderType;
                    }
                    else {
                        main = false;
                        loaderType = typeEntry.loaderType;
                    }
                }
                else {
                    main = type != Loader.TEXTURE2D;
                    loaderType = typeEntry.loaderType;
                }
            }
            else {
                if (!extEntry)
                    return NullURLInfo;
                main = true;
                typeId = extEntry[0].typeId;
                loaderType = extEntry[0].loaderType;
            }
            return { ext, main, typeId, loaderType };
        }
        static warnFailed(url, err, initiatorUrl) {
            if (initiatorUrl)
                this.warn(`Failed to load '${url}' (in '${initiatorUrl}')`, err);
            else
                this.warn(`Failed to load '${url}'`, err);
        }
        static warn(msg, err) {
            if (err)
                console.warn(msg, err);
            else
                console.warn(msg);
        }
        static getRes(url, type) {
            url = URL.formatURL(url);
            let ret = Loader._getRes(url, type);
            return ret || null;
        }
        static _getRes(url, type) {
            let resArr = Loader.loadedMap[url];
            if (!resArr)
                return undefined;
            let ret;
            if (type) {
                let typeEntry = Loader.typeMap[type];
                if (!typeEntry)
                    return undefined;
                if (resArr.length == 2) {
                    if (resArr[0] == typeEntry.typeId)
                        ret = resArr[1];
                }
                else {
                    let i = resArr.indexOf(typeEntry.typeId);
                    if (i != -1)
                        ret = resArr[i + 1];
                }
            }
            else
                ret = resArr[1];
            if ((ret instanceof Resource) && ret.destroyed)
                return undefined;
            else
                return ret;
        }
        static getTexture2D(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getBaseTexture(url) {
            return Loader.getRes(url, Loader.TEXTURE2D);
        }
        static getAtlas(url) {
            return Loader.getRes(url, Loader.ATLAS);
        }
        getRes(url, type) {
            return Loader.getRes(url, type);
        }
        static createNodes(url) {
            var _a;
            return (_a = Loader.getRes(url)) === null || _a === void 0 ? void 0 : _a.create();
        }
        static cacheRes(url, data, type) {
            url = URL.formatURL(url);
            let urlInfo = Loader.getURLInfo(url, type);
            if (urlInfo.typeId != null)
                Loader._cacheRes(url, data, urlInfo.typeId, urlInfo.main);
        }
        static _cacheRes(url, data, typeId, main) {
            let entry = Loader.loadedMap[url];
            if (main) {
                if (entry) {
                    entry[0] = typeId;
                    entry[1] = data;
                }
                else
                    entry = Loader.loadedMap[url] = [typeId, data];
            }
            else {
                if (entry) {
                    let i = entry.findIndex(e => e === typeId);
                    if (i != -1)
                        entry[i + 1] = data;
                    else
                        entry.push(typeId, data);
                }
                else
                    entry = Loader.loadedMap[url] = [null, undefined, typeId, data];
            }
        }
        cacheRes(url, data, type) {
            Loader.cacheRes(url, data, type);
        }
        static clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        clearRes(url, checkObj) {
            url = URL.formatURL(url);
            Loader._clearRes(url, checkObj);
        }
        static _clearRes(url, checkObj) {
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            if (checkObj) {
                if (entry[1] == checkObj) {
                    if (entry.length == 2)
                        delete Loader.loadedMap[url];
                    else
                        entry[1] = undefined;
                }
                else {
                    let i = entry.indexOf(checkObj);
                    if (i == -1)
                        return;
                    if (entry.length == 4 && entry[0] == null)
                        delete Loader.loadedMap[url];
                    else
                        entry.splice(i - 1, 2);
                }
                if ((checkObj instanceof Resource) && !checkObj.destroyed) {
                    checkObj.destroy();
                }
            }
            else {
                delete Loader.loadedMap[url];
                if (entry.length > 2) {
                    for (let i = 1; i < entry.length; i += 2) {
                        let obj = entry[i];
                        if ((obj instanceof Resource) && !obj.destroyed) {
                            obj.destroy();
                        }
                    }
                }
                else {
                    let obj = entry[1];
                    if ((obj instanceof Resource) && !obj.destroyed) {
                        obj.destroy();
                    }
                }
            }
        }
        clearTextureRes(url) {
            url = URL.formatURL(url);
            let entry = Loader.loadedMap[url];
            if (!entry)
                return;
            let res = entry[1];
            if (res instanceof Texture) {
                res.disposeBitmap();
            }
            else if (res instanceof AtlasResource) {
                for (let tex of res.textures)
                    tex.disposeBitmap();
            }
        }
        static setGroup(url, group) {
            url = URL.formatURL(url);
            let set = Loader.groupMap[group];
            if (!set)
                set = Loader.groupMap[group] = new Set();
            set.add(url);
        }
        static clearResByGroup(group) {
            let set = Loader.groupMap[group];
            if (set) {
                for (let k of set)
                    Loader._clearRes(k);
            }
        }
        clearUnLoaded() {
            if (this._queue.length == 0)
                return;
            let arr = this._queue.concat();
            this._queue.length = 0;
            for (let item of arr)
                item.onComplete(null);
        }
        cancelLoadByUrls(urls) {
            if (!urls)
                return;
            for (var i = 0, n = urls.length; i < n; i++) {
                this.cancelLoadByUrl(urls[i]);
            }
        }
        cancelLoadByUrl(url) {
            url = URL.formatURL(url);
            let i = this._queue.findIndex(item => item.url == url);
            if (i != -1) {
                let item = this._queue[i];
                this._queue.splice(i, 1);
                item.onComplete(null);
            }
        }
        loadPackage(path, arg2, arg3) {
            let progress;
            let remoteUrl;
            if (typeof (arg2) === "string") {
                remoteUrl = arg2;
                progress = arg3;
            }
            else {
                progress = arg3 || arg2;
            }
            if (remoteUrl) {
                if (!remoteUrl.endsWith("/"))
                    remoteUrl += "/";
                URL.basePaths[path.length > 0 ? (path + "/") : path] = remoteUrl;
                return this._loadFileConfig(path, true, progress);
            }
            else {
                if (LayaEnv.isPreview)
                    return Promise.resolve();
                if (path.length === 0)
                    return this._loadFileConfig(path, true, progress);
                else
                    return new Promise((resolve) => {
                        Loader.downloader.package(path, progress, (data, error) => {
                            var _a;
                            if (error != null) {
                                Loader.warn(`Failed to load package '${path}'`, error);
                                resolve();
                                return;
                            }
                            this._loadFileConfig(path, (_a = data === null || data === void 0 ? void 0 : data.loadScript) !== null && _a !== void 0 ? _a : true, progress).then(() => resolve());
                        });
                    });
            }
        }
        _loadFileConfig(path, loadScript, onProgress) {
            if (path.length > 0)
                path += "/";
            return this.fetch(path + "fileconfig.json", "json", onProgress).then(fileConfig => {
                if (fileConfig == null)
                    return null;
                this._parseFileConfig(fileConfig);
                if (loadScript && fileConfig.entry)
                    return Browser.loadLib(path + fileConfig.entry);
                else
                    return null;
            });
        }
        _parseFileConfig(fileConfig) {
            let files = [];
            let col = fileConfig.files;
            for (let k in col) {
                if (k.length > 0) {
                    for (let file of col[k])
                        files.push(k + "/" + file);
                }
                else {
                    for (let file of col[k])
                        files.push(file);
                }
            }
            if (fileConfig.hash) {
                let i = 0;
                let version = URL.version;
                for (let k of fileConfig.hash) {
                    if (k != null)
                        version[files[i]] = k;
                    i++;
                }
            }
            let configs = fileConfig.config;
            let len = configs.length;
            let i = 0, j = 0, m = 0, k = 0, n = 0;
            let indice;
            let c;
            let metaMap = AssetDb.inst.metaMap;
            while (true) {
                if (indice == null) {
                    if (i >= len)
                        break;
                    c = configs[i];
                    indice = c.i;
                    if (Array.isArray(indice))
                        n = indice.length;
                    else {
                        m = indice;
                        n = 0;
                        k = 1;
                    }
                    j = 0;
                }
                if (k == 0) {
                    if (j >= n) {
                        i++;
                        indice = null;
                        continue;
                    }
                    k = indice[j++];
                    if (k > 0) {
                        m = k;
                        k = 0;
                    }
                    else
                        k = -k;
                }
                else
                    k--;
                let file = files[m + k];
                switch (c.t) {
                    case 0:
                        metaMap[file] = c;
                        break;
                    case 1:
                        AtlasInfoManager.addAtlas(file, c.prefix, c.frames);
                        break;
                    case 2:
                        AssetDb.inst.shaderNameMap[c.shaderName] = file;
                        break;
                    case 3:
                        Loader.preLoadedMap[URL.formatURL(file)] = c;
                        break;
                }
            }
        }
    }
    Loader.TEXT = "text";
    Loader.JSON = "json";
    Loader.XML = "xml";
    Loader.BUFFER = "arraybuffer";
    Loader.IMAGE = "image";
    Loader.SOUND = "sound";
    Loader.VIDEO = "video";
    Loader.ATLAS = "atlas";
    Loader.FONT = "font";
    Loader.TTF = "ttf";
    Loader.HIERARCHY = "HIERARCHY";
    Loader.MESH = "MESH";
    Loader.MATERIAL = "MATERIAL";
    Loader.TEXTURE2D = "TEXTURE2D";
    Loader.TEXTURECUBE = "TEXTURE2D";
    Loader.TEXTURE2DARRAY = "TEXTURE2D";
    Loader.ANIMATIONCLIP = "ANIMATIONCLIP";
    Loader.TERRAINHEIGHTDATA = "TERRAINHEIGHTDATA";
    Loader.TERRAINRES = "TERRAIN";
    Loader.SPINE = "SPINE";
    Loader.extMap = {};
    Loader.typeMap = {};
    Loader.hotReloadableFlags = {};
    Loader.assetTypeToLoadType = {
        "Image": Loader.IMAGE,
        "Texture2D": Loader.TEXTURE2D,
        "RenderTexture": Loader.TEXTURE2D,
        "TextureCube": Loader.TEXTURECUBE,
        "Prefab": Loader.HIERARCHY,
        "Material": Loader.MATERIAL,
        "Mesh": Loader.MESH,
        "Spine": Loader.SPINE,
    };
    Loader.downloader = new Downloader();
    Loader.groupMap = {};
    Loader.loadedMap = {};
    Loader.preLoadedMap = {};
    class LoadTask {
        constructor() {
            this.options = {};
            this.onProgress = new Delegate();
            this.onComplete = new Delegate();
            this.progress = new BatchProgress((progress) => this.onProgress.invoke(progress));
        }
        reset() {
            for (let k in this.options)
                delete this.options[k];
            this.onProgress.clear();
            this.onComplete.clear();
            this.progress.reset();
            this.obsoluteInst = null;
            this.result = null;
        }
    }
    const loadTaskPool = [];
    const dummyOptions = {};

    class ClassUtils {
        static regClass(className, classDef) {
            ClassUtils._classMap[className] = classDef;
        }
        static getClass(className) {
            return ClassUtils._classMap[className];
        }
        static regRuntime(url, cls) {
            ClassUtils._runtimeMap[url] = cls;
        }
        static getRuntime(url) {
            return ClassUtils._runtimeMap[url];
        }
    }
    ClassUtils._classMap = {};
    ClassUtils._runtimeMap = {};

    function dummy$1() { }
    function regClass(assetId) {
        return function (constructor) {
            ClassUtils.regClass(assetId, constructor);
        };
    }
    function classInfo(info) { return dummy$1; }
    function runInEditor(constructor) { }
    function allowMultiple(constructor) {
        constructor.prototype._$singleton = false;
    }
    function property(info) { return dummy$1; }
    function regLoader(fileExtensions, type, hotReloadable) {
        return function (constructor) {
            Loader.registerLoader(fileExtensions, constructor, type, hotReloadable);
        };
    }

    class Const {
    }
    Const.ENUM_TEXTALIGN_DEFAULT = 0;
    Const.ENUM_TEXTALIGN_CENTER = 1;
    Const.ENUM_TEXTALIGN_RIGHT = 2;
    Const.INDEX_BYTES = 2;
    Const.MAX_CLIP_SIZE = 99999999;
    class NodeFlags {
    }
    NodeFlags.ACTIVE = 0x1;
    NodeFlags.ACTIVE_INHIERARCHY = 0x2;
    NodeFlags.AWAKED = 0x4;
    NodeFlags.ACTUAL_VISIBLE = 0x8;
    NodeFlags.DISPLAY = 0x10;
    NodeFlags.HAS_ZORDER = 0x20;
    NodeFlags.AREA_2D = 0x40;
    NodeFlags.DISPLAYED_INSTAGE = 0x80;
    NodeFlags.DRAWCALL_OPTIMIZE = 0x100;
    NodeFlags.CHECK_INPUT = 0x200;
    NodeFlags.DEMAND_TRANS_EVENT = 0x400;
    NodeFlags.HAS_SCRIPT = 0x800;
    NodeFlags.ESCAPE_DRAWING_TO_TEXTURE = 0x1000;
    NodeFlags.DISABLE_INNER_CLIPPING = 0x2000;
    NodeFlags.DISABLE_OUTER_CLIPPING = 0x4000;
    NodeFlags.FORCE_VISIBLE = 0x8000;
    NodeFlags.EDITING_NODE = 0x10000;
    NodeFlags.HIDE_BY_EDITOR = 0x20000;
    NodeFlags.LOCK_BY_EDITOR = 0x40000;
    NodeFlags.EDITING_ROOT_NODE = 0x80000;
    NodeFlags.FORCE_HIDDEN = 0x100000;
    NodeFlags.NOT_IN_PAGE = 0x200000;
    NodeFlags.ESCAPE_LAYOUT = 0x400000;
    class HideFlags {
    }
    HideFlags.HideInHierarchy = 0x1;
    HideFlags.HideInInspector = 0x2;
    HideFlags.DontSave = 0x4;
    HideFlags.HideAndDontSave = 0x7;

    class GrahamScan {
        static _getPoints(count, tempUse = false, rst = null) {
            while (_mPointList.length < count)
                _mPointList.push(new Point());
            if (!rst)
                rst = [];
            rst.length = 0;
            if (tempUse) {
                GrahamScan.getFrom(rst, _mPointList, count);
            }
            else {
                GrahamScan.getFromR(rst, _mPointList, count);
            }
            return rst;
        }
        static getFrom(rst, src, count) {
            var i;
            for (i = 0; i < count; i++) {
                rst.push(src[i]);
            }
            return rst;
        }
        static getFromR(rst, src, count) {
            var i;
            for (i = 0; i < count; i++) {
                rst.push(src.pop());
            }
            return rst;
        }
        static pListToPointList(pList, tempUse) {
            var i, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, _tempPointList);
            for (i = 0; i < len; i++) {
                rst[i].setTo(pList[i + i], pList[i + i + 1]);
            }
            return rst;
        }
        static pointListToPlist(pointList) {
            var i, len = pointList.length, rst = _temPList, tPoint;
            rst.length = 0;
            for (i = 0; i < len; i++) {
                tPoint = pointList[i];
                rst.push(tPoint.x, tPoint.y);
            }
            return rst;
        }
        static scanPList(pList) {
            Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
        }
        static scan(PointSet) {
            let i, j, k = 0;
            let n = PointSet.length;
            let _tmpDic = {};
            let ch = _temArr;
            ch.length = 0;
            n = PointSet.length;
            for (i = n - 1; i >= 0; i--) {
                let tmp = PointSet[i];
                let key = tmp.x + "_" + tmp.y;
                if (!(key in _tmpDic)) {
                    _tmpDic[key] = true;
                    ch.push(tmp);
                }
            }
            n = ch.length;
            Utils.copyArray(PointSet, ch);
            for (i = 1; i < n; i++) {
                if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
                    k = i;
            }
            let tmp = PointSet[0];
            PointSet[0] = PointSet[k];
            PointSet[k] = tmp;
            for (i = 1; i < n - 1; i++) {
                k = i;
                for (j = i + 1; j < n; j++) {
                    if ((multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (dis(PointSet[0], PointSet[j]) < dis(PointSet[0], PointSet[k]))))
                        k = j;
                }
                let tmp = PointSet[i];
                PointSet[i] = PointSet[k];
                PointSet[k] = tmp;
            }
            ch.length = 0;
            if (PointSet.length < 3) {
                return Utils.copyArray(ch, PointSet);
            }
            ch.push(PointSet[0], PointSet[1], PointSet[2]);
            for (i = 3; i < n; i++) {
                while (ch.length >= 2 && multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0)
                    ch.pop();
                PointSet[i] && ch.push(PointSet[i]);
            }
            return ch;
        }
    }
    const _mPointList = [];
    const _tempPointList = [];
    const _temPList = [];
    const _temArr = [];
    function multiply(p1, p2, p0) {
        return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
    }
    function dis(p1, p2) {
        return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
    }

    class SpriteConst {
    }
    SpriteConst.ALPHA = 0x01;
    SpriteConst.TRANSFORM = 0x02;
    SpriteConst.BLEND = 0x04;
    SpriteConst.CANVAS = 0x08;
    SpriteConst.FILTERS = 0x10;
    SpriteConst.MASK = 0x20;
    SpriteConst.CLIP = 0x40;
    SpriteConst.TEXTURE = 0x80;
    SpriteConst.GRAPHICS = 0x100;
    SpriteConst.RENDERNODE2D = 0x200;
    SpriteConst.CUSTOM = 0x400;
    SpriteConst.HITAREA = 0x800;
    SpriteConst.CHILDS = 0x1000;
    SpriteConst.REPAINT_NONE = 0;
    SpriteConst.REPAINT_NODE = 0x01;
    SpriteConst.REPAINT_CACHE = 0x02;
    SpriteConst.REPAINT_ALL = 0x03;
    exports.TransformKind = void 0;
    (function (TransformKind) {
        TransformKind[TransformKind["Pos"] = 1] = "Pos";
        TransformKind[TransformKind["Width"] = 2] = "Width";
        TransformKind[TransformKind["Height"] = 4] = "Height";
        TransformKind[TransformKind["Anchor"] = 8] = "Anchor";
        TransformKind[TransformKind["Scale"] = 16] = "Scale";
        TransformKind[TransformKind["Skew"] = 32] = "Skew";
        TransformKind[TransformKind["Rotation"] = 64] = "Rotation";
        TransformKind[TransformKind["Matrix"] = 128] = "Matrix";
        TransformKind[TransformKind["Size"] = 6] = "Size";
        TransformKind[TransformKind["Layout"] = 30] = "Layout";
        TransformKind[TransformKind["TRS"] = 81] = "TRS";
    })(exports.TransformKind || (exports.TransformKind = {}));

    exports.RenderParams = void 0;
    (function (RenderParams) {
        RenderParams[RenderParams["Max_Active_Texture_Count"] = 0] = "Max_Active_Texture_Count";
        RenderParams[RenderParams["Max_Uniform_Count"] = 1] = "Max_Uniform_Count";
        RenderParams[RenderParams["Max_AnisoLevel_Count"] = 2] = "Max_AnisoLevel_Count";
        RenderParams[RenderParams["MAX_Texture_Size"] = 3] = "MAX_Texture_Size";
        RenderParams[RenderParams["MAX_Texture_Image_Uint"] = 4] = "MAX_Texture_Image_Uint";
        RenderParams[RenderParams["SHADER_CAPAILITY_LEVEL"] = 5] = "SHADER_CAPAILITY_LEVEL";
        RenderParams[RenderParams["FLOAT"] = 6] = "FLOAT";
        RenderParams[RenderParams["UNSIGNED_BYTE"] = 7] = "UNSIGNED_BYTE";
        RenderParams[RenderParams["BYTE"] = 8] = "BYTE";
        RenderParams[RenderParams["UNSIGNED_SHORT"] = 9] = "UNSIGNED_SHORT";
    })(exports.RenderParams || (exports.RenderParams = {}));

    class VertexElementFormat {
        static __init__() {
            VertexElementFormat._elementInfos = {
                "single": [1, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "vector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "color": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "byte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte3": [3, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "byte": [1, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 0],
                "short2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "short4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 0],
                "normalizedshort2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "normalizedshort4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_SHORT), 1],
                "halfvector2": [2, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "halfvector4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.FLOAT), 0],
                "nbyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.BYTE), 1],
                "ubyte4": [4, LayaGL.renderEngine.getParams(exports.RenderParams.UNSIGNED_BYTE), 1],
            };
        }
        static getElementInfos(element) {
            var info = VertexElementFormat._elementInfos[element];
            if (info)
                return info;
            else
                throw "VertexElementFormat: this vertexElementFormat is not implement.";
        }
    }
    VertexElementFormat.Single = "single";
    VertexElementFormat.Vector2 = "vector2";
    VertexElementFormat.Vector3 = "vector3";
    VertexElementFormat.Vector4 = "vector4";
    VertexElementFormat.Color = "color";
    VertexElementFormat.Byte4 = "byte4";
    VertexElementFormat.Byte3 = "byte3";
    VertexElementFormat.Byte2 = "byte2";
    VertexElementFormat.ByteOne = "byte";
    VertexElementFormat.Short2 = "short2";
    VertexElementFormat.Short4 = "short4";
    VertexElementFormat.NormalizedShort2 = "normalizedshort2";
    VertexElementFormat.NormalizedShort4 = "normalizedshort4";
    VertexElementFormat.HalfVector2 = "halfvector2";
    VertexElementFormat.HalfVector4 = "halfvector4";
    VertexElementFormat.NorByte4 = "nbyte4";
    VertexElementFormat.NorUByte4 = "ubyte4";

    class VertexStateContext {
    }
    class VertexDeclaration {
        get id() {
            return this._id;
        }
        get vertexStride() {
            return this._vertexStride;
        }
        get vertexElementCount() {
            return this._vertexElements.length;
        }
        constructor(vertexStride, vertexElements) {
            this._id = ++VertexDeclaration._uniqueIDCounter;
            this._vertexElementsDic = {};
            this._vertexStride = vertexStride;
            this._vertexElements = vertexElements;
            this._VAElements = [];
            var count = vertexElements.length;
            this._shaderValues = {};
            for (var j = 0; j < count; j++) {
                var vertexElement = vertexElements[j];
                var name = vertexElement._elementUsage;
                this._vertexElementsDic[name] = vertexElement;
                var value = new VertexStateContext();
                var elmentInfo = VertexElementFormat.getElementInfos(vertexElement._elementFormat);
                value.elementString = vertexElement._elementFormat;
                value.elementCount = elmentInfo[0];
                value.elementType = elmentInfo[1];
                value.normalized = elmentInfo[2];
                value.vertexStride = this._vertexStride;
                value.elementOffset = vertexElement._offset;
                this._shaderValues[name] = value;
                this._VAElements.push({ format: vertexElement._elementFormat, stride: vertexElement._offset, shaderLocation: name });
            }
        }
        getVertexElementByIndex(index) {
            return this._vertexElements[index];
        }
        getVertexElementByUsage(usage) {
            return this._vertexElementsDic[usage];
        }
    }
    VertexDeclaration._uniqueIDCounter = 1;

    class VertexElement {
        get offset() {
            return this._offset;
        }
        get elementFormat() {
            return this._elementFormat;
        }
        get elementUsage() {
            return this._elementUsage;
        }
        constructor(offset, elementFormat, elementUsage) {
            this._offset = offset;
            this._elementFormat = elementFormat;
            this._elementUsage = elementUsage;
        }
    }

    class Sprite2DGeometry {
        constructor(stride, vballoc, iballoc) {
            this._stride = 0;
            this._vertNum = 0;
            this._indexNum = 0;
            this._stride = stride;
            this._VBBuff = new ArrayBuffer(vballoc || 32);
            this._IBBuff = new ArrayBuffer(iballoc || 8);
            this.onVBRealloc(this._VBBuff);
            this.onIBRealloc(this._IBBuff);
        }
        get vbBuffer() {
            return this._VBBuff;
        }
        get ibBuffer() {
            return this._IBBuff;
        }
        get indexNum() {
            return this._indexNum;
        }
        get vertexNum() {
            return this._vertNum;
        }
        clearMesh() {
            this._vertNum = 0;
            this._indexNum = 0;
        }
        expVBSize(len) {
            if (len) {
                let curLen = this._vertNum * this._stride;
                if (curLen + len > this._VBBuff.byteLength) {
                    let old = this._VBBuff;
                    this._VBBuff = new ArrayBuffer(curLen + len * 8);
                    (new Uint8Array(this._VBBuff, 0, curLen)).set(new Uint8Array(old, 0, curLen));
                    this.onVBRealloc(this._VBBuff);
                }
            }
        }
        expIBSize(len) {
            if (len) {
                let curlen = this._indexNum * 2;
                if (curlen + len > this._IBBuff.byteLength) {
                    let old = this._IBBuff;
                    this._IBBuff = new ArrayBuffer(curlen + len * 8);
                    (new Uint8Array(this._IBBuff, 0, curlen)).set(new Uint8Array(old, 0, curlen));
                    this.onIBRealloc(this._IBBuff);
                }
            }
        }
    }

    function createQuadIB(quadNum) {
        let ibbuf = new Byte(quadNum * 6 * 2);
        let ib = new Uint16Array(ibbuf.buffer);
        var idx = 0;
        var curvert = 0;
        for (var i = 0; i < quadNum; i++) {
            ib[idx++] = curvert;
            ib[idx++] = curvert + 2;
            ib[idx++] = curvert + 1;
            ib[idx++] = curvert;
            ib[idx++] = curvert + 3;
            ib[idx++] = curvert + 2;
            curvert += 4;
        }
        return ib;
    }
    class MeshQuadTexture extends Sprite2DGeometry {
        static __int__() {
            MeshQuadTexture._fixib = createQuadIB(MeshQuadTexture._maxIB);
            MeshQuadTexture.VertexDeclarition = new VertexDeclaration(48, [
                new VertexElement(0, VertexElementFormat.Vector4, 0),
                new VertexElement(16, VertexElementFormat.Vector4, 1),
                new VertexElement(32, VertexElementFormat.Vector4, 2),
            ]);
        }
        constructor(vballoc = 4) {
            super(MeshQuadTexture.const_stride, vballoc, 4);
            this._curVBPos = 0;
        }
        onVBRealloc(buff) {
            this._vbFloat32Array = new Float32Array(buff);
        }
        onIBRealloc(buff) {
        }
        addQuad(pos, uv, color, useTex) {
            this.expVBSize(MeshQuadTexture.const_stride);
            var vbdata = this._vbFloat32Array;
            let r = ((color >>> 16) & 0xff) / 255.0;
            let g = ((color >>> 8) & 0xff) / 255.0;
            let b = (color & 0xff) / 255.0;
            let a = (color >>> 24) / 255.0;
            var cpos = this._curVBPos;
            var useTexVal = useTex ? 1 : 0;
            vbdata[cpos++] = pos[0];
            vbdata[cpos++] = pos[1];
            vbdata[cpos++] = uv[0];
            vbdata[cpos++] = uv[1];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            vbdata[cpos++] = pos[2];
            vbdata[cpos++] = pos[3];
            vbdata[cpos++] = uv[2];
            vbdata[cpos++] = uv[3];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            vbdata[cpos++] = pos[4];
            vbdata[cpos++] = pos[5];
            vbdata[cpos++] = uv[4];
            vbdata[cpos++] = uv[5];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            vbdata[cpos++] = pos[6];
            vbdata[cpos++] = pos[7];
            vbdata[cpos++] = uv[6];
            vbdata[cpos++] = uv[7];
            vbdata[cpos++] = b;
            vbdata[cpos++] = g;
            vbdata[cpos++] = r;
            vbdata[cpos++] = a;
            vbdata[cpos++] = useTexVal;
            cpos += 3;
            this._curVBPos = cpos;
            this._vertNum += 4;
            this._indexNum += 6;
        }
        clearMesh() {
            super.clearMesh();
            this._curVBPos = 0;
        }
        get ibBuffer() {
            return MeshQuadTexture._fixib.buffer;
        }
        get vertexDeclarition() {
            return MeshQuadTexture.VertexDeclarition;
        }
    }
    MeshQuadTexture.const_stride = 48;
    MeshQuadTexture._maxIB = 16 * 1024;

    class Filter extends EventDispatcher {
        constructor() {
            super();
            this.left = 0;
            this.top = 0;
            this.width = 0;
            this.height = 0;
            let rect1 = this._rectMeshNormY = new MeshQuadTexture();
            rect1.addQuad([0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 0, 1], 0xffffffff, true);
            this._rectMeshVBNormY = new Float32Array(rect1.vbBuffer);
            let rectInvY = this._rectMeshInvY = new MeshQuadTexture();
            rectInvY.addQuad([0, 0, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0], 0xffffffff, true);
            this._rectMeshVBInvY = new Float32Array(rectInvY.vbBuffer);
            this.useFlipY(false);
        }
        onChange() {
            this.event(Event.CHANGED);
        }
        useFlipY(b) {
            this._rectMesh = b ? this._rectMeshInvY : this._rectMeshNormY;
            this._rectMeshVB = b ? this._rectMeshVBInvY : this._rectMeshVBNormY;
        }
        set render2D(r) {
            this._render2D = r;
        }
        get type() { return -1; }
    }
    Filter.COLOR = 0x20;
    Filter._filter = function (sprite, context, x, y) {
        var next = this._next;
        if (!next)
            return;
        var filters = sprite.filters, len = filters.length;
        if (len == 1 && (filters[0].type == Filter.COLOR)) {
            context.save();
            context.setColorFilter(filters[0]);
            next._fun.call(next, sprite, context, x, y);
            context.restore();
            return;
        }
        let cache = sprite._getCacheStyle();
        let rtOffX = 0, rtOffY = 0;
        if (this._renderNextToCacheRT(sprite, context, 16, 16, 16, 16)) {
            rtOffX = cache.cacheRect.x;
            rtOffY = cache.cacheRect.y;
            let src = cache.renderTexture;
            let dst = src;
            let width = src.width;
            let height = src.height;
            for (let i = 0; i < len; i++) {
                src = dst;
                var filter = filters[i];
                filter._render2D = context.render2D;
                filter.useFlipY(i != 0);
                filter.render(src, width, height);
                width = filter.width;
                height = filter.height;
                dst = filter.texture;
                rtOffX += filter.left;
                rtOffY += filter.top;
            }
            cache.renderTexture = dst;
            cache.renderTexOffx = rtOffX;
            cache.renderTexOffy = rtOffY;
        }
        cache.renderTexture && context._drawRenderTexture(cache.renderTexture, x + cache.renderTexOffx, y + cache.renderTexOffy, cache.renderTexture.width, cache.renderTexture.height, null, 1.0, RenderTexture2D.defuv);
    };

    exports.GPUEngineStatisticsInfo = void 0;
    (function (GPUEngineStatisticsInfo) {
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_UniformBufferUploadCount"] = 0] = "C_UniformBufferUploadCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_GeometryBufferUploadCount"] = 1] = "C_GeometryBufferUploadCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_TriangleCount"] = 2] = "C_TriangleCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_SetRenderPassCount"] = 3] = "C_SetRenderPassCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_DrawCallCount"] = 4] = "C_DrawCallCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_Instancing_DrawCallCount"] = 5] = "C_Instancing_DrawCallCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["C_ShaderCompile"] = 6] = "C_ShaderCompile";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["T_ShaderCompile"] = 7] = "T_ShaderCompile";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["FrameClearCount"] = 8] = "FrameClearCount";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_GPUMemory"] = 9] = "M_GPUMemory";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_GPUBuffer"] = 10] = "M_GPUBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_VertexBuffer"] = 11] = "M_VertexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_IndexBuffer"] = 12] = "M_IndexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_UniformBlockBuffer"] = 13] = "M_UniformBlockBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_GPUBuffer"] = 14] = "RC_GPUBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_VertexBuffer"] = 15] = "RC_VertexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_IndexBuffer"] = 16] = "RC_IndexBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_UniformBlockBuffer"] = 17] = "RC_UniformBlockBuffer";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_ALLTexture"] = 18] = "M_ALLTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_Texture2D"] = 19] = "M_Texture2D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_TextureCube"] = 20] = "M_TextureCube";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_Texture3D"] = 21] = "M_Texture3D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_Texture2DArray"] = 22] = "M_Texture2DArray";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_ALLTexture"] = 23] = "RC_ALLTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_Texture2D"] = 24] = "RC_Texture2D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_TextureCube"] = 25] = "RC_TextureCube";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_Texture3D"] = 26] = "RC_Texture3D";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_Texture2DArray"] = 27] = "RC_Texture2DArray";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["M_ALLRenderTexture"] = 28] = "M_ALLRenderTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["RC_ALLRenderTexture"] = 29] = "RC_ALLRenderTexture";
        GPUEngineStatisticsInfo[GPUEngineStatisticsInfo["Count"] = 30] = "Count";
    })(exports.GPUEngineStatisticsInfo || (exports.GPUEngineStatisticsInfo = {}));
    exports.RenderPassStatisticsInfo = void 0;
    (function (RenderPassStatisticsInfo) {
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_CameraRender"] = 0] = "T_CameraRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_OpaqueRender"] = 1] = "T_Render_OpaqueRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_TransparentRender"] = 2] = "T_Render_TransparentRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_PostProcess"] = 3] = "T_Render_PostProcess";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_CameraEventCMD"] = 4] = "T_Render_CameraEventCMD";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_ShadowPassMode"] = 5] = "T_Render_ShadowPassMode";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_Render_CameraOtherDest"] = 6] = "T_Render_CameraOtherDest";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_RenderPreUpdate"] = 7] = "T_RenderPreUpdate";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OtherRender"] = 8] = "T_OtherRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OnlyMeshRender"] = 9] = "T_OnlyMeshRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OnlySkinnedMeshRender"] = 10] = "T_OnlySkinnedMeshRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_OnlyShurikenParticleRender"] = 11] = "T_OnlyShurikenParticleRender";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_CameraMainCull"] = 12] = "T_CameraMainCull";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["T_ShadowMapCull"] = 13] = "T_ShadowMapCull";
        RenderPassStatisticsInfo[RenderPassStatisticsInfo["RenderPassStatisticCount"] = 14] = "RenderPassStatisticCount";
    })(exports.RenderPassStatisticsInfo || (exports.RenderPassStatisticsInfo = {}));

    class Stat {
        static show(x, y, views) {
            if (!Stat._statUI)
                Stat._statUI = new Stat._statUIClass();
            this.hide();
            Stat._show = true;
            LayaGL.renderEngine._enableStatistics = true;
            Stat._currentShowArray = views || Stat.AllShow;
            Stat._statUI.show(x, y, Stat._currentShowArray);
            ILaya.systemTimer.frameLoop(1, null, Stat.loop);
            ILaya.timer.frameLoop(1, null, Stat.clear);
        }
        static hide() {
            if (!Stat._show)
                return;
            Stat._show = false;
            Stat._currentShowArray = null;
            ILaya.timer.clear(null, Stat.loop);
            ILaya.timer.clear(null, Stat.clear);
            if (Stat._statUI)
                Stat._statUI.hide();
        }
        static loop() {
            Stat._count++;
            let timer = Browser.now();
            if (timer - Stat._timer < 1000)
                return;
            let count = Stat._count;
            Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
            if (Stat._show) {
                Stat.updateEngineData();
                let delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
                Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay + "ms";
                Stat._statUI.update();
            }
            Stat._count = 0;
            Stat._timer = timer;
        }
        static updateEngineData() {
            Stat.trianglesFaces += LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.C_TriangleCount);
            Stat.drawCall += LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.C_DrawCallCount);
            Stat.instanceDrawCall += LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.C_Instancing_DrawCallCount);
            Stat.gpuMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_GPUMemory);
            Stat.textureMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_ALLTexture);
            Stat.renderTextureMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_ALLRenderTexture);
            Stat.bufferMemory = LayaGL.renderEngine.getStatisticsInfo(exports.GPUEngineStatisticsInfo.M_GPUBuffer);
        }
        static clear() {
            if (!Stat._currentShowArray || Stat._count)
                return;
            Stat._currentShowArray.forEach(element => {
                if (element.mode == "average")
                    Stat[element.value] = 0;
            });
            LayaGL.renderEngine.clearStatisticsInfo();
            Stat.renderPassStatArray.fill(0);
        }
        static render(ctx, x, y) {
            if (Stat._show)
                Stat._statUI.render(ctx, x, y);
        }
    }
    Stat.FPSStatUIParams = { title: "FPS", value: "_fpsStr", color: "yellow", units: "int", mode: "summit" };
    Stat.NodeStatUIParams = { title: "Node", value: "spriteCount", color: "white", units: "int", mode: "summit" };
    Stat.Sprite3DStatUIParams = { title: "Sprite3D", value: "sprite3DCount", color: "white", units: "int", mode: "summit" };
    Stat.DrawCall = { title: "DrawCall", value: "drawCall", color: "white", units: "int", mode: "average" };
    Stat.TriangleFace = { title: "TriangleFace", value: "trianglesFaces", color: "white", units: "int", mode: "average" };
    Stat.RenderNode = { title: "RenderNode", value: "renderNode", color: "white", units: "int", mode: "summit" };
    Stat.SkinRenderNode = { title: "SkinRenderNode", value: "skinRenderNode", color: "white", units: "int", mode: "summit" };
    Stat.ParticleRenderNode = { title: "ParticleRenderNode", value: "particleRenderNode", color: "white", units: "int", mode: "summit" };
    Stat.FrustumCulling = { title: "FrustumCulling", value: "frustumCulling", color: "white", units: "int", mode: "average" };
    Stat.UniformUpload = { title: "UniformUpload", value: "uniformUpload", color: "white", units: "int", mode: "average" };
    Stat.OpaqueDrawCall = { title: "OpaqueDrawCall", value: "opaqueDrawCall", color: "white", units: "int", mode: "average" };
    Stat.TransDrawCall = { title: "TransDrawCall", value: "transDrawCall", color: "white", units: "int", mode: "average" };
    Stat.DepthCastDrawCall = { title: "DepthCastDrawCall", value: "depthCastDrawCall", color: "white", units: "int", mode: "average" };
    Stat.ShadowDrawCall = { title: "ShadowDrawCall", value: "shadowMapDrawCall", color: "white", units: "int", mode: "average" };
    Stat.InstanceDrawCall = { title: "InstanceDrawCall", value: "instanceDrawCall", color: "white", units: "int", mode: "average" };
    Stat.CMDDrawCall = { title: "CMDDrawCall", value: "cmdDrawCall", color: "white", units: "int", mode: "average" };
    Stat.BlitDrawCall = { title: "BlitDrawCall", value: "blitDrawCall", color: "white", units: "int", mode: "average" };
    Stat.GPUMemory = { title: "GPUMemory", value: "gpuMemory", color: "white", units: "M", mode: "summit" };
    Stat.TextureMemeory = { title: "TextureMemory", value: "textureMemory", color: "white", units: "M", mode: "summit" };
    Stat.RenderTextureMemory = { title: "RenderTextureMemory", value: "renderTextureMemory", color: "white", units: "M", mode: "summit" };
    Stat.BufferMemory = { title: "BufferMemory", value: "bufferMemory", color: "white", units: "M", mode: "summit" };
    Stat.uploadUniformNum = { title: "UploadUniformNum", value: "uploadUniform", color: "white", units: "int", mode: "average" };
    Stat.AllShow = [Stat.FPSStatUIParams, Stat.NodeStatUIParams, Stat.Sprite3DStatUIParams, Stat.DrawCall, Stat.TriangleFace, Stat.RenderNode, Stat.SkinRenderNode, Stat.ParticleRenderNode,
        Stat.FrustumCulling, Stat.OpaqueDrawCall, Stat.TransDrawCall, Stat.ShadowDrawCall, Stat.DepthCastDrawCall, Stat.InstanceDrawCall, Stat.CMDDrawCall, Stat.BlitDrawCall, Stat.GPUMemory, Stat.TextureMemeory, Stat.RenderTextureMemory, Stat.BufferMemory, Stat.uploadUniformNum];
    Stat.memoryShow = [Stat.GPUMemory, Stat.TextureMemeory, Stat.RenderTextureMemory, Stat.BufferMemory];
    Stat.renderShow = [Stat.DrawCall, Stat.TriangleFace, Stat.OpaqueDrawCall, Stat.TransDrawCall, Stat.ShadowDrawCall, Stat.DepthCastDrawCall, Stat.InstanceDrawCall, Stat.CMDDrawCall, Stat.BlitDrawCall];
    Stat.toogle_Shadow = { title: "Shadow", value: "enableShadow", color: "white" };
    Stat.toogle_MulLight = { title: "MulLight", value: "enableMulLight", color: "white" };
    Stat.toogle_Light = { title: "Light", value: "enableLight", color: "white" };
    Stat.toogle_Postprocess = { title: "Postprocess", value: "enablePostprocess", color: "white" };
    Stat.toogle_AnimatorUpdate = { title: "AnimatorUpdate", value: "enableAnimatorUpdate", color: "white" };
    Stat.toogle_PhysicsUpdate = { title: "PhysicsUpdate", value: "enablePhysicsUpdate", color: "white" };
    Stat.toogle_Skin = { title: "Skin", value: "enableSkin", color: "white" };
    Stat.toogle_Transparent = { title: "Transparent", value: "enableTransparent", color: "white" };
    Stat.toogle_Particle = { title: "Particle", value: "enableParticle", color: "white" };
    Stat.toogle_msaa = { title: "MSAA", value: "enablemsaa", color: "white" };
    Stat.toogle_CameraCMD = { title: "CameraCMD", value: "enableCameraCMD", color: "white" };
    Stat.toogle_Opaque = { title: "Opaque", value: "enableOpaque", color: "white" };
    Stat.AllToggle = [Stat.toogle_Shadow, Stat.toogle_Light, Stat.toogle_MulLight, Stat.toogle_Postprocess, Stat.toogle_AnimatorUpdate, Stat.toogle_PhysicsUpdate, Stat.toogle_Opaque, Stat.toogle_Transparent, Stat.toogle_CameraCMD, Stat.toogle_Skin, Stat.toogle_Particle, Stat.toogle_msaa];
    Stat.RenderModeToggle = [Stat.toogle_Shadow, Stat.toogle_Light, Stat.toogle_MulLight, Stat.toogle_Postprocess, Stat.toogle_AnimatorUpdate, Stat.toogle_PhysicsUpdate];
    Stat.RenderFuncToggle = [Stat.toogle_Opaque, Stat.toogle_Transparent, Stat.toogle_CameraCMD, Stat.toogle_Skin, Stat.toogle_Particle, Stat.toogle_msaa];
    Stat.FPS = 0;
    Stat.loopCount = 0;
    Stat.spriteRenderUseCacheCount = 0;
    Stat.canvasNormal = 0;
    Stat.canvasBitmap = 0;
    Stat.canvasReCache = 0;
    Stat.renderSlow = false;
    Stat._timer = 0;
    Stat._count = 0;
    Stat._fpsStr = "";
    Stat.spriteCount = 0;
    Stat.sprite3DCount = 0;
    Stat.drawCall = 0;
    Stat.draw2D = 0;
    Stat.trianglesFaces = 0;
    Stat.renderNode = 0;
    Stat.meshRenderNode = 0;
    Stat.skinRenderNode = 0;
    Stat.particleRenderNode = 0;
    Stat.frustumCulling = 0;
    Stat.uniformUpload = 0;
    Stat.opaqueDrawCall = 0;
    Stat.transDrawCall = 0;
    Stat.depthCastDrawCall = 0;
    Stat.shadowMapDrawCall = 0;
    Stat.instanceDrawCall = 0;
    Stat.cmdDrawCall = 0;
    Stat.blitDrawCall = 0;
    Stat.renderPassStatArray = new Array(exports.RenderPassStatisticsInfo.RenderPassStatisticCount);
    Stat.enableRenderPassStatArray = false;
    Stat.textureMemory = 0;
    Stat.renderTextureMemory = 0;
    Stat.bufferMemory = 0;
    Stat.uploadUniform = 0;
    Stat.enableShadow = true;
    Stat.enableMulLight = true;
    Stat.enableLight = true;
    Stat.enableCameraCMD = true;
    Stat.enablePostprocess = true;
    Stat.enableSkin = true;
    Stat.enableTransparent = true;
    Stat.enableParticle = true;
    Stat.enableAnimatorUpdate = true;
    Stat.enablePhysicsUpdate = true;
    Stat.enablemsaa = true;
    Stat.enableOpaque = true;
    window.Stat = Stat;

    exports.BufferTargetType = void 0;
    (function (BufferTargetType) {
        BufferTargetType[BufferTargetType["ARRAY_BUFFER"] = 0] = "ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["ELEMENT_ARRAY_BUFFER"] = 1] = "ELEMENT_ARRAY_BUFFER";
        BufferTargetType[BufferTargetType["UNIFORM_BUFFER"] = 2] = "UNIFORM_BUFFER";
        BufferTargetType[BufferTargetType["COPY_READ_BUFFER"] = 3] = "COPY_READ_BUFFER";
        BufferTargetType[BufferTargetType["COPY_WRITE_BUFFER"] = 4] = "COPY_WRITE_BUFFER";
        BufferTargetType[BufferTargetType["TRANSFORM_FEEDBACK_BUFFER"] = 5] = "TRANSFORM_FEEDBACK_BUFFER";
    })(exports.BufferTargetType || (exports.BufferTargetType = {}));
    exports.BufferUsage = void 0;
    (function (BufferUsage) {
        BufferUsage[BufferUsage["Static"] = 0] = "Static";
        BufferUsage[BufferUsage["Dynamic"] = 1] = "Dynamic";
        BufferUsage[BufferUsage["Stream"] = 2] = "Stream";
    })(exports.BufferUsage || (exports.BufferUsage = {}));

    exports.DrawType = void 0;
    (function (DrawType) {
        DrawType[DrawType["DrawArray"] = 0] = "DrawArray";
        DrawType[DrawType["DrawArrayInstance"] = 1] = "DrawArrayInstance";
        DrawType[DrawType["DrawElement"] = 2] = "DrawElement";
        DrawType[DrawType["DrawElementInstance"] = 3] = "DrawElementInstance";
    })(exports.DrawType || (exports.DrawType = {}));

    exports.IndexFormat = void 0;
    (function (IndexFormat) {
        IndexFormat[IndexFormat["UInt8"] = 0] = "UInt8";
        IndexFormat[IndexFormat["UInt16"] = 1] = "UInt16";
        IndexFormat[IndexFormat["UInt32"] = 2] = "UInt32";
    })(exports.IndexFormat || (exports.IndexFormat = {}));

    exports.MeshTopology = void 0;
    (function (MeshTopology) {
        MeshTopology[MeshTopology["Points"] = 0] = "Points";
        MeshTopology[MeshTopology["Lines"] = 1] = "Lines";
        MeshTopology[MeshTopology["LineLoop"] = 2] = "LineLoop";
        MeshTopology[MeshTopology["LineStrip"] = 3] = "LineStrip";
        MeshTopology[MeshTopology["Triangles"] = 4] = "Triangles";
        MeshTopology[MeshTopology["TriangleStrip"] = 5] = "TriangleStrip";
        MeshTopology[MeshTopology["TriangleFan"] = 6] = "TriangleFan";
    })(exports.MeshTopology || (exports.MeshTopology = {}));

    const TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    class RenderState2D {
        static restoreTempArray() {
            TEMPMAT4_ARRAY[0] = 1;
            TEMPMAT4_ARRAY[1] = 0;
            TEMPMAT4_ARRAY[4] = 0;
            TEMPMAT4_ARRAY[5] = 1;
            TEMPMAT4_ARRAY[12] = 0;
            TEMPMAT4_ARRAY[13] = 0;
        }
        static clear() {
            RenderState2D.worldAlpha = 1;
        }
    }
    RenderState2D.worldMatrix4 = TEMPMAT4_ARRAY;
    RenderState2D.worldMatrix = new Matrix();
    RenderState2D.matWVP = null;
    RenderState2D.worldAlpha = 1.0;
    RenderState2D.worldScissorTest = false;
    RenderState2D.width = 0;
    RenderState2D.height = 0;
    RenderState2D.InvertY = false;

    class Render2DGlobalState {
    }
    Render2DGlobalState.curRT = null;
    class Render2D {
        constructor(out = null) {
            this._renderTexture = null;
            this._renderTexture = out;
        }
    }
    class Render2DSimple extends Render2D {
        constructor(out = null) {
            super(out);
            this._lastRT = null;
            if (!Render2DSimple.rendercontext2D) {
                Render2DSimple.rendercontext2D = LayaGL.render2DRenderPassFactory.createRenderContext2D();
            }
            this._renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
            this._renderElement.nodeCommonMap = ["Sprite2D"];
        }
        clone(out) {
            return new Render2DSimple(out);
        }
        _createMesh(decl) {
            let geo = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            let mesh = LayaGL.renderDeviceFactory.createBufferState();
            geo.bufferState = mesh;
            let vb = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            vb.vertexDeclaration = decl;
            let ib = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Dynamic);
            mesh.applyState([vb], ib);
            geo.indexFormat = exports.IndexFormat.UInt16;
            return geo;
        }
        getGeo(decl) {
            let geo = Render2DSimple._geoMap[decl.id];
            if (geo == undefined) {
                geo = this._createMesh(decl);
                Render2DSimple._geoMap[decl.id] = geo;
            }
            return geo;
        }
        renderStart(clear, clearColor) {
            this._lastRT = Render2DGlobalState.curRT;
            if (this._renderTexture) {
                Render2DSimple.rendercontext2D.invertY = this._renderTexture._invertY;
                Render2DSimple.rendercontext2D.setRenderTarget(this._renderTexture._renderTarget, clear, clearColor);
                Render2DGlobalState.curRT = this._renderTexture;
            }
            else {
                Render2DSimple.rendercontext2D.invertY = false;
                Render2DSimple.rendercontext2D.setOffscreenView(RenderState2D.width, RenderState2D.height);
                if (!Render2DGlobalState.curRT)
                    Render2DSimple.rendercontext2D.setRenderTarget(null, clear, clearColor);
            }
            RenderTexture2D._clear = false;
        }
        drawElement(ele) {
            Render2DSimple.rendercontext2D.drawRenderElementOne(ele);
        }
        draw(mesh2d, vboff, vblen, iboff, iblen, mtl, customMaterial) {
            Stat.draw2D++;
            let geo = this.getGeo(mesh2d.vertexDeclarition);
            let mesh = geo.bufferState;
            let vb = mesh._vertexBuffers[0];
            let ib = mesh._bindedIndexBuffer;
            vb.setDataLength(vblen);
            vb.setData(mesh2d.vbBuffer, vboff, 0, vblen);
            ib._setIndexDataLength(iblen);
            ib._setIndexData(new Uint16Array(mesh2d.ibBuffer, iboff, iblen / 2), 0);
            geo.clearRenderParams();
            geo.setDrawElemenParams(iblen / 2, 0);
            let mat = customMaterial;
            this._renderElement.geometry = geo;
            this._renderElement.value2DShaderData = mtl.shaderData;
            if (mat) {
                this._renderElement.subShader = mat._shader.getSubShaderAt(0);
                this._renderElement.materialShaderData = mat.shaderData;
            }
            else {
                this._renderElement.subShader = mtl._defaultShader.getSubShaderAt(0);
                this._renderElement.materialShaderData = null;
            }
            Render2DSimple.rendercontext2D.drawRenderElementOne(this._renderElement);
        }
        renderEnd() {
            let lastRT = this._lastRT ? this._lastRT._renderTarget : null;
            Render2DSimple.rendercontext2D.invertY = false;
            Render2DSimple.rendercontext2D.setRenderTarget(lastRT, false, Color.BLACK);
            Render2DGlobalState.curRT = this._lastRT;
            this._lastRT = null;
        }
    }
    Render2DSimple._geoMap = {};

    class SingletonList {
        constructor() {
            this.elements = [];
            this.length = 0;
        }
        _add(element) {
            if (this.length === this.elements.length)
                this.elements.push(element);
            else
                this.elements[this.length] = element;
        }
        add(element) {
            let index = this.elements.indexOf(element);
            if ((typeof (element) != "number") && index != -1 && index < this.length)
                return;
            if (this.length === this.elements.length)
                this.elements.push(element);
            else
                this.elements[this.length] = element;
            this.length++;
        }
        indexof(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length)
                return index;
            return -1;
        }
        remove(element) {
            let index = this.elements.indexOf(element);
            if (index != -1 && index < this.length) {
                this.elements[index] = this.elements[this.length - 1];
                this.elements[this.length - 1] = null;
                this.length--;
            }
        }
        clear() {
            this.elements = [];
            this.length = 0;
        }
        clean() {
            this.elements.length = this.length;
        }
        cloneTo(out) {
            out.length = this.length;
            out.elements = this.elements.slice();
        }
        destroy() {
            this.elements = null;
        }
    }
    class FastSinglelist extends SingletonList {
        add(element) {
            this._add(element);
            this.length++;
        }
    }

    class Batch2DInfo {
        constructor() {
            this.batchFun = null;
            this.batch = false;
            this.indexStart = -1;
            this.elementLenth = 0;
        }
        static create() {
            if (this._pool.length != 0) {
                return this._pool.pop();
            }
            else
                return new Batch2DInfo();
        }
        static recover(info) {
            this._pool.push(info);
        }
    }
    Batch2DInfo._pool = [];
    class RenderManager2D {
        static regisBatch(renderElementType, batch) {
            if (RenderManager2D._batchMapManager[renderElementType])
                throw "Overlapping batch optimization";
            else
                RenderManager2D._batchMapManager[renderElementType] = batch;
        }
        set renderLayerMask(value) {
            this._renderLayerMask = value;
        }
        set cullRect(value) {
            this._cullRect = value;
        }
        get list() {
            return this._list;
        }
        set list(value) {
            this._list = value;
        }
        constructor() {
            this._lastRenderNodeType = -1;
            this._renderEnd = true;
            this._renderLayerMask = 0xFFFFFFFF;
            this._cullRect = new Vector4();
            this.list = new FastSinglelist();
            this._renderElementList = new FastSinglelist();
            this._batchInfoList = new FastSinglelist();
        }
        addRenderObject(object) {
            this.list.add(object);
        }
        removeRenderObject(object) {
            this.list.remove(object);
        }
        clearList() {
            this._list.clear();
            this._renderElementList.clear();
            for (var i = 0, n = this._batchInfoList.length; i < n; i++) {
                let element = this._batchInfoList.elements[i];
                if (element.batch) {
                    element.batchFun.recover();
                }
                Batch2DInfo.recover(element);
            }
            this._batchInfoList.clear();
        }
        renderUpdate() {
            var context = Render2DSimple.rendercontext2D;
            let lists = this._list.elements;
            for (let i = 0, n = this._list.length; i < n; i++) {
                let render = lists[i];
                if (render.renderUpdate && render._renderUpdateMask != Stat.loopCount) {
                    render.renderUpdate(context);
                    render._renderUpdateMask = Stat.loopCount;
                }
            }
        }
        render(context) {
            this.renderUpdate();
            for (var i = 0, n = this._list.length; i < n; i++) {
                this._cull(this._list.elements[i], context);
            }
            this._batch();
            context.drawRenderElementList(this._renderElementList);
            this.endRender();
        }
        _cull(renderNode, context) {
            if (renderNode.preRenderUpdate)
                renderNode.preRenderUpdate(context);
            let n = renderNode._renderElements.length;
            if (n == 1) {
                this._batchStart(renderNode._renderType, 1);
                this._renderElementList.add(renderNode._renderElements[0]);
            }
            else {
                this._batchStart(renderNode._renderType, n);
                for (var i = 0; i < n; i++) {
                    this._renderElementList.add(renderNode._renderElements[i]);
                }
            }
        }
        _isRectIntersect(rect1, rect2) {
            return !(rect1.x > rect2.z || rect1.z < rect2.x || rect1.y > rect2.w || rect1.w < rect2.y);
        }
        _batch() {
            this._batchInfoList.add(this._lastbatch2DInfo);
            this._renderElementList.length = 0;
            for (var i = 0, n = this._batchInfoList.length; i < n; i++) {
                let info = this._batchInfoList.elements[i];
                if (info.batch) {
                    info.batchFun.batchRenderElement(this._renderElementList, info.indexStart, info.elementLenth);
                }
                else {
                    for (let j = info.indexStart, m = info.elementLenth + info.indexStart; j < m; j++)
                        this._renderElementList.add(this._renderElementList.elements[j]);
                }
            }
        }
        _batchStart(renderNodeType, elementLength) {
            if (this._lastRenderNodeType == -1) {
                this._lastbatch2DInfo = Batch2DInfo.create();
                this._lastbatch2DInfo.batch = false;
                this._lastbatch2DInfo.batchFun = RenderManager2D._batchMapManager[renderNodeType];
                this._lastbatch2DInfo.indexStart = 0;
                this._lastbatch2DInfo.elementLenth = elementLength;
                this._lastRenderNodeType = renderNodeType;
                return;
            }
            if (this._lastRenderNodeType == renderNodeType) {
                this._lastbatch2DInfo.batch = !!(this._lastbatch2DInfo.batchFun);
                this._lastbatch2DInfo.elementLenth += elementLength;
            }
            else {
                this._batchInfoList.add(this._lastbatch2DInfo);
                this._lastbatch2DInfo = Batch2DInfo.create();
                this._lastbatch2DInfo.batch = false;
                this._lastbatch2DInfo.batchFun = RenderManager2D._batchMapManager[renderNodeType];
                this._lastbatch2DInfo.indexStart = this._renderElementList.length;
                this._lastbatch2DInfo.elementLenth = elementLength;
                this._lastRenderNodeType = renderNodeType;
            }
        }
        endRender() {
            this.clearList();
            this._renderEnd = true;
            this._lastRenderNodeType = -1;
        }
    }
    RenderManager2D._batchMapManager = {};

    exports.BlendEquationSeparate = void 0;
    (function (BlendEquationSeparate) {
        BlendEquationSeparate[BlendEquationSeparate["ADD"] = 0] = "ADD";
        BlendEquationSeparate[BlendEquationSeparate["SUBTRACT"] = 1] = "SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["REVERSE_SUBTRACT"] = 2] = "REVERSE_SUBTRACT";
        BlendEquationSeparate[BlendEquationSeparate["MIN"] = 3] = "MIN";
        BlendEquationSeparate[BlendEquationSeparate["MAX"] = 4] = "MAX";
    })(exports.BlendEquationSeparate || (exports.BlendEquationSeparate = {}));

    exports.BlendFactor = void 0;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["Zero"] = 0] = "Zero";
        BlendFactor[BlendFactor["One"] = 1] = "One";
        BlendFactor[BlendFactor["SourceColor"] = 2] = "SourceColor";
        BlendFactor[BlendFactor["OneMinusSourceColor"] = 3] = "OneMinusSourceColor";
        BlendFactor[BlendFactor["DestinationColor"] = 4] = "DestinationColor";
        BlendFactor[BlendFactor["OneMinusDestinationColor"] = 5] = "OneMinusDestinationColor";
        BlendFactor[BlendFactor["SourceAlpha"] = 6] = "SourceAlpha";
        BlendFactor[BlendFactor["OneMinusSourceAlpha"] = 7] = "OneMinusSourceAlpha";
        BlendFactor[BlendFactor["DestinationAlpha"] = 8] = "DestinationAlpha";
        BlendFactor[BlendFactor["OneMinusDestinationAlpha"] = 9] = "OneMinusDestinationAlpha";
        BlendFactor[BlendFactor["SourceAlphaSaturate"] = 10] = "SourceAlphaSaturate";
        BlendFactor[BlendFactor["BlendColor"] = 11] = "BlendColor";
        BlendFactor[BlendFactor["OneMinusBlendColor"] = 12] = "OneMinusBlendColor";
    })(exports.BlendFactor || (exports.BlendFactor = {}));

    exports.BlendType = void 0;
    (function (BlendType) {
        BlendType[BlendType["BLEND_DISABLE"] = 0] = "BLEND_DISABLE";
        BlendType[BlendType["BLEND_ENABLE_ALL"] = 1] = "BLEND_ENABLE_ALL";
        BlendType[BlendType["BLEND_ENABLE_SEPERATE"] = 2] = "BLEND_ENABLE_SEPERATE";
    })(exports.BlendType || (exports.BlendType = {}));

    exports.CompareFunction = void 0;
    (function (CompareFunction) {
        CompareFunction[CompareFunction["Never"] = 0] = "Never";
        CompareFunction[CompareFunction["Less"] = 1] = "Less";
        CompareFunction[CompareFunction["Equal"] = 2] = "Equal";
        CompareFunction[CompareFunction["LessEqual"] = 3] = "LessEqual";
        CompareFunction[CompareFunction["Greater"] = 4] = "Greater";
        CompareFunction[CompareFunction["NotEqual"] = 5] = "NotEqual";
        CompareFunction[CompareFunction["GreaterEqual"] = 6] = "GreaterEqual";
        CompareFunction[CompareFunction["Always"] = 7] = "Always";
        CompareFunction[CompareFunction["Off"] = 8] = "Off";
    })(exports.CompareFunction || (exports.CompareFunction = {}));

    exports.CullMode = void 0;
    (function (CullMode) {
        CullMode[CullMode["Off"] = 0] = "Off";
        CullMode[CullMode["Front"] = 1] = "Front";
        CullMode[CullMode["Back"] = 2] = "Back";
    })(exports.CullMode || (exports.CullMode = {}));
    exports.FrontFace = void 0;
    (function (FrontFace) {
        FrontFace[FrontFace["CW"] = 0] = "CW";
        FrontFace[FrontFace["CCW"] = 1] = "CCW";
    })(exports.FrontFace || (exports.FrontFace = {}));

    exports.StencilOperation = void 0;
    (function (StencilOperation) {
        StencilOperation[StencilOperation["Keep"] = 0] = "Keep";
        StencilOperation[StencilOperation["Zero"] = 1] = "Zero";
        StencilOperation[StencilOperation["Replace"] = 2] = "Replace";
        StencilOperation[StencilOperation["IncrementSaturate"] = 3] = "IncrementSaturate";
        StencilOperation[StencilOperation["DecrementSaturate"] = 4] = "DecrementSaturate";
        StencilOperation[StencilOperation["Invert"] = 5] = "Invert";
        StencilOperation[StencilOperation["IncrementWrap"] = 6] = "IncrementWrap";
        StencilOperation[StencilOperation["DecrementWrap"] = 7] = "DecrementWrap";
    })(exports.StencilOperation || (exports.StencilOperation = {}));

    class RenderState {
        ;
        get cull() {
            return this._cull;
        }
        set cull(value) {
            this._cull = value;
        }
        get blend() {
            return this._blend;
        }
        set blend(value) {
            this._blend = value;
        }
        get srcBlend() {
            return this._srcBlend;
        }
        set srcBlend(value) {
            this._srcBlend = value;
        }
        get dstBlend() {
            return this._dstBlend;
        }
        set dstBlend(value) {
            this._dstBlend = value;
        }
        get srcBlendRGB() {
            return this._srcBlendRGB;
        }
        set srcBlendRGB(value) {
            this._srcBlendRGB = value;
        }
        get dstBlendRGB() {
            return this._dstBlendRGB;
        }
        set dstBlendRGB(value) {
            this._dstBlendRGB = value;
        }
        get srcBlendAlpha() {
            return this._srcBlendAlpha;
        }
        set srcBlendAlpha(value) {
            this._srcBlendAlpha = value;
        }
        get dstBlendAlpha() {
            return this._dstBlendAlpha;
        }
        set dstBlendAlpha(value) {
            this._dstBlendAlpha = value;
        }
        get blendEquation() {
            return this._blendEquation;
        }
        set blendEquation(value) {
            this._blendEquation = value;
        }
        get blendEquationRGB() {
            return this._blendEquationRGB;
        }
        set blendEquationRGB(value) {
            this._blendEquationRGB = value;
        }
        get blendEquationAlpha() {
            return this._blendEquationAlpha;
        }
        set blendEquationAlpha(value) {
            this._blendEquationAlpha = value;
        }
        get depthTest() {
            return this._depthTest;
        }
        set depthTest(value) {
            this._depthTest = value;
        }
        get depthWrite() {
            return this._depthWrite;
        }
        set depthWrite(value) {
            this._depthWrite = value;
        }
        get stencilWrite() {
            return this._stencilWrite;
        }
        set stencilWrite(value) {
            this._stencilWrite = value;
        }
        get stencilTest() {
            return this._stencilTest;
        }
        set stencilTest(value) {
            this._stencilTest = value;
        }
        get stencilRef() {
            return this._stencilRef;
        }
        set stencilRef(value) {
            this._stencilRef = value;
        }
        get stencilOp() {
            return this._stencilOp;
        }
        set stencilOp(value) {
            this._stencilOp = value;
        }
        createObj() {
        }
        constructor() {
            this._stencilOp = new Vector3();
            this.createObj();
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.srcBlend = RenderState.BLENDPARAM_ONE;
            this.dstBlend = RenderState.BLENDPARAM_ZERO;
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE;
            this.dstBlendRGB = RenderState.BLENDPARAM_ZERO;
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE;
            this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
        }
        setNull() {
            this.cull = null;
            this.blend = null;
            this.srcBlend = null;
            this.dstBlend = null;
            this.srcBlendRGB = null;
            this.dstBlendRGB = null;
            this.srcBlendAlpha = null;
            this.dstBlendAlpha = null;
            this.blendEquation = null;
            this.blendEquationRGB = null;
            this.blendEquationAlpha = null;
            this.depthTest = null;
            this.depthWrite = null;
            this.stencilRef = null;
            this.stencilTest = null;
            this.stencilWrite = null;
            this.stencilOp.set(null, null, null);
        }
        cloneTo(dest) {
            dest.cull = this.cull;
            dest.blend = this.blend;
            dest.srcBlend = this.srcBlend;
            dest.dstBlend = this.dstBlend;
            dest.srcBlendRGB = this.srcBlendRGB;
            dest.dstBlendRGB = this.dstBlendRGB;
            dest.srcBlendAlpha = this.srcBlendAlpha;
            dest.dstBlendAlpha = this.dstBlendAlpha;
            dest.blendEquation = this.blendEquation;
            dest.blendEquationRGB = this.blendEquationRGB;
            dest.blendEquationAlpha = this.blendEquationAlpha;
            dest.depthTest = this.depthTest;
            dest.depthWrite = this.depthWrite;
            dest.stencilRef = this.stencilRef;
            dest.stencilTest = this.stencilTest;
            dest.stencilWrite = this.stencilWrite;
            this.stencilOp.cloneTo(dest.stencilOp);
        }
        clone() {
            var dest = new RenderState();
            this.cloneTo(dest);
            return dest;
        }
    }
    RenderState.CULL_NONE = exports.CullMode.Off;
    RenderState.CULL_FRONT = exports.CullMode.Front;
    RenderState.CULL_BACK = exports.CullMode.Back;
    RenderState.BLEND_DISABLE = exports.BlendType.BLEND_DISABLE;
    RenderState.BLEND_ENABLE_ALL = exports.BlendType.BLEND_ENABLE_ALL;
    RenderState.BLEND_ENABLE_SEPERATE = exports.BlendType.BLEND_ENABLE_SEPERATE;
    RenderState.BLENDPARAM_ZERO = exports.BlendFactor.Zero;
    RenderState.BLENDPARAM_ONE = exports.BlendFactor.One;
    RenderState.BLENDPARAM_SRC_COLOR = exports.BlendFactor.SourceColor;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = exports.BlendFactor.OneMinusSourceColor;
    RenderState.BLENDPARAM_DST_COLOR = exports.BlendFactor.DestinationColor;
    RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = exports.BlendFactor.OneMinusDestinationColor;
    RenderState.BLENDPARAM_SRC_ALPHA = exports.BlendFactor.SourceAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = exports.BlendFactor.OneMinusSourceAlpha;
    RenderState.BLENDPARAM_DST_ALPHA = exports.BlendFactor.DestinationAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = exports.BlendFactor.OneMinusDestinationAlpha;
    RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = exports.BlendFactor.SourceAlphaSaturate;
    RenderState.BLENDPARAM_BLENDCOLOR = exports.BlendFactor.BlendColor;
    RenderState.BLENDPARAM_BLEND_ONEMINUS_COLOR = exports.BlendFactor.OneMinusBlendColor;
    RenderState.BLENDEQUATION_ADD = exports.BlendEquationSeparate.ADD;
    RenderState.BLENDEQUATION_SUBTRACT = exports.BlendEquationSeparate.SUBTRACT;
    RenderState.BLENDEQUATION_REVERSE_SUBTRACT = exports.BlendEquationSeparate.REVERSE_SUBTRACT;
    RenderState.BLENDEQUATION_MIN = exports.BlendEquationSeparate.MIN;
    RenderState.BLENDEQUATION_MAX = exports.BlendEquationSeparate.MAX;
    RenderState.DEPTHTEST_OFF = exports.CompareFunction.Off;
    RenderState.DEPTHTEST_NEVER = exports.CompareFunction.Never;
    RenderState.DEPTHTEST_LESS = exports.CompareFunction.Less;
    RenderState.DEPTHTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.DEPTHTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.DEPTHTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.DEPTHTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.DEPTHTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.DEPTHTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILTEST_OFF = exports.CompareFunction.Off;
    RenderState.STENCILTEST_NEVER = exports.CompareFunction.Never;
    RenderState.STENCILTEST_LESS = exports.CompareFunction.Less;
    RenderState.STENCILTEST_EQUAL = exports.CompareFunction.Equal;
    RenderState.STENCILTEST_LEQUAL = exports.CompareFunction.LessEqual;
    RenderState.STENCILTEST_GREATER = exports.CompareFunction.Greater;
    RenderState.STENCILTEST_NOTEQUAL = exports.CompareFunction.NotEqual;
    RenderState.STENCILTEST_GEQUAL = exports.CompareFunction.GreaterEqual;
    RenderState.STENCILTEST_ALWAYS = exports.CompareFunction.Always;
    RenderState.STENCILOP_KEEP = exports.StencilOperation.Keep;
    RenderState.STENCILOP_ZERO = exports.StencilOperation.Zero;
    RenderState.STENCILOP_REPLACE = exports.StencilOperation.Replace;
    RenderState.STENCILOP_INCR = exports.StencilOperation.IncrementSaturate;
    RenderState.STENCILOP_INCR_WRAP = exports.StencilOperation.IncrementWrap;
    RenderState.STENCILOP_DECR = exports.StencilOperation.DecrementSaturate;
    RenderState.STENCILOP_DECR_WRAP = exports.StencilOperation.DecrementWrap;
    RenderState.STENCILOP_INVERT = exports.StencilOperation.Invert;
    RenderState.Default = new RenderState();

    class IncludeFile {
        static splitToWords(str, block) {
            let out = [];
            let c;
            let ofs = -1;
            let word;
            let n = str.length;
            for (let i = 0; i < n; i++) {
                c = str.charAt(i);
                if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
                    if (ofs >= 0 && (i - ofs) > 1) {
                        word = str.substring(ofs, i);
                        out.push(word);
                    }
                    if (c == '"' || c == "'") {
                        let ofs2 = str.indexOf(c, i + 1);
                        if (ofs2 < 0) {
                            throw "Sharder err:" + str;
                        }
                        out.push(str.substring(i + 1, ofs2));
                        i = ofs2;
                        ofs = -1;
                        continue;
                    }
                    if (c == '(' && block && out.length > 0) {
                        word = out[out.length - 1] + ";";
                        if ("vec4;main;".indexOf(word) < 0)
                            block.useFuns += word;
                    }
                    ofs = -1;
                    continue;
                }
                if (ofs < 0)
                    ofs = i;
            }
            if (ofs < n && (n - ofs) > 1) {
                word = str.substring(ofs, n);
                out.push(word);
            }
            return out;
        }
        constructor(txt) {
            this.codes = {};
            this.funs = {};
            this.curUseID = -1;
            this.funnames = "";
            this.script = txt;
            let begin = 0, ofs, end;
            while (true) {
                begin = txt.indexOf("#begin", begin);
                if (begin < 0)
                    break;
                end = begin + 5;
                while (true) {
                    end = txt.indexOf("#end", end);
                    if (end < 0)
                        break;
                    if (txt.charAt(end + 4) === 'i')
                        end += 5;
                    else
                        break;
                }
                if (end < 0) {
                    throw "add include err,no #end:" + txt;
                }
                ofs = txt.indexOf('\n', begin);
                let words = IncludeFile.splitToWords(txt.substring(begin, ofs), null);
                if (words[1] == 'code') {
                    this.codes[words[2]] = txt.substring(ofs + 1, end);
                }
                else if (words[1] == 'function') {
                    ofs = txt.indexOf("function", begin);
                    ofs += "function".length;
                    this.funs[words[3]] = txt.substring(ofs + 1, end);
                    this.funnames += words[3] + ";";
                }
                begin = end + 1;
            }
        }
        getWith(name = null) {
            let r = name ? this.codes[name] : this.script;
            if (!r) {
                throw "get with error:" + name;
            }
            return r;
        }
        getFunsScript(funsdef) {
            let r = "";
            for (let i in this.funs) {
                if (funsdef.indexOf(i + ";") >= 0) {
                    r += this.funs[i];
                }
            }
            return r;
        }
    }

    class ShaderNode {
        constructor(includefiles) {
            this.childs = [];
            this.text = "";
            this.useFuns = "";
            this.z = 0;
            this.includefiles = includefiles;
        }
        setParent(parent) {
            parent.childs.push(this);
            this.z = parent.z + 1;
            this.parent = parent;
        }
        setCondition(condition, type) {
            if (condition) {
                this.conditionType = type;
                condition = condition.replace(/(\s*$)/g, "");
                this.condition = function () {
                    return this[condition];
                };
                this.condition.__condition = condition;
            }
        }
        toscript(def, out) {
            return this._toscript(def, out, ++ShaderNode.__id);
        }
        _toscript(def, out, id) {
            if (this.childs.length < 1 && !this.text)
                return out;
            out.length;
            if (this.condition) {
                var ifdef = !!this.condition.call(def);
                this.conditionType === 2 && (ifdef = !ifdef);
                if (!ifdef && ShaderNode.__noCompileEnable)
                    return out;
            }
            if (this.noCompile || !ShaderNode.__noCompileEnable)
                this.text && out.push(this.text);
            this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
                o._toscript(def, out, id);
            });
            if (this.includefiles.length > 0 && this.useFuns.length > 0) {
                var funsCode;
                for (var i = 0, n = this.includefiles.length; i < n; i++) {
                    if (this.includefiles[i].curUseID == id) {
                        continue;
                    }
                    funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
                    if (funsCode.length > 0) {
                        this.includefiles[i].curUseID = id;
                        out[0] = funsCode + out[0];
                    }
                }
            }
            return out;
        }
    }
    ShaderNode.__id = 1;
    ShaderNode.__noCompileEnable = true;

    const _clearCR = new RegExp("\r", "g");
    const _splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g");
    const CullStateMap = {
        "Back": exports.CullMode.Back,
        "Front": exports.CullMode.Front,
        "Off": exports.CullMode.Off
    };
    const BlendStateMap = {
        "Disable": exports.BlendType.BLEND_DISABLE,
        "All": exports.BlendType.BLEND_ENABLE_ALL,
        "Seperate": exports.BlendType.BLEND_ENABLE_SEPERATE
    };
    const BlendFactorMap = {
        "Zero": exports.BlendFactor.Zero,
        "One": exports.BlendFactor.One,
        "SourceColor": exports.BlendFactor.SourceColor,
        "OneMinusSourceColor": exports.BlendFactor.OneMinusSourceColor,
        "DestinationColor": exports.BlendFactor.DestinationColor,
        "OneMinusDestinationColor": exports.BlendFactor.OneMinusDestinationColor,
        "SourceAlpha": exports.BlendFactor.SourceAlpha,
        "OneMinusSourceAlpha": exports.BlendFactor.OneMinusSourceAlpha,
        "DestinationAlpha": exports.BlendFactor.DestinationAlpha,
        "OneMinusDestinationAlpha": exports.BlendFactor.OneMinusDestinationAlpha,
        "SourceAlphaSaturate": exports.BlendFactor.SourceAlphaSaturate,
        "BlendColor": exports.BlendFactor.BlendColor,
        "OneMinusBlendColor": exports.BlendFactor.OneMinusBlendColor,
    };
    const BlendEquationMap = {
        "Add": exports.BlendEquationSeparate.ADD,
        "Subtract": exports.BlendEquationSeparate.SUBTRACT,
        "Reverse_substract": exports.BlendEquationSeparate.REVERSE_SUBTRACT,
        "Min": exports.BlendEquationSeparate.MIN,
        "Max": exports.BlendEquationSeparate.MAX
    };
    const CompareFunctionMap = {
        "Never": exports.CompareFunction.Never,
        "Less": exports.CompareFunction.Less,
        "Equal": exports.CompareFunction.Equal,
        "LessEqual": exports.CompareFunction.LessEqual,
        "Greater": exports.CompareFunction.Greater,
        "NotEqual": exports.CompareFunction.NotEqual,
        "GreaterEqual": exports.CompareFunction.GreaterEqual,
        "Always": exports.CompareFunction.Always,
        "Off": exports.CompareFunction.Off,
    };
    const StencilOperationMap = {
        "Keep": exports.StencilOperation.Keep,
        "Zero": exports.StencilOperation.Zero,
        "Replace": exports.StencilOperation.Replace,
        "IncrementSaturate": exports.StencilOperation.IncrementSaturate,
        "DecrementSaturate": exports.StencilOperation.DecrementSaturate,
        "Invert": exports.StencilOperation.Invert,
        "IncrementWrap": exports.StencilOperation.IncrementWrap,
        "DecrementWrap": exports.StencilOperation.DecrementWrap,
    };
    class ShaderCompile {
        static addInclude(fileName, txt, allowReplace) {
            if (!txt || txt.length === 0) {
                console.error("shader include file err:" + fileName);
                return null;
            }
            if (!allowReplace && ShaderCompile.includes[fileName]) {
                console.warn("shader include file already exists:" + fileName);
                return ShaderCompile.includes[fileName];
            }
            txt = txt.replace(_clearCR, "");
            let file = new IncludeFile(txt);
            ShaderCompile.includes[fileName] = file;
            return file;
        }
        static compile(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            for (let inc of includes) {
                if (inc.file)
                    result.includeNames.add(inc.name);
                else
                    console.warn(`ShaderCompile missing file ${inc.name}`);
            }
            return result;
        }
        static compileAsync(vs, ps, basePath) {
            let result = {
                vsNode: new ShaderNode([]),
                psNode: new ShaderNode([]),
                includeNames: new Set(),
                defs: new Set()
            };
            let includes = [];
            vs = vs.replace(_clearCR, "");
            ps = ps.replace(_clearCR, "");
            ShaderCompile._compileToTree(result.vsNode, vs, result.defs, includes, basePath);
            ShaderCompile._compileToTree(result.psNode, ps, result.defs, includes, basePath);
            return this._loadIncludesDeep(result, includes, 0);
        }
        static _loadIncludesDeep(result, includes, index) {
            let toLoad;
            let includesCnt = includes.length;
            for (let i = index; i < includesCnt; i++) {
                let inc = includes[i];
                if (inc.file)
                    result.includeNames.add(inc.name);
                else {
                    if (!toLoad)
                        toLoad = [];
                    toLoad.push(inc);
                }
            }
            if (!toLoad)
                return Promise.resolve(result);
            return ILaya.loader.load(toLoad.map(tc => tc.name)).then(files => {
                let cnt = toLoad.length;
                for (let i = 0; i < cnt; i++) {
                    let inc = toLoad[i];
                    let file = files[i];
                    if (!file) {
                        let childs = inc.node.parent.childs;
                        childs.splice(childs.indexOf(inc.node), 1);
                    }
                    else {
                        result.includeNames.add(inc.name);
                        let text = file.getWith(inc.codeName);
                        if (inc.node.condition)
                            inc.node.text = text;
                        else {
                            ShaderCompile._compileToTree(inc.node, text, result.defs, includes, URL.getPath(inc.name));
                            inc.node.text = "";
                        }
                    }
                }
                if (includes.length > includesCnt)
                    return ShaderCompile._loadIncludesDeep(result, includes, includesCnt);
                else
                    return result;
            });
        }
        static _compileToTree(parent, script, defs, includes, basePath) {
            let node, preNode;
            let text, name, fname;
            let ofs, words;
            let i, n, j;
            let lines = script.split("\n");
            for (i = 0; i < lines.length; i++) {
                text = lines[i];
                if (text.length < 1)
                    continue;
                ofs = text.indexOf("//");
                if (ofs === 0)
                    continue;
                if (ofs >= 0)
                    text = text.substr(0, ofs);
                if ((ofs = text.indexOf("#")) < 0) {
                    preNode = parent.childs[parent.childs.length - 1];
                    let includefiles = parent.includefiles;
                    if (preNode && !preNode.name) {
                        includefiles.length > 0 && IncludeFile.splitToWords(text, preNode);
                        preNode.text += "\n" + text;
                        continue;
                    }
                    node = new ShaderNode(includefiles);
                    node.text = text;
                    node.noCompile = true;
                    includefiles.length > 0 && IncludeFile.splitToWords(text, node);
                    node.setParent(parent);
                    continue;
                }
                node = new ShaderNode(parent.includefiles);
                node.text = text;
                node.noCompile = true;
                name = "#";
                for (j = ofs + 1, n = text.length; j < n; j++) {
                    let c = text.charAt(j);
                    if (c === ' ' || c === '\t' || c === '?')
                        break;
                    name += c;
                }
                node.name = name;
                switch (name) {
                    case "#ifdef":
                    case "#ifndef":
                        node.src = text;
                        node.noCompile = text.match(/[!&|()=<>]/) != null;
                        if (!node.noCompile) {
                            words = text.replace(/^\s*/, '').split(/\s+/);
                            node.setCondition(words[1], name === "#ifdef" ? ShaderCompile.IFDEF_YES : ShaderCompile.IFDEF_ELSE);
                            node.text = node.text;
                        }
                        else {
                            console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && defs.add(text);
                        }
                        break;
                    case "#if":
                    case "#elif":
                        node.src = text;
                        node.noCompile = true;
                        if (name == "#elif") {
                            parent = parent.parent;
                            preNode = parent.childs[parent.childs.length - 1];
                            preNode.text = preNode.src;
                            preNode.noCompile = true;
                            preNode.condition = null;
                        }
                        node.setParent(parent);
                        parent = node;
                        words = text.substr(j).split(_splitToWordExps3);
                        for (j = 0; j < words.length; j++) {
                            text = words[j];
                            text.length && text != "defined" && defs.add(text);
                        }
                        break;
                    case "#else":
                        node.src = text;
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.condition = preNode.condition;
                            node.conditionType = preNode.conditionType == ShaderCompile.IFDEF_YES ? ShaderCompile.IFDEF_ELSE : ShaderCompile.IFDEF_YES;
                        }
                        node.setParent(parent);
                        parent = node;
                        break;
                    case "#endif":
                        parent = parent.parent;
                        preNode = parent.childs[parent.childs.length - 1];
                        node.noCompile = preNode.noCompile;
                        if (!node.noCompile) {
                            node.text = node.text;
                        }
                        node.setParent(parent);
                        break;
                    case "#include":
                        words = IncludeFile.splitToWords(text, null);
                        let includeName = words[1];
                        let includeFile;
                        if (includeName.startsWith("."))
                            includeName = URL.join(basePath, includeName);
                        else if (includeName.startsWith("/"))
                            includeName = URL.formatURL(includeName.substring(1));
                        else {
                            includeFile = ShaderCompile.includes[includeName];
                            if (!includeFile)
                                includeName = "internal/" + includeName;
                        }
                        includeFile = ShaderCompile.includes[includeName];
                        if (!includeFile && ShaderCompile.loadIncludeFileSync) {
                            ShaderCompile.loadIncludeFileSync(includeName);
                            includeFile = ShaderCompile.includes[includeName];
                        }
                        let codeName = words[2] == 'with' ? words[3] : null;
                        includes.push({ name: includeName, codeName: codeName, node: node, file: includeFile });
                        node.setParent(parent);
                        if ((ofs = words[0].indexOf("?")) < 0) {
                            if (includeFile) {
                                text = includeFile.getWith(codeName);
                                this._compileToTree(node, text, defs, includes, URL.getPath(includeName));
                            }
                            node.text = "";
                        }
                        else {
                            node.setCondition(words[0].substr(ofs + 1), ShaderCompile.IFDEF_YES);
                            if (includeFile)
                                node.text = includeFile.getWith(codeName);
                        }
                        break;
                    case "#import":
                        words = IncludeFile.splitToWords(text, null);
                        fname = words[1];
                        node.includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
                        break;
                    default:
                        node.setParent(parent);
                        break;
                }
            }
        }
        static getRenderState(obj, renderState) {
            if (!obj) {
                return;
            }
            renderState.cull = CullStateMap[obj.cull];
            renderState.blend = BlendStateMap[obj.blend];
            renderState.srcBlend = BlendFactorMap[obj.srcBlend];
            renderState.dstBlend = BlendFactorMap[obj.dstBlend];
            renderState.srcBlendRGB = BlendFactorMap[obj.srcBlendRGB];
            renderState.dstBlendRGB = BlendFactorMap[obj.dstBlendRGB];
            renderState.srcBlendAlpha = BlendFactorMap[obj.srcBlendAlpha];
            renderState.dstBlendAlpha = BlendFactorMap[obj.dstBlendAlpha];
            renderState.blendEquation = BlendEquationMap[obj.blendEquation];
            renderState.blendEquationRGB = BlendEquationMap[obj.blendEquationRGB];
            renderState.blendEquationAlpha = BlendEquationMap[obj.blendEquationAlpha];
            renderState.depthTest = CompareFunctionMap[obj.depthTest];
            renderState.depthWrite = obj.depthWrite;
            renderState.stencilRef = obj.stencilRef;
            renderState.stencilTest = CompareFunctionMap[obj.stencilTest];
            renderState.stencilWrite = obj.stencilWrite;
            let stencilOp = obj.stencilOp;
            let stencilFail = stencilOp ? stencilOp[0] : null;
            let stencilZFail = stencilOp ? stencilOp[1] : null;
            let stencilZPass = stencilOp ? stencilOp[2] : null;
            renderState.stencilOp.x = StencilOperationMap[stencilFail];
            renderState.stencilOp.y = StencilOperationMap[stencilZFail];
            renderState.stencilOp.z = StencilOperationMap[stencilZPass];
            return;
        }
    }
    ShaderCompile.IFDEF_NO = 0;
    ShaderCompile.IFDEF_YES = 1;
    ShaderCompile.IFDEF_ELSE = 2;
    ShaderCompile.IFDEF_PARENT = 3;
    ShaderCompile.includes = {};

    class Vector2 {
        constructor(x = 0, y = 0) {
            this.x = x;
            this.y = y;
        }
        setValue(x, y) {
            this.x = x;
            this.y = y;
            return this;
        }
        static scale(a, b, out) {
            out.x = a.x * b;
            out.y = a.y * b;
        }
        static equals(a, b) {
            return MathUtils3D.nearEqual(a.x, b.x) && MathUtils3D.nearEqual(a.y, b.y);
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
        }
        toArray() {
            return [this.x, this.y];
        }
        writeTo(array, offset = 0) {
            array[offset + 0] = this.x;
            array[offset + 1] = this.y;
        }
        cloneTo(destObject) {
            destObject.x = this.x;
            destObject.y = this.y;
            return destObject;
        }
        static dot(a, b) {
            return (a.x * b.x) + (a.y * b.y);
        }
        static normalize(s, out) {
            var x = s.x, y = s.y;
            var len = x * x + y * y;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = x * len;
                out.y = y * len;
            }
        }
        static scalarLength(a) {
            var x = a.x, y = a.y;
            return Math.sqrt(x * x + y * y);
        }
        static distance(a, b) {
            let x = a.x - b.x;
            let y = a.y - b.y;
            return Math.sqrt(x * x + y * y);
        }
        clone() {
            var destVector2 = new Vector2();
            this.cloneTo(destVector2);
            return destVector2;
        }
    }
    Vector2.ZERO = new Vector2(0.0, 0.0);
    Vector2.ONE = new Vector2(1.0, 1.0);
    Vector2.TEMP = new Vector2();

    const _DEFAULTELEMENTS = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    class Matrix3x3 {
        static createRotationQuaternion(rotation, out) {
            var rotX = rotation.x;
            var rotY = rotation.y;
            var rotZ = rotation.z;
            var rotW = rotation.w;
            var xx = rotX * rotX;
            var yy = rotY * rotY;
            var zz = rotZ * rotZ;
            var xy = rotX * rotY;
            var zw = rotZ * rotW;
            var zx = rotZ * rotX;
            var yw = rotY * rotW;
            var yz = rotY * rotZ;
            var xw = rotX * rotW;
            var resultE = out.elements;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[3] = 2.0 * (xy - zw);
            resultE[4] = 1.0 - (2.0 * (zz + xx));
            resultE[5] = 2.0 * (yz + xw);
            resultE[6] = 2.0 * (zx + yw);
            resultE[7] = 2.0 * (yz - xw);
            resultE[8] = 1.0 - (2.0 * (yy + xx));
        }
        static createFromTranslation(trans, out) {
            var e = out.elements;
            e[0] = 1;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = 1;
            e[5] = 0;
            e[6] = trans.x;
            e[7] = trans.y;
            e[8] = 1;
        }
        static createMatrixFromValue(pos, rotate, scale = Vector2.ONE, out) {
            var e = out.elements;
            var s = Math.sin(rotate), c = Math.cos(rotate);
            e[0] = c * scale.x;
            e[1] = s * scale.x;
            e[2] = 0;
            e[3] = -s * scale.y;
            e[4] = c * scale.y;
            e[5] = 0;
            e[6] = pos.x;
            e[7] = pos.y;
            e[8] = 1;
        }
        static createFromRotation(rad, out) {
            var e = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            e[0] = c;
            e[1] = s;
            e[2] = 0;
            e[3] = -s;
            e[4] = c;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = 1;
        }
        static createFromScaling(scale, out) {
            var e = out.elements;
            e[0] = scale.x;
            e[1] = 0;
            e[2] = 0;
            e[3] = 0;
            e[4] = scale.y;
            e[5] = 0;
            e[6] = 0;
            e[7] = 0;
            e[8] = scale.z;
        }
        static createFromMatrix4x4(sou, out) {
            var souE = sou.elements;
            var outE = out.elements;
            outE[0] = souE[0];
            outE[1] = souE[1];
            outE[2] = souE[2];
            outE[3] = souE[4];
            outE[4] = souE[5];
            outE[5] = souE[6];
            outE[6] = souE[8];
            outE[7] = souE[9];
            outE[8] = souE[10];
        }
        static multiply(left, right, out) {
            var l = left.elements;
            var r = right.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2];
            var l21 = l[3], l22 = l[4], l23 = l[5];
            var l31 = l[6], l32 = l[7], l33 = l[8];
            var r11 = r[0], r12 = r[1], r13 = r[2];
            var r21 = r[3], r22 = r[4], r23 = r[5];
            var r31 = r[6], r32 = r[7], r33 = r[8];
            e[0] = r11 * l11 + r12 * l21 + r13 * l31;
            e[1] = r11 * l12 + r12 * l22 + r13 * r32;
            e[2] = r11 * l13 + r12 * l23 + r13 * l33;
            e[3] = r21 * l11 + r22 * l21 + r23 * l31;
            e[4] = r21 * l12 + r22 * l22 + r23 * l32;
            e[5] = r21 * l13 + r22 * l23 + r23 * l33;
            e[6] = r31 * l11 + r32 * l21 + r33 * l31;
            e[7] = r31 * l12 + r32 * l22 + r33 * l32;
            e[8] = r31 * l13 + r32 * l23 + r33 * l33;
        }
        constructor(createElement = true) {
            createElement && (this.elements = _DEFAULTELEMENTS.slice());
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        determinant() {
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        }
        translate(trans, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var x = trans.x, y = trans.y;
            e[0] = a00;
            e[1] = a01;
            e[2] = a02;
            e[3] = a10;
            e[4] = a11;
            e[5] = a12;
            e[6] = x * a00 + y * a10 + a20;
            e[7] = x * a01 + y * a11 + a21;
            e[8] = x * a02 + y * a12 + a22;
        }
        rotate(rad, out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var s = Math.sin(rad);
            var c = Math.cos(rad);
            e[0] = c * a00 + s * a10;
            e[1] = c * a01 + s * a11;
            e[2] = c * a02 + s * a12;
            e[3] = c * a10 - s * a00;
            e[4] = c * a11 - s * a01;
            e[5] = c * a12 - s * a02;
            e[6] = a20;
            e[7] = a21;
            e[8] = a22;
        }
        scale(scale, out) {
            var e = out.elements;
            var f = this.elements;
            var x = scale.x, y = scale.y;
            e[0] = x * f[0];
            e[1] = x * f[1];
            e[2] = x * f[2];
            e[3] = y * f[3];
            e[4] = y * f[4];
            e[5] = y * f[5];
            e[6] = f[6];
            e[7] = f[7];
            e[8] = f[8];
        }
        invert(out) {
            var e = out.elements;
            var f = this.elements;
            var a00 = f[0], a01 = f[1], a02 = f[2];
            var a10 = f[3], a11 = f[4], a12 = f[5];
            var a20 = f[6], a21 = f[7], a22 = f[8];
            var b01 = a22 * a11 - a12 * a21;
            var b11 = -a22 * a10 + a12 * a20;
            var b21 = a21 * a10 - a11 * a20;
            var det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return;
            }
            det = 1.0 / det;
            e[0] = b01 * det;
            e[1] = (-a22 * a01 + a02 * a21) * det;
            e[2] = (a12 * a01 - a02 * a11) * det;
            e[3] = b11 * det;
            e[4] = (a22 * a00 - a02 * a20) * det;
            e[5] = (-a12 * a00 + a02 * a10) * det;
            e[6] = b21 * det;
            e[7] = (-a21 * a00 + a01 * a20) * det;
            e[8] = (a11 * a00 - a01 * a10) * det;
        }
        transpose(out) {
            var e = out.elements;
            var f = this.elements;
            if (out === this) {
                var a01 = f[1], a02 = f[2], a12 = f[5];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = a01;
                e[5] = f[7];
                e[6] = a02;
                e[7] = a12;
            }
            else {
                e[0] = f[0];
                e[1] = f[3];
                e[2] = f[6];
                e[3] = f[1];
                e[4] = f[4];
                e[5] = f[7];
                e[6] = f[2];
                e[7] = f[5];
                e[8] = f[8];
            }
        }
        identity() {
            this.elements.set(_DEFAULTELEMENTS);
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            d.set(s);
        }
        clone() {
            var dest = new Matrix3x3(false);
            dest.elements = this.elements.slice();
            return dest;
        }
        static lookAt(eye, target, up, out) {
            Vector3.subtract(eye, target, _tempV30);
            Vector3.normalize(_tempV30, _tempV30);
            Vector3.cross(up, _tempV30, _tempV31);
            Vector3.normalize(_tempV31, _tempV31);
            Vector3.cross(_tempV30, _tempV31, _tempV32);
            var v0 = _tempV30;
            var v1 = _tempV31;
            var v2 = _tempV32;
            var me = out.elements;
            me[0] = v1.x;
            me[3] = v1.y;
            me[6] = v1.z;
            me[1] = v2.x;
            me[4] = v2.y;
            me[7] = v2.z;
            me[2] = v0.x;
            me[5] = v0.y;
            me[8] = v0.z;
        }
        static forwardLookAt(eye, target, up, out) {
            var vx = _tempV31;
            var vy = _tempV32;
            var vz = _tempV30;
            target.vsub(eye, vz).normalize();
            up.cross(vz, vx).normalize();
            vz.cross(vx, vy);
            var m = out.elements;
            m[0] = vx.x;
            m[1] = vx.y;
            m[2] = vx.z;
            m[3] = vy.x;
            m[4] = vy.y;
            m[5] = vy.z;
            m[6] = vz.x;
            m[7] = vz.y;
            m[8] = vz.z;
        }
    }
    Matrix3x3.DEFAULT = new Matrix3x3();
    Matrix3x3.TEMP = new Matrix3x3();
    const _tempV30 = new Vector3();
    const _tempV31 = new Vector3();
    const _tempV32 = new Vector3();

    class Quaternion {
        static createFromYawPitchRoll(yaw, pitch, roll, out) {
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        static multiply(left, right, out) {
            var lx = left.x;
            var ly = left.y;
            var lz = left.z;
            var lw = left.w;
            var rx = right.x;
            var ry = right.y;
            var rz = right.z;
            var rw = right.w;
            var a = (ly * rz - lz * ry);
            var b = (lz * rx - lx * rz);
            var c = (lx * ry - ly * rx);
            var d = (lx * rx + ly * ry + lz * rz);
            out.x = (lx * rw + rx * lw) + a;
            out.y = (ly * rw + ry * lw) + b;
            out.z = (lz * rw + rz * lw) + c;
            out.w = lw * rw - d;
        }
        static rotationAxisAngle(axis, rad, out) {
            const normalAxis = Vector3.TEMP;
            Vector3.normalize(axis, normalAxis);
            rad *= 0.5;
            const s = Math.sin(rad);
            out.x = normalAxis.x * s;
            out.y = normalAxis.y * s;
            out.z = normalAxis.z * s;
            out.w = Math.cos(rad);
        }
        static arcTanAngle(x, y) {
            if (x == 0) {
                if (y == 1)
                    return Math.PI / 2;
                return -Math.PI / 2;
            }
            if (x > 0)
                return Math.atan(y / x);
            if (x < 0) {
                if (y > 0)
                    return Math.atan(y / x) + Math.PI;
                return Math.atan(y / x) - Math.PI;
            }
            return 0;
        }
        static angleTo(from, location, angle) {
            Vector3.subtract(location, from, TEMPVector30);
            Vector3.normalize(TEMPVector30, TEMPVector30);
            angle.x = Math.asin(TEMPVector30.y);
            angle.y = Quaternion.arcTanAngle(-TEMPVector30.z, -TEMPVector30.x);
        }
        static createFromAxisAngle(axis, rad, out) {
            rad = rad * 0.5;
            var s = Math.sin(rad);
            out.x = s * axis.x;
            out.y = s * axis.y;
            out.z = s * axis.z;
            out.w = Math.cos(rad);
        }
        static createFromMatrix4x4(mat, out) {
            var me = mat.elements;
            var sqrt;
            var half;
            var scale = me[0] + me[5] + me[10];
            if (scale > 0.0) {
                sqrt = Math.sqrt(scale + 1.0);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (me[6] - me[9]) * sqrt;
                out.y = (me[8] - me[2]) * sqrt;
                out.z = (me[1] - me[4]) * sqrt;
            }
            else if ((me[0] >= me[5]) && (me[0] >= me[10])) {
                sqrt = Math.sqrt(1.0 + me[0] - me[5] - me[10]);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (me[1] + me[4]) * half;
                out.z = (me[2] + me[8]) * half;
                out.w = (me[6] - me[9]) * half;
            }
            else if (me[5] > me[10]) {
                sqrt = Math.sqrt(1.0 + me[5] - me[0] - me[10]);
                half = 0.5 / sqrt;
                out.x = (me[4] + me[1]) * half;
                out.y = 0.5 * sqrt;
                out.z = (me[9] + me[6]) * half;
                out.w = (me[8] - me[2]) * half;
            }
            else {
                sqrt = Math.sqrt(1.0 + me[10] - me[0] - me[5]);
                half = 0.5 / sqrt;
                out.x = (me[8] + me[2]) * half;
                out.y = (me[9] + me[6]) * half;
                out.z = 0.5 * sqrt;
                out.w = (me[1] - me[4]) * half;
            }
        }
        static slerp(left, right, t, out) {
            var ax = left.x, ay = left.y, az = left.z, aw = left.w, bx = right.x, by = right.y, bz = right.z, bw = right.w;
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out.x = scale0 * ax + scale1 * bx;
            out.y = scale0 * ay + scale1 * by;
            out.z = scale0 * az + scale1 * bz;
            out.w = scale0 * aw + scale1 * bw;
            return out;
        }
        static lerp(left, right, amount, out) {
            var inverse = 1.0 - amount;
            if (Quaternion.dot(left, right) >= 0) {
                out.x = (inverse * left.x) + (amount * right.x);
                out.y = (inverse * left.y) + (amount * right.y);
                out.z = (inverse * left.z) + (amount * right.z);
                out.w = (inverse * left.w) + (amount * right.w);
            }
            else {
                out.x = (inverse * left.x) - (amount * right.x);
                out.y = (inverse * left.y) - (amount * right.y);
                out.z = (inverse * left.z) - (amount * right.z);
                out.w = (inverse * left.w) - (amount * right.w);
            }
            out.normalize(out);
        }
        static add(left, right, out) {
            out.x = left.x + right.x;
            out.y = left.y + right.y;
            out.z = left.z + right.z;
            out.w = left.w + right.w;
        }
        static dot(left, right) {
            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        }
        constructor(x = 0, y = 0, z = 0, w = 1) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        setValue(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        set(x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        }
        scaling(scaling, out) {
            out.x = this.x * scaling;
            out.y = this.y * scaling;
            out.z = this.z * scaling;
            out.w = this.w * scaling;
        }
        normalize(out) {
            var len = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out.x = this.x * len;
                out.y = this.y * len;
                out.z = this.z * len;
                out.w = this.w * len;
            }
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        rotateX(rad, out) {
            rad *= 0.5;
            var bx = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.w * bx;
            out.y = this.y * bw + this.z * bx;
            out.z = this.z * bw - this.y * bx;
            out.w = this.w * bw - this.x * bx;
        }
        rotateY(rad, out) {
            rad *= 0.5;
            var by = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw - this.z * by;
            out.y = this.y * bw + this.w * by;
            out.z = this.z * bw + this.x * by;
            out.w = this.w * bw - this.y * by;
        }
        rotateZ(rad, out) {
            rad *= 0.5;
            var bz = Math.sin(rad), bw = Math.cos(rad);
            out.x = this.x * bw + this.y * bz;
            out.y = this.y * bw - this.x * bz;
            out.z = this.z * bw + this.w * bz;
            out.w = this.w * bw - this.z * bz;
        }
        getYawPitchRoll(out) {
            Vector3.transformQuat(Vector3.ForwardRH, this, TEMPVector31);
            let upe = TEMPVector32;
            let angle = TEMPVector33;
            Vector3.transformQuat(Vector3.Up, this, upe);
            Quaternion.angleTo(Vector3.ZERO, TEMPVector31, angle);
            if (angle.x == Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(upe.z, upe.x);
                angle.z = 0;
            }
            else if (angle.x == -Math.PI / 2) {
                angle.y = Quaternion.arcTanAngle(-upe.z, -upe.x);
                angle.z = 0;
            }
            else {
                Matrix4x4.createRotationY(-angle.y, Matrix4x4.TEMP);
                Vector3.transformCoordinate(upe, Matrix4x4.TEMP, upe);
                Matrix4x4.createRotationX(-angle.x, Matrix4x4.TEMP);
                Vector3.transformCoordinate(upe, Matrix4x4.TEMP, upe);
                angle.z = Quaternion.arcTanAngle(upe.y, -upe.x);
            }
            if (angle.y <= -Math.PI)
                angle.y = Math.PI;
            if (angle.z <= -Math.PI)
                angle.z = Math.PI;
            if (angle.y >= Math.PI && angle.z >= Math.PI) {
                angle.y = 0;
                angle.z = 0;
                angle.x = Math.PI - angle.x;
            }
            var oe = out;
            oe.x = angle.y;
            oe.y = angle.x;
            oe.z = angle.z;
        }
        invert(out) {
            var a0 = this.x, a1 = this.y, a2 = this.z, a3 = this.w;
            var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
            var invDot = dot ? 1.0 / dot : 0;
            out.x = -a0 * invDot;
            out.y = -a1 * invDot;
            out.z = -a2 * invDot;
            out.w = a3 * invDot;
        }
        identity() {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.w = 1;
        }
        fromArray(array, offset = 0) {
            this.x = array[offset + 0];
            this.y = array[offset + 1];
            this.z = array[offset + 2];
            this.w = array[offset + 3];
        }
        cloneTo(destObject) {
            if (this === destObject) {
                return;
            }
            destObject.x = this.x;
            destObject.y = this.y;
            destObject.z = this.z;
            destObject.w = this.w;
        }
        clone() {
            var dest = new Quaternion();
            this.cloneTo(dest);
            return dest;
        }
        equals(b) {
            return MathUtils3D.nearEqual(this.x, b.x) && MathUtils3D.nearEqual(this.y, b.y) && MathUtils3D.nearEqual(this.z, b.z) && MathUtils3D.nearEqual(this.w, b.w);
        }
        static rotationLookAt(forward, up, out) {
            Quaternion.lookAt(Vector3.ZERO, forward, up, out);
        }
        static lookAt(eye, target, up, out) {
            Matrix3x3.lookAt(eye, target, up, Matrix3x3.TEMP);
            Quaternion.rotationMatrix(Matrix3x3.TEMP, out);
        }
        static forwardLookAt(eye, target, up, out) {
            Matrix3x3.forwardLookAt(eye, target, up, Matrix3x3.TEMP);
            Quaternion.rotationMatrix(Matrix3x3.TEMP, out);
        }
        lengthSquared() {
            return (this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w);
        }
        static invert(value, out) {
            var lengthSq = value.lengthSquared();
            if (!MathUtils3D.isZero(lengthSq)) {
                lengthSq = 1.0 / lengthSq;
                out.x = -value.x * lengthSq;
                out.y = -value.y * lengthSq;
                out.z = -value.z * lengthSq;
                out.w = value.w * lengthSq;
            }
        }
        static rotationMatrix(matrix3x3, out) {
            var me = matrix3x3.elements;
            var m11 = me[0];
            var m12 = me[1];
            var m13 = me[2];
            var m21 = me[3];
            var m22 = me[4];
            var m23 = me[5];
            var m31 = me[6];
            var m32 = me[7];
            var m33 = me[8];
            var sqrt, half;
            var scale = m11 + m22 + m33;
            if (scale > 0) {
                sqrt = Math.sqrt(scale + 1);
                out.w = sqrt * 0.5;
                sqrt = 0.5 / sqrt;
                out.x = (m23 - m32) * sqrt;
                out.y = (m31 - m13) * sqrt;
                out.z = (m12 - m21) * sqrt;
            }
            else if ((m11 >= m22) && (m11 >= m33)) {
                sqrt = Math.sqrt(1 + m11 - m22 - m33);
                half = 0.5 / sqrt;
                out.x = 0.5 * sqrt;
                out.y = (m12 + m21) * half;
                out.z = (m13 + m31) * half;
                out.w = (m23 - m32) * half;
            }
            else if (m22 > m33) {
                sqrt = Math.sqrt(1 + m22 - m11 - m33);
                half = 0.5 / sqrt;
                out.x = (m21 + m12) * half;
                out.y = 0.5 * sqrt;
                out.z = (m32 + m23) * half;
                out.w = (m31 - m13) * half;
            }
            else {
                sqrt = Math.sqrt(1 + m33 - m11 - m22);
                half = 0.5 / sqrt;
                out.x = (m31 + m13) * half;
                out.y = (m32 + m23) * half;
                out.z = 0.5 * sqrt;
                out.w = (m12 - m21) * half;
            }
        }
    }
    Quaternion.TEMP = new Quaternion();
    Quaternion.DEFAULT = new Quaternion();
    Quaternion.NAN = new Quaternion(NaN, NaN, NaN, NaN);
    const TEMPVector30 = new Vector3();
    const TEMPVector31 = new Vector3();
    const TEMPVector32 = new Vector3();
    const TEMPVector33 = new Vector3();

    const DEFAULTARRAY = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    class Matrix4x4 {
        static createRotationX(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[7] = oe[8] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[0] = oe[15] = 1;
            oe[5] = oe[10] = c;
            oe[6] = s;
            oe[9] = -s;
        }
        static createRotationY(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[1] = oe[3] = oe[4] = oe[6] = oe[7] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[5] = oe[15] = 1;
            oe[0] = oe[10] = c;
            oe[2] = -s;
            oe[8] = s;
        }
        static createRotationZ(rad, out) {
            var oe = out.elements;
            var s = Math.sin(rad), c = Math.cos(rad);
            oe[2] = oe[3] = oe[6] = oe[7] = oe[8] = oe[9] = oe[11] = oe[12] = oe[13] = oe[14] = 0;
            oe[10] = oe[15] = 1;
            oe[0] = oe[5] = c;
            oe[1] = s;
            oe[4] = -s;
        }
        static createRotationYawPitchRoll(yaw, pitch, roll, result) {
            Quaternion.createFromYawPitchRoll(yaw, pitch, roll, Quaternion.TEMP);
            Matrix4x4.createRotationQuaternion(Quaternion.TEMP, result);
        }
        static createRotationAxis(axis, angle, result) {
            var x = axis.x;
            var y = axis.y;
            var z = axis.z;
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var xx = x * x;
            var yy = y * y;
            var zz = z * z;
            var xy = x * y;
            var xz = x * z;
            var yz = y * z;
            var resultE = result.elements;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = xx + (cos * (1.0 - xx));
            resultE[1] = (xy - (cos * xy)) + (sin * z);
            resultE[2] = (xz - (cos * xz)) - (sin * y);
            resultE[4] = (xy - (cos * xy)) - (sin * z);
            resultE[5] = yy + (cos * (1.0 - yy));
            resultE[6] = (yz - (cos * yz)) + (sin * x);
            resultE[8] = (xz - (cos * xz)) + (sin * y);
            resultE[9] = (yz - (cos * yz)) - (sin * x);
            resultE[10] = zz + (cos * (1.0 - zz));
        }
        static createRotationQuaternion(rotation, result) {
            var resultE = result.elements;
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            resultE[3] = resultE[7] = resultE[11] = resultE[12] = resultE[13] = resultE[14] = 0;
            resultE[15] = 1.0;
            resultE[0] = 1.0 - (2.0 * (yy + zz));
            resultE[1] = 2.0 * (xy + zw);
            resultE[2] = 2.0 * (zx - yw);
            resultE[4] = 2.0 * (xy - zw);
            resultE[5] = 1.0 - (2.0 * (zz + xx));
            resultE[6] = 2.0 * (yz + xw);
            resultE[8] = 2.0 * (zx + yw);
            resultE[9] = 2.0 * (yz - xw);
            resultE[10] = 1.0 - (2.0 * (yy + xx));
        }
        static createTranslate(trans, out) {
            var oe = out.elements;
            oe[4] = oe[8] = oe[1] = oe[9] = oe[2] = oe[6] = oe[3] = oe[7] = oe[11] = 0;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
        }
        static createScaling(scale, out) {
            var oe = out.elements;
            oe[0] = scale.x;
            oe[5] = scale.y;
            oe[10] = scale.z;
            oe[1] = oe[4] = oe[8] = oe[12] = oe[9] = oe[13] = oe[2] = oe[6] = oe[14] = oe[3] = oe[7] = oe[11] = 0;
            oe[15] = 1;
        }
        static multiply(left, right, out) {
            var l = right.elements;
            var r = left.elements;
            var e = out.elements;
            var l11 = l[0], l12 = l[1], l13 = l[2], l14 = l[3];
            var l21 = l[4], l22 = l[5], l23 = l[6], l24 = l[7];
            var l31 = l[8], l32 = l[9], l33 = l[10], l34 = l[11];
            var l41 = l[12], l42 = l[13], l43 = l[14], l44 = l[15];
            var r11 = r[0], r12 = r[1], r13 = r[2], r14 = r[3];
            var r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7];
            var r31 = r[8], r32 = r[9], r33 = r[10], r34 = r[11];
            var r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
            e[0] = (l11 * r11) + (l12 * r21) + (l13 * r31) + (l14 * r41);
            e[1] = (l11 * r12) + (l12 * r22) + (l13 * r32) + (l14 * r42);
            e[2] = (l11 * r13) + (l12 * r23) + (l13 * r33) + (l14 * r43);
            e[3] = (l11 * r14) + (l12 * r24) + (l13 * r34) + (l14 * r44);
            e[4] = (l21 * r11) + (l22 * r21) + (l23 * r31) + (l24 * r41);
            e[5] = (l21 * r12) + (l22 * r22) + (l23 * r32) + (l24 * r42);
            e[6] = (l21 * r13) + (l22 * r23) + (l23 * r33) + (l24 * r43);
            e[7] = (l21 * r14) + (l22 * r24) + (l23 * r34) + (l24 * r44);
            e[8] = (l31 * r11) + (l32 * r21) + (l33 * r31) + (l34 * r41);
            e[9] = (l31 * r12) + (l32 * r22) + (l33 * r32) + (l34 * r42);
            e[10] = (l31 * r13) + (l32 * r23) + (l33 * r33) + (l34 * r43);
            e[11] = (l31 * r14) + (l32 * r24) + (l33 * r34) + (l34 * r44);
            e[12] = (l41 * r11) + (l42 * r21) + (l43 * r31) + (l44 * r41);
            e[13] = (l41 * r12) + (l42 * r22) + (l43 * r32) + (l44 * r42);
            e[14] = (l41 * r13) + (l42 * r23) + (l43 * r33) + (l44 * r43);
            e[15] = (l41 * r14) + (l42 * r24) + (l43 * r34) + (l44 * r44);
        }
        static createFromQuaternion(rotation, out) {
            var e = out.elements;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x;
            var y2 = y + y;
            var z2 = z + z;
            var xx = x * x2;
            var yx = y * x2;
            var yy = y * y2;
            var zx = z * x2;
            var zy = z * y2;
            var zz = z * z2;
            var wx = w * x2;
            var wy = w * y2;
            var wz = w * z2;
            e[0] = 1 - yy - zz;
            e[1] = yx + wz;
            e[2] = zx - wy;
            e[3] = 0;
            e[4] = yx - wz;
            e[5] = 1 - xx - zz;
            e[6] = zy + wx;
            e[7] = 0;
            e[8] = zx + wy;
            e[9] = zy - wx;
            e[10] = 1 - xx - yy;
            e[11] = 0;
            e[12] = 0;
            e[13] = 0;
            e[14] = 0;
            e[15] = 1;
        }
        static createAffineTransformation(trans, rot, scale, out) {
            var oe = out.elements;
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
            oe[0] = (1 - (yy + zz)) * sx;
            oe[1] = (xy + wz) * sx;
            oe[2] = (xz - wy) * sx;
            oe[3] = 0;
            oe[4] = (xy - wz) * sy;
            oe[5] = (1 - (xx + zz)) * sy;
            oe[6] = (yz + wx) * sy;
            oe[7] = 0;
            oe[8] = (xz + wy) * sz;
            oe[9] = (yz - wx) * sz;
            oe[10] = (1 - (xx + yy)) * sz;
            oe[11] = 0;
            oe[12] = trans.x;
            oe[13] = trans.y;
            oe[14] = trans.z;
            oe[15] = 1;
        }
        static createLookAt(eye, target, up, out) {
            var oE = out.elements;
            var xaxis = _tempVector0;
            var yaxis = _tempVector1;
            var zaxis = _tempVector2;
            Vector3.subtract(eye, target, zaxis);
            Vector3.normalize(zaxis, zaxis);
            Vector3.cross(up, zaxis, xaxis);
            Vector3.normalize(xaxis, xaxis);
            Vector3.cross(zaxis, xaxis, yaxis);
            oE[3] = oE[7] = oE[11] = 0;
            oE[15] = 1;
            oE[0] = xaxis.x;
            oE[4] = xaxis.y;
            oE[8] = xaxis.z;
            oE[1] = yaxis.x;
            oE[5] = yaxis.y;
            oE[9] = yaxis.z;
            oE[2] = zaxis.x;
            oE[6] = zaxis.y;
            oE[10] = zaxis.z;
            oE[12] = -Vector3.dot(xaxis, eye);
            oE[13] = -Vector3.dot(yaxis, eye);
            oE[14] = -Vector3.dot(zaxis, eye);
        }
        static createPerspective(fov, aspect, znear, zfar, out) {
            var yScale = 1.0 / Math.tan(fov * 0.5);
            var xScale = yScale / aspect;
            var halfWidth = znear / xScale;
            var halfHeight = znear / yScale;
            Matrix4x4.createPerspectiveOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, znear, zfar, out);
        }
        static createPerspectiveOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = zfar / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[7] = oe[12] = oe[13] = oe[15] = 0;
            oe[0] = 2.0 * znear / (right - left);
            oe[5] = 2.0 * znear / (top - bottom);
            oe[8] = (left + right) / (right - left);
            oe[9] = (top + bottom) / (top - bottom);
            oe[10] = -zRange;
            oe[11] = -1.0;
            oe[14] = -znear * zRange;
        }
        static createOrthoOffCenter(left, right, bottom, top, znear, zfar, out) {
            var oe = out.elements;
            var zRange = 1.0 / (zfar - znear);
            oe[1] = oe[2] = oe[3] = oe[4] = oe[6] = oe[8] = oe[7] = oe[9] = oe[11] = 0;
            oe[15] = 1;
            oe[0] = 2.0 / (right - left);
            oe[5] = 2.0 / (top - bottom);
            oe[10] = -zRange;
            oe[12] = (left + right) / (left - right);
            oe[13] = (top + bottom) / (bottom - top);
            oe[14] = -znear * zRange;
        }
        constructor(m11 = 1, m12 = 0, m13 = 0, m14 = 0, m21 = 0, m22 = 1, m23 = 0, m24 = 0, m31 = 0, m32 = 0, m33 = 1, m34 = 0, m41 = 0, m42 = 0, m43 = 0, m44 = 1, elements = null) {
            if (arguments.length == 0) {
                this.elements = DEFAULTARRAY.slice();
                return;
            }
            if (arguments.length === 1 && arguments[0] === null)
                return;
            var e = elements ? this.elements = elements : this.elements = new Float32Array(16);
            e[0] = m11;
            e[1] = m12;
            e[2] = m13;
            e[3] = m14;
            e[4] = m21;
            e[5] = m22;
            e[6] = m23;
            e[7] = m24;
            e[8] = m31;
            e[9] = m32;
            e[10] = m33;
            e[11] = m34;
            e[12] = m41;
            e[13] = m42;
            e[14] = m43;
            e[15] = m44;
        }
        getElementByRowColumn(row, column) {
            if (row < 0 || row > 3)
                throw new Error("row for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column for matrices run from 0 to 3, inclusive.");
            return this.elements[(row * 4) + column];
        }
        setElementByRowColumn(row, column, value) {
            if (row < 0 || row > 3)
                throw new Error("row for matrices run from 0 to 3, inclusive.");
            if (column < 0 || column > 3)
                throw new Error("column for matrices run from 0 to 3, inclusive.");
            this.elements[(row * 4) + column] = value;
        }
        setRotation(rotation) {
            var rotationX = rotation.x;
            var rotationY = rotation.y;
            var rotationZ = rotation.z;
            var rotationW = rotation.w;
            var xx = rotationX * rotationX;
            var yy = rotationY * rotationY;
            var zz = rotationZ * rotationZ;
            var xy = rotationX * rotationY;
            var zw = rotationZ * rotationW;
            var zx = rotationZ * rotationX;
            var yw = rotationY * rotationW;
            var yz = rotationY * rotationZ;
            var xw = rotationX * rotationW;
            var e = this.elements;
            e[0] = 1.0 - (2.0 * (yy + zz));
            e[1] = 2.0 * (xy + zw);
            e[2] = 2.0 * (zx - yw);
            e[4] = 2.0 * (xy - zw);
            e[5] = 1.0 - (2.0 * (zz + xx));
            e[6] = 2.0 * (yz + xw);
            e[8] = 2.0 * (zx + yw);
            e[9] = 2.0 * (yz - xw);
            e[10] = 1.0 - (2.0 * (yy + xx));
        }
        setPosition(position) {
            var e = this.elements;
            e[12] = position.x;
            e[13] = position.y;
            e[14] = position.z;
        }
        equalsOtherMatrix(other) {
            var e = this.elements;
            var oe = other.elements;
            return (MathUtils3D.nearEqual(e[0], oe[0]) && MathUtils3D.nearEqual(e[1], oe[1]) && MathUtils3D.nearEqual(e[2], oe[2]) && MathUtils3D.nearEqual(e[3], oe[3]) && MathUtils3D.nearEqual(e[4], oe[4]) && MathUtils3D.nearEqual(e[5], oe[5]) && MathUtils3D.nearEqual(e[6], oe[6]) && MathUtils3D.nearEqual(e[7], oe[7]) && MathUtils3D.nearEqual(e[8], oe[8]) && MathUtils3D.nearEqual(e[9], oe[9]) && MathUtils3D.nearEqual(e[10], oe[10]) && MathUtils3D.nearEqual(e[11], oe[11]) && MathUtils3D.nearEqual(e[12], oe[12]) && MathUtils3D.nearEqual(e[13], oe[13]) && MathUtils3D.nearEqual(e[14], oe[14]) && MathUtils3D.nearEqual(e[15], oe[15]));
        }
        decomposeTransRotScale(translation, rotation, scale) {
            var rotationMatrix = _tempMatrix$1;
            if (this.decomposeTransRotMatScale(translation, rotationMatrix, scale)) {
                Quaternion.createFromMatrix4x4(rotationMatrix, rotation);
                return true;
            }
            else {
                rotation.identity();
                return false;
            }
        }
        decomposeTransRotMatScale(translation, rotationMatrix, scale) {
            var e = this.elements;
            var te = translation;
            var re = rotationMatrix.elements;
            var se = scale;
            te.x = e[12];
            te.y = e[13];
            te.z = e[14];
            var m11 = e[0], m12 = e[1], m13 = e[2];
            var m21 = e[4], m22 = e[5], m23 = e[6];
            var m31 = e[8], m32 = e[9], m33 = e[10];
            var sX = se.x = Math.sqrt((m11 * m11) + (m12 * m12) + (m13 * m13));
            var sY = se.y = Math.sqrt((m21 * m21) + (m22 * m22) + (m23 * m23));
            var sZ = se.z = Math.sqrt((m31 * m31) + (m32 * m32) + (m33 * m33));
            if (MathUtils3D.isZero(sX) || MathUtils3D.isZero(sY) || MathUtils3D.isZero(sZ)) {
                re[1] = re[2] = re[3] = re[4] = re[6] = re[7] = re[8] = re[9] = re[11] = re[12] = re[13] = re[14] = 0;
                re[0] = re[5] = re[10] = re[15] = 1;
                return false;
            }
            var at = _tempVector0;
            at.x = m31 / sZ;
            at.y = m32 / sZ;
            at.z = m33 / sZ;
            var tempRight = _tempVector1;
            tempRight.x = m11 / sX;
            tempRight.y = m12 / sX;
            tempRight.z = m13 / sX;
            var up = _tempVector2;
            Vector3.cross(at, tempRight, up);
            var right = _tempVector1;
            Vector3.cross(up, at, right);
            re[3] = re[7] = re[11] = re[12] = re[13] = re[14] = 0;
            re[15] = 1;
            re[0] = right.x;
            re[1] = right.y;
            re[2] = right.z;
            re[4] = up.x;
            re[5] = up.y;
            re[6] = up.z;
            re[8] = at.x;
            re[9] = at.y;
            re[10] = at.z;
            ((re[0] * m11 + re[1] * m12 + re[2] * m13) < 0.0) && (se.x = -sX);
            ((re[4] * m21 + re[5] * m22 + re[6] * m23) < 0.0) && (se.y = -sY);
            ((re[8] * m31 + re[9] * m32 + re[10] * m33) < 0.0) && (se.z = -sZ);
            return true;
        }
        decomposeYawPitchRoll(yawPitchRoll) {
            var pitch = Math.asin(-this.elements[9]);
            yawPitchRoll.y = pitch;
            var test = Math.cos(pitch);
            if (test > MathUtils3D.zeroTolerance) {
                yawPitchRoll.z = Math.atan2(this.elements[1], this.elements[5]);
                yawPitchRoll.x = Math.atan2(this.elements[8], this.elements[10]);
            }
            else {
                yawPitchRoll.z = Math.atan2(-this.elements[4], this.elements[0]);
                yawPitchRoll.x = 0.0;
            }
        }
        normalize() {
            var v = this.elements;
            var c = v[0], d = v[1], e = v[2], g = Math.sqrt(c * c + d * d + e * e);
            if (g) {
                if (g == 1)
                    return;
            }
            else {
                v[0] = 0;
                v[1] = 0;
                v[2] = 0;
                return;
            }
            g = 1 / g;
            v[0] = c * g;
            v[1] = d * g;
            v[2] = e * g;
        }
        transpose() {
            var e, t;
            e = this.elements;
            t = e[1];
            e[1] = e[4];
            e[4] = t;
            t = e[2];
            e[2] = e[8];
            e[8] = t;
            t = e[3];
            e[3] = e[12];
            e[12] = t;
            t = e[6];
            e[6] = e[9];
            e[9] = t;
            t = e[7];
            e[7] = e[13];
            e[13] = t;
            t = e[11];
            e[11] = e[14];
            e[14] = t;
            return this;
        }
        invert(out) {
            var ae = this.elements;
            var oe = out.elements;
            var a00 = ae[0], a01 = ae[1], a02 = ae[2], a03 = ae[3], a10 = ae[4], a11 = ae[5], a12 = ae[6], a13 = ae[7], a20 = ae[8], a21 = ae[9], a22 = ae[10], a23 = ae[11], a30 = ae[12], a31 = ae[13], a32 = ae[14], a33 = ae[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (Math.abs(det) === 0.0) {
                return;
            }
            det = 1.0 / det;
            oe[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            oe[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            oe[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            oe[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            oe[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            oe[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            oe[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            oe[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            oe[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            oe[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            oe[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            oe[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            oe[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            oe[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            oe[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            oe[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
        }
        static billboard(objectPosition, cameraPosition, cameraUp, cameraForward, mat) {
            Vector3.subtract(objectPosition, cameraPosition, _tempVector0);
            var lengthSq = Vector3.scalarLengthSquared(_tempVector0);
            if (MathUtils3D.isZero(lengthSq)) {
                Vector3.scale(cameraForward, -1, _tempVector1);
                _tempVector1.cloneTo(_tempVector0);
            }
            else {
                Vector3.scale(_tempVector0, 1 / Math.sqrt(lengthSq), _tempVector0);
            }
            Vector3.cross(cameraUp, _tempVector0, _tempVector2);
            Vector3.normalize(_tempVector2, _tempVector2);
            Vector3.cross(_tempVector0, _tempVector2, _tempVector3);
            var crosse = _tempVector2;
            var finale = _tempVector3;
            var diffee = _tempVector0;
            var obpose = objectPosition;
            var mate = mat.elements;
            mate[0] = crosse.x;
            mate[1] = crosse.y;
            mate[2] = crosse.z;
            mate[3] = 0.0;
            mate[4] = finale.x;
            mate[5] = finale.y;
            mate[6] = finale.z;
            mate[7] = 0.0;
            mate[8] = diffee.x;
            mate[9] = diffee.y;
            mate[10] = diffee.z;
            mate[11] = 0.0;
            mate[12] = obpose.x;
            mate[13] = obpose.y;
            mate[14] = obpose.z;
            mate[15] = 1.0;
        }
        identity() {
            this.elements.set(DEFAULTARRAY);
        }
        isIdentity() {
            let delty = function (num0, num1) {
                return Math.abs(num0 - num1) < 1e-7;
            };
            let e = this.elements;
            let defined = Matrix4x4.DEFAULT.elements;
            for (let i = 0, n = e.length; i < n; i++) {
                if (!delty(e[i], defined[i]))
                    return false;
            }
            return true;
        }
        cloneTo(destObject) {
            var s, d;
            s = this.elements;
            d = destObject.elements;
            if (s === d) {
                return;
            }
            destObject.elements.set(this.elements);
        }
        cloneByArray(destObject) {
            this.elements.set(destObject);
        }
        clone() {
            var dest = new Matrix4x4(null);
            dest.elements = this.elements.slice();
            return dest;
        }
        static translation(v3, out) {
            var oe = out.elements;
            oe[0] = oe[5] = oe[10] = oe[15] = 1;
            oe[12] = v3.x;
            oe[13] = v3.y;
            oe[14] = v3.z;
        }
        getTranslationVector(out) {
            var me = this.elements;
            out.x = me[12];
            out.y = me[13];
            out.z = me[14];
        }
        setTranslationVector(translate) {
            var me = this.elements;
            var ve = translate;
            me[12] = ve.x;
            me[13] = ve.y;
            me[14] = ve.z;
        }
        getForward(out) {
            var me = this.elements;
            out.x = -me[8];
            out.y = -me[9];
            out.z = -me[10];
        }
        setForward(forward) {
            var me = this.elements;
            me[8] = -forward.x;
            me[9] = -forward.y;
            me[10] = -forward.z;
        }
        getInvertFront() {
            this.decomposeTransRotScale(_tempVector0, Quaternion.TEMP, _tempVector1);
            var scale = _tempVector1;
            var isInvert = scale.x < 0;
            (scale.y < 0) && (isInvert = !isInvert);
            (scale.z < 0) && (isInvert = !isInvert);
            return isInvert;
        }
    }
    Matrix4x4.TEMP = new Matrix4x4();
    Matrix4x4.DEFAULT = new Matrix4x4();
    Matrix4x4.DEFAULTINVERT = new Matrix4x4(-1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    Matrix4x4.ZERO = new Matrix4x4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const _tempVector0 = new Vector3();
    const _tempVector1 = new Vector3();
    const _tempVector2 = new Vector3();
    const _tempVector3 = new Vector3();
    const _tempMatrix$1 = new Matrix4x4();

    exports.ShaderDataType = void 0;
    (function (ShaderDataType) {
        ShaderDataType[ShaderDataType["None"] = 0] = "None";
        ShaderDataType[ShaderDataType["Int"] = 1] = "Int";
        ShaderDataType[ShaderDataType["Bool"] = 2] = "Bool";
        ShaderDataType[ShaderDataType["Float"] = 3] = "Float";
        ShaderDataType[ShaderDataType["Vector2"] = 4] = "Vector2";
        ShaderDataType[ShaderDataType["Vector3"] = 5] = "Vector3";
        ShaderDataType[ShaderDataType["Vector4"] = 6] = "Vector4";
        ShaderDataType[ShaderDataType["Color"] = 7] = "Color";
        ShaderDataType[ShaderDataType["Matrix4x4"] = 8] = "Matrix4x4";
        ShaderDataType[ShaderDataType["Texture2D"] = 9] = "Texture2D";
        ShaderDataType[ShaderDataType["Texture3D"] = 10] = "Texture3D";
        ShaderDataType[ShaderDataType["TextureCube"] = 11] = "TextureCube";
        ShaderDataType[ShaderDataType["Buffer"] = 12] = "Buffer";
        ShaderDataType[ShaderDataType["Matrix3x3"] = 13] = "Matrix3x3";
        ShaderDataType[ShaderDataType["Texture2DArray"] = 14] = "Texture2DArray";
    })(exports.ShaderDataType || (exports.ShaderDataType = {}));
    function checkShaderDataValueLegal(value, shaderType) {
        let legal = false;
        switch (shaderType) {
            case exports.ShaderDataType.Int:
            case exports.ShaderDataType.Float:
                legal = typeof value == "number";
                break;
            case exports.ShaderDataType.Bool:
                legal = typeof value == "boolean";
                break;
            case exports.ShaderDataType.Vector2:
                legal = value instanceof Vector2;
                break;
            case exports.ShaderDataType.Vector3:
                legal = value instanceof Vector3;
                break;
            case exports.ShaderDataType.Vector4:
                legal = value instanceof Vector4;
                break;
            case exports.ShaderDataType.Color:
                legal = value instanceof Color;
                break;
            case exports.ShaderDataType.Matrix4x4:
                legal = value instanceof Matrix4x4;
                break;
            case exports.ShaderDataType.Texture2D:
                legal = value instanceof BaseTexture;
                break;
            case exports.ShaderDataType.TextureCube:
                legal = value instanceof BaseTexture;
                break;
            case exports.ShaderDataType.Buffer:
                legal = value instanceof ArrayBuffer;
                break;
            case exports.ShaderDataType.Matrix3x3:
                legal = value instanceof Matrix3x3;
                break;
            default:
                legal = false;
                break;
        }
        if (!legal)
            console.warn("The setting value and Shader type do not match");
        return legal;
    }
    function ShaderDataDefaultValue(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return 0;
            case exports.ShaderDataType.Bool:
                return false;
            case exports.ShaderDataType.Float:
                return 0;
            case exports.ShaderDataType.Vector2:
                return Vector2.ZERO;
            case exports.ShaderDataType.Vector3:
                return Vector3.ZERO;
            case exports.ShaderDataType.Vector4:
                return Vector4.ZERO;
            case exports.ShaderDataType.Color:
                return Color.BLACK;
            case exports.ShaderDataType.Matrix4x4:
                return Matrix4x4.DEFAULT;
            case exports.ShaderDataType.Matrix3x3:
                return Matrix3x3.DEFAULT;
        }
        return null;
    }
    class ShaderData {
        constructor(ownerResource = null) {
            this._ownerResource = ownerResource;
        }
        getDefineData() {
            throw new NotImplementedError();
        }
        getData() {
            throw new NotImplementedError();
        }
        addDefine(define) {
            throw new NotImplementedError();
        }
        addDefines(define) {
            throw new NotImplementedError();
        }
        removeDefine(define) {
            throw new NotImplementedError();
        }
        hasDefine(define) {
            throw new NotImplementedError();
        }
        clearDefine() {
            throw new NotImplementedError();
        }
        clearData() {
            throw new NotImplementedError();
        }
        getBool(index) {
            throw new NotImplementedError();
        }
        setBool(index, value) {
            throw new NotImplementedError();
        }
        getInt(index) {
            throw new NotImplementedError();
        }
        setInt(index, value) {
            throw new NotImplementedError();
        }
        getNumber(index) {
            throw new NotImplementedError();
        }
        setNumber(index, value) {
            throw new NotImplementedError();
        }
        getVector2(index) {
            throw new NotImplementedError();
        }
        setVector2(index, value) {
            throw new NotImplementedError();
        }
        getVector3(index) {
            throw new NotImplementedError();
        }
        setVector3(index, value) {
            throw new NotImplementedError();
        }
        getVector(index) {
            throw new NotImplementedError();
        }
        setVector(index, value) {
            throw new NotImplementedError();
        }
        getColor(index) {
            throw new NotImplementedError();
        }
        setColor(index, value) {
            throw new NotImplementedError();
        }
        getMatrix4x4(index) {
            throw new NotImplementedError();
        }
        setMatrix4x4(index, value) {
            throw new NotImplementedError();
        }
        getMatrix3x3(index) {
            throw new NotImplementedError();
        }
        setMatrix3x3(index, value) {
            throw new NotImplementedError();
        }
        getBuffer(index) {
            throw new NotImplementedError();
        }
        setBuffer(index, value) {
            throw new NotImplementedError();
        }
        setTexture(index, value) {
            throw new NotImplementedError();
        }
        getTexture(index) {
            throw new NotImplementedError();
        }
        setShaderData(uniformIndex, type, value) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    this.setInt(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Bool:
                    this.setBool(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Float:
                    this.setNumber(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector2:
                    this.setVector2(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector3:
                    this.setVector3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector4:
                    this.setVector(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Color:
                    this.setColor(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix4x4:
                    this.setMatrix4x4(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix3x3:
                    this.setMatrix3x3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    this.setTexture(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Buffer:
                    this.setBuffer(uniformIndex, value);
                    break;
                default:
                    throw new Error(`unknown shader data type: ${type}`);
            }
        }
        getShaderData(uniformIndex, type) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    return this.getInt(uniformIndex);
                case exports.ShaderDataType.Bool:
                    return this.getBool(uniformIndex);
                case exports.ShaderDataType.Float:
                    return this.getNumber(uniformIndex);
                case exports.ShaderDataType.Vector2:
                    return this.getVector2(uniformIndex);
                case exports.ShaderDataType.Vector3:
                    return this.getVector3(uniformIndex);
                case exports.ShaderDataType.Vector4:
                    return this.getVector(uniformIndex);
                case exports.ShaderDataType.Color:
                    return this.getColor(uniformIndex);
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    return this.getTexture(uniformIndex);
                case exports.ShaderDataType.Buffer:
                    return this.getBuffer(uniformIndex);
                case exports.ShaderDataType.Matrix3x3:
                    return this.getMatrix3x3(uniformIndex);
                case exports.ShaderDataType.Matrix4x4:
                    return this.getMatrix4x4(uniformIndex);
                default:
                    throw "unknown shader data type.";
            }
        }
        _setInternalTexture(index, value) {
            throw new NotImplementedError();
        }
        cloneTo(destObject) {
            throw new NotImplementedError();
        }
        clone() {
            throw new NotImplementedError();
        }
        destroy() {
            throw new NotImplementedError();
        }
    }

    class ShaderCompileDefineBase {
        constructor(owner, name, compiledObj) {
            this._owner = owner;
            this.name = name;
            this._VS = compiledObj.vsNode;
            this._PS = compiledObj.psNode;
            this._defs = compiledObj.defs;
            this._validDefine = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            for (let k of compiledObj.defs)
                this._validDefine.add(Shader3D.getDefineByName(k));
        }
        withCompile(compileDefine) {
            return null;
        }
    }

    class ShaderVariant {
        get shader() {
            return this._shader;
        }
        get subShaderIndex() {
            return this._subShaderIndex;
        }
        get passIndex() {
            return this._passIndex;
        }
        get defineNames() {
            return this._defineNames;
        }
        constructor(shader, subShaderIndex, passIndex, defines) {
            this._subShaderIndex = 0;
            this._passIndex = 0;
            this.setValue(shader, subShaderIndex, passIndex, defines);
        }
        setValue(shader, subShaderIndex, passIndex, defineNames) {
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        var validDefine = pass._validDefine;
                        for (var i = 0, n = defineNames.length; i < n; i++) {
                            var defname = defineNames[i];
                            if (!validDefine.has(Shader3D.getDefineByName(defname)))
                                throw `ShaderVariantInfo:Invalid defineName ${defname} in ${shader._name} subShaderIndex of ${subShaderIndex} passIndex of ${passIndex}.`;
                        }
                    }
                    else {
                        throw `ShaderVariantInfo:Shader don't have passIndex of ${passIndex}.`;
                    }
                }
                else {
                    throw `ShaderVariantInfo:Shader don't have subShaderIndex of ${subShaderIndex}.`;
                }
            }
            else {
                throw `ShaderVariantInfo:Shader can't be null.`;
            }
            this._shader = shader;
            this._subShaderIndex = subShaderIndex;
            this._passIndex = passIndex;
            this._defineNames = defineNames;
        }
        equal(other) {
            if (this._shader !== other._shader || this._subShaderIndex !== other._subShaderIndex || this._passIndex !== other._passIndex)
                return false;
            var defines = this._defineNames;
            var otherDefines = other._defineNames;
            if (defines.length !== otherDefines.length)
                return false;
            for (var i = 0, n = this._defineNames.length; i < n; i++) {
                if (defines[i] !== otherDefines[i])
                    return false;
            }
            return true;
        }
        clone() {
            var dest = new ShaderVariant(this._shader, this._subShaderIndex, this._passIndex, this._defineNames.slice());
            return dest;
        }
    }
    class ShaderVariantCollection {
        constructor(items) {
            this.items = items || {};
        }
        add(shaderPass, defines) {
            var _a;
            let shader = shaderPass._owner._owner;
            let subShaderIndex = shader._subShaders.indexOf(shaderPass._owner);
            let passIndex = shaderPass._owner._passes.indexOf(shaderPass);
            let nodeCommonMap = shaderPass.nodeCommonMap;
            let additionMap = (_a = shaderPass.additionShaderData) !== null && _a !== void 0 ? _a : [];
            if (!nodeCommonMap)
                return;
            defines = defines.filter((v) => !Shader3D._configDefineValues.has(Shader3D.getDefineByName(v)));
            let col = this.items[shader._name];
            if (!col) {
                col = [];
                this.items[shader._name] = col;
            }
            if (col.some(v => {
                return (v.subShaderIndex === subShaderIndex &&
                    v.passIndex === passIndex &&
                    v.defines.length === defines.length &&
                    v.defines.every((name, index) => name === defines[index]) &&
                    v.nodeCommonMap.length === nodeCommonMap.length &&
                    v.nodeCommonMap.every((name, index) => name === nodeCommonMap[index]) &&
                    v.additionMap.length === additionMap.length &&
                    v.additionMap.every((name, index) => name === additionMap[index]));
            }))
                return;
            col.push({
                subShaderIndex: subShaderIndex,
                passIndex: passIndex,
                defines: defines,
                nodeCommonMap: nodeCommonMap.concat(),
                additionMap: additionMap.concat()
            });
            console.debug(`Shader variant: ${shader._name}/${subShaderIndex}/${passIndex}/${defines.join(",")}/${nodeCommonMap ? nodeCommonMap.join(",") : ""}/${additionMap ? additionMap.join(",") : ""}`);
        }
        compileAll() {
            let items = this.items;
            for (let shaderName in items) {
                let variants = items[shaderName];
                for (let variant of variants) {
                    let suc = Shader3D.compileShaderByDefineNames(shaderName, variant.subShaderIndex, variant.passIndex, variant.defines, variant.nodeCommonMap, variant.additionMap);
                    let msg = `${shaderName}/${variant.subShaderIndex}/${variant.passIndex}/${variant.defines.join(",")}/${variant.nodeCommonMap ? variant.nodeCommonMap.join(",") : ""}/${variant.additionMap ? variant.additionMap.join(",") : ""}`;
                    if (suc)
                        console.debug("Warm up", msg);
                    else
                        console.warn("Warm up failed!", msg);
                }
            }
        }
    }
    ShaderVariantCollection.active = new ShaderVariantCollection();

    class ShaderPass extends ShaderCompileDefineBase {
        get pipelineMode() {
            return this._pipelineMode;
        }
        set pipelineMode(value) {
            this._pipelineMode = value;
            this.moduleData.pipelineMode = value;
        }
        set nodeCommonMap(value) {
            this._nodeUniformCommonMap = value;
            this.moduleData.nodeCommonMap = value;
        }
        get nodeCommonMap() {
            return this._nodeUniformCommonMap;
        }
        set additionShaderData(value) {
            this.moduleData.additionShaderData = value;
        }
        get additionShaderData() {
            return this.moduleData.additionShaderData;
        }
        get statefirst() {
            return this._statefirst;
        }
        set statefirst(value) {
            this._statefirst = value;
            this.moduleData.statefirst = value;
        }
        get renderState() {
            return this.moduleData.renderState;
        }
        constructor(owner, compiledObj) {
            super(owner, null, compiledObj);
            this._statefirst = false;
            this.moduleData = LayaGL.unitRenderModuleDataFactory.createShaderPass(this);
            this.moduleData.validDefine = this._validDefine;
        }
        static createShaderInstance(shaderpass, is2D, compileDefine) {
            _defineStrings.length = 0;
            Shader3D._getNamesByDefineData(compileDefine, _defineStrings);
            let shaderProcessInfo = {
                is2D,
                vs: shaderpass._VS,
                ps: shaderpass._PS,
                attributeMap: shaderpass._owner._attributeMap,
                uniformMap: shaderpass._owner._uniformMap,
                defineString: _defineStrings,
            };
            if (Shader3D.debugMode)
                ShaderVariantCollection.active.add(shaderpass, _defineStrings);
            let shader = LayaGL.renderDeviceFactory.createShaderInstance(shaderProcessInfo, shaderpass);
            return shader;
        }
        withCompile(compileDefine, is2D = false) {
            var shader = this.moduleData.getCacheShader(compileDefine);
            if (shader)
                return shader;
            shader = ShaderPass.createShaderInstance(this, is2D, compileDefine);
            this.moduleData.setCacheShader(compileDefine, shader);
            return shader;
        }
        withComplieByBin(compileDefine, is2D = false, buffer) {
            var shader = this.moduleData.getCacheShader(compileDefine);
            if (shader)
                return shader;
            this.moduleData.setCacheShader(compileDefine, shader);
            return null;
        }
    }
    const _defineStrings = [];

    class VertexMesh {
        static __init__() {
            VertexMesh.instanceWorldMatrixDeclaration = new VertexDeclaration(80, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW0),
                new VertexElement(16, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW1),
                new VertexElement(32, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW2),
                new VertexElement(48, VertexElementFormat.Vector4, VertexMesh.MESH_WORLDMATRIX_ROW3),
                new VertexElement(64, VertexElementFormat.Vector4, VertexMesh.MESH_CUSTOME2),
            ]);
            VertexMesh.instanceSimpleAnimatorDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_SIMPLEANIMATOR)]);
            VertexMesh.instanceLightMapScaleOffsetDeclaration = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, VertexMesh.MESH_LIGHTMAPSCALEOFFSET)]);
        }
        static getVertexDeclaration(vertexFlag, compatible = true) {
            var verDec = VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
            if (!verDec) {
                var subFlags = vertexFlag.split(",");
                var offset = 0;
                var elements = [];
                for (var i = 0, n = subFlags.length; i < n; i++) {
                    var element;
                    switch (subFlags[i]) {
                        case "POSITION":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                            offset += 12;
                            break;
                        case "NORMAL":
                            element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_NORMAL0);
                            offset += 12;
                            break;
                        case "COLOR":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                            offset += 16;
                            break;
                        case "UV":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                            offset += 8;
                            break;
                        case "UV1":
                            element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE1);
                            offset += 8;
                            break;
                        case "BLENDWEIGHT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                            offset += 16;
                            break;
                        case "BLENDINDICES":
                            if (compatible) {
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 16;
                            }
                            else {
                                element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                offset += 4;
                            }
                            break;
                        case "TANGENT":
                            element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_TANGENT0);
                            offset += 16;
                            break;
                        case "NORMAL_BYTE":
                            element = new VertexElement(offset, VertexElementFormat.NorByte4, VertexMesh.MESH_NORMAL0);
                            offset += 4;
                            break;
                        default:
                            throw "VertexMesh: unknown vertex flag.";
                    }
                    elements.push(element);
                }
                verDec = new VertexDeclaration(offset, elements);
                VertexMesh._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
            }
            return verDec;
        }
    }
    VertexMesh.MESH_POSITION0 = 0;
    VertexMesh.MESH_COLOR0 = 1;
    VertexMesh.MESH_TEXTURECOORDINATE0 = 2;
    VertexMesh.MESH_NORMAL0 = 3;
    VertexMesh.MESH_TANGENT0 = 4;
    VertexMesh.MESH_BLENDINDICES0 = 5;
    VertexMesh.MESH_BLENDWEIGHT0 = 6;
    VertexMesh.MESH_TEXTURECOORDINATE1 = 7;
    VertexMesh.MESH_WORLDMATRIX_ROW0 = 8;
    VertexMesh.MESH_WORLDMATRIX_ROW1 = 9;
    VertexMesh.MESH_WORLDMATRIX_ROW2 = 10;
    VertexMesh.MESH_WORLDMATRIX_ROW3 = 11;
    VertexMesh.MESH_SIMPLEANIMATOR = 12;
    VertexMesh.MESH_LIGHTMAPSCALEOFFSET = 13;
    VertexMesh.MESH_CUSTOME0 = 12;
    VertexMesh.MESH_CUSTOME1 = 13;
    VertexMesh.MESH_CUSTOME2 = 14;
    VertexMesh.MESH_CUSTOME3 = 15;
    VertexMesh._vertexDeclarationMap = {};

    class SubShader {
        static regIncludeBindUnifrom(includeName, uniformMap, defaultValue) {
            let obj = {};
            let data = obj[includeName] = {};
            data["uniformMap"] = uniformMap;
            data["defaultValue"] = defaultValue;
            Object.assign(SubShader.IncludeUniformMap, obj);
        }
        constructor(attributeMap = SubShader.DefaultAttributeMap, uniformMap = {}, uniformDefaultValue = null) {
            this._flags = {};
            this._passes = [];
            this.moduleData = LayaGL.unitRenderModuleDataFactory.createSubShader();
            this._attributeMap = attributeMap;
            this._uniformDefaultValue = uniformDefaultValue;
            this._uniformMap = new Map();
            for (const key in uniformMap) {
                if (typeof uniformMap[key] == "object") {
                    let block = (uniformMap[key]);
                    for (const uniformName in block) {
                        let uniformType = block[uniformName];
                        this.addUniform(uniformName, uniformType);
                    }
                }
                else {
                    let unifromType = uniformMap[key];
                    this.addUniform(key, unifromType);
                    if (unifromType == exports.ShaderDataType.Texture2D || unifromType == exports.ShaderDataType.TextureCube || unifromType == exports.ShaderDataType.Texture3D || unifromType == exports.ShaderDataType.Texture2DArray) {
                        let textureGammaDefine = Shader3D.getDefineByName(`Gamma_${key}`);
                        let uniformIndex = Shader3D.propertyNameToID(key);
                        LayaGL.renderEngine.addTexGammaDefine(uniformIndex, textureGammaDefine);
                    }
                }
            }
            this.moduleData.setUniformMap(this._uniformMap);
        }
        addUniform(name, type) {
            let uniformName = name;
            let arrayLength = getArrayLength(name);
            if (arrayLength > 0) {
                uniformName = name.substring(0, name.lastIndexOf('['));
            }
            let uniform = {
                id: Shader3D.propertyNameToID(uniformName),
                propertyName: name,
                uniformtype: type,
                arrayLength: arrayLength
            };
            this._uniformMap.set(uniform.id, uniform);
            if (type == exports.ShaderDataType.Texture2D || type == exports.ShaderDataType.TextureCube || type == exports.ShaderDataType.Texture3D || type == exports.ShaderDataType.Texture2DArray) {
                let textureGammaDefine = Shader3D.getDefineByName(`Gamma_${name}`);
                LayaGL.renderEngine.addTexGammaDefine(uniform.id, textureGammaDefine);
            }
        }
        addShaderPass(vs, ps, pipelineMode = "Forward") {
            return this._addShaderPass(ShaderCompile.compile(vs, ps), pipelineMode);
        }
        _addShaderPass(compiledObj, pipelineMode = "Forward") {
            var shaderPass = new ShaderPass(this, compiledObj);
            shaderPass.pipelineMode = pipelineMode;
            this._passes.push(shaderPass);
            this.moduleData.addShaderPass(shaderPass.moduleData);
            this._addIncludeUniform(compiledObj.includeNames);
            return shaderPass;
        }
        _addIncludeUniform(includemap) {
            for (let ele of includemap) {
                if (SubShader.IncludeUniformMap[ele]) {
                    let includeBindInfo = SubShader.IncludeUniformMap[ele];
                    let bindtypeMap = includeBindInfo["uniformMap"];
                    let bindDefaultValue = includeBindInfo["defaultValue"];
                    for (var i in bindtypeMap) {
                        if (!this._uniformMap.has(Shader3D.propertyNameToID(i))) {
                            this.addUniform(i, bindtypeMap[i]);
                        }
                    }
                    for (var i in bindDefaultValue) {
                        if (!this._uniformDefaultValue[i]) {
                            this._uniformDefaultValue[i] = bindDefaultValue[i];
                        }
                    }
                }
            }
        }
    }
    SubShader.IncludeUniformMap = {};
    SubShader.DefaultAttributeMap = {
        'a_Position': [VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4],
        'a_Normal': [VertexMesh.MESH_NORMAL0, exports.ShaderDataType.Vector3],
        'a_Tangent0': [VertexMesh.MESH_TANGENT0, exports.ShaderDataType.Vector4],
        'a_Texcoord0': [VertexMesh.MESH_TEXTURECOORDINATE0, exports.ShaderDataType.Vector2],
        'a_Texcoord1': [VertexMesh.MESH_TEXTURECOORDINATE1, exports.ShaderDataType.Vector2],
        'a_Color': [VertexMesh.MESH_COLOR0, exports.ShaderDataType.Vector4],
        'a_BoneWeights': [VertexMesh.MESH_BLENDWEIGHT0, exports.ShaderDataType.Vector4],
        'a_BoneIndices': [VertexMesh.MESH_BLENDINDICES0, exports.ShaderDataType.Vector4],
        'a_WorldMat': [VertexMesh.MESH_WORLDMATRIX_ROW0, exports.ShaderDataType.Matrix4x4],
        'a_SimpleTextureParams': [VertexMesh.MESH_SIMPLEANIMATOR, exports.ShaderDataType.Vector4],
        'a_LightmapScaleOffset': [VertexMesh.MESH_LIGHTMAPSCALEOFFSET, exports.ShaderDataType.Vector4],
        "a_WorldInvertFront": [VertexMesh.MESH_CUSTOME2, exports.ShaderDataType.Vector4],
    };
    function getArrayLength(name) {
        let endPos = name.lastIndexOf(']');
        let startPos = name.lastIndexOf('[');
        if (startPos != -1 && endPos == name.length - 1) {
            let arrayLengthStr = name.slice(startPos + 1, endPos);
            let arrayLength = parseInt(arrayLengthStr);
            if (!isNaN(arrayLength) && arrayLength > 0) {
                return arrayLength;
            }
        }
        return 0;
    }

    exports.ShaderFeatureType = void 0;
    (function (ShaderFeatureType) {
        ShaderFeatureType[ShaderFeatureType["DEFAULT"] = 0] = "DEFAULT";
        ShaderFeatureType[ShaderFeatureType["D3"] = 1] = "D3";
        ShaderFeatureType[ShaderFeatureType["D2_primitive"] = 2] = "D2_primitive";
        ShaderFeatureType[ShaderFeatureType["D2_TextureSV"] = 3] = "D2_TextureSV";
        ShaderFeatureType[ShaderFeatureType["D2_BaseRednerNode2D"] = 4] = "D2_BaseRednerNode2D";
        ShaderFeatureType[ShaderFeatureType["PostProcess"] = 5] = "PostProcess";
        ShaderFeatureType[ShaderFeatureType["Sky"] = 6] = "Sky";
        ShaderFeatureType[ShaderFeatureType["Effect"] = 7] = "Effect";
    })(exports.ShaderFeatureType || (exports.ShaderFeatureType = {}));
    class Shader3D {
        static init() {
            Shader3D._configDefineValues = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            Shader3D.SHADERDEFINE_REMAP_POSITIONZ = Shader3D.getDefineByName("REMAP_Z");
            Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE = Shader3D.getDefineByName("LOD_TEXTURE_SAMPLE");
            Shader3D.SHADERDEFINE_BREAK_TEXTURE_SAMPLE = Shader3D.getDefineByName("BREAK_TEXTURE_SAMPLE");
            if (LayaGL.renderEngine._remapZ)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_REMAP_POSITIONZ);
            if (LayaGL.renderEngine._lodTextureSample)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE);
            if (LayaGL.renderEngine._breakTextureSample)
                Shader3D._configDefineValues.add(Shader3D.SHADERDEFINE_BREAK_TEXTURE_SAMPLE);
            Shader3D._compileDefineDatas = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
        }
        static _getNamesByDefineData(defineData, out) {
            LayaGL.renderEngine.getNamesByDefineData(defineData, out);
            return out;
        }
        static getDefineByName(name) {
            return LayaGL.renderEngine.getDefineByName(name);
        }
        static propertyNameToID(name) {
            return LayaGL.renderEngine.propertyNameToID(name);
        }
        static propertyIDToName(id) {
            return LayaGL.renderEngine.propertyIDToName(id);
        }
        static addInclude(fileName, txt) {
            ShaderCompile.addInclude(fileName, txt);
        }
        static compileShaderByDefineNames(shaderName, subShaderIndex, passIndex, defineNames, nodeCommonMap, additionMap) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    if (pass) {
                        pass.nodeCommonMap = nodeCommonMap;
                        pass.additionShaderData = additionMap;
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        Shader3D._configDefineValues.cloneTo(compileDefineDatas);
                        for (let n of defineNames)
                            compileDefineDatas.add(Shader3D.getDefineByName(n));
                        pass.withCompile(compileDefineDatas);
                        return true;
                    }
                }
            }
            return false;
        }
        static compileShaderByBin(shaderName, subShaderIndex, passIndex, defineNames, nodeCommonMap, cacheBuffer) {
            var shader = Shader3D.find(shaderName);
            if (shader) {
                var subShader = shader.getSubShaderAt(subShaderIndex);
                if (subShader) {
                    var pass = subShader._passes[passIndex];
                    pass.nodeCommonMap = nodeCommonMap;
                    if (pass) {
                        var compileDefineDatas = Shader3D._compileDefineDatas;
                        compileDefineDatas.clear();
                        for (let n of defineNames)
                            compileDefineDatas.add(Shader3D.getDefineByName(n));
                        pass.withComplieByBin(compileDefineDatas, false, cacheBuffer);
                    }
                }
            }
        }
        static add(name, enableInstancing = false, supportReflectionProbe = false) {
            return Shader3D._preCompileShader[name] = new Shader3D(name, enableInstancing, supportReflectionProbe);
        }
        static find(name) {
            return Shader3D._preCompileShader[name];
        }
        static parse(data, basePath) {
            var _a;
            if (!data.name)
                console.warn("shader name is empty", data);
            if (!data.uniformMap)
                console.warn(`${data.name}: uniformMap is empty`);
            let shader = Shader3D.add(data.name, data.enableInstancing, data.supportReflectionProbe);
            shader._surportVolumetricGI = data.surportVolumetricGI;
            shader.shaderType = data.shaderType;
            let subshader = new SubShader(data.attributeMap ? data.attributeMap : SubShader.DefaultAttributeMap, data.uniformMap, data.defaultValue);
            shader.addSubShader(subshader);
            let passDataArray = data.shaderPass;
            for (var i in passDataArray) {
                let passData = passDataArray[i];
                if (!passData.VS) {
                    console.warn(`${data.name}: VS of pass ${i} is empty`);
                    continue;
                }
                if (!passData.FS) {
                    console.warn(`${data.name}: FS of pass ${i} is empty`);
                    continue;
                }
                let shaderPass = subshader._addShaderPass(ShaderCompile.compile(passData.VS, passData.FS, basePath), passData.pipeline);
                shaderPass.statefirst = (_a = passData.statefirst) !== null && _a !== void 0 ? _a : false;
                ShaderCompile.getRenderState(passData.renderState, shaderPass.renderState);
            }
            return shader;
        }
        get name() {
            return this._name;
        }
        constructor(name, enableInstancing, supportReflectionProbe) {
            this._enableInstancing = false;
            this._supportReflectionProbe = false;
            this._surportVolumetricGI = false;
            this._subShaders = [];
            this._name = name;
            this._enableInstancing = enableInstancing;
            this._supportReflectionProbe = supportReflectionProbe;
        }
        addSubShader(subShader) {
            this._subShaders.push(subShader);
            subShader._owner = this;
            subShader.moduleData.enableInstance = this._enableInstancing;
            subShader.moduleData.shaderName = this._name;
        }
        getSubShaderAt(index) {
            return this._subShaders[index];
        }
    }
    Shader3D.PERIOD_CUSTOM = 0;
    Shader3D.PERIOD_MATERIAL = 1;
    Shader3D.PERIOD_SPRITE = 2;
    Shader3D.PERIOD_CAMERA = 3;
    Shader3D.PERIOD_SCENE = 4;
    Shader3D._propertyNameMap = {};
    Shader3D._preCompileShader = {};
    Shader3D.debugMode = false;

    class Bezier {
        static getPoints(pList, inSertCount = 5, count = 2, out) {
            out = out || [];
            let len = pList.length;
            if (len < (count + 1) * 2)
                return out;
            switch (count) {
                case 2:
                    _calFun = getPoint2;
                    break;
                case 3:
                    _calFun = getPoint3;
                    break;
                default:
                    return [];
            }
            while (tmpPoints$1.length <= count) {
                tmpPoints$1.push(new Point());
            }
            for (let i = 0; i < count * 2; i += 2) {
                _switchPoint(pList[i], pList[i + 1]);
            }
            for (let i = count * 2; i < len; i += 2) {
                _switchPoint(pList[i], pList[i + 1]);
                if ((i / 2) % count == 0)
                    insertPoints(inSertCount, out);
            }
            return out;
        }
        static getRate(t, px0, py0, px1, py1) {
            let key = _getBezierParamKey(px0, py0, px1, py1);
            let vKey = key * 100 + t;
            if (_bezierResultCache[vKey])
                return _bezierResultCache[vKey];
            let points;
            if (_bezierPointsCache[key])
                points = _bezierPointsCache[key];
            else {
                var controlPoints;
                controlPoints = [0, 0, px0, py0, px1, py1, 1, 1];
                points = Bezier.getPoints(controlPoints, 100, 3);
                _bezierPointsCache[key] = points;
            }
            let len = points.length;
            for (let i = 0; i < len; i += 2) {
                if (t <= points[i]) {
                    _bezierResultCache[vKey] = points[i + 1];
                    return points[i + 1];
                }
            }
            _bezierResultCache[vKey] = 1;
            return 1;
        }
    }
    const tmpPoints$1 = [new Point(), new Point(), new Point()];
    var _calFun = getPoint2;
    const _bezierResultCache = {};
    const _bezierPointsCache = {};
    function _switchPoint(x, y) {
        let tPoint = tmpPoints$1.shift();
        tPoint.setTo(x, y);
        tmpPoints$1.push(tPoint);
    }
    function getPoint2(t, rst) {
        var p1 = tmpPoints$1[0];
        var p2 = tmpPoints$1[1];
        var p3 = tmpPoints$1[2];
        var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
        var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
        rst.push(lineX, lineY);
    }
    function getPoint3(t, rst) {
        var p1 = tmpPoints$1[0];
        var p2 = tmpPoints$1[1];
        var p3 = tmpPoints$1[2];
        var p4 = tmpPoints$1[3];
        var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
        var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
        rst.push(lineX, lineY);
    }
    function insertPoints(count, rst) {
        var i;
        count = count > 0 ? count : 5;
        var dLen;
        dLen = 1 / count;
        for (i = 0; i <= 1; i += dLen) {
            _calFun(i, rst);
        }
    }
    function _getBezierParamKey(px0, py0, px1, py1) {
        return (((px0 * 100 + py0) * 100 + px1) * 100 + py1) * 100;
    }

    class RenderStateContext {
        static __init__() {
        }
        static setDepthTest(value) {
            LayaGL.renderEngine._GLRenderState.setDepthTest(value);
        }
        static setDepthMask(value) {
            LayaGL.renderEngine._GLRenderState.setDepthMask(value);
        }
        static setDepthFunc(value) {
            LayaGL.renderEngine._GLRenderState.setDepthFunc(value);
        }
        static setStencilTest(value) {
            LayaGL.renderEngine._GLRenderState.setStencilTest(value);
        }
        static setStencilMask(value) {
            LayaGL.renderEngine._GLRenderState.setStencilMask(value);
        }
        static setStencilFunc(fun, ref) {
            LayaGL.renderEngine._GLRenderState.setStencilFunc(fun, ref);
        }
        static setstencilOp(fail, zfail, zpass) {
            LayaGL.renderEngine._GLRenderState.setstencilOp(fail, zfail, zpass);
        }
        static setBlend(value) {
            LayaGL.renderEngine._GLRenderState.setBlend(value);
        }
        static setBlendEquation(blendEquation) {
            LayaGL.renderEngine._GLRenderState.setBlendEquation(blendEquation);
        }
        static setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha) {
            LayaGL.renderEngine._GLRenderState.setBlendEquationSeparate(blendEquationRGB, blendEquationAlpha);
        }
        static setBlendFunc(sFactor, dFactor) {
            LayaGL.renderEngine._GLRenderState.setBlendFunc(sFactor, dFactor);
        }
        static setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            LayaGL.renderEngine._GLRenderState.setBlendFuncSeperate(srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        static setCullFace(value) {
            LayaGL.renderEngine._GLRenderState.setCullFace(value);
        }
        static setFrontFace(value) {
            LayaGL.renderEngine._GLRenderState.setFrontFace(value);
        }
    }
    RenderStateContext.stencilFuncArray = new Array(2);
    RenderStateContext.blendEquationSeparateArray = new Array(2);
    RenderStateContext.blenfunArray = new Array(2);
    RenderStateContext.blendFuncSeperateArray = new Array(4);
    RenderStateContext.stencilOpArray = new Array(3);

    class BlendMode {
        static _init_() {
            BlendMode.fns = [
                BlendMode.BlendNormal,
                BlendMode.BlendAdd,
                BlendMode.BlendMultiply,
                BlendMode.BlendScreen,
                BlendMode.BlendOverlay,
                BlendMode.BlendLight,
                BlendMode.BlendMask,
                BlendMode.BlendDestinationOut,
                BlendMode.BlendAddOld,
                BlendMode.BlendSourceAlpha,
            ];
            BlendMode.targetFns = [
                BlendMode.BlendNormalTarget,
                BlendMode.BlendAddTarget,
                BlendMode.BlendMultiplyTarget,
                BlendMode.BlendScreenTarget,
                BlendMode.BlendOverlayTarget,
                BlendMode.BlendLightTarget,
                BlendMode.BlendMask,
                BlendMode.BlendDestinationOut,
                BlendMode.BlendAddTargetOld,
                BlendMode.BlendSourceAlpha
            ];
        }
        static BlendNormal() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendAddOld() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.DestinationAlpha);
        }
        static BlendAdd() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendMultiply() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.DestinationColor, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendScreen() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendOverlay() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendLight() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendNormalTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendAddTargetOld() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.DestinationAlpha);
        }
        static BlendAddTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendMultiplyTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.DestinationColor, exports.BlendFactor.OneMinusSourceAlpha);
        }
        static BlendScreenTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendOverlayTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.OneMinusSourceColor);
        }
        static BlendLightTarget() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.One, exports.BlendFactor.One);
        }
        static BlendMask() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.Zero, exports.BlendFactor.SourceAlpha);
        }
        static BlendDestinationOut() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.Zero, exports.BlendFactor.Zero);
        }
        static BlendSourceAlpha() {
            RenderStateContext.setBlendFunc(exports.BlendFactor.SourceAlpha, exports.BlendFactor.OneMinusSourceAlpha);
        }
    }
    BlendMode.activeBlendFunction = null;
    BlendMode.NAMES = [
        "normal",
        "add",
        "multiply",
        "screen",
        "overlay",
        "light",
        "mask",
        "destination-out",
        "add_old"
    ];
    BlendMode.TOINT = {
        "normal": 0,
        "add": 1,
        "multiply": 2,
        "screen": 3,
        "overlay": 4,
        "light": 5,
        "mask": 6,
        "destination-out": 7,
        "lighter": 1,
        "lighter_old": 8,
        "add_old": 8
    };
    BlendMode.NORMAL = "normal";
    BlendMode.MASK = "mask";
    BlendMode.LIGHTER = "lighter";

    class ColorUtils {
        constructor(value) {
            this.arrColor = [];
            if (value == null || value == 'none') {
                this.strColor = "#00000000";
                this.numColor = 0;
                this.arrColor = [0, 0, 0, 0];
                return;
            }
            tmpColor.parse(value);
            if (typeof (value) == 'string')
                this.strColor = value;
            else
                this.strColor = tmpColor.getStyleString();
            tmpColor.writeTo(this.arrColor);
            this.numColor = tmpColor.getABGR();
        }
        static _initSaveMap() {
            ColorUtils._SAVE_SIZE = 0;
            ColorUtils._SAVE = {};
        }
        static create(value) {
            let key = value + "";
            let color = ColorUtils._SAVE[key];
            if (color != null)
                return color;
            if (ColorUtils._SAVE_SIZE > 500)
                ColorUtils._initSaveMap();
            ColorUtils._SAVE_SIZE++;
            return ColorUtils._SAVE[key] = new ColorUtils(value);
        }
    }
    ColorUtils._SAVE = {};
    ColorUtils._SAVE_SIZE = 0;
    const tmpColor = new Color();

    class DrawStyle {
        static create(value) {
            if (value != null) {
                let color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
                return color._drawStyle || (color._drawStyle = new DrawStyle(value));
            }
            else
                return DrawStyle.DEFAULT;
        }
        constructor(value) {
            if (value != null)
                this._color = (value instanceof ColorUtils) ? value : ColorUtils.create(value);
            else
                this._color = ColorUtils.create(0);
        }
        equal(value) {
            if (typeof (value) == 'string')
                return this._color.strColor === value;
            if (value instanceof ColorUtils)
                return this._color.numColor === value.numColor;
            return false;
        }
    }
    DrawStyle.DEFAULT = DrawStyle.create(0);

    class Path {
        constructor() {
            this._lastOriX = 0;
            this._lastOriY = 0;
            this.paths = [];
            this._curPath = null;
        }
        beginPath(convex) {
            this.paths.length = 1;
            this._curPath = this.paths[0] = new renderPath();
            this._curPath.convex = convex;
        }
        closePath() {
            this._curPath.loop = true;
        }
        newPath() {
            this._curPath = new renderPath();
            this.paths.push(this._curPath);
        }
        addPoint(pointX, pointY) {
            this._curPath.path.push(pointX, pointY);
        }
        push(points, convex) {
            if (!this._curPath) {
                this._curPath = new renderPath();
                this.paths.push(this._curPath);
            }
            else if (this._curPath.path.length > 0) {
                this._curPath = new renderPath();
                this.paths.push(this._curPath);
            }
            var rp = this._curPath;
            rp.path = points.slice();
            rp.convex = convex;
        }
        reset() {
            this.paths.length = 0;
        }
    }
    class renderPath {
        constructor() {
            this.path = [];
            this.loop = false;
            this.convex = false;
        }
    }

    class SaveBase {
        constructor() {
        }
        static _createArray() {
            var value = [];
            value._length = 0;
            return value;
        }
        static _init() {
            var namemap = SaveBase._namemap = {};
            namemap[SaveBase.TYPE_ALPHA] = "ALPHA";
            namemap[SaveBase.TYPE_FILESTYLE] = "fillStyle";
            namemap[SaveBase.TYPE_FONT] = "font";
            namemap[SaveBase.TYPE_LINEWIDTH] = "lineWidth";
            namemap[SaveBase.TYPE_STROKESTYLE] = "strokeStyle";
            namemap[SaveBase.TYPE_ENABLEMERGE] = "_mergeID";
            namemap[SaveBase.TYPE_MARK] = namemap[SaveBase.TYPE_TRANSFORM] = namemap[SaveBase.TYPE_TRANSLATE] = [];
            namemap[SaveBase.TYPE_TEXTBASELINE] = "textBaseline";
            namemap[SaveBase.TYPE_TEXTALIGN] = "textAlign";
            namemap[SaveBase.TYPE_GLOBALCOMPOSITEOPERATION] = "_nBlendType";
            namemap[SaveBase.TYPE_SHADER] = "shader";
            namemap[SaveBase.TYPE_FILTERS] = "filters";
            namemap[SaveBase.TYPE_COLORFILTER] = '_colorFiler';
            return namemap;
        }
        isSaveMark() { return false; }
        restore(context) {
            this._dataObj[this._valueName] = this._value;
            SaveBase.POOL[SaveBase.POOL._length++] = this;
            this._newSubmit && (context.stopMerge = true);
        }
        static save(context, type, dataObj, newSubmit) {
            if ((context._saveMark._saveuse & type) !== type) {
                context._saveMark._saveuse |= type;
                var cache = SaveBase.POOL;
                var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
                o._value = dataObj[o._valueName = SaveBase._namemap[type]];
                o._dataObj = dataObj;
                o._newSubmit = newSubmit;
                var _save = context._save;
                _save[_save._length++] = o;
            }
        }
    }
    SaveBase.TYPE_ALPHA = 0x1;
    SaveBase.TYPE_FILESTYLE = 0x2;
    SaveBase.TYPE_FONT = 0x8;
    SaveBase.TYPE_LINEWIDTH = 0x100;
    SaveBase.TYPE_STROKESTYLE = 0x200;
    SaveBase.TYPE_MARK = 0x400;
    SaveBase.TYPE_TRANSFORM = 0x800;
    SaveBase.TYPE_TRANSLATE = 0x1000;
    SaveBase.TYPE_ENABLEMERGE = 0x2000;
    SaveBase.TYPE_TEXTBASELINE = 0x4000;
    SaveBase.TYPE_TEXTALIGN = 0x8000;
    SaveBase.TYPE_GLOBALCOMPOSITEOPERATION = 0x10000;
    SaveBase.TYPE_CLIPRECT = 0x20000;
    SaveBase.TYPE_CLIPRECT_STENCIL = 0x40000;
    SaveBase.TYPE_IBVB = 0x80000;
    SaveBase.TYPE_SHADER = 0x100000;
    SaveBase.TYPE_FILTERS = 0x200000;
    SaveBase.TYPE_FILTERS_TYPE = 0x400000;
    SaveBase.TYPE_COLORFILTER = 0x800000;
    SaveBase.POOL = SaveBase._createArray();
    SaveBase._namemap = SaveBase._init();

    class SaveClipRect {
        constructor() {
            this._globalClipMatrix = new Matrix();
            this._clipInfoID = -1;
            this._clipRect = new Rectangle();
        }
        isSaveMark() { return false; }
        restore(context) {
            this._globalClipMatrix.copyTo(context._globalClipMatrix);
            this._clipRect.clone(context._clipRect);
            context._clipInfoID = this._clipInfoID;
            SaveClipRect.POOL[SaveClipRect.POOL._length++] = this;
        }
        static save(context) {
            if ((context._saveMark._saveuse & SaveBase.TYPE_CLIPRECT) == SaveBase.TYPE_CLIPRECT)
                return;
            context._saveMark._saveuse |= SaveBase.TYPE_CLIPRECT;
            var cache = SaveClipRect.POOL;
            var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
            context._globalClipMatrix.copyTo(o._globalClipMatrix);
            context._clipRect.clone(o._clipRect);
            o._clipInfoID = context._clipInfoID;
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveClipRect.POOL = SaveBase._createArray();

    class SaveMark {
        constructor() {
            this._saveuse = 0;
        }
        isSaveMark() {
            return true;
        }
        restore(context) {
            context._saveMark = this._preSaveMark;
            SaveMark.POOL[SaveMark.POOL._length++] = this;
        }
        static Create(context) {
            var no = SaveMark.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveMark());
            o._saveuse = 0;
            o._preSaveMark = context._saveMark;
            context._saveMark = o;
            return o;
        }
    }
    SaveMark.POOL = SaveBase._createArray();

    class SaveTransform {
        constructor() {
            this._matrix = new Matrix();
        }
        isSaveMark() { return false; }
        restore(context) {
            context._curMat = this._savematrix;
            SaveTransform.POOL[SaveTransform.POOL._length++] = this;
        }
        static save(context) {
            var _saveMark = context._saveMark;
            if ((_saveMark._saveuse & SaveBase.TYPE_TRANSFORM) === SaveBase.TYPE_TRANSFORM)
                return;
            _saveMark._saveuse |= SaveBase.TYPE_TRANSFORM;
            var no = SaveTransform.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
            o._savematrix = context._curMat;
            context._curMat = context._curMat.copyTo(o._matrix);
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveTransform.POOL = SaveBase._createArray();

    class SaveTranslate {
        constructor() {
            this._mat = new Matrix();
        }
        isSaveMark() { return false; }
        restore(context) {
            this._mat.copyTo(context._curMat);
            SaveTranslate.POOL[SaveTranslate.POOL._length++] = this;
        }
        static save(context) {
            var no = SaveTranslate.POOL;
            var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
            context._curMat.copyTo(o._mat);
            var _save = context._save;
            _save[_save._length++] = o;
        }
    }
    SaveTranslate.POOL = SaveBase._createArray();

    var prime_ps = "#define SHADER_NAME PrimitiveFS2D\nprecision mediump float;\n#include \"Sprite2DFrag.glsl\";\nvoid main(){clip();gl_FragColor=getGlColor(v_color);gl_FragColor.rgb*=gl_FragColor.a;}";

    var prime_vs = "#define SHADER_NAME PrimitiveVS2D\n#include \"Sprite2DVertex.glsl\";\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvoid main(){vec4 pos;getPosition(pos);vertexInfo info;getVertexInfo(info);v_color=info.color;v_cliped=info.cliped;gl_Position=pos;}";

    var texture_ps = "#define SHADER_NAME TextureFS2D\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"Sprite2DFrag.glsl\";\nvoid main(){clip();vec4 color=getSpriteTextureColor();setglColor(color);}";

    var texture_vs = "#define SHADER_NAME TextureVS2D\n#include \"Sprite2DVertex.glsl\";\nvoid main(){vec4 pos;getPosition(pos);vertexInfo info;getVertexInfo(info);v_texcoordAlpha=info.texcoordAlpha;v_useTex=info.useTex;v_color=info.color;gl_Position=pos;}";

    var baseRender2D_vs = "#define SHADER_NAME BaseRender2DVS\n#include \"Sprite2DVertex.glsl\";\nvoid main(){vec4 pos;getPosition(pos);vertexInfo info;getVertexInfo(info);v_texcoord=info.uv;v_color=info.color;\n#ifdef LIGHT2D_ENABLE\nlightAndShadow(info);\n#endif\ngl_Position=pos;}";

    var baseRender2D_ps = "#define SHADER_NAME BaseRender2DPS\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#include \"Sprite2DFrag.glsl\";\nvoid main(){clip();vec4 textureColor;\n#ifdef CLIPMODE\nvec2 texcoord=v_texcoord.xy;vec4 clampedRange=u_baseRender2DTextureRange;clampedRange.xy=max(u_baseRender2DTextureRange.xy,vec2(0.0,0.0));clampedRange.zw=min(u_baseRender2DTextureRange.xy+u_baseRender2DTextureRange.zw,vec2(1.0,1.0));vec2 inRange=step(clampedRange.xy,texcoord)*step(texcoord,clampedRange.zw);float useTexture=inRange.x*inRange.y;texcoord=fract(texcoord);textureColor=mix(vec4(0.0,0.0,0.0,0.0),texture2D(u_baseRender2DTexture,texcoord),useTexture);\n#else\nvec2 texcoord=v_texcoord.xy*u_baseRender2DTextureRange.zw+u_baseRender2DTextureRange.xy;textureColor=texture2D(u_baseRender2DTexture,texcoord);\n#endif\n#ifdef LIGHT2D_ENABLE\nlightAndShadow(textureColor);\n#endif\ntextureColor=transspaceColor(textureColor);setglColor(textureColor);}";

    var ColorGLSL = "#if !defined(Color_lib)\n#define Color_lib\n#include \"Math.glsl\";\nvec3 linearToGamma(in vec3 value){return pow(value,vec3(1.0/2.2));}vec4 linearToGamma(in vec4 value){return vec4(linearToGamma(value.rgb),value.a);}vec3 gammaToLinear(in vec3 value){return pow(value,vec3(2.2));}vec4 gammaToLinear(in vec4 value){return vec4(gammaToLinear(value.rgb),value.a);}const float c_RGBDMaxRange=255.0;vec4 encodeRGBD(in vec3 color){float maxRGB=max(vecmax(color),FLT_EPS);float d=max(1.0,c_RGBDMaxRange/maxRGB);d=saturate(d/255.0);vec3 rgb=color.rgb*d;rgb=saturate(rgb);return vec4(rgb,d);}vec3 decodeRGBD(in vec4 rgbd){vec3 color=rgbd.rgb*(1.0/rgbd.a);return color;}vec4 encodeRGBM(in vec3 color,float range){color*=1.0/range;float maxRGB=max(vecmax(color),FLT_EPS);float m=ceil(maxRGB*255.0)/255.0;vec3 rgb=color.rgb*1.0/m;vec4 rgbm=vec4(rgb,m);return rgbm;}vec3 decodeRGBM(in vec4 rgbm,float range){return range*rgbm.rgb*rgbm.a;}\n#include \"OutputTransform.glsl\";\n#endif\n";

    var MathGLSL = "#if !defined(Math_lib)\n#define Math_lib\n#ifndef GRAPHICS_API_GLES3\nmat2 inverse(mat2 m){return mat2(m[1][1],-m[0][1],-m[1][0],m[0][0])/(m[0][0]*m[1][1]-m[0][1]*m[1][0]);}mat3 inverse(mat3 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2];float a10=m[1][0],a11=m[1][1],a12=m[1][2];float a20=m[2][0],a21=m[2][1],a22=m[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}mat4 inverse(mat4 m){float a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],b00=a00*a11-a01*a10,b01=a00*a12-a02*a10,b02=a00*a13-a03*a10,b03=a01*a12-a02*a11,b04=a01*a13-a03*a11,b05=a02*a13-a03*a12,b06=a20*a31-a21*a30,b07=a20*a32-a22*a30,b08=a20*a33-a23*a30,b09=a21*a32-a22*a31,b10=a21*a33-a23*a31,b11=a22*a33-a23*a32,det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;return mat4(a11*b11-a12*b10+a13*b09,a02*b10-a01*b11-a03*b09,a31*b05-a32*b04+a33*b03,a22*b04-a21*b05-a23*b03,a12*b08-a10*b11-a13*b07,a00*b11-a02*b08+a03*b07,a32*b02-a30*b05-a33*b01,a20*b05-a22*b02+a23*b01,a10*b10-a11*b08+a13*b06,a01*b08-a00*b10-a03*b06,a30*b04-a31*b02+a33*b00,a21*b02-a20*b04-a23*b00,a11*b07-a10*b09-a12*b06,a00*b09-a01*b07+a02*b06,a31*b01-a30*b03-a32*b00,a20*b03-a21*b01+a22*b00)/det;}mat4 transpose(mat4 m){return mat4(m[0][0],m[1][0],m[2][0],m[3][0],m[0][1],m[1][1],m[2][1],m[3][1],m[0][2],m[1][2],m[2][2],m[3][2],m[0][3],m[1][3],m[2][3],m[3][3]);}mat3 transpose(mat3 m){return mat3(m[0][0],m[1][0],m[2][0],m[0][1],m[1][1],m[2][1],m[0][2],m[1][2],m[2][2]);}\n#endif\n#define PI 3.14159265359\n#define INVERT_PI 0.31830988618\n#define HALF_PI 1.570796327\n#define MEDIUMP_FLT_MAX 65504.0\n#define MEDIUMP_FLT_MIN 0.00006103515625\n#if defined(GL_FRAGMENT_PRECISION_HIGH)\n#define FLT_EPS 1e-5\n#define saturateMediump(x) x\n#else\n#define FLT_EPS MEDIUMP_FLT_MIN\n#define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)\n#endif\n#define saturate(x) clamp(x, 0.0, 1.0)\nfloat pow2(float x){return x*x;}vec3 pow2(vec3 x){return x*x;}float pow5(float x){float x2=x*x;return x2*x2*x;}const float INVERT_LOG10=0.43429448190325176;float log10(float x){return log(x)*INVERT_LOG10;}float vecmax(const vec2 v){return max(v.x,v.y);}float vecmax(const vec3 v){return max(v.x,max(v.y,v.z));}float vecmax(const vec4 v){return max(max(v.x,v.y),max(v.z,v.w));}float vecmin(const vec2 v){return min(v.x,v.y);}float vecmin(const vec3 v){return min(v.x,min(v.y,v.z));}float vecmin(const vec4 v){return min(min(v.x,v.y),min(v.z,v.w));}vec3 SafeNormalize(in vec3 inVec){float dp3=max(0.001,dot(inVec,inVec));return inVec*inversesqrt(dp3);}vec3 normalScale(in vec3 normal,in float scale){normal*=vec3(scale,scale,1.0);return normalize(normal);}float acosFast(float x){float y=abs(x);float p=-0.1565827*y+1.570796;p*=sqrt(1.0-y);return x>=0.0 ? p : PI-p;}float acosFastPositive(float x){float p=-0.1565827*x+1.570796;return p*sqrt(1.0-x);}float interleavedGradientNoise(const highp vec2 w){const vec3 m=vec3(0.06711056,0.00583715,52.9829189);return fract(m.z*fract(dot(w,m.xy)));}vec3 rotationByEuler(in vec3 vector,in vec3 rot){float halfRoll=rot.z*0.5;float halfPitch=rot.x*0.5;float halfYaw=rot.y*0.5;float sinRoll=sin(halfRoll);float cosRoll=cos(halfRoll);float sinPitch=sin(halfPitch);float cosPitch=cos(halfPitch);float sinYaw=sin(halfYaw);float cosYaw=cos(halfYaw);float quaX=(cosYaw*sinPitch*cosRoll)+(sinYaw*cosPitch*sinRoll);float quaY=(sinYaw*cosPitch*cosRoll)-(cosYaw*sinPitch*sinRoll);float quaZ=(cosYaw*cosPitch*sinRoll)-(sinYaw*sinPitch*cosRoll);float quaW=(cosYaw*cosPitch*cosRoll)+(sinYaw*sinPitch*sinRoll);float x=quaX+quaX;float y=quaY+quaY;float z=quaZ+quaZ;float wx=quaW*x;float wy=quaW*y;float wz=quaW*z;float xx=quaX*x;float xy=quaX*y;float xz=quaX*z;float yy=quaY*y;float yz=quaY*z;float zz=quaZ*z;return vec3(((vector.x*((1.0-yy)-zz))+(vector.y*(xy-wz)))+(vector.z*(xz+wy)),((vector.x*(xy+wz))+(vector.y*((1.0-xx)-zz)))+(vector.z*(yz-wx)),((vector.x*(xz-wy))+(vector.y*(yz+wx)))+(vector.z*((1.0-xx)-yy)));}vec3 rotationByAxis(in vec3 vector,in vec3 axis,in float angle){float halfAngle=angle*0.5;float sinf=sin(halfAngle);float quaX=axis.x*sinf;float quaY=axis.y*sinf;float quaZ=axis.z*sinf;float quaW=cos(halfAngle);float x=quaX+quaX;float y=quaY+quaY;float z=quaZ+quaZ;float wx=quaW*x;float wy=quaW*y;float wz=quaW*z;float xx=quaX*x;float xy=quaX*y;float xz=quaX*z;float yy=quaY*y;float yz=quaY*z;float zz=quaZ*z;return vec3(((vector.x*((1.0-yy)-zz))+(vector.y*(xy-wz)))+(vector.z*(xz+wy)),((vector.x*(xy+wz))+(vector.y*((1.0-xx)-zz)))+(vector.z*(yz-wx)),((vector.x*(xz-wy))+(vector.y*(yz+wx)))+(vector.z*((1.0-xx)-yy)));}vec3 rotationByQuaternions(in vec3 v,in vec4 q){return v+2.0*cross(q.xyz,cross(q.xyz,v)+q.w*v);}\n#endif\n";

    var Sprite2DFrag = "vec3 gammaToLinear(in vec3 value){return pow((value+0.055)/1.055,vec3(2.4));}vec4 gammaToLinear(in vec4 value){return vec4(gammaToLinear(value.rgb),value.a);}vec3 linearToGamma(in vec3 value){return vec3(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))));}vec4 linearToGamma(in vec4 value){return vec4(linearToGamma(value.rgb),value.a);}vec4 transspaceColor(vec4 color){\n#ifndef GAMMATEXTURE\n#ifdef GAMMASPACE\ncolor.xyz=linearToGamma(color.xyz);\n#endif\n#else\n#ifndef GAMMASPACE\ncolor.xyz=gammaToLinear(color.xyz);\n#endif\n#endif\nreturn color;}varying vec2 v_cliped;\n#if defined(PRIMITIVEMESH)\nvarying vec4 v_color;vec4 getGlColor(vec4 color){\n#ifdef GAMMASPACE\nreturn color;\n#else\nreturn gammaToLinear(color);\n#endif\n}\n#elif defined(TEXTUREVS)\nvarying vec4 v_texcoordAlpha;varying vec4 v_color;varying float v_useTex;uniform sampler2D u_spriteTexture;\n#ifdef BLUR_FILTER\nuniform vec4 u_strength_sig2_2sig2_gauss1;uniform vec2 u_blurInfo;\n#define PI 3.141593\n#endif\n#ifdef COLOR_FILTER\nuniform vec4 u_colorAlpha;uniform mat4 u_colorMat;\n#endif\n#ifdef GLOW_FILTER\nuniform vec4 u_color;uniform vec4 u_blurInfo1;uniform vec4 u_blurInfo2;\n#endif\n#ifdef COLOR_ADD\nuniform vec4 u_colorAdd;\n#endif\n#ifdef FILLTEXTURE\nuniform vec4 u_TexRange;\n#endif\n#ifdef BLUR_FILTER\nfloat getGaussian(float x,float y){return u_strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/u_strength_sig2_2sig2_gauss1.z);}vec4 blur(){const float blurw=9.0;vec4 vec4Color=vec4(0.0,0.0,0.0,0.0);vec2 halfsz=vec2(blurw,blurw)/2.0/u_blurInfo;vec2 startpos=v_texcoordAlpha.xy-halfsz;vec2 ctexcoord=startpos;vec2 step=1.0/u_blurInfo;for(float y=0.0;y<=blurw;++y){ctexcoord.x=startpos.x;for(float x=0.0;x<=blurw;++x){vec4Color+=transspaceColor(texture2D(u_spriteTexture,ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0));ctexcoord.x+=step.x;}ctexcoord.y+=step.y;}return vec4Color;}\n#endif\nvec4 getSpriteTextureColor(){\n#ifdef FILLTEXTURE\nvec4 color=texture2D(u_spriteTexture,fract(v_texcoordAlpha.xy)*u_TexRange.zw+u_TexRange.xy);\n#else\nvec4 color=texture2D(u_spriteTexture,v_texcoordAlpha.xy);\n#endif\nreturn transspaceColor(color);}void setglColor(in vec4 color){if(v_useTex<=0.)color=vec4(1.,1.,1.,1.);color.a*=v_color.w;vec4 transColor=v_color;\n#ifndef GAMMASPACE\ntransColor=gammaToLinear(v_color);\n#endif\ncolor.rgb*=transColor.rgb;gl_FragColor=color;\n#ifdef COLOR_ADD\ngl_FragColor=vec4(u_colorAdd.rgb,u_colorAdd.a*gl_FragColor.a);gl_FragColor.xyz*=u_colorAdd.a;\n#endif\n#ifdef BLUR_FILTER\ngl_FragColor=blur();gl_FragColor.w*=v_color.w;\n#endif\n#ifdef COLOR_FILTER\nmat4 alphaMat=u_colorMat;alphaMat[0][3]*=gl_FragColor.a;alphaMat[1][3]*=gl_FragColor.a;alphaMat[2][3]*=gl_FragColor.a;gl_FragColor=gl_FragColor*alphaMat;gl_FragColor+=u_colorAlpha/255.0*gl_FragColor.a;\n#endif\n#ifdef GLOW_FILTER\nconst float c_IterationTime=10.0;float floatIterationTotalTime=c_IterationTime*c_IterationTime;vec4 vec4Color=vec4(0.0,0.0,0.0,0.0);vec2 vec2FilterDir=vec2(-u_blurInfo1.z/u_blurInfo2.x,-u_blurInfo1.w/u_blurInfo2.y);vec2 vec2FilterOff=vec2(u_blurInfo1.x/u_blurInfo2.x/c_IterationTime*2.0,u_blurInfo1.y/u_blurInfo2.y/c_IterationTime*2.0);float maxNum=u_blurInfo1.x*u_blurInfo1.y;vec2 vec2Off=vec2(0.0,0.0);float floatOff=c_IterationTime/2.0;for(float i=0.0;i<=c_IterationTime;++i){for(float j=0.0;j<=c_IterationTime;++j){vec2Off=vec2(vec2FilterOff.x*(i-floatOff),vec2FilterOff.y*(j-floatOff));vec4Color+=transspaceColor(texture2D(u_spriteTexture,v_texcoordAlpha.xy+vec2FilterDir+vec2Off));}}vec4Color/=floatIterationTotalTime;gl_FragColor=vec4(u_color.rgb,vec4Color.a*u_blurInfo2.z);gl_FragColor.rgb*=gl_FragColor.a;\n#endif\n}\n#endif\n#ifdef BASERENDER2D\nvarying vec2 v_texcoord;varying vec4 v_color;uniform sampler2D u_baseRender2DTexture;uniform vec4 u_baseRender2DTextureRange;uniform vec4 u_baseRenderColor;\n#ifdef LIGHT2D_ENABLE\nvarying vec2 v_lightUV;uniform vec3 u_LightDirection;uniform vec4 u_LightAndShadow2DParam;uniform vec4 u_LightAndShadow2DAmbient;uniform sampler2D u_LightAndShadow2D;\n#ifdef LIGHT2D_SCENEMODE_ADD\nuniform sampler2D u_LightAndShadow2D_AddMode;\n#endif\n#ifdef LIGHT2D_SCENEMODE_SUB\nuniform sampler2D u_LightAndShadow2D_SubMode;\n#endif\n#ifdef LIGHT2D_NORMAL_PARAM\nuniform sampler2D u_normal2DTexture;uniform float u_normal2DStrength;\n#endif\nvoid lightAndShadow(inout vec4 color){\n#ifdef LIGHT2D_EMPTY\ncolor.rgb*=u_LightAndShadow2DAmbient.rgb;\n#else\nvec2 uv=v_lightUV;vec2 tt=step(vec2(0.0),uv)*step(uv,vec2(1.0));float side=tt.x*tt.y;vec3 ambient=color.rgb*u_LightAndShadow2DAmbient.rgb;color.rgb=color.rgb*texture2D(u_LightAndShadow2D,uv).rgb*side;side*=color.a;\n#ifdef LIGHT2D_SCENEMODE_ADD\ncolor.rgb=min(vec3(1.0),color.rgb+texture2D(u_LightAndShadow2D_AddMode,uv).rgb*side);\n#endif\n#ifdef LIGHT2D_SCENEMODE_SUB\ncolor.rgb=max(vec3(0.0),color.rgb-texture2D(u_LightAndShadow2D_SubMode,uv).rgb*side);\n#endif\n#ifdef LIGHT2D_NORMAL_PARAM\nvec3 dr=normalize(u_LightDirection);vec3 normal=normalize(texture2D(u_normal2DTexture,v_texcoord).rgb*2.0-1.0);color.rgb=color.rgb*((1.0-u_normal2DStrength)+abs(dot(dr,normal.rgb))*u_normal2DStrength);\n#endif\ncolor.rgb=min(vec3(1.0),color.rgb+ambient);\n#endif\n}\n#endif\nvoid setglColor(in vec4 color){color.a*=v_color.w;vec4 transColor=v_color;\n#ifndef GAMMASPACE\ntransColor=gammaToLinear(v_color);\n#endif\ncolor.rgb*=transColor.rgb;gl_FragColor=color;}vec2 transformUV(in vec2 texcoord,in vec4 tilingOffset){vec2 uv=texcoord*tilingOffset.zw+tilingOffset.xy;return uv;}\n#endif\nvoid clip(){if(v_cliped.x<0.)discard;if(v_cliped.x>1.)discard;if(v_cliped.y<0.)discard;if(v_cliped.y>1.)discard;}";

    var Sprite2DShaderInfo = "\n#if defined(PRIMITIVEMESH)\nstruct vertexInfo{vec4 color;vec2 cliped;};\n#elif defined(TEXTUREVS)\nstruct vertexInfo{vec4 color;vec2 cliped;vec4 texcoordAlpha;float useTex;};\n#endif\n";

    var Sprite2DVertex = "#include \"Sprite2DShaderInfo.glsl\";\n#ifdef CAMERA2D\nuniform mat3 u_view2D;\n#endif\n#ifdef WORLDMAT\nuniform mat4 u_mmat;vec4 transedPos;\n#endif\n#ifdef PRIMITIVEMESH\nuniform vec4 u_clipMatDir;uniform vec2 u_clipMatPos;uniform vec2 u_size;uniform float u_VertAlpha;varying vec2 v_cliped;varying vec4 v_color;void getVertexInfo(inout vertexInfo info){info.color=a_attribColor;info.color.a*=u_VertAlpha;float clipw=length(u_clipMatDir.xy);float cliph=length(u_clipMatDir.zw);\n#ifdef WORLDMAT\nvec2 clippos=transedPos.xy-u_clipMatPos.xy;\n#else\nvec2 clippos=a_position.xy-u_clipMatPos.xy;\n#endif\nif(clipw>20000.&&cliph>20000.)info.cliped=vec2(0.5,0.5);else{info.cliped=vec2(dot(clippos,u_clipMatDir.xy)/clipw/clipw,dot(clippos,u_clipMatDir.zw)/cliph/cliph);}}void getPosition(inout vec4 pos){pos=vec4(a_position.xy,0.,1.);\n#ifdef WORLDMAT\npos=u_mmat*pos;transedPos=pos;\n#ifdef CAMERA2D\npos.xy=(u_view2D*vec3(pos.x,pos.y,1.0)).xy+u_size/2.;\n#endif\npos=vec4((pos.x/u_size.x-0.5)*2.0,(0.5-pos.y/u_size.y)*2.0,pos.z,1.0);\n#else\n#ifdef CAMERA2D\npos.xy=(u_view2D*vec3(pos.x,pos.y,1.0)).xy+u_size/2.;\n#endif\npos=vec4((pos.x/u_size.x-0.5)*2.0,(0.5-pos.y/u_size.y)*2.0,pos.z,1.0);\n#endif\n#ifdef INVERTY\npos.y=-pos.y;\n#endif\n}\n#endif\n#ifdef TEXTUREVS\nuniform vec4 u_clipMatDir;uniform vec2 u_clipMatPos;uniform vec2 u_size;uniform float u_VertAlpha;varying vec2 v_cliped;varying vec4 v_color;\n#ifdef MVP3D\nuniform mat4 u_MvpMatrix;\n#endif\nvarying vec4 v_texcoordAlpha;varying float v_useTex;void getVertexInfo(inout vertexInfo info){info.texcoordAlpha.xy=a_posuv.zw;info.color=a_attribColor;info.color.a*=u_VertAlpha;info.color.xyz*=info.color.w;info.useTex=a_attribFlags.r;}void getPosition(inout vec4 glPosition){vec4 pos=vec4(a_posuv.xy,0.,1.);\n#ifdef WORLDMAT\npos=u_mmat*pos;transedPos=pos;\n#endif\n#ifdef CAMERA2D\npos.xy=(u_view2D*vec3(pos.x,pos.y,1.0)).xy+u_size/2.;\n#endif\nfloat clipw=length(u_clipMatDir.xy);float cliph=length(u_clipMatDir.zw);vec2 clpos=u_clipMatPos.xy;\n#ifdef WORLDMAT\nvec2 clippos=transedPos.xy-clpos;\n#else\nvec2 clippos=pos.xy-clpos;\n#endif\nif(clipw>20000.&&cliph>20000.)v_cliped=vec2(0.5,0.5);else{v_cliped=vec2(dot(clippos,u_clipMatDir.xy)/clipw/clipw,dot(clippos,u_clipMatDir.zw)/cliph/cliph);}vec4 pos1=vec4((pos.x/u_size.x-0.5)*2.0,(0.5-pos.y/u_size.y)*2.0,0.,1.0);\n#ifdef MVP3D\nglPosition=u_MvpMatrix*pos1;\n#else\nglPosition=pos1;\n#endif\n#ifdef INVERTY\nglPosition.y=-glPosition.y;\n#endif\n}\n#endif\n#ifdef BASERENDER2D\nvarying vec2 v_texcoord;varying vec4 v_color;varying vec2 v_cliped;uniform vec3 u_NMatrix_0;uniform vec3 u_NMatrix_1;uniform vec2 u_baseRenderSize2D;uniform vec4 u_baseRenderColor;uniform vec4 u_clipMatDir;uniform vec2 u_clipMatPos;struct vertexInfo{vec4 color;vec2 uv;vec2 pos;vec2 lightUV;};\n#ifdef LIGHT2D_ENABLE\nvarying vec2 v_lightUV;uniform vec4 u_LightAndShadow2DParam;uniform vec3 u_LightAndShadow2DSceneInv0;uniform vec3 u_LightAndShadow2DSceneInv1;uniform vec3 u_LightAndShadow2DStageMat0;uniform vec3 u_LightAndShadow2DStageMat1;void lightAndShadow(vertexInfo info){v_lightUV=info.lightUV;}void invertMat(inout vec3 v1,inout vec3 v2){float a1=v1.x;float b1=v2.x;float c1=v1.y;float d1=v2.y;float tx1=v1.z;float ty1=v2.z;float n=a1*d1-b1*c1;v1.x=d1/n;v2.x=-b1/n;v1.y=-c1/n;v2.y=a1/n;v1.z=(c1*ty1-d1*tx1)/n;v2.z=-(a1*ty1-b1*tx1)/n;}\n#endif\nvoid transfrom(vec2 pos,vec3 xDir,vec3 yDir,out vec2 outPos){outPos.x=xDir.x*pos.x+xDir.y*pos.y+xDir.z;outPos.y=yDir.x*pos.x+yDir.y*pos.y+yDir.z;}void getGlobalPos(in vec2 localPos,out vec2 globalPos){transfrom(localPos,u_NMatrix_0,u_NMatrix_1,globalPos);}void getViewPos(in vec2 globalPos,out vec2 viewPos){\n#ifdef CAMERA2D\nviewPos.xy=(u_view2D*vec3(globalPos,1.0)).xy+u_baseRenderSize2D/2.;\n#else\nviewPos.xy=globalPos;\n#endif\n}vec4 linearToGamma(in vec4 value){return vec4(mix(pow(value.rgb,vec3(0.41666))*1.055-vec3(0.055),value.rgb*12.92,vec3(lessThanEqual(value.rgb,vec3(0.0031308)))),value.a);}void getVertexInfo(inout vertexInfo info){info.pos=a_position.xy;info.color=vec4(1.0,1.0,1.0,1.0);\n#ifdef COLOR\ninfo.color=a_color;info.color.rgb*=a_color.a;\n#endif\ninfo.color*=linearToGamma(u_baseRenderColor);\n#ifdef UV\ninfo.uv=a_uv;\n#endif\n#ifdef LIGHT2D_ENABLE\nvec2 global;vec3 stageInv0=vec3(u_LightAndShadow2DStageMat0.x,u_LightAndShadow2DStageMat0.y,u_LightAndShadow2DStageMat0.z);vec3 stageInv1=vec3(u_LightAndShadow2DStageMat1.x,u_LightAndShadow2DStageMat1.y,u_LightAndShadow2DStageMat1.z);invertMat(stageInv0,stageInv1);getGlobalPos(info.pos,global);transfrom(global,stageInv0,stageInv1,global);transfrom(global,u_LightAndShadow2DSceneInv0,u_LightAndShadow2DSceneInv1,global);transfrom(global,u_LightAndShadow2DStageMat0,u_LightAndShadow2DStageMat1,global);info.lightUV.x=(global.x-u_LightAndShadow2DParam.x)/u_LightAndShadow2DParam.z;info.lightUV.y=1.0-(global.y-u_LightAndShadow2DParam.y)/u_LightAndShadow2DParam.w;\n#endif\n}vec2 getClipedInfo(vec2 screenPos){vec2 cliped;float clipw=length(u_clipMatDir.xy);float cliph=length(u_clipMatDir.zw);vec2 clippos=screenPos-u_clipMatPos.xy;if(clipw>20000.&&cliph>20000.)cliped=vec2(0.5,0.5);else{cliped=vec2(dot(clippos,u_clipMatDir.xy)/clipw/clipw,dot(clippos,u_clipMatDir.zw)/cliph/cliph);}return cliped;}void getProjectPos(in vec2 viewPos,out vec4 projectPos){projectPos=vec4((viewPos.x/u_baseRenderSize2D.x-0.5)*2.0,(0.5-viewPos.y/u_baseRenderSize2D.y)*2.0,0.,1.0);\n#ifdef INVERTY\nprojectPos.y=-projectPos.y;\n#endif\n}void getPosition(inout vec4 pos){vec2 globalPos;getGlobalPos(a_position.xy,globalPos);vec2 viewPos;getViewPos(globalPos,viewPos);v_cliped=getClipedInfo(viewPos);getProjectPos(viewPos,pos);}\n#endif\n";

    class Shader2D {
        destroy() {
        }
        static __init__() {
            Shader3D.addInclude("Sprite2DFrag.glsl", Sprite2DFrag);
            Shader3D.addInclude("Sprite2DVertex.glsl", Sprite2DVertex);
            Shader3D.addInclude("Sprite2DShaderInfo.glsl", Sprite2DShaderInfo);
            Shader3D.addInclude("Color.glsl", ColorGLSL);
            Shader3D.addInclude("Math.glsl", MathGLSL);
            Shader2D.textureShader = Shader3D.add("Sprite2DTexture", false, false);
            Shader2D.textureShader.shaderType = exports.ShaderFeatureType.D2_TextureSV;
            let subShader = new SubShader(Shader2D.textureAttribute, {}, {});
            Shader2D.textureShader.addSubShader(subShader);
            subShader.addShaderPass(texture_vs, texture_ps);
            Shader2D.primitiveShader = Shader3D.add("Sprite2DPrimitive", false, false);
            Shader2D.primitiveShader.shaderType = exports.ShaderFeatureType.D2_primitive;
            subShader = new SubShader(Shader2D.primitiveAttribute, {}, {});
            Shader2D.primitiveShader.addSubShader(subShader);
            subShader.addShaderPass(prime_vs, prime_ps);
            Shader2D.render2DNodeShader = Shader3D.add("baseRender2D", false, false);
            Shader2D.render2DNodeShader.shaderType = exports.ShaderFeatureType.D2_BaseRednerNode2D;
            subShader = new SubShader(Shader2D.Render2DNodeAttribute, {}, {});
            Shader2D.render2DNodeShader.addSubShader(subShader);
            subShader.addShaderPass(baseRender2D_vs, baseRender2D_ps);
        }
    }
    Shader2D.primitiveAttribute = {
        'a_position': [0, exports.ShaderDataType.Vector4],
        'a_attribColor': [1, exports.ShaderDataType.Vector4],
    };
    Shader2D.textureAttribute = {
        'a_posuv': [0, exports.ShaderDataType.Vector4],
        'a_attribColor': [1, exports.ShaderDataType.Vector4],
        'a_attribFlags': [2, exports.ShaderDataType.Vector4]
    };
    Shader2D.Render2DNodeAttribute = {
        'a_position': [0, exports.ShaderDataType.Vector4],
        'a_color': [1, exports.ShaderDataType.Vector4],
        'a_uv': [2, exports.ShaderDataType.Vector2]
    };

    class ShaderDefines2D {
        static __init__() {
            ShaderDefines2D.TEXTURE2D = Shader3D.getDefineByName("TEXTURE2D");
            ShaderDefines2D.PRIMITIVE = Shader3D.getDefineByName("PRIMITIVE");
            ShaderDefines2D.FILTERGLOW = Shader3D.getDefineByName("GLOW_FILTER");
            ShaderDefines2D.FILTERBLUR = Shader3D.getDefineByName("BLUR_FILTER");
            ShaderDefines2D.FILTERCOLOR = Shader3D.getDefineByName("COLOR_FILTER");
            ShaderDefines2D.COLORADD = Shader3D.getDefineByName("COLOR_ADD");
            ShaderDefines2D.WORLDMAT = Shader3D.getDefineByName("WORLDMAT");
            ShaderDefines2D.FILLTEXTURE = Shader3D.getDefineByName("FILLTEXTURE");
            ShaderDefines2D.MVP3D = Shader3D.getDefineByName('MVP3D');
            ShaderDefines2D.GAMMASPACE = Shader3D.getDefineByName('GAMMASPACE');
            ShaderDefines2D.INVERTY = Shader3D.getDefineByName('INVERTY');
            ShaderDefines2D.GAMMATEXTURE = Shader3D.getDefineByName('GAMMATEXTURE');
            ShaderDefines2D.TEXTURESHADER = Shader3D.getDefineByName("TEXTUREVS");
            ShaderDefines2D.PRIMITIVESHADER = Shader3D.getDefineByName("PRIMITIVEMESH");
            ShaderDefines2D.initSprite2DCommandEncoder();
        }
        static initSprite2DCommandEncoder() {
            ShaderDefines2D.UNIFORM_MMAT = Shader3D.propertyNameToID("u_mmat");
            ShaderDefines2D.UNIFORM_CLIPMATDIR = Shader3D.propertyNameToID("u_clipMatDir");
            ShaderDefines2D.UNIFORM_CLIPMATPOS = Shader3D.propertyNameToID("u_clipMatPos");
            ShaderDefines2D.UNIFORM_MMAT2 = Shader3D.propertyNameToID("u_mmat2");
            ShaderDefines2D.UNIFORM_SIZE = Shader3D.propertyNameToID("u_size");
            ShaderDefines2D.UNIFORM_VERTALPHA = Shader3D.propertyNameToID("u_VertAlpha");
            ShaderDefines2D.UNIFORM_MVPMatrix = Shader3D.propertyNameToID("u_MvpMatrix");
            ShaderDefines2D.UNIFORM_SPRITETEXTURE = Shader3D.propertyNameToID("u_spriteTexture");
            ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1 = Shader3D.propertyNameToID("u_strength_sig2_2sig2_gauss1");
            ShaderDefines2D.UNIFORM_BLURINFO = Shader3D.propertyNameToID("u_blurInfo");
            ShaderDefines2D.UNIFORM_COLORALPHA = Shader3D.propertyNameToID("u_colorAlpha");
            ShaderDefines2D.UNIFORM_COLORMAT = Shader3D.propertyNameToID("u_colorMat");
            ShaderDefines2D.UNIFORM_COLOR = Shader3D.propertyNameToID("u_color");
            ShaderDefines2D.UNIFORM_BLURINFO1 = Shader3D.propertyNameToID("u_blurInfo1");
            ShaderDefines2D.UNIFORM_BLURINFO2 = Shader3D.propertyNameToID("u_blurInfo2");
            ShaderDefines2D.UNIFORM_COLORADD = Shader3D.propertyNameToID("u_colorAdd");
            ShaderDefines2D.UNIFORM_TEXRANGE = Shader3D.propertyNameToID("u_TexRange");
            const commandUniform = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2D");
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_MMAT, "u_mmat", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATDIR, "u_clipMatDir", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATPOS, "u_clipMatPos", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_MMAT2, "u_mmat2", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_SIZE, "u_size", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_VERTALPHA, "u_VertAlpha", exports.ShaderDataType.Float);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_MVPMatrix, "u_MvpMatrix", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_SPRITETEXTURE, "u_spriteTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1, "u_strength_sig2_2sig2_gauss1", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_BLURINFO, "u_blurInfo", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORALPHA, "u_colorAlpha", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORMAT, "u_colorMat", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLOR, "u_color", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_BLURINFO1, "u_blurInfo1", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_BLURINFO2, "u_blurInfo2", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORADD, "u_colorAdd", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_TEXRANGE, "u_TexRange", exports.ShaderDataType.Vector4);
        }
    }

    exports.RenderSpriteData = void 0;
    (function (RenderSpriteData) {
        RenderSpriteData[RenderSpriteData["Zero"] = 0] = "Zero";
        RenderSpriteData[RenderSpriteData["Texture2D"] = 1] = "Texture2D";
        RenderSpriteData[RenderSpriteData["Primitive"] = 2] = "Primitive";
    })(exports.RenderSpriteData || (exports.RenderSpriteData = {}));
    class Value2D {
        constructor(mainID) {
            this._needRelease = false;
            this.mainID = exports.RenderSpriteData.Zero;
            this.ref = 1;
            this._cacheID = 0;
            this.mainID = mainID;
            Value2D.prototype.initialize.call(this);
        }
        initialize() {
            let mainID = this.mainID;
            this.shaderData = this.shaderData || LayaGL.renderDeviceFactory.createShaderData(null);
            if (this.mainID == exports.RenderSpriteData.Texture2D) {
                this.shaderData.addDefine(ShaderDefines2D.TEXTURESHADER);
            }
            if (this.mainID == exports.RenderSpriteData.Primitive) {
                this.shaderData.addDefine(ShaderDefines2D.PRIMITIVESHADER);
            }
            this.textureHost = null;
            this.clipMatDir = new Vector4(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE);
            this.clipMatPos = new Vector2();
            this._cacheID = mainID;
            let cache = Value2D._cache[this._cacheID];
            if (mainID > 0 && !cache) {
                cache = Value2D._cache[this._cacheID] = [];
                cache._length = 0;
            }
            this.shaderData.setBool(Shader3D.DEPTH_WRITE, false);
            this.shaderData.setInt(Shader3D.DEPTH_TEST, RenderState.DEPTHTEST_OFF);
            this.shaderData.setInt(Shader3D.BLEND, RenderState.BLEND_ENABLE_ALL);
            this.shaderData.setInt(Shader3D.BLEND_EQUATION, RenderState.BLENDEQUATION_ADD);
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            this.shaderData.setNumber(ShaderDefines2D.UNIFORM_VERTALPHA, 1.0);
            this.shaderData.setInt(Shader3D.CULL, RenderState.CULL_NONE);
        }
        reinit() {
            this.initialize();
        }
        static _initone(type, classT) {
            Value2D._compileDefine = LayaGL.unitRenderModuleDataFactory.createDefineDatas();
            Value2D._typeClass[type] = classT;
            Value2D._cache[type] = [];
            Value2D._cache[type]._length = 0;
        }
        static create(mainType) {
            var types = Value2D._cache[mainType] ? Value2D._cache[mainType] : [];
            if (types._length) {
                let sv = types[--types._length];
                sv.reinit();
                return sv;
            }
            else
                return new Value2D._typeClass[mainType]();
        }
        set size(value) {
            this.shaderData.setVector2(ShaderDefines2D.UNIFORM_SIZE, value);
        }
        get size() {
            return this.shaderData.getVector2(ShaderDefines2D.UNIFORM_SIZE);
        }
        set vertAlpha(value) {
            this.shaderData.setNumber(ShaderDefines2D.UNIFORM_VERTALPHA, value);
        }
        get vertAlpha() {
            return this.shaderData.getNumber(ShaderDefines2D.UNIFORM_VERTALPHA);
        }
        set mmat(value) {
            this.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_MMAT, value);
        }
        get mmat() {
            return this.shaderData.getMatrix4x4(ShaderDefines2D.UNIFORM_MMAT);
        }
        set u_MvpMatrix(value) {
            this.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_MVPMatrix, value);
        }
        get u_MvpMatrix() {
            return this.shaderData.getMatrix4x4(ShaderDefines2D.UNIFORM_MVPMatrix);
        }
        get textureHost() {
            return this._textureHost;
        }
        set textureHost(value) {
            this._textureHost = value;
            let textrueReadGamma = false;
            if (this.textureHost) {
                if (this.textureHost instanceof BaseTexture) {
                    textrueReadGamma = this.textureHost.gammaCorrection != 1;
                }
                else if (this.textureHost instanceof Texture && this.textureHost.bitmap) {
                    textrueReadGamma = this.textureHost.bitmap.gammaCorrection != 1;
                }
            }
            if (textrueReadGamma) {
                this.shaderData.addDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            else {
                this.shaderData.removeDefine(ShaderDefines2D.GAMMATEXTURE);
            }
            let tex;
            if (value instanceof Texture) {
                tex = value.bitmap;
            }
            else {
                tex = value;
            }
            this.shaderData.setTexture(ShaderDefines2D.UNIFORM_SPRITETEXTURE, tex);
        }
        set color(value) {
            value && this.shaderData.setVector(ShaderDefines2D.UNIFORM_COLOR, value);
        }
        get color() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_COLOR);
        }
        set colorAdd(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_COLORADD, value);
        }
        get colorAdd() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_COLORADD);
        }
        set clipMatDir(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATDIR, value);
        }
        get clipMatDir() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_CLIPMATDIR);
        }
        set clipMatPos(value) {
            this.shaderData.setVector2(ShaderDefines2D.UNIFORM_CLIPMATPOS, value);
        }
        get clipMatPos() {
            return this.shaderData.getVector2(ShaderDefines2D.UNIFORM_CLIPMATPOS);
        }
        upload(material, shaderData) {
        }
        setFilter(value) {
            if (!value)
                return;
            this.shaderData.addDefine(value.typeDefine);
        }
        clear() {
            if (this.shaderData) {
                this.shaderData.clearDefine();
            }
            this.textureHost = null;
        }
        blendNormal() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
        }
        blendPremulAlpha() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
        }
        blendAdd() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
        }
        blendMask() {
            this.shaderData.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
            this.shaderData.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
        }
        release() {
            if ((--this.ref) < 1) {
                let cache = Value2D._cache[this._cacheID];
                cache && (cache[cache._length++] = this);
                this.clear();
                this.filters = null;
                this.ref = 1;
            }
        }
    }
    Value2D._cache = [];
    Value2D._typeClass = [];
    class Value2DManager {
    }

    const minAngle = 15 * Math.PI / 180;
    const precision = 1e-13;
    const tempData = new Array(256);
    const tempIndexs = new Array(4);
    const vec2$1 = new Vector2();
    class BasePoly {
        static _checkMinAngle(p1x, p1y, p2x, p2y, p3x, p3y) {
            const v1x = p2x - p1x;
            const v1y = p2y - p1y;
            const v2x = p3x - p2x;
            const v2y = p3y - p2y;
            const dot = v1x * v2x + v1y * v2y;
            const len1 = Math.sqrt(v1x * v1x + v1y * v1y);
            const len2 = Math.sqrt(v2x * v2x + v2y * v2y);
            const cosAngle = dot / (len1 * len2);
            const angle = Math.acos(Math.abs(cosAngle));
            return Math.abs(angle) < minAngle;
        }
        static createLine2(p, indices, lineWidth, indexBase, outVertex, loop) {
            if (p.length < 4)
                return null;
            let offset = indexBase;
            var points = tempData.length > (p.length + 2) ? tempData : new Array(p.length + 2);
            points[0] = p[0];
            points[1] = p[1];
            var newlen = 2;
            var i = 0;
            var length = p.length;
            for (i = 2; i < length; i += 2) {
                if (Math.abs(p[i] - p[i - 2]) + Math.abs(p[i + 1] - p[i - 1]) > 0.01) {
                    points[newlen++] = p[i];
                    points[newlen++] = p[i + 1];
                }
            }
            let delta = Math.abs(p[0] - points[newlen - 2]) + Math.abs(p[1] - points[newlen - 1]);
            if (loop && delta > 0) {
                if (delta > precision) {
                    points[newlen++] = p[0];
                    points[newlen++] = p[1];
                }
                else {
                    points[newlen - 2] = p[0];
                    points[newlen - 1] = p[1];
                }
            }
            var result = outVertex;
            length = newlen / 2;
            var w = lineWidth / 2;
            var p1x, p1y, p2x, p2y, p3x, p3y;
            p1x = points[0];
            p1y = points[1];
            p2x = points[2];
            p2y = points[3];
            this.getNormal(p1x, p1y, p2x, p2y, w, vec2$1);
            result.push(p1x - vec2$1.x, p1y - vec2$1.y, p1x + vec2$1.x, p1y + vec2$1.y);
            for (i = 1; i < length - 1; i++) {
                p1x = points[(i - 1) * 2];
                p1y = points[(i - 1) * 2 + 1];
                p2x = points[(i) * 2];
                p2y = points[(i) * 2 + 1];
                p3x = points[(i + 1) * 2];
                p3y = points[(i + 1) * 2 + 1];
                indices.push(indexBase + 0, indexBase + 1, indexBase + 3, indexBase + 3, indexBase + 2, indexBase + 0);
                indexBase += 2;
                indexBase += this._setMiddleVertexs(p1x, p1y, p2x, p2y, p3x, p3y, w, result, vec2$1, indices, indexBase);
            }
            p1x = points[newlen - 4];
            p1y = points[newlen - 3];
            p2x = points[newlen - 2];
            p2y = points[newlen - 1];
            this.getNormal(p1x, p1y, p2x, p2y, w, vec2$1);
            result.push(p2x - vec2$1.x, p2y - vec2$1.y, p2x + vec2$1.x, p2y + vec2$1.y);
            indices.push(indexBase + 0, indexBase + 1, indexBase + 3, indexBase + 3, indexBase + 2, indexBase + 0);
            if (p2x == points[0] && p2y == points[1]) {
                p3x = points[2];
                p3y = points[3];
                let last = result.length / 2;
                indexBase += 4;
                tempIndexs[0] = offset + last - 2;
                tempIndexs[1] = offset + last - 1;
                tempIndexs[2] = offset;
                tempIndexs[3] = offset + 1;
                this._setMiddleVertexs(p1x, p1y, p2x, p2y, p3x, p3y, w, result, vec2$1, indices, indexBase, tempIndexs);
            }
            return result;
        }
        static _setMiddleVertexs(x1, y1, x2, y2, x3, y3, w, vertexs, out, indices, indexBase, edgeIndexArray = null) {
            this.getNormal(x1, y1, x2, y2, w, out);
            let perpx = out.x;
            let perpy = out.y;
            this.getNormal(x2, y2, x3, y3, w, out);
            let perp2x = out.x;
            let perp2y = out.y;
            if (this._checkMinAngle(x1, y1, x2, y2, x3, y3)) {
                if (!edgeIndexArray) {
                    vertexs.push(x2 - perpx, y2 - perpy, x2 + perpx, y2 + perpy);
                    vertexs.push(x2 - perp2x, y2 - perp2y, x2 + perp2x, y2 + perp2y);
                    indices.push(indexBase + 0, indexBase + 1, indexBase + 3, indexBase + 3, indexBase + 2, indexBase + 0);
                }
                else {
                    indices.push(edgeIndexArray[0], edgeIndexArray[1], edgeIndexArray[3], edgeIndexArray[3], edgeIndexArray[2], edgeIndexArray[0]);
                }
                return 2;
            }
            let a1 = (-perpy + y1) - (-perpy + y2);
            let b1 = (-perpx + x2) - (-perpx + x1);
            let c1 = (-perpx + x1) * (-perpy + y2) - (-perpx + x2) * (-perpy + y1);
            let a2 = (-perp2y + y3) - (-perp2y + y2);
            let b2 = (-perp2x + x2) - (-perp2x + x3);
            let c2 = (-perp2x + x3) * (-perp2y + y2) - (-perp2x + x2) * (-perp2y + y3);
            let denom = a1 * b2 - a2 * b1;
            denom = a1 * b2 - a2 * b1;
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                vertexs.push(x2 - perpx, y2 - perpy, x2 + perpx, y2 + perpy);
                return 0;
            }
            let px = (b1 * c2 - b2 * c1) / denom;
            let py = (a2 * c1 - a1 * c2) / denom;
            if (!edgeIndexArray) {
                vertexs.push(x2 - perpx, y2 - perpy, x2 + perpx, y2 + perpy);
                if (denom > 0) {
                    vertexs.push(px, py, x2, y2);
                    indices.push(indexBase + 0, indexBase + 2, indexBase + 4);
                    indices.push(indexBase + 4, indexBase + 3, indexBase + 0);
                }
                else {
                    vertexs.push(x2 - (px - x2), y2 - (py - y2), x2, y2);
                    indices.push(indexBase + 1, indexBase + 2, indexBase + 5);
                    indices.push(indexBase + 5, indexBase + 3, indexBase + 1);
                }
                vertexs.push(x2 - perp2x, y2 - perp2y, x2 + perp2x, y2 + perp2y);
            }
            else {
                if (denom > 0) {
                    vertexs.push(px, py, x2, y2);
                    indices.push(edgeIndexArray[0], indexBase + 0, edgeIndexArray[2]);
                    indices.push(edgeIndexArray[2], indexBase + 1, edgeIndexArray[0]);
                }
                else {
                    vertexs.push(x2 - (px - x2), y2 - (py - y2), x2, y2);
                    indices.push(edgeIndexArray[1], indexBase + 0, edgeIndexArray[3]);
                    indices.push(edgeIndexArray[3], indexBase + 1, edgeIndexArray[1]);
                }
            }
            return 4;
        }
        static getNormal(x1, y1, x2, y2, w, out) {
            if (!out) {
                out = new Vector2();
            }
            let perpx = y2 - y1;
            let perpy = x1 - x2;
            let dist = Math.sqrt(perpx * perpx + perpy * perpy);
            out.x = perpx / dist * w;
            out.y = perpy / dist * w;
            return out;
        }
        static createLineTriangle(path, color, width, loop, outvb, vbstride, outib) {
            var points = path.slice();
            var ptlen = points.length;
            var p1x = points[0], p1y = points[1];
            var p2x = points[2], p2y = points[2];
            var len = 0;
            var rp = 0;
            var dx = 0, dy = 0;
            var pointnum = ptlen / 2;
            if (pointnum <= 1)
                return;
            if (pointnum == 2) {
                return;
            }
            var tmpData = new Array(pointnum * 4);
            var realPtNum = 0;
            var ci = 0;
            for (var i = 0; i < pointnum - 1; i++) {
                p1x = points[ci++], p1y = points[ci++];
                p2x = points[ci++], p2y = points[ci++];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            if (loop) {
                p1x = points[ptlen - 2], p1y = points[ptlen - 1];
                p2x = points[0], p2y = points[1];
                dx = p2x - p1x, dy = p2y - p1y;
                if (dx != 0 && dy != 0) {
                    len = Math.sqrt(dx * dx + dy * dy);
                    if (len > 1e-3) {
                        rp = realPtNum * 4;
                        tmpData[rp] = p1x;
                        tmpData[rp + 1] = p1y;
                        tmpData[rp + 2] = dx / len;
                        tmpData[rp + 3] = dy / len;
                        realPtNum++;
                    }
                }
            }
            else {
                rp = realPtNum * 4;
                tmpData[rp] = p1x;
                tmpData[rp + 1] = p1y;
                tmpData[rp + 2] = dx / len;
                tmpData[rp + 3] = dy / len;
                realPtNum++;
            }
            ci = 0;
            for (i = 0; i < pointnum; i++) {
                p1x = points[ci], p1y = points[ci + 1];
                p2x = points[ci + 2], p2y = points[ci + 3];
            }
        }
    }

    class EarcutNode {
        constructor(i, x, y) {
            this.i = i;
            this.x = x;
            this.y = y;
            this.prev = null;
            this.next = null;
            this.z = null;
            this.prevZ = null;
            this.nextZ = null;
            this.steiner = false;
        }
    }

    class Earcut {
        static earcut(data, holeIndices, dim) {
            dim = dim || 2;
            var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = Earcut.linkedList(data, 0, outerLen, dim, true), triangles = [];
            if (!outerNode)
                return triangles;
            var minX, minY, maxX, maxY, x, y, invSize;
            if (hasHoles)
                outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
            if (data.length > 80 * dim) {
                minX = maxX = data[0];
                minY = maxY = data[1];
                for (var i = dim; i < outerLen; i += dim) {
                    x = data[i];
                    y = data[i + 1];
                    if (x < minX)
                        minX = x;
                    if (y < minY)
                        minY = y;
                    if (x > maxX)
                        maxX = x;
                    if (y > maxY)
                        maxY = y;
                }
                invSize = Math.max(maxX - minX, maxY - minY);
                invSize = invSize !== 0 ? 1 / invSize : 0;
            }
            Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
            return triangles;
        }
        static linkedList(data, start, end, dim, clockwise) {
            var i, last;
            if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
                for (i = start; i < end; i += dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            else {
                for (i = end - dim; i >= start; i -= dim)
                    last = Earcut.insertNode(i, data[i], data[i + 1], last);
            }
            if (last && Earcut.equals(last, last.next)) {
                Earcut.removeNode(last);
                last = last.next;
            }
            return last;
        }
        static filterPoints(start, end) {
            if (!start)
                return start;
            if (!end)
                end = start;
            var p = start, again;
            do {
                again = false;
                if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
                    Earcut.removeNode(p);
                    p = end = p.prev;
                    if (p === p.next)
                        break;
                    again = true;
                }
                else {
                    p = p.next;
                }
            } while (again || p !== end);
            return end;
        }
        static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
            if (!ear)
                return;
            if (!pass && invSize)
                Earcut.indexCurve(ear, minX, minY, invSize);
            var stop = ear, prev, next;
            while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;
                if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
                    triangles.push(prev.i / dim);
                    triangles.push(ear.i / dim);
                    triangles.push(next.i / dim);
                    Earcut.removeNode(ear);
                    ear = next.next;
                    stop = next.next;
                    continue;
                }
                ear = next;
                if (ear === stop) {
                    if (!pass) {
                        Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
                    }
                    else if (pass === 1) {
                        ear = Earcut.cureLocalIntersections(ear, triangles, dim);
                        Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    }
                    else if (pass === 2) {
                        Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                    }
                    break;
                }
            }
        }
        static isEar(ear) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var p = ear.next.next;
            while (p !== ear.prev) {
                if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.next;
            }
            return true;
        }
        static isEarHashed(ear, minX, minY, invSize) {
            var a = ear.prev, b = ear, c = ear.next;
            if (Earcut.area(a, b, c) >= 0)
                return false;
            var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
            var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize), maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
            var p = ear.nextZ;
            while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.nextZ;
            }
            p = ear.prevZ;
            while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next &&
                    Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                    Earcut.area(p.prev, p, p.next) >= 0)
                    return false;
                p = p.prevZ;
            }
            return true;
        }
        static cureLocalIntersections(start, triangles, dim) {
            var p = start;
            do {
                var a = p.prev, b = p.next.next;
                if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
                    triangles.push(a.i / dim);
                    triangles.push(p.i / dim);
                    triangles.push(b.i / dim);
                    Earcut.removeNode(p);
                    Earcut.removeNode(p.next);
                    p = start = b;
                }
                p = p.next;
            } while (p !== start);
            return p;
        }
        static splitEarcut(start, triangles, dim, minX, minY, invSize) {
            var a = start;
            do {
                var b = a.next.next;
                while (b !== a.prev) {
                    if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
                        var c = Earcut.splitPolygon(a, b);
                        a = Earcut.filterPoints(a, a.next);
                        c = Earcut.filterPoints(c, c.next);
                        Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
                        Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
                        return;
                    }
                    b = b.next;
                }
                a = a.next;
            } while (a !== start);
        }
        static eliminateHoles(data, holeIndices, outerNode, dim) {
            var queue = [], i, len, start, end, list;
            for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                list = Earcut.linkedList(data, start, end, dim, false);
                if (list === list.next)
                    list.steiner = true;
                queue.push(Earcut.getLeftmost(list));
            }
            queue.sort(Earcut.compareX);
            for (i = 0; i < queue.length; i++) {
                Earcut.eliminateHole(queue[i], outerNode);
                outerNode = Earcut.filterPoints(outerNode, outerNode.next);
            }
            return outerNode;
        }
        static compareX(a, b) {
            return a.x - b.x;
        }
        static eliminateHole(hole, outerNode) {
            outerNode = Earcut.findHoleBridge(hole, outerNode);
            if (outerNode) {
                var b = Earcut.splitPolygon(outerNode, hole);
                Earcut.filterPoints(b, b.next);
            }
        }
        static findHoleBridge(hole, outerNode) {
            var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
            do {
                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                    if (x <= hx && x > qx) {
                        qx = x;
                        if (x === hx) {
                            if (hy === p.y)
                                return p;
                            if (hy === p.next.y)
                                return p.next;
                        }
                        m = p.x < p.next.x ? p : p.next;
                    }
                }
                p = p.next;
            } while (p !== outerNode);
            if (!m)
                return null;
            if (hx === qx)
                return m.prev;
            var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
            p = m.next;
            while (p !== stop) {
                if (hx >= p.x && p.x >= mx && hx !== p.x &&
                    Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                    tan = Math.abs(hy - p.y) / (hx - p.x);
                    if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
                        m = p;
                        tanMin = tan;
                    }
                }
                p = p.next;
            }
            return m;
        }
        static indexCurve(start, minX, minY, invSize) {
            var p = start;
            do {
                if (p.z === null)
                    p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
            } while (p !== start);
            p.prevZ.nextZ = null;
            p.prevZ = null;
            Earcut.sortLinked(p);
        }
        static sortLinked(list) {
            var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
            do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;
                while (p) {
                    numMerges++;
                    q = p;
                    pSize = 0;
                    for (i = 0; i < inSize; i++) {
                        pSize++;
                        q = q.nextZ;
                        if (!q)
                            break;
                    }
                    qSize = inSize;
                    while (pSize > 0 || (qSize > 0 && q)) {
                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                            e = p;
                            p = p.nextZ;
                            pSize--;
                        }
                        else {
                            e = q;
                            q = q.nextZ;
                            qSize--;
                        }
                        if (tail)
                            tail.nextZ = e;
                        else
                            list = e;
                        e.prevZ = tail;
                        tail = e;
                    }
                    p = q;
                }
                tail.nextZ = null;
                inSize *= 2;
            } while (numMerges > 1);
            return list;
        }
        static zOrder(x, y, minX, minY, invSize) {
            x = 32767 * (x - minX) * invSize;
            y = 32767 * (y - minY) * invSize;
            x = (x | (x << 8)) & 0x00FF00FF;
            x = (x | (x << 4)) & 0x0F0F0F0F;
            x = (x | (x << 2)) & 0x33333333;
            x = (x | (x << 1)) & 0x55555555;
            y = (y | (y << 8)) & 0x00FF00FF;
            y = (y | (y << 4)) & 0x0F0F0F0F;
            y = (y | (y << 2)) & 0x33333333;
            y = (y | (y << 1)) & 0x55555555;
            return x | (y << 1);
        }
        static getLeftmost(start) {
            var p = start, leftmost = start;
            do {
                if (p.x < leftmost.x)
                    leftmost = p;
                p = p.next;
            } while (p !== start);
            return leftmost;
        }
        static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
        }
        static isValidDiagonal(a, b) {
            return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
                Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
        }
        static area(p, q, r) {
            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        }
        static equals(p1, p2) {
            return p1.x === p2.x && p1.y === p2.y;
        }
        static intersects(p1, q1, p2, q2) {
            if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
                (Earcut.equals(p1, q2) && Earcut.equals(p2, q1)))
                return true;
            return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
                Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
        }
        static intersectsPolygon(a, b) {
            var p = a;
            do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                    Earcut.intersects(p, p.next, a, b))
                    return true;
                p = p.next;
            } while (p !== a);
            return false;
        }
        static locallyInside(a, b) {
            return Earcut.area(a.prev, a, a.next) < 0 ?
                Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
                Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
        }
        static middleInside(a, b) {
            var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
            do {
                if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                    (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                    inside = !inside;
                p = p.next;
            } while (p !== a);
            return inside;
        }
        static splitPolygon(a, b) {
            var a2 = new EarcutNode(a.i, a.x, a.y), b2 = new EarcutNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
            a.next = b;
            b.prev = a;
            a2.next = an;
            an.prev = a2;
            b2.next = a2;
            a2.prev = b2;
            bp.next = b2;
            b2.prev = bp;
            return b2;
        }
        static insertNode(i, x, y, last) {
            var p = new EarcutNode(i, x, y);
            if (!last) {
                p.prev = p;
                p.next = p;
            }
            else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
            }
            return p;
        }
        static removeNode(p) {
            p.next.prev = p.prev;
            p.prev.next = p.next;
            if (p.prevZ)
                p.prevZ.nextZ = p.nextZ;
            if (p.nextZ)
                p.nextZ.prevZ = p.prevZ;
        }
        static signedArea(data, start, end, dim) {
            var sum = 0;
            for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                j = i;
            }
            return sum;
        }
    }

    class SubmitKey {
        constructor() {
            this.clear();
        }
        clear() {
            this.submitType = -1;
            this.blendShader = this.other = 0;
        }
    }

    class SubmitBase {
        constructor() {
            this.clipInfoID = -1;
            this.blendType = -1;
            this._id = 0;
            this._renderType = 0;
            this._key = new SubmitKey();
            this._startIdx = 0;
            this._numEle = 0;
            this._colorFiler = null;
            this.shaderValue = null;
            this._id = ++SubmitBase.ID;
        }
        static create(context, mesh, sv) {
            var o = new SubmitBase();
            o._mesh = mesh;
            o._key.clear();
            o._key.submitType = SubmitBase.KEY_DRAWTEXTURE;
            o._startIdx = mesh.indexNum * Const.INDEX_BYTES;
            o._numEle = 0;
            var blendType = context._nBlendType;
            o._key.blendShader = blendType;
            o.shaderValue = sv;
            o.material = context._material;
            o._colorFiler = context._colorFiler;
            return o;
        }
    }
    SubmitBase.KEY_ONCE = -1;
    SubmitBase.KEY_FILLRECT = 1;
    SubmitBase.KEY_DRAWTEXTURE = 2;
    SubmitBase.KEY_VG = 3;
    SubmitBase.KEY_TRIANGLES = 4;
    SubmitBase.ID = 1;
    SubmitBase.RENDERBASE = new SubmitBase();

    class RenderInfo {
    }
    RenderInfo.loopStTm = 0;
    RenderInfo.loopCount = 0;

    class CharSubmitCache {
        constructor(ctx) {
            this._data = [];
            this._ndata = 0;
            this._clipid = -1;
            this._clipMatrix = new Matrix();
            this._enable = false;
            this._clipid = ctx._clipInfoID;
            ctx._globalClipMatrix.copyTo(this._clipMatrix);
        }
        clear() {
            this._tex = null;
            this._imgId = -1;
            this._ndata = 0;
            this._enable = false;
            this._colorFiler = null;
        }
        destroy() {
            this.clear();
            this._data.length = 0;
            this._data = null;
        }
        add(ctx, tex, imgid, pos, uv, color) {
            if (this._ndata > 0 && (this._tex != tex || this._imgId != imgid ||
                (this._clipid >= 0 && this._clipid != ctx._clipInfoID))) {
                this.submit(ctx);
            }
            this._clipid = ctx._clipInfoID;
            ctx._globalClipMatrix.copyTo(this._clipMatrix);
            this._tex = tex;
            this._imgId = imgid;
            this._colorFiler = ctx._colorFiler;
            this._data[this._ndata] = pos;
            this._data[this._ndata + 1] = uv;
            this._data[this._ndata + 2] = color;
            this._ndata += 3;
        }
        getPos() {
            if (CharSubmitCache.__nPosPool == 0)
                return new Array(8);
            return CharSubmitCache.__posPool[--CharSubmitCache.__nPosPool];
        }
        enable(value, ctx) {
            if (value === this._enable)
                return;
            this._enable = value;
            this._enable || this.submit(ctx);
        }
        submit(ctx) {
            var n = this._ndata;
            if (!n)
                return;
            ctx.drawLeftData();
            let shaderValue = Value2D.create(exports.RenderSpriteData.Texture2D);
            ctx.fillShaderValue(shaderValue);
            shaderValue.textureHost = this._tex;
            let _mesh = ctx._mesh = ctx._meshQuatTex;
            let submit = ctx._curSubmit = SubmitBase.create(ctx, _mesh, shaderValue);
            submit._key.other = this._imgId;
            submit._colorFiler = this._colorFiler;
            var cm = shaderValue.clipMatDir;
            let clipInfo = this._clipMatrix;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            shaderValue.clipMatDir = cm;
            var cmp = shaderValue.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty;
            shaderValue.clipMatPos = cmp;
            submit.clipInfoID = this._clipid;
            for (var i = 0; i < n; i += 3) {
                _mesh.addQuad(this._data[i], this._data[i + 1], this._data[i + 2], true);
                CharSubmitCache.__posPool[CharSubmitCache.__nPosPool++] = this._data[i];
            }
            this._ndata = 0;
            if (RenderInfo.loopCount % 100 == 0)
                this._data.length = 0;
            ctx.drawLeftData();
        }
    }
    CharSubmitCache.__posPool = [];
    CharSubmitCache.__nPosPool = 0;

    class AtlasGrid {
        constructor(width = 0, height = 0, id = 0) {
            this.atlasID = 0;
            this._width = 0;
            this._height = 0;
            this._texCount = 0;
            this._rowInfo = null;
            this._cells = null;
            this._used = 0;
            this._cells = null;
            this._rowInfo = null;
            this.atlasID = id;
            this._init(width, height);
        }
        addRect(type, width, height, pt) {
            if (!this._get(width, height, pt))
                return false;
            this._fill(pt.x, pt.y, width, height, type);
            this._texCount++;
            return true;
        }
        _release() {
            this._cells = null;
            this._rowInfo = null;
        }
        _init(width, height) {
            this._width = width;
            this._height = height;
            this._release();
            if (this._width == 0)
                return false;
            this._cells = new Uint8Array(this._width * this._height * 3);
            this._rowInfo = new Uint8Array(this._height);
            this._used = 0;
            this._clear();
            return true;
        }
        _get(width, height, pt) {
            if (width > this._width || height > this._height) {
                return false;
            }
            var rx = -1;
            var ry = -1;
            var nWidth = this._width;
            var nHeight = this._height;
            var pCellBox = this._cells;
            for (var y = 0; y < nHeight; y++) {
                if (this._rowInfo[y] < width)
                    continue;
                for (var x = 0; x < nWidth;) {
                    var tm = (y * nWidth + x) * 3;
                    if (pCellBox[tm] !== 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    rx = x;
                    ry = y;
                    for (var xx = 0; xx < width; xx++) {
                        if (pCellBox[3 * xx + tm + 2] < height) {
                            rx = -1;
                            break;
                        }
                    }
                    if (rx < 0) {
                        x += pCellBox[tm + 1];
                        continue;
                    }
                    pt.x = rx;
                    pt.y = ry;
                    return true;
                }
            }
            return false;
        }
        _fill(x, y, w, h, type) {
            var nWidth = this._width;
            var nHeghit = this._height;
            this._check((x + w) <= nWidth && (y + h) <= nHeghit);
            for (var yy = y; yy < (h + y); ++yy) {
                this._check(this._rowInfo[yy] >= w);
                this._rowInfo[yy] -= w;
                for (var xx = 0; xx < w; xx++) {
                    var tm = (x + yy * nWidth + xx) * 3;
                    this._check(this._cells[tm] === 0);
                    this._cells[tm] = type;
                    this._cells[tm + 1] = w;
                    this._cells[tm + 2] = h;
                }
            }
            if (x > 0) {
                for (yy = 0; yy < h; ++yy) {
                    var s = 0;
                    for (xx = x - 1; xx >= 0; --xx, ++s) {
                        if (this._cells[((y + yy) * nWidth + xx) * 3] !== 0)
                            break;
                    }
                    for (xx = s; xx > 0; --xx) {
                        this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
                        this._check(xx > 0);
                    }
                }
            }
            if (y > 0) {
                for (xx = x; xx < (x + w); ++xx) {
                    s = 0;
                    for (yy = y - 1; yy >= 0; --yy, s++) {
                        if (this._cells[(xx + yy * nWidth) * 3] !== 0)
                            break;
                    }
                    for (yy = s; yy > 0; --yy) {
                        this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
                        this._check(yy > 0);
                    }
                }
            }
            this._used += (w * h) / (this._width * this._height);
        }
        _check(ret) {
            if (ret == false) {
                console.log("xtexMerger 错误啦");
            }
        }
        _clear() {
            this._texCount = 0;
            for (var y = 0; y < this._height; y++) {
                this._rowInfo[y] = this._width;
            }
            for (var i = 0; i < this._height; i++) {
                for (var j = 0; j < this._width; j++) {
                    var tm = (i * this._width + j) * 3;
                    this._cells[tm] = 0;
                    this._cells[tm + 1] = this._width - j;
                    this._cells[tm + 2] = this._width - i;
                }
            }
        }
    }

    exports.WrapMode = void 0;
    (function (WrapMode) {
        WrapMode[WrapMode["Repeat"] = 0] = "Repeat";
        WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
        WrapMode[WrapMode["Mirrored"] = 2] = "Mirrored";
    })(exports.WrapMode || (exports.WrapMode = {}));

    class Render {
        static __init__() {
            let ctx = new Context();
            ctx.isMain = true;
            Render._context = ctx;
            Browser.mainCanvas.context = ctx;
            Render.frameInterval = 1000 / Config.FPS;
            let timeId = 0;
            PAL.browser.on("visibilitychange", (visible) => {
                if (!visible)
                    timeId = window.setInterval(Render.loop, 1000);
                else if (timeId != 0)
                    window.clearInterval(timeId);
            });
            Render.startLoop();
        }
        static startLoop() {
            performance.now();
            let first = true;
            let startTm = 0;
            let requestFrame = PAL.browser.requestFrame;
            function loop(stamp) {
                performance.now();
                if (first) {
                    startTm = Math.floor(stamp / Render.frameInterval) * Render.frameInterval;
                    first = false;
                }
                stamp -= startTm;
                let frm = Math.floor(stamp / Render.frameInterval);
                let dfrm = frm - Render.lastFrame;
                if (dfrm > 0 || !Config.fixedFrames) {
                    Render.lastFrame = frm;
                    Render.loop();
                }
                requestFrame(loop);
            }
            requestFrame(loop);
        }
        static loop() {
            this._globalRepaintGet = this._globalRepaintSet;
            this._globalRepaintSet = false;
            ILaya.stage.render(Render._context, 0, 0);
        }
        static vsyncTime() {
            return Render.lastFrame * Render.frameInterval;
        }
        static isGlobalRepaint() {
            return Render._globalRepaintGet;
        }
        static setGlobalRepaint() {
            Render._globalRepaintSet = true;
        }
        static get canvas() {
            return Browser.mainCanvas.source;
        }
    }
    Render.frameInterval = 1000 / 60;
    Render.lastFrame = 0;
    Render._globalRepaintSet = false;
    Render._globalRepaintGet = false;

    class TextRenderConfig {
    }
    TextRenderConfig.maxCanvasWidth = 4096;
    TextRenderConfig.atlasWidth = 1024;
    TextRenderConfig.atlasGridW = 16;
    TextRenderConfig.noAtlas = false;
    TextRenderConfig.forceSplitRender = false;
    TextRenderConfig.forceWholeRender = false;
    TextRenderConfig.scaleFontWithCtx = true;
    TextRenderConfig.maxFontScale = 4;
    TextRenderConfig.standardFontSize = 32;
    TextRenderConfig.destroyAtlasDt = 10;
    TextRenderConfig.checkCleanTextureDt = 2000;
    TextRenderConfig.destroyUnusedTextureDt = 10;
    TextRenderConfig.cleanMem = 100 * 1024 * 1024;
    TextRenderConfig.showLog = false;
    TextRenderConfig.debugUV = false;
    TextRenderConfig.simClean = false;
    TextRenderConfig.debugCharCanvas = false;
    TextRenderConfig.useImageData = true;

    class TextTexture extends Texture2D {
        constructor(textureW, textureH) {
            super(textureW, textureH, exports.TextureFormat.R8G8B8A8, false, false, true, true);
            this.genID = 0;
            this.curUsedCovRate = 0;
            this.curUsedCovRateAtlas = 0;
            this.lastTouchTm = 0;
            this.ri = null;
            this._discardTm = 0;
            this.setPixelsData(null, true, false);
            this.lock = true;
            this.filterMode = exports.FilterMode.Bilinear;
            this.wrapModeU = exports.WrapMode.Clamp;
            this.wrapModeV = exports.WrapMode.Clamp;
            if (TextRenderConfig.debugUV) {
                this.fillWhite();
            }
        }
        addChar(data, x, y, uv) {
            if (TextRenderConfig.useImageData) {
                var dt = data.data;
                if (data.data instanceof Uint8ClampedArray)
                    dt = new Uint8Array(dt.buffer);
                LayaGL.textureContext.setTextureSubPixelsData(this._texture, dt, 0, false, x, y, data.width, data.height, true, false);
            }
            else {
                LayaGL.textureContext.setTextureSubImageData(this._texture, data, x, y, true, false);
            }
            let u0;
            let v0;
            let u1;
            let v1;
            if (LayaEnv.isConch || dt != null) {
                u0 = x / this.width;
                v0 = y / this.height;
                u1 = (x + data.width) / this.width;
                v1 = (y + data.height) / this.height;
            }
            else {
                u0 = (x + 1) / this.width;
                v0 = (y + 1) / this.height;
                u1 = (x + data.width - 1) / this.width;
                v1 = (y + data.height - 1) / this.height;
            }
            uv = uv || new Array(8);
            uv[0] = u0, uv[1] = v0;
            uv[2] = u1, uv[3] = v0;
            uv[4] = u1, uv[5] = v1;
            uv[6] = u0, uv[7] = v1;
            return uv;
        }
        fillWhite() {
            var dt = new Uint8Array(this.width * this.height * 4);
            dt.fill(0xff);
            LayaGL.textureContext.setTextureImageData(this._getSource(), dt, true, false);
        }
        discard() {
            Render.setGlobalRepaint();
            this.destroy();
            return;
        }
        static getTextTexture(w, h) {
            return new TextTexture(w, h);
        }
        static clean() {
            var curtm = RenderInfo.loopStTm;
            if (TextTexture.cleanTm === 0)
                TextTexture.cleanTm = curtm;
            if (curtm - TextTexture.cleanTm >= TextRenderConfig.checkCleanTextureDt) {
                for (let i = 0; i < TextTexture.poolLen; i++) {
                    var p = TextTexture.pool[i];
                    if (curtm - p._discardTm >= TextRenderConfig.destroyUnusedTextureDt) {
                        p.destroy();
                        TextTexture.pool[i] = TextTexture.pool[TextTexture.poolLen - 1];
                        TextTexture.poolLen--;
                        i--;
                    }
                }
                TextTexture.cleanTm = curtm;
            }
        }
        touchTexture() {
            let frame = RenderInfo.loopCount;
            if (this.lastTouchTm != frame) {
                this.curUsedCovRate = 0;
                this.curUsedCovRateAtlas = 0;
                this.lastTouchTm = frame;
            }
        }
        touchRect(ri, frame) {
            if (this.lastTouchTm != frame) {
                this.curUsedCovRate = 0;
                this.curUsedCovRateAtlas = 0;
                this.lastTouchTm = frame;
            }
            var texw2 = TextRenderConfig.atlasWidth * TextRenderConfig.atlasWidth;
            var gridw2 = TextRenderConfig.atlasGridW * TextRenderConfig.atlasGridW;
            this.curUsedCovRate += (ri.bmpWidth * ri.bmpHeight) / texw2;
            this.curUsedCovRateAtlas += (Math.ceil(ri.bmpWidth / TextRenderConfig.atlasGridW) * Math.ceil(ri.bmpHeight / TextRenderConfig.atlasGridW)) / (texw2 / gridw2);
        }
    }
    TextTexture.pool = new Array(10);
    TextTexture.poolLen = 0;
    TextTexture.cleanTm = 0;

    class TextAtlas {
        constructor() {
            this.texWidth = 1024;
            this.texHeight = 1024;
            this.texture = null;
            this.charMaps = {};
            this.texHeight = this.texWidth = TextRenderConfig.atlasWidth;
            this.texture = TextTexture.getTextTexture(this.texWidth, this.texHeight);
            if (this.texWidth / TextRenderConfig.atlasGridW > 256) {
                TextRenderConfig.atlasGridW = Math.ceil(this.texWidth / 256);
            }
            this.atlasgrid = new AtlasGrid(this.texWidth / TextRenderConfig.atlasGridW, this.texHeight / TextRenderConfig.atlasGridW, this.texture.id);
        }
        setProtecteDist(d) {
        }
        getAEmpty(w, h, pt) {
            var find = this.atlasgrid.addRect(1, Math.ceil(w / TextRenderConfig.atlasGridW), Math.ceil(h / TextRenderConfig.atlasGridW), pt);
            if (find) {
                pt.x *= TextRenderConfig.atlasGridW;
                pt.y *= TextRenderConfig.atlasGridW;
            }
            return find;
        }
        get usedRate() {
            return this.atlasgrid._used;
        }
        destroy() {
            for (var k in this.charMaps) {
                var ri = this.charMaps[k];
                ri.deleted = true;
            }
            this.texture.discard();
        }
        printDebugInfo() {
        }
    }

    class FontInfo {
        static parse(font) {
            if (font === _lastFont) {
                return _lastFontInfo;
            }
            let r = FontInfo._cache[font];
            if (!r) {
                r = FontInfo._cache[font] = new FontInfo(font);
            }
            _lastFont = font;
            _lastFontInfo = r;
            return r;
        }
        constructor(font) {
            this._family = "Arial";
            this._size = 14;
            this._italic = false;
            this._bold = false;
            this.setFont(font || "14px Arial");
        }
        setFont(value) {
            this._font = value;
            var words = value.split(' ');
            var l = words.length;
            if (l < 2) {
                if (l == 1) {
                    if (words[0].indexOf('px') > 0) {
                        this._size = parseInt(words[0]);
                    }
                }
                return;
            }
            var szpos = -1;
            for (let i = 0; i < l; i++) {
                if (words[i].indexOf('px') > 0 || words[i].indexOf('pt') > 0) {
                    szpos = i;
                    this._size = parseInt(words[i]);
                    if (this._size <= 0) {
                        console.debug('font parse error:' + value);
                        this._size = 14;
                    }
                    break;
                }
            }
            var fpos = szpos + 1;
            var familys = words[fpos];
            fpos++;
            for (; fpos < l; fpos++) {
                familys += ' ' + words[fpos];
            }
            this._family = (familys.split(','))[0];
            this._italic = words.indexOf('italic') >= 0;
            this._bold = words.indexOf('bold') >= 0;
        }
    }
    FontInfo._cache = {};
    var _lastFont = '';
    var _lastFontInfo;

    class WordText$1 {
        constructor() {
            this.pagecharsCtx = null;
            this.width = -1;
            this.pageChars = [];
            this.scalex = 1;
            this.scaley = 1;
        }
        setText(txt) {
            this.text = txt;
            if (this._nativeObj)
                this._nativeObj._text = txt;
            else
                this.width = -1;
            this.cleanCache();
        }
        toString() {
            return this.text;
        }
        get length() {
            return this.text ? this.text.length : 0;
        }
        cleanCache() {
            if (this._nativeObj) {
                this._nativeObj.cleanCache();
                return;
            }
            let chars = this.pageChars;
            if (chars.length > 0) {
                for (var i in chars) {
                    let p = chars[i];
                    if (!p)
                        continue;
                    let tex = p.tex;
                    let words = p.words;
                    if (words.length == 1 && tex && tex.ri) {
                        tex.destroy();
                    }
                }
                this.pageChars = [];
            }
            this.scalex = 1;
            this.scaley = 1;
        }
        get splitRender() {
            return this._splitRender;
        }
        set splitRender(value) {
            this._splitRender = value;
            if (this._nativeObj)
                this._nativeObj.splitRender = value;
        }
    }

    class CharRenderInfo {
        constructor() {
            this.isRandomTouch = true;
            this.char = '';
            this.deleted = false;
            this.uv = new Array(8);
            this.pos = 0;
            this.orix = 0;
            this.oriy = 0;
            this.touchTick = 0;
            this.isSpace = false;
        }
        touch() {
            var curLoop = RenderInfo.loopCount;
            if (this.touchTick != curLoop) {
                this.texture.touchRect(this, curLoop);
                this.touchTick = curLoop;
            }
        }
    }

    class CharRender_Canvas {
        constructor(maxw, maxh) {
            this.fontsz = 16;
            this.lastScaleX = 1.0;
            this.lastScaleY = 1.0;
            this.maxTexW = 0;
            this.maxTexH = 0;
            this.maxTexW = maxw;
            this.maxTexH = maxh;
            let canvas = Browser.createElement("canvas");
            this.canvas = canvas;
            canvas.width = 1024;
            canvas.height = 512;
            if (Browser.isDomSupported) {
                canvas.style.left = "-10000px";
                canvas.style.position = "absolute";
                Browser.document.body.appendChild(canvas);
            }
            this.ctx = canvas.getContext('2d', { willReadFrequently: true });
        }
        get canvasWidth() {
            return this.canvas.width;
        }
        set canvasWidth(w) {
            if (this.canvas.width == w)
                return;
            this.canvas.width = w;
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.scale(this.lastScaleX, this.lastScaleY);
        }
        getWidth(font, str) {
            if (this.lastFont != font) {
                this.ctx.font = font;
                this.lastFont = font;
            }
            return this.ctx.measureText(str).width;
        }
        scale(sx, sy) {
            if (!TextRenderConfig.useImageData) {
                this.lastScaleX = sx;
                this.lastScaleY = sy;
                return;
            }
            if (this.lastScaleX != sx || this.lastScaleY != sy) {
                this.ctx.setTransform(sx, 0, 0, sy, 0, 0);
                this.lastScaleX = sx;
                this.lastScaleY = sy;
            }
        }
        getCharBmp(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom, rect) {
            var ctx = this.ctx;
            var sz = this.fontsz;
            if (ctx.font != font) {
                ctx.font = font;
                ctx._lastFont = font;
            }
            cri.width = ctx.measureText(char).width;
            var w = cri.width * this.lastScaleX;
            var h = cri.height * this.lastScaleY;
            w += (margin_left + margin_right) * this.lastScaleX;
            h += (margin_top + margin_bottom) * this.lastScaleY;
            w = Math.ceil(w);
            h = Math.ceil(h);
            w = Math.min(w, this.canvas.width);
            h = Math.min(h, this.canvas.height);
            var clearW = w + lineWidth * 2 + 1;
            var clearH = h + lineWidth * 2 + 1;
            if (rect) {
                clearW = Math.max(clearW, rect[0] + rect[2] + 1);
                clearH = Math.max(clearH, rect[1] + rect[3] + 1);
            }
            ctx.clearRect(0, 0, clearW / this.lastScaleX + 1, clearH / this.lastScaleY + 1);
            ctx.save();
            ctx.textBaseline = "middle";
            if (lineWidth > 0) {
                ctx.lineJoin = "round";
                ctx.strokeStyle = strokeColStr;
                ctx.lineWidth = lineWidth;
                ctx.strokeText(char, margin_left, margin_top + sz / 2);
            }
            if (colStr) {
                ctx.fillStyle = colStr;
                ctx.fillText(char, margin_left, margin_top + sz / 2);
            }
            if (TextRenderConfig.debugCharCanvas) {
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(1, 1, w - 2, h - 2);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(margin_left, margin_top, cri.width, cri.height);
            }
            if (rect) {
                if (rect[2] <= 0)
                    rect[2] = Math.ceil(-rect[2] + (cri.width + lineWidth * 2) * this.lastScaleX);
                if (rect[2] <= 0)
                    rect[2] = 1;
            }
            var imgdt = rect ? (ctx.getImageData(rect[0], rect[1], rect[2], rect[3] + 1)) : (ctx.getImageData(0, 0, w, h + 1));
            ctx.restore();
            cri.bmpWidth = imgdt.width;
            cri.bmpHeight = imgdt.height;
            return imgdt;
        }
        getCharCanvas(char, font, lineWidth, colStr, strokeColStr, cri, margin_left, margin_top, margin_right, margin_bottom) {
            var ctx = this.ctx;
            if (ctx.font != font) {
                ctx.font = font;
                ctx._lastFont = font;
            }
            if (Browser.isIOSHighPerformanceModePlus) {
                ctx.font = font;
            }
            cri.width = ctx.measureText(char).width;
            var w = cri.width * this.lastScaleX;
            var h = cri.height * this.lastScaleY;
            w += (margin_left + margin_right) * this.lastScaleX;
            h += ((margin_top + margin_bottom) * this.lastScaleY + 1);
            w = Math.min(Math.ceil(w), this.maxTexW);
            h = Math.min(Math.ceil(h), this.maxTexH);
            this.canvas.width = Math.min(w + 1, this.maxTexW);
            this.canvas.height = Math.min(h + 1, this.maxTexH);
            ctx.font = font;
            ctx.clearRect(0, 0, w + 1 + lineWidth, h + 1 + lineWidth);
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.save();
            if (TextRenderConfig.scaleFontWithCtx) {
                ctx.scale(this.lastScaleX, this.lastScaleY);
            }
            ctx.translate(margin_left, margin_top);
            ctx.textAlign = "left";
            var sz = this.fontsz;
            ctx.textBaseline = "middle";
            if (lineWidth > 0) {
                ctx.lineJoin = "round";
                ctx.strokeStyle = strokeColStr;
                ctx.fillStyle = colStr;
                ctx.lineWidth = lineWidth;
                if (ctx.fillAndStrokeText) {
                    ctx.fillAndStrokeText(char, 0, sz / 2);
                }
                else {
                    ctx.strokeText(char, 0, sz / 2);
                    ctx.fillText(char, 0, sz / 2);
                }
            }
            else if (colStr) {
                ctx.fillStyle = colStr;
                ctx.fillText(char, 0, sz / 2);
            }
            if (TextRenderConfig.debugCharCanvas) {
                ctx.strokeStyle = '#ff0000';
                ctx.strokeRect(0, 0, w, h);
                ctx.strokeStyle = '#00ff00';
                ctx.strokeRect(0, 0, cri.width, cri.height);
            }
            ctx.restore();
            cri.bmpWidth = this.canvas.width;
            cri.bmpHeight = this.canvas.height;
            return this.canvas;
        }
    }

    var pixelBBX = [0, 0, 0, 0];
    const tmpRI = new CharRenderInfo();
    class MeasureFont {
        constructor(charRender) {
            this.charRender = charRender;
        }
        getFontSizeInfo(font, size) {
            let fontstr = 'bold ' + size + 'px ' + font;
            if (!TextRenderConfig.useImageData) {
                let fontSizeW = this.charRender.getWidth(fontstr, '有') * 1.5;
                let fontSizeH = size * 1.5;
                var szinfo = fontSizeW << 8 | fontSizeH;
                return szinfo;
            }
            pixelBBX[0] = size / 2;
            pixelBBX[1] = size / 2;
            pixelBBX[2] = size;
            pixelBBX[3] = size;
            var orix = 16;
            var oriy = 16;
            var marginr = 16;
            var marginb = 16;
            this.charRender.scale(1, 1);
            tmpRI.height = size;
            this.charRender.fontsz = size;
            var bmpdt = this.charRender.getCharBmp('g', fontstr, 0, 'red', null, tmpRI, orix, oriy, marginr, marginb);
            this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
            this.updateBbx(bmpdt, pixelBBX, false);
            bmpdt = this.charRender.getCharBmp('有', fontstr, 0, 'red', null, tmpRI, oriy, oriy, marginr, marginb);
            this.bmpData32 = new Uint32Array(bmpdt.data.buffer);
            if (pixelBBX[2] < orix + tmpRI.width)
                pixelBBX[2] = orix + tmpRI.width;
            this.updateBbx(bmpdt, pixelBBX, false);
            var xoff = Math.max(orix - pixelBBX[0], 0);
            var yoff = Math.max(oriy - pixelBBX[1], 0);
            var bbxw = pixelBBX[2] - pixelBBX[0];
            var bbxh = pixelBBX[3] - pixelBBX[1];
            var sizeinfo = xoff << 24 | yoff << 16 | bbxw << 8 | bbxh;
            return sizeinfo;
        }
        checkBmpLine(data, l, sx, ex) {
            if (this.bmpData32.buffer != data.data.buffer) {
                this.bmpData32 = new Uint32Array(data.data.buffer);
            }
            var stpos = data.width * l + sx;
            for (var x = sx; x < ex; x++) {
                if (this.bmpData32[stpos++] != 0)
                    return true;
            }
            return false;
        }
        updateBbx(data, curbbx, onlyH = false) {
            var w = data.width;
            var h = data.height;
            var x = 0;
            var sy = curbbx[1];
            var ey = 0;
            var y = sy;
            if (this.checkBmpLine(data, sy, 0, w)) {
                while (true) {
                    y = (sy + ey) / 2 | 0;
                    if (y + 1 >= sy) {
                        curbbx[1] = y;
                        break;
                    }
                    if (this.checkBmpLine(data, y, 0, w)) {
                        sy = y;
                    }
                    else {
                        ey = y;
                    }
                }
            }
            if (curbbx[3] > h)
                curbbx[3] = h;
            else {
                y = sy = curbbx[3];
                ey = h;
                if (this.checkBmpLine(data, sy, 0, w)) {
                    while (true) {
                        y = (sy + ey) / 2 | 0;
                        if (y - 1 <= sy) {
                            curbbx[3] = y;
                            break;
                        }
                        if (this.checkBmpLine(data, y, 0, w)) {
                            sy = y;
                        }
                        else {
                            ey = y;
                        }
                    }
                }
            }
            if (onlyH)
                return;
            var minx = curbbx[0];
            var stpos = w * curbbx[1];
            for (y = curbbx[1]; y < curbbx[3]; y++) {
                for (x = 0; x < minx; x++) {
                    if (this.bmpData32[stpos + x] != 0) {
                        minx = x;
                        break;
                    }
                }
                stpos += w;
            }
            curbbx[0] = minx;
            var maxx = curbbx[2];
            stpos = w * curbbx[1];
            for (y = curbbx[1]; y < curbbx[3]; y++) {
                for (x = maxx; x < w; x++) {
                    if (this.bmpData32[stpos + x] != 0) {
                        maxx = x;
                        break;
                    }
                }
                stpos += w;
            }
            curbbx[2] = maxx;
        }
    }

    class TextRender extends EventDispatcher {
        constructor() {
            super();
            this.mapFont = {};
            this.textAtlases = [];
            this.isoTextures = [];
            this.fontSizeInfo = {};
            this.fontID = 0;
            this.fontScaleX = 1.0;
            this.fontScaleY = 1.0;
            this._curStrPos = 0;
            this.lastFont = null;
            this.fontSizeW = 0;
            this.fontSizeH = 0;
            this.fontSizeOffX = 0;
            this.fontSizeOffY = 0;
            this.renderPerChar = true;
            this.charRender = new CharRender_Canvas(2048, 2048);
            this.fontMeasure = new MeasureFont(this.charRender);
        }
        getFontSizeInfo(font) {
            let finfo = this.fontSizeInfo[font];
            if (!finfo)
                this.fontSizeInfo[font] = finfo = this.fontMeasure.getFontSizeInfo(font, TextRenderConfig.standardFontSize);
            return finfo;
        }
        setFont(font) {
            if (this.lastFont == font)
                return;
            this.lastFont = font;
            var fontsz = this.getFontSizeInfo(font._family);
            var offx = fontsz >> 24;
            var offy = (fontsz >> 16) & 0xff;
            var fw = (fontsz >> 8) & 0xff;
            var fh = fontsz & 0xff;
            var k = font._size / TextRenderConfig.standardFontSize;
            this.fontSizeOffX = Math.ceil(offx * k);
            this.fontSizeOffY = Math.ceil(offy * k);
            this.fontSizeW = Math.ceil(fw * k);
            this.fontSizeH = Math.ceil(fh * k);
            if (font._font.indexOf('italic') >= 0) {
                this.fontStr = font._font.replace('italic', '');
            }
            else {
                this.fontStr = font._font;
            }
        }
        getNextChar(str) {
            var len = str.length;
            var start = this._curStrPos;
            if (!str.substring)
                return null;
            if (start >= len)
                return null;
            var i = start;
            var state = 0;
            for (; i < len; i++) {
                var c = str.charCodeAt(i);
                if ((c >>> 11) == 0x1b) {
                    if (state == 1)
                        break;
                    state = 1;
                    i++;
                }
                else if (c === 0xfe0e || c === 0xfe0f) ;
                else if (c == 0x200d) {
                    state = 2;
                }
                else {
                    if (state == 0)
                        state = 1;
                    else if (state == 1)
                        break;
                    else ;
                }
            }
            this._curStrPos = i;
            return str.substring(start, i);
        }
        filltext(ctx, data, x, y, fontStr, color, strokeColor, lineWidth, textAlign) {
            if (data.length <= 0)
                return;
            var font = FontInfo.parse(fontStr);
            var nTextAlign = 0;
            switch (textAlign) {
                case 'center':
                    nTextAlign = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    nTextAlign = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
            }
            this._fast_filltext(ctx, data, x, y, font, color, strokeColor, lineWidth, nTextAlign);
        }
        _fast_filltext(ctx, data, x, y, font, color, strokeColor, lineWidth, textAlign) {
            if (data && !(data.length >= 1))
                return;
            if (lineWidth < 0)
                lineWidth = 0;
            this.setFont(font);
            this.fontScaleX = this.fontScaleY = 1.0;
            if (TextRenderConfig.scaleFontWithCtx) {
                let sx = ctx.getMatScaleX();
                let sy = ctx.getMatScaleY();
                if (sx < 1e-4 || sy < 1e-1)
                    return;
                if (sx > 1)
                    this.fontScaleX = Math.min(TextRenderConfig.maxFontScale, sx);
                if (sy > 1)
                    this.fontScaleY = Math.min(TextRenderConfig.maxFontScale, sy);
            }
            font._italic && (ctx._italicDeg = 13);
            let wt = data;
            let isWT = data instanceof WordText$1;
            let str = data && data.toString();
            let sameTexData = isWT ? wt.pageChars : [];
            let strWidth = 0;
            if (isWT) {
                str = wt.text;
                strWidth = wt.width;
                if (strWidth < 0) {
                    strWidth = wt.width = this.charRender.getWidth(this.fontStr, str);
                }
            }
            else {
                strWidth = str ? this.charRender.getWidth(this.fontStr, str) : 0;
            }
            switch (textAlign) {
                case Const.ENUM_TEXTALIGN_CENTER:
                    x -= strWidth / 2;
                    break;
                case Const.ENUM_TEXTALIGN_RIGHT:
                    x -= strWidth;
                    break;
            }
            if (isWT) {
                if (this.hasFreedText(sameTexData) || wt.pagecharsCtx != ctx) {
                    sameTexData = wt.pageChars = [];
                }
            }
            let splitTex = this.renderPerChar = (!isWT) || TextRenderConfig.forceSplitRender || (isWT && wt.splitRender);
            if (!sameTexData || sameTexData.length < 1) {
                if (isWT) {
                    wt.scalex = this.fontScaleX;
                    wt.scaley = this.fontScaleY;
                }
                if (splitTex) {
                    let stx = 0;
                    let sty = 0;
                    this._curStrPos = 0;
                    let curstr;
                    while (true) {
                        curstr = this.getNextChar(str);
                        if (!curstr)
                            break;
                        let ri = this.getCharRenderInfo(curstr, font, color, strokeColor, lineWidth, false);
                        if (!ri) {
                            break;
                        }
                        if (ri.isSpace) ;
                        else {
                            var add = sameTexData[ri.texture.id];
                            if (!add) {
                                var o1 = { texgen: ri.texture.genID, tex: ri.texture, words: new Array() };
                                sameTexData[ri.texture.id] = o1;
                                add = o1.words;
                            }
                            else {
                                add = add.words;
                            }
                            add.push({ ri: ri, x: stx, y: sty, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY });
                            stx += ri.width;
                        }
                    }
                }
                else {
                    let margin = (font._size / 3 | 0);
                    let isotex = TextRenderConfig.noAtlas || (strWidth + margin + margin) * this.fontScaleX > TextRenderConfig.atlasWidth;
                    let ri = this.getCharRenderInfo(str, font, color, strokeColor, lineWidth, isotex);
                    sameTexData[0] = { texgen: ri.texture.genID, tex: ri.texture, words: [{ ri: ri, x: 0, y: 0, w: ri.bmpWidth / this.fontScaleX, h: ri.bmpHeight / this.fontScaleY }] };
                }
                isWT && (wt.pagecharsCtx = ctx);
            }
            this._drawResortedWords(ctx, x, y, sameTexData);
            ctx._italicDeg = 0;
        }
        _drawResortedWords(ctx, startx, starty, samePagesData) {
            var isLastRender = ctx._charSubmitCache ? ctx._charSubmitCache._enable : false;
            var mat = ctx._curMat;
            for (var id in samePagesData) {
                var dt = samePagesData[id];
                if (!dt)
                    continue;
                var pri = dt.words;
                var count = pri.length;
                if (count <= 0)
                    continue;
                var tex = samePagesData[id].tex;
                for (var j = 0; j < count; j++) {
                    var riSaved = pri[j];
                    var ri = riSaved.ri;
                    if (ri.isSpace)
                        continue;
                    ctx.touchRes(ri);
                    ctx.drawTexAlign = true;
                    ctx._inner_drawTexture(tex, tex.id, startx + riSaved.x - ri.orix, starty + riSaved.y - ri.oriy, riSaved.w, riSaved.h, mat, ri.uv, 1.0, isLastRender, 0xffffffff);
                }
            }
        }
        hasFreedText(txts) {
            for (let i in txts) {
                var pri = txts[i];
                if (!pri)
                    continue;
                var tex = pri.tex;
                if (tex.destroyed || tex.genID != pri.texgen) {
                    return true;
                }
            }
            return false;
        }
        getCharRenderInfo(str, font, color, strokeColor, lineWidth, isoTexture = false) {
            var fid = this.mapFont[font._family];
            if (fid == undefined) {
                this.mapFont[font._family] = fid = this.fontID++;
            }
            var key = str + '_' + fid + '_' + font._size + '_' + color;
            if (lineWidth > 0)
                key += '_' + strokeColor + lineWidth;
            if (font._bold)
                key += 'P';
            if (this.fontScaleX != 1 || this.fontScaleY != 1) {
                key += (this.fontScaleX * 20 | 0) + '_' + (this.fontScaleY * 20 | 0);
            }
            var sz = this.textAtlases.length;
            var ri;
            var atlas;
            if (!isoTexture) {
                for (let i = 0; i < sz; i++) {
                    atlas = this.textAtlases[i];
                    ri = atlas.charMaps[key];
                    if (ri) {
                        ri.touch();
                        return ri;
                    }
                }
            }
            ri = new CharRenderInfo();
            let charRender = this.charRender;
            charRender.scale(this.fontScaleX, this.fontScaleY);
            ri.char = str;
            ri.height = font._size;
            var margin = (font._size / 3 | 0);
            if (!lineWidth) {
                lineWidth = 0;
            }
            var w1 = Math.ceil((charRender.getWidth(this.fontStr, str) + 2 * lineWidth) * this.fontScaleX);
            let needCanvW = Math.min(TextRenderConfig.maxCanvasWidth, w1 + margin * 2 * this.fontScaleX);
            if (needCanvW > charRender.canvasWidth) {
                charRender.canvasWidth = needCanvW;
            }
            if (isoTexture) {
                charRender.fontsz = font._size;
                let tex;
                let imgdt;
                if (TextRenderConfig.useImageData)
                    imgdt = charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin);
                else
                    imgdt = charRender.getCharCanvas(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin);
                tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);
                tex.addChar(imgdt, 0, 0, ri.uv);
                ri.texture = tex;
                ri.orix = margin;
                ri.oriy = margin;
                tex.ri = ri;
                this.isoTextures.push(tex);
            }
            else {
                var len = str.length;
                var lineExt = lineWidth * 1;
                var fw = Math.ceil((this.fontSizeW + lineExt * 2) * this.fontScaleX);
                var fh = Math.ceil((this.fontSizeH + lineExt * 2) * this.fontScaleY);
                imgdtRect[0] = ((margin - this.fontSizeOffX - lineExt) * this.fontScaleX) | 0;
                imgdtRect[1] = ((margin - this.fontSizeOffY - lineExt) * this.fontScaleY) | 0;
                if (this.renderPerChar || len == 1) {
                    imgdtRect[2] = Math.max(w1, fw);
                    imgdtRect[3] = Math.max(w1, fh);
                }
                else {
                    imgdtRect[2] = -(this.fontSizeOffX * this.fontScaleX);
                    imgdtRect[3] = fh;
                }
                this.charRender.fontsz = font._size;
                let imgdt;
                if (TextRenderConfig.useImageData)
                    imgdt = this.charRender.getCharBmp(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin, imgdtRect);
                else
                    imgdt = this.charRender.getCharCanvas(str, this.fontStr, lineWidth, color, strokeColor, ri, margin, margin, margin, margin);
                if (imgdt.width > TextRenderConfig.atlasWidth || imgdt.height > TextRenderConfig.atlasWidth) {
                    var tex = TextTexture.getTextTexture(imgdt.width, imgdt.height);
                    tex.addChar(imgdt, 0, 0, ri.uv);
                    ri.texture = tex;
                    ri.orix = margin;
                    ri.oriy = margin;
                    tex.ri = ri;
                    this.isoTextures.push(tex);
                }
                else {
                    atlas = this.findAtlas(imgdt.width, imgdt.height);
                    atlas.texture.addChar(imgdt, tmpAtlasPos.x, tmpAtlasPos.y, ri.uv);
                    ri.texture = atlas.texture;
                    if (!TextRenderConfig.useImageData) {
                        ri.orix = margin;
                        ri.oriy = margin;
                    }
                    else {
                        ri.orix = (this.fontSizeOffX + lineExt);
                        ri.oriy = (this.fontSizeOffY + lineExt);
                    }
                    atlas.charMaps[key] = ri;
                }
            }
            return ri;
        }
        findAtlas(w, h) {
            var sz = this.textAtlases.length;
            var atlas;
            var find = false;
            for (var i = 0; i < sz; i++) {
                atlas = this.textAtlases[i];
                find = atlas.getAEmpty(w, h, tmpAtlasPos);
                if (find) {
                    break;
                }
            }
            if (!find) {
                atlas = new TextAtlas();
                this.textAtlases.push(atlas);
                find = atlas.getAEmpty(w, h, tmpAtlasPos);
                if (!find) {
                    throw 'err1';
                }
                this.cleanAtlases();
            }
            return atlas;
        }
        GC() {
            var i = 0;
            var sz = this.textAtlases.length;
            var dt = 0;
            var destroyDt = TextRenderConfig.destroyAtlasDt;
            var totalUsedRateAtlas = 0;
            var curloop = RenderInfo.loopCount;
            var maxWasteRateID = -1;
            var maxWasteRate = 0;
            var tex = null;
            var curatlas = null;
            for (; i < sz; i++) {
                curatlas = this.textAtlases[i];
                tex = curatlas.texture;
                if (tex) {
                    totalUsedRateAtlas += tex.curUsedCovRateAtlas;
                    var waste = curatlas.usedRate - tex.curUsedCovRateAtlas;
                    if (maxWasteRate < waste) {
                        maxWasteRate = waste;
                        maxWasteRateID = i;
                    }
                }
                dt = curloop - curatlas.texture.lastTouchTm;
                if (dt > destroyDt) {
                    TextRenderConfig.showLog && console.log('TextRender GC delete atlas ' + tex ? curatlas.texture.id : 'unk');
                    curatlas.destroy();
                    this.textAtlases[i] = this.textAtlases[sz - 1];
                    sz--;
                    i--;
                    maxWasteRateID = -1;
                }
            }
            this.textAtlases.length = sz;
            sz = this.isoTextures.length;
            for (i = 0; i < sz; i++) {
                tex = this.isoTextures[i];
                dt = curloop - tex.lastTouchTm;
                if (dt > TextRenderConfig.destroyUnusedTextureDt) {
                    tex.ri.deleted = true;
                    tex.ri.texture = null;
                    tex.destroy();
                    this.isoTextures[i] = this.isoTextures[sz - 1];
                    sz--;
                    i--;
                }
            }
            this.isoTextures.length = sz;
            var needGC = this.textAtlases.length > 1 && this.textAtlases.length - totalUsedRateAtlas >= 2;
            if (TextRenderConfig.atlasWidth * TextRenderConfig.atlasWidth * 4 * this.textAtlases.length > TextRenderConfig.cleanMem || needGC || TextRenderConfig.simClean) {
                TextRenderConfig.simClean = false;
                TextRenderConfig.showLog && console.log('清理使用率低的贴图。总使用率:', totalUsedRateAtlas, ':', this.textAtlases.length, '最差贴图:' + maxWasteRateID);
                if (maxWasteRateID >= 0) {
                    curatlas = this.textAtlases[maxWasteRateID];
                    curatlas.destroy();
                    this.textAtlases[maxWasteRateID] = this.textAtlases[this.textAtlases.length - 1];
                    this.textAtlases.length = this.textAtlases.length - 1;
                    this.event('GC');
                }
            }
        }
        cleanAtlases() {
        }
    }
    const tmpAtlasPos = new Point();
    const imgdtRect = [0, 0, 0, 0];

    class MeshTexture extends Sprite2DGeometry {
        static __init__() {
            MeshTexture.VertexDeclarition = new VertexDeclaration(48, [
                new VertexElement(0, VertexElementFormat.Vector4, 0),
                new VertexElement(16, VertexElementFormat.Vector4, 1),
                new VertexElement(32, VertexElementFormat.Vector4, 2),
            ]);
        }
        constructor() {
            super(MeshTexture.const_stride, 4, 4);
        }
        onVBRealloc(buff) {
            this._vbFloat32Array = new Float32Array(buff);
        }
        onIBRealloc(buff) {
            this._ibU16Array = new Uint16Array(buff);
        }
        addData(vertices, uvs, idx, matrix, rgba, uvrect = null) {
            let addVert = vertices.length / 2;
            this.expVBSize(addVert * MeshTexture.const_stride);
            var vertsz = vertices.length >> 1;
            var startpos = this._vertNum * MeshTexture.const_stride;
            var f32pos = startpos >> 2;
            var vbdata = this._vbFloat32Array;
            var ci = 0;
            var m00 = matrix.a;
            var m01 = matrix.b;
            var m10 = matrix.c;
            var m11 = matrix.d;
            var tx = matrix.tx;
            var ty = matrix.ty;
            var i = 0;
            let uvminx = 0;
            let uvminy = 0;
            let uvu = 1;
            let uvv = 1;
            if (uvrect) {
                uvminx = uvrect[0];
                uvminy = uvrect[1];
                uvu = uvrect[2];
                uvv = uvrect[3];
            }
            let r = ((rgba >>> 16) & 0xff) / 255.0;
            let g = ((rgba >>> 8) & 0xff) / 255.0;
            let b = (rgba & 0xff) / 255.0;
            let a = (rgba >>> 24) / 255.0;
            for (i = 0; i < vertsz; i++) {
                var x = vertices[ci], y = vertices[ci + 1];
                vbdata[f32pos] = x * m00 + y * m10 + tx;
                vbdata[f32pos + 1] = x * m01 + y * m11 + ty;
                vbdata[f32pos + 2] = uvminx + uvs[ci] * uvu;
                vbdata[f32pos + 3] = uvminy + uvs[ci + 1] * uvv;
                vbdata[f32pos + 4] = b;
                vbdata[f32pos + 5] = g;
                vbdata[f32pos + 6] = r;
                vbdata[f32pos + 7] = a;
                vbdata[f32pos + 8] = 0xff;
                f32pos += 12;
                ci += 2;
            }
            var vertN = this._vertNum;
            var ibstart = this._indexNum;
            this.expIBSize(idx.byteLength);
            var indexBuffer = this._ibU16Array;
            if (vertN > 0) {
                for (let i = ibstart, si = 0, end = ibstart + idx.length; i < end; i++, si++) {
                    indexBuffer[i] = idx[si] + vertN;
                }
            }
            else {
                indexBuffer.set(idx);
            }
            this._vertNum += vertsz;
            this._indexNum += idx.length;
        }
        get vertexDeclarition() {
            return MeshTexture.VertexDeclarition;
        }
    }
    MeshTexture.const_stride = 48;
    MeshTexture.VertexDeclarition = null;

    class MeshVG extends Sprite2DGeometry {
        static __init__() {
            MeshVG.vertexDeclaration = new VertexDeclaration(24, [
                new VertexElement(0, VertexElementFormat.Vector2, 0),
                new VertexElement(8, VertexElementFormat.Vector4, 1),
            ]);
        }
        constructor() {
            super(MeshVG.const_stride, 4, 4);
            this._vbFloat32Array = null;
        }
        onVBRealloc(buff) {
            this._vbFloat32Array = new Float32Array(buff);
        }
        onIBRealloc(buff) {
        }
        addVertAndIBToMesh(points, rgba, ib) {
            var startpos = this._vertNum * MeshVG.const_stride;
            this.expVBSize(points.length / 2 * MeshVG.const_stride);
            var f32pos = startpos >> 2;
            var vbdata = this._vbFloat32Array;
            var ci = 0;
            let r = ((rgba >>> 16) & 0xff) / 255.0;
            let g = ((rgba >>> 8) & 0xff) / 255.0;
            let b = (rgba & 0xff) / 255.0;
            let a = (rgba >>> 24) / 255.0;
            var sz = points.length / 2;
            for (var i = 0; i < sz; i++) {
                vbdata[f32pos++] = points[ci];
                vbdata[f32pos++] = points[ci + 1];
                ci += 2;
                vbdata[f32pos++] = b;
                vbdata[f32pos++] = g;
                vbdata[f32pos++] = r;
                vbdata[f32pos++] = a;
            }
            this.expIBSize(ib.length * 2);
            (new Uint16Array(this._IBBuff, this._indexNum * 2, ib.length)).set(new Uint16Array(ib));
            this._vertNum += sz;
            this._indexNum += ib.length;
        }
        get vertexDeclarition() {
            return MeshVG.vertexDeclaration;
        }
    }
    MeshVG.const_stride = 24;
    MeshVG.vertexDeclaration = null;

    const defaultClipMatrix = new Matrix(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE, 0, 0);
    const tmpuv1 = [0, 0, 0, 0, 0, 0, 0, 0];
    const tmpMat$1 = new Matrix();
    const _clipResult = new Vector2();
    const MAXVERTNUM = 65535;
    const MAXCLIPRECT = new Rectangle(0, 0, Const.MAX_CLIP_SIZE, Const.MAX_CLIP_SIZE);
    const SEGNUM = 32;
    class Context {
        constructor() {
            this._material = null;
            this.stopMerge = true;
            this._curSubmit = SubmitBase.RENDERBASE;
            this._submitKey = new SubmitKey();
            this._clipRect = MAXCLIPRECT;
            this._globalClipMatrix = defaultClipMatrix.clone();
            this._clipInfoID = 0;
            this._matBuffer = new Float32Array(6);
            this._lastMatScaleX = 1.0;
            this._lastMatScaleY = 1.0;
            this._nBlendType = 0;
            this._save = null;
            this._charSubmitCache = null;
            this._saveMark = null;
            this._italicDeg = 0;
            this._lastTex = null;
            this._colorFiler = null;
            this.sprite = null;
            this.drawTexAlign = false;
            this._alpha = 1.0;
            this._fillStyle = DrawStyle.DEFAULT;
            this._strokeStyle = DrawStyle.DEFAULT;
            this._drawCount = 1;
            this._drawTexToDrawTri_Vert = new Float32Array(8);
            this._drawTexToDrawTri_Index = new Uint16Array([0, 1, 2, 0, 2, 3]);
            this._tempUV = new Float32Array(8);
            this._drawTriUseAbsMatrix = false;
            this._other = null;
            this._path = null;
            this._width = Const.MAX_CLIP_SIZE;
            this._height = Const.MAX_CLIP_SIZE;
            this._meshQuatTex = new MeshQuadTexture();
            this._meshVG = new MeshVG();
            this._meshTex = new MeshTexture();
            this._transedPoints = new Array(8);
            this._temp4Points = new Array(8);
            this._lastMat_a = 1.0;
            this._lastMat_b = 0.0;
            this._lastMat_c = 0.0;
            this._lastMat_d = 1.0;
            this._shader2D = new Shader2D();
            this._fillColor = 0;
            this._flushCnt = 0;
            this._defTexture = null;
            this._isMain = false;
            this._render2D = null;
            this._clearColor = new Color(0, 0, 0, 0);
            this._clear = false;
            this._shaderValueNeedRelease = [];
            this._clipID_Gen = 0;
            this.render2D = new Render2DSimple();
            Context._contextcount++;
            if (!this._defTexture) {
                var defTex2d = new Texture2D(2, 2, exports.TextureFormat.R8G8B8A8, true, false, false);
                defTex2d.setPixelsData(new Uint8Array(16), false, false);
                defTex2d.lock = true;
                this._defTexture = new Texture(defTex2d);
            }
            this._lastTex = this._defTexture;
            this._other = ContextParams.DEFAULT;
            this._curMat = Matrix.create();
            this._charSubmitCache = new CharSubmitCache(this);
            this._mesh = this._meshQuatTex;
            this._mesh.clearMesh();
            this._save = [SaveMark.Create(this)];
            this._save.length = 10;
            this.clear();
            this._render2DManager = new RenderManager2D();
            if (!Context._textRender)
                Context._textRender = new TextRender();
        }
        copyState(ctx) {
        }
        set isMain(v) {
            this._isMain = v;
        }
        get isMain() {
            return this._isMain;
        }
        set render2D(render) {
            this._render2D = render;
        }
        get render2D() {
            return this._render2D;
        }
        get lineJoin() {
            return '';
        }
        set lineJoin(value) {
        }
        get lineCap() {
            return '';
        }
        set lineCap(value) {
        }
        get miterLimit() {
            return '';
        }
        set miterLimit(value) {
        }
        touchRes(res) {
            res.touch();
        }
        transformByMatrix(matrix, tx, ty) {
            this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx + tx, matrix.ty + ty);
        }
        drawRect(x, y, width, height, fillColor, lineColor, lineWidth) {
            var ctx = this;
            if (fillColor != null) {
                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, width, height);
            }
            if (lineColor != null) {
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = lineWidth;
                ctx.strokeRect(x, y, width, height);
            }
        }
        alpha(value) {
            this.globalAlpha *= value;
        }
        _transform(mat, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
            this.translate(-pivotX, -pivotY);
        }
        _rotate(angle, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.rotate(angle);
            this.translate(-pivotX, -pivotY);
        }
        _scale(scaleX, scaleY, pivotX, pivotY) {
            this.translate(pivotX, pivotY);
            this.scale(scaleX, scaleY);
            this.translate(-pivotX, -pivotY);
        }
        _drawLine(x, y, fromX, fromY, toX, toY, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + fromX, y + fromY);
            this.lineTo(x + toX, y + toY);
            this.stroke();
        }
        _drawLines(x, y, points, lineColor, lineWidth, vid) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.addPath(points.slice(), false, false, x, y);
            this.stroke();
        }
        drawCurves(x, y, points, lineColor, lineWidth) {
            this.beginPath();
            this.strokeStyle = lineColor;
            this.lineWidth = lineWidth;
            this.moveTo(x + points[0], y + points[1]);
            var i = 2, n = points.length;
            while (i < n) {
                this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
            }
            this.stroke();
        }
        _fillAndStroke(fillColor, strokeColor, lineWidth, isConvexPolygon = false) {
            if (fillColor != null) {
                this.fillStyle = fillColor;
                this.fill();
            }
            if (strokeColor != null && lineWidth > 0) {
                this.strokeStyle = strokeColor;
                this.lineWidth = lineWidth;
                this.stroke();
            }
        }
        _drawCircle(x, y, radius, fillColor, lineColor, lineWidth, vid) {
            this.beginPath(true);
            this.arc(x, y, radius, radius, 0, 2 * Math.PI, false, true, 40);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawEllipse(x, y, width, height, fillColor, lineColor, lineWidth) {
            this.beginPath(true);
            this.arc(x, y, width, height, 0, 2 * Math.PI, false, true, 40);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawRoundRect(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth) {
            if (width <= 0)
                return;
            if (height <= 0)
                return;
            this.beginPath(true);
            var tPath = this._getPath();
            if (0 >= lt) {
                tPath.addPoint(x, y);
            }
            else {
                let st = Math.PI;
                let ed = 1.5 * Math.PI;
                if (width < lt + rt) {
                    let dxlt = lt * (lt + rt - width) / (lt + rt);
                    let hity = Math.sqrt(lt * lt - dxlt * dxlt);
                    let ang = Math.atan2(hity, dxlt);
                    let dAng = 0.5 * Math.PI - ang;
                    ed -= dAng;
                }
                if (height < lt + lb) {
                    let dylt = lt * (lt + lb - height) / (lt + lb);
                    let hitx = Math.sqrt(lt * lt - dylt * dylt);
                    let ang = Math.atan2(dylt, hitx);
                    st += ang;
                }
                if (st > ed) ;
                else {
                    this.arc(x + lt, y + lt, lt, lt, st, ed, false, true, 5);
                }
            }
            let startX = x + width - rt;
            if (0 >= rt) {
                tPath.addPoint(startX, y);
            }
            else {
                let st = 1.5 * Math.PI;
                let ed = 2 * Math.PI;
                if (width < lt + rt) {
                    let dxlt = rt * (lt + rt - width) / (lt + rt);
                    let hity = Math.sqrt(lt * lt - dxlt * dxlt);
                    let ang = Math.atan2(hity, dxlt);
                    let dAng = 0.5 * Math.PI - ang;
                    st += dAng;
                }
                if (height < rt + rb) {
                    let dyrt = rt * (rt + rb - height) / (rt + rb);
                    let hitx = Math.sqrt(rt * rt - dyrt * dyrt);
                    let ang = Math.atan2(dyrt, hitx);
                    ed -= ang;
                }
                if (st > ed) ;
                else {
                    this.arc(startX, y + rt, rt, rt, st, ed, false, true, 5);
                }
            }
            startX = x + width - rb;
            let startY = y + height - rb;
            if (0 >= rb) {
                tPath.addPoint(startX, startY);
            }
            else {
                let st = 0;
                let ed = 0.5 * Math.PI;
                if (width < lb + rb) {
                    let dxlb = rb * (lb + rb - width) / (lb + rb);
                    let hity = Math.sqrt(lb * lb - dxlb * dxlb);
                    let ang = Math.atan2(hity, dxlb);
                    let dAng = 0.5 * Math.PI - ang;
                    ed -= dAng;
                }
                if (height < rt + rb) {
                    let dyrt = rb * (rt + rb - height) / (rt + rb);
                    let hitx = Math.sqrt(rb * rb - dyrt * dyrt);
                    let ang = Math.atan2(dyrt, hitx);
                    st += ang;
                }
                if (st > ed) ;
                else {
                    this.arc(startX, startY, rb, rb, st, ed, false, true, 5);
                }
            }
            startX = x + lb;
            startY = y + height - lb;
            if (0 >= lb) {
                tPath.addPoint(startX, startY);
            }
            else {
                let st = 0.5 * Math.PI;
                let ed = Math.PI;
                if (width < lb + rb) {
                    let dxlb = rb * (lb + rb - width) / (lb + rb);
                    let hity = Math.sqrt(lb * lb - dxlb * dxlb);
                    let ang = Math.atan2(hity, dxlb);
                    let dAng = 0.5 * Math.PI - ang;
                    st += dAng;
                }
                if (height < lt + lb) {
                    let dylt = lb * (lt + lb - height) / (lt + lb);
                    let hitx = Math.sqrt(lb * lb - dylt * dylt);
                    let ang = Math.atan2(dylt, hitx);
                    ed -= ang;
                }
                if (st > ed) ;
                else {
                    this.arc(startX, startY, lb, lb, st, ed, false, true, 5);
                }
            }
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth, vid) {
            this.beginPath();
            this.moveTo(x, y);
            this.arc(x, y, radius, radius, startAngle, endAngle);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth);
        }
        _drawPoly(x, y, points, fillColor, lineColor, lineWidth, isConvexPolygon, vid) {
            this.beginPath();
            this.addPath(points.slice(), true, isConvexPolygon, x, y);
            this.closePath();
            this._fillAndStroke(fillColor, lineColor, lineWidth, isConvexPolygon);
        }
        _drawPath(x, y, paths, brush, pen) {
            this.beginPath();
            for (var i = 0, n = paths.length; i < n; i++) {
                var path = paths[i];
                switch (path[0]) {
                    case "moveTo":
                        this.moveTo(x + path[1], y + path[2]);
                        break;
                    case "lineTo":
                        this.lineTo(x + path[1], y + path[2]);
                        break;
                    case "arcTo":
                        this.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
                        break;
                    case "closePath":
                        this.closePath();
                        break;
                }
            }
            if (brush != null) {
                this.fillStyle = brush.fillStyle;
                this.fill();
            }
            if (pen != null) {
                this.strokeStyle = pen.strokeStyle;
                this.lineWidth = pen.lineWidth || 1;
                this.lineJoin = pen.lineJoin;
                this.lineCap = pen.lineCap;
                this.miterLimit = pen.miterLimit;
                this.stroke();
            }
        }
        static set2DRenderConfig() {
        }
        clearBG(r, g, b, a) {
            if (r == null || r == undefined) {
                this._clear = false;
            }
            else {
                this._clearColor.setValue(r, g, b, a);
                this._clear = true;
            }
        }
        _releaseMem() {
            this._curMat && this._curMat.destroy();
            this._curMat = null;
            this._shader2D.destroy();
            this._shader2D = null;
            this._charSubmitCache.clear();
            this._path = null;
            this._save = null;
            this.sprite = null;
        }
        destroy() {
            --Context._contextcount;
            this.sprite = null;
            this._charSubmitCache && this._charSubmitCache.destroy();
            if (this._defTexture) {
                this._defTexture.bitmap && this._defTexture.bitmap.destroy();
                this._defTexture.destroy();
            }
            for (var i = 0, n = this._shaderValueNeedRelease.length; i < n; i++) {
                this._shaderValueNeedRelease[i] && this._shaderValueNeedRelease[i].release();
            }
        }
        clear() {
            this._submitKey.clear();
            this._drawCount = 1;
            this._other = ContextParams.DEFAULT;
            this._alpha = 1.0;
            this._nBlendType = 0;
            this._clipRect = MAXCLIPRECT;
            this._fillStyle = this._strokeStyle = DrawStyle.DEFAULT;
            this._curMat.identity();
            this._other.clear();
            this._saveMark = this._save[0];
            this._save._length = 1;
        }
        size(w, h) {
            if (this._width != w || this._height != h) {
                this._width = w;
                this._height = h;
                if (this.isMain) {
                    RenderState2D.width = w;
                    RenderState2D.height = h;
                }
            }
            if (w === 0 && h === 0)
                this._releaseMem();
        }
        get width() {
            return this._width;
        }
        set width(w) {
            this.size(w, this._height);
        }
        get height() {
            return this._height;
        }
        set height(h) {
            this.size(this._width, h);
        }
        getMatScaleX() {
            if (this._lastMat_a == this._curMat.a && this._lastMat_b == this._curMat.b)
                return this._lastMatScaleX;
            this._lastMatScaleX = this._curMat.getScaleX();
            this._lastMat_a = this._curMat.a;
            this._lastMat_b = this._curMat.b;
            return this._lastMatScaleX;
        }
        getMatScaleY() {
            if (this._lastMat_c == this._curMat.c && this._lastMat_d == this._curMat.d)
                return this._lastMatScaleY;
            this._lastMatScaleY = this._curMat.getScaleY();
            this._lastMat_c = this._curMat.c;
            this._lastMat_d = this._curMat.d;
            return this._lastMatScaleY;
        }
        getFillColor() {
            return this._fillColor;
        }
        set fillStyle(value) {
            if (!this._fillStyle.equal(value)) {
                SaveBase.save(this, SaveBase.TYPE_FILESTYLE, this._shader2D, false);
                this._fillStyle = DrawStyle.create(value);
                this._submitKey.other = -this._fillStyle._color.numColor;
            }
        }
        get fillStyle() {
            return this._fillStyle;
        }
        set globalAlpha(value) {
            value = Math.floor(value * 1000) / 1000;
            if (value != this._alpha) {
                SaveBase.save(this, SaveBase.TYPE_ALPHA, this._shader2D, false);
                this._alpha = value;
            }
        }
        get globalAlpha() {
            return this._alpha;
        }
        set textAlign(value) {
            (this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTALIGN, this._other, false), this._other.textAlign = value);
        }
        get textAlign() {
            return this._other.textAlign;
        }
        set textBaseline(value) {
            (this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_TEXTBASELINE, this._other, false), this._other.textBaseline = value);
        }
        get textBaseline() {
            return this._other.textBaseline;
        }
        set globalCompositeOperation(value) {
            this._drawToRender2D(this._curSubmit);
            var n = BlendMode.TOINT[value];
            n == null || (this._nBlendType === n) || (SaveBase.save(this, SaveBase.TYPE_GLOBALCOMPOSITEOPERATION, this, true), this._curSubmit = SubmitBase.RENDERBASE, this._nBlendType = n);
        }
        get globalCompositeOperation() {
            return BlendMode.NAMES[this._nBlendType];
        }
        set strokeStyle(value) {
            this._strokeStyle.equal(value) || (SaveBase.save(this, SaveBase.TYPE_STROKESTYLE, this._shader2D, false), this._strokeStyle = DrawStyle.create(value), this._submitKey.other = -this._strokeStyle._color.numColor);
        }
        get strokeStyle() {
            return this._strokeStyle;
        }
        translate(x, y) {
            if (x !== 0 || y !== 0) {
                SaveTranslate.save(this);
                if (this._curMat._bTransform) {
                    SaveTransform.save(this);
                    this._curMat.tx += (x * this._curMat.a + y * this._curMat.c);
                    this._curMat.ty += (x * this._curMat.b + y * this._curMat.d);
                }
                else {
                    this._curMat.tx = x;
                    this._curMat.ty = y;
                }
            }
        }
        set lineWidth(value) {
            (this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this, SaveBase.TYPE_LINEWIDTH, this._other, false), this._other.lineWidth = value);
        }
        get lineWidth() {
            return this._other.lineWidth;
        }
        save() {
            this._save[this._save._length++] = SaveMark.Create(this);
        }
        restore() {
            var sz = this._save._length;
            var lastBlend = this._nBlendType;
            if (sz < 1)
                return;
            for (var i = sz - 1; i >= 0; i--) {
                var o = this._save[i];
                o.restore(this);
                if (o.isSaveMark()) {
                    this._save._length = i;
                    return;
                }
            }
            if (lastBlend != this._nBlendType) {
                this.stopMerge = true;
            }
        }
        fillText(txt, x, y, fontStr, color, align, lineWidth = 0, borderColor = "") {
            Context._textRender.filltext(this, txt, x, y, fontStr, color, borderColor, lineWidth, align);
        }
        drawText(text, x, y, font, color, textAlign) {
            Context._textRender.filltext(this, text, x, y, font, color, null, 0, textAlign);
        }
        strokeWord(text, x, y, font, color, lineWidth, textAlign) {
            Context._textRender.filltext(this, text, x, y, font, null, color, lineWidth, textAlign);
        }
        fillBorderText(txt, x, y, font, color, borderColor, lineWidth, textAlign) {
            Context._textRender.filltext(this, txt, x, y, font, color, borderColor, lineWidth, textAlign);
        }
        _fast_filltext(data, x, y, fontObj, color, strokeColor, lineWidth, textAlign) {
            Context._textRender._fast_filltext(this, data, x, y, fontObj, color, strokeColor, lineWidth, textAlign);
        }
        _fillRect(x, y, width, height, rgba) {
            var submit = this._curSubmit;
            var sameKey = this._mesh.vertexNum + 4 < MAXVERTNUM &&
                submit && (submit._key.submitType === SubmitBase.KEY_DRAWTEXTURE &&
                submit._key.blendShader === this._nBlendType &&
                !this.isStopMerge(submit)) &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshQuatTex;
            }
            let mesh = this._mesh;
            this.transformQuad(x, y, width, height, 0, this._curMat, this._transedPoints);
            if (!this.clipedOff(this._transedPoints)) {
                if (!sameKey) {
                    submit = this._curSubmit = SubmitBase.create(this, mesh, Value2D.create(exports.RenderSpriteData.Texture2D));
                    this.fillShaderValue(submit.shaderValue);
                    this._copyClipInfo(submit.shaderValue);
                    submit.clipInfoID = this._clipInfoID;
                    if (!this._lastTex || this._lastTex.destroyed) {
                        submit.shaderValue.textureHost = this._defTexture;
                    }
                    else {
                        submit.shaderValue.textureHost = this._lastTex;
                    }
                    submit._key.other = (this._lastTex && this._lastTex.bitmap) ? this._lastTex.bitmap.id : -1;
                }
                mesh.addQuad(this._transedPoints, Texture.NO_UV, rgba, false);
                this._curSubmit._numEle += 6;
            }
        }
        fillRect(x, y, width, height, fillStyle) {
            var drawstyle = fillStyle ? DrawStyle.create(fillStyle) : this._fillStyle;
            var rgba = this.mixRGBandAlpha(drawstyle._color.numColor);
            this._fillRect(x, y, width, height, rgba);
        }
        fillTexture(texture, x, y, width, height, type, offset, color) {
            if (!texture._getSource()) {
                this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                return;
            }
            this._fillTexture(texture, texture.width, texture.height, texture.uvrect, x, y, width, height, type, offset.x, offset.y, color);
        }
        _fillTexture(texture, texw, texh, texuvRect, x, y, width, height, type, offsetx, offsety, color) {
            var submit = this._curSubmit;
            this._drawToRender2D(this._curSubmit);
            this._mesh = this._meshQuatTex;
            var repeatx = true;
            var repeaty = true;
            switch (type) {
                case "repeat": break;
                case "repeat-x":
                    repeaty = false;
                    break;
                case "repeat-y":
                    repeatx = false;
                    break;
                case "no-repeat":
                    repeatx = repeaty = false;
                    break;
            }
            var uv = this._temp4Points;
            var stu = 0;
            var stv = 0;
            var stx = 0, sty = 0, edx = 0, edy = 0;
            if (offsetx < 0) {
                stx = x;
                stu = (-offsetx % texw) / texw;
            }
            else {
                stx = x + offsetx;
            }
            if (offsety < 0) {
                sty = y;
                stv = (-offsety % texh) / texh;
            }
            else {
                sty = y + offsety;
            }
            edx = x + width;
            edy = y + height;
            (!repeatx) && (edx = Math.min(edx, x + offsetx + texw));
            (!repeaty) && (edy = Math.min(edy, y + offsety + texh));
            if (edx < x || edy < y)
                return;
            if (stx > edx || sty > edy)
                return;
            var edu = (edx - x - offsetx) / texw;
            var edv = (edy - y - offsety) / texh;
            this.transformQuad(stx, sty, edx - stx, edy - sty, 0, this._curMat, this._transedPoints);
            uv[0] = stu;
            uv[1] = stv;
            uv[2] = edu;
            uv[3] = stv;
            uv[4] = edu;
            uv[5] = edv;
            uv[6] = stu;
            uv[7] = edv;
            if (!this.clipedOff(this._transedPoints)) {
                var sv = Value2D.create(exports.RenderSpriteData.Texture2D);
                sv.shaderData.addDefine(ShaderDefines2D.FILLTEXTURE);
                var arry = texuvRect.concat();
                Vector4.TEMP.setValue(arry[0], arry[1], arry[2], arry[3]);
                sv.u_TexRange = Vector4.TEMP;
                submit = this._curSubmit = SubmitBase.create(this, this._mesh, sv);
                this.fillShaderValue(sv);
                submit.clipInfoID = this._clipInfoID;
                submit.shaderValue.textureHost = texture;
                var rgba = this._mixRGBandAlpha(color, this._alpha);
                this._mesh.addQuad(this._transedPoints, uv, rgba, true);
                this._curSubmit._numEle += 6;
            }
            this.breakNextMerge();
        }
        setColorFilter(filter) {
            SaveBase.save(this, SaveBase.TYPE_COLORFILTER, this, true);
            this._colorFiler = filter;
            this.stopMerge = true;
        }
        drawTexture(tex, x, y, width, height, color = 0xffffffff) {
            this._drawTextureM(tex, x, y, width, height, null, 1, null, color);
        }
        drawTextures(tex, pos, tx, ty, colors) {
            if (!tex._getSource()) {
                this.sprite && ILaya.systemTimer.callLater(this, this._repaintSprite);
                return;
            }
            var n = pos.length / 2;
            var ipos = 0;
            var bmpid = tex.bitmap.id;
            for (var i = 0; i < n; i++) {
                const color = typeof colors[i] === 'number' ? colors[i] : 0xffffffff;
                this._inner_drawTexture(tex, bmpid, pos[ipos++] + tx, pos[ipos++] + ty, 0, 0, null, null, 1.0, false, color);
            }
        }
        _drawTextureM(tex, x, y, width, height, m, alpha, uv, color) {
            var cs = this.sprite;
            if (!tex._getSource(function () {
                if (cs) {
                    cs.repaint();
                }
            })) {
                return false;
            }
            return this._inner_drawTexture(tex, tex.bitmap.id, x, y, width, height, m, uv, alpha, false, color);
        }
        _drawRenderTexture(tex, x, y, width, height, m, alpha, uv, color = 0xffffffff) {
            return this._inner_drawTexture(tex, -1, x, y, width, height, m, uv, alpha, false, color);
        }
        _copyClipInfo(shaderValue) {
            let clipInfo = this._globalClipMatrix;
            var cm = shaderValue.clipMatDir;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            shaderValue.clipMatDir = cm;
            var cmp = shaderValue.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty;
            shaderValue.clipMatPos = cmp;
        }
        _copyClipInfoToShaderData(shaderData) {
            let clipInfo = this._globalClipMatrix;
            Vector4.TEMP.setValue(clipInfo.a, clipInfo.b, clipInfo.c, clipInfo.d);
            shaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATDIR, Vector4.TEMP);
            Vector2.TEMP.setValue(clipInfo.tx, clipInfo.ty);
            shaderData.setVector2(ShaderDefines2D.UNIFORM_CLIPMATPOS, Vector2.TEMP);
        }
        isStopMerge(submit) {
            return this.stopMerge || (submit.clipInfoID !== this._clipInfoID);
        }
        drawCallOptimize(enable) {
            this._charSubmitCache.enable(enable, this);
            return enable;
        }
        _drawToRender2D(submit) {
            let mesh = this._mesh;
            if (mesh.indexNum <= 0)
                return;
            let shaderValue = submit.shaderValue;
            let shaderdata = shaderValue.shaderData;
            switch (submit._key.blendShader) {
                case 1:
                case 3:
                case 5:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
                    break;
                case 2:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_DST_COLOR);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                case 6:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
                    break;
                case 7:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ZERO);
                    break;
                case 9:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                default:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            }
            if (submit._colorFiler) {
                var ft = submit._colorFiler;
                shaderValue.setFilter(ft);
                Matrix4x4.TEMP.cloneByArray(ft._mat);
                shaderdata.setMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT, Matrix4x4.TEMP);
                Vector4.TEMP.setValue(ft._alpha[0], ft._alpha[1], ft._alpha[2], ft._alpha[3]);
                shaderdata.setVector(ShaderDefines2D.UNIFORM_COLORALPHA, Vector4.TEMP);
            }
            this._drawMesh(mesh, 0, mesh.vertexNum, submit._startIdx, mesh.indexNum, submit.shaderValue, submit.material);
            this.stopMerge = false;
            this._drawCount++;
        }
        _drawMesh(mesh, vboff, vertNum, iboff, indexNum, shaderValue, customMaterial) {
            if (!this._render2DManager._renderEnd) {
                this._render2DManager.render(Render2DSimple.rendercontext2D);
            }
            if (mesh.indexNum) {
                this._render2D.draw(mesh, vboff, vertNum * mesh.vertexDeclarition.vertexStride, iboff, indexNum * 2, shaderValue, customMaterial);
            }
            mesh.clearMesh();
            if (!shaderValue._needRelease) {
                shaderValue._needRelease = true;
                this._shaderValueNeedRelease.push(shaderValue);
            }
        }
        _inner_drawTexture(tex, imgid, x, y, width, height, m, uv, alpha, lastRender, color) {
            if (width <= 0 || height <= 0) {
                return false;
            }
            var preKey = this._curSubmit._key;
            uv = uv || tex._uv;
            if (preKey.submitType === SubmitBase.KEY_TRIANGLES && preKey.other === imgid) {
                var tv = this._drawTexToDrawTri_Vert;
                tv[0] = x;
                tv[1] = y;
                tv[2] = x + width, tv[3] = y, tv[4] = x + width, tv[5] = y + height, tv[6] = x, tv[7] = y + height;
                this._drawTriUseAbsMatrix = true;
                var tuv = this._tempUV;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this.drawTriangles(tex, 0, 0, tv, tuv, this._drawTexToDrawTri_Index, m || this._curMat, alpha, null, 0xffffffff);
                this._drawTriUseAbsMatrix = false;
                return true;
            }
            var submit = this._curSubmit;
            var ops = lastRender ? this._charSubmitCache.getPos() : this._transedPoints;
            this.transformQuad(x, y, width || tex.width, height || tex.height, this._italicDeg, m || this._curMat, ops);
            if (this.drawTexAlign) {
                var round = Math.round;
                ops[0] = round(ops[0]);
                ops[1] = round(ops[1]);
                ops[2] = round(ops[2]);
                ops[3] = round(ops[3]);
                ops[4] = round(ops[4]);
                ops[5] = round(ops[5]);
                ops[6] = round(ops[6]);
                ops[7] = round(ops[7]);
                this.drawTexAlign = false;
            }
            var rgba = this._mixRGBandAlpha(color, this._alpha * alpha);
            if (lastRender) {
                this._charSubmitCache.add(this, tex, imgid, ops, uv, rgba);
                return true;
            }
            var sameKey = (imgid >= 0 && preKey.submitType === SubmitBase.KEY_DRAWTEXTURE && preKey.other === imgid) &&
                !this.isStopMerge(this._curSubmit) &&
                this._mesh.vertexNum + 4 < MAXVERTNUM &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshQuatTex;
            }
            this._lastTex = tex;
            if (!sameKey) {
                let shaderValue = Value2D.create(exports.RenderSpriteData.Texture2D);
                this.fillShaderValue(shaderValue);
                shaderValue.textureHost = tex;
                this._curSubmit = submit = SubmitBase.create(this, this._mesh, shaderValue);
                submit._key.other = imgid;
                this._copyClipInfo(submit.shaderValue);
                submit.clipInfoID = this._clipInfoID;
            }
            this._mesh.addQuad(ops, uv, rgba, true);
            submit._numEle += 6;
            return true;
        }
        fillShaderValue(shaderValue) {
            shaderValue.size = new Vector2(this._width, this._height);
            this._copyClipInfo(shaderValue);
        }
        clipedOff(pt) {
            if (this._clipRect.width <= 0 || this._clipRect.height <= 0)
                return true;
            return false;
        }
        transformQuad(x, y, w, h, italicDeg, m, out) {
            var xoff = 0;
            if (italicDeg != 0) {
                xoff = Math.tan(italicDeg * Math.PI / 180) * h;
            }
            var maxx = x + w;
            var maxy = y + h;
            var tx = m.tx;
            var ty = m.ty;
            var ma = m.a;
            var mb = m.b;
            var mc = m.c;
            var md = m.d;
            var a0 = x + xoff;
            var a1 = y;
            var a2 = maxx + xoff;
            var a3 = y;
            var a4 = maxx;
            var a5 = maxy;
            var a6 = x;
            var a7 = maxy;
            if (m._bTransform) {
                out[0] = a0 * ma + a1 * mc + tx;
                out[1] = a0 * mb + a1 * md + ty;
                out[2] = a2 * ma + a3 * mc + tx;
                out[3] = a2 * mb + a3 * md + ty;
                out[4] = a4 * ma + a5 * mc + tx;
                out[5] = a4 * mb + a5 * md + ty;
                out[6] = a6 * ma + a7 * mc + tx;
                out[7] = a6 * mb + a7 * md + ty;
            }
            else {
                out[0] = a0 + tx;
                out[1] = a1 + ty;
                out[2] = a2 + tx;
                out[3] = a3 + ty;
                out[4] = a4 + tx;
                out[5] = a5 + ty;
                out[6] = a6 + tx;
                out[7] = a7 + ty;
            }
        }
        breakNextMerge() {
            this.stopMerge = true;
        }
        _repaintSprite() {
            this.sprite && this.sprite.repaint();
        }
        drawTextureWithTransform(tex, x, y, width, height, transform, tx, ty, alpha, blendMode, uv, color = 0xffffffff) {
            var oldcomp;
            var curMat = this._curMat;
            if (blendMode) {
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            if (!transform) {
                this._drawTextureM(tex, x + tx, y + ty, width, height, curMat, alpha, uv, color);
                if (blendMode) {
                    this.globalCompositeOperation = oldcomp;
                }
                return;
            }
            tmpMat$1.a = transform.a;
            tmpMat$1.b = transform.b;
            tmpMat$1.c = transform.c;
            tmpMat$1.d = transform.d;
            tmpMat$1.tx = transform.tx + tx;
            tmpMat$1.ty = transform.ty + ty;
            tmpMat$1._bTransform = transform._bTransform;
            if (transform && curMat._bTransform) {
                Matrix.mul(tmpMat$1, curMat, tmpMat$1);
                transform = tmpMat$1;
                transform._bTransform = true;
            }
            else {
                tmpMat$1.tx += curMat.tx;
                tmpMat$1.ty += curMat.ty;
                transform = tmpMat$1;
            }
            this._drawTextureM(tex, x, y, width, height, transform, alpha, uv, color);
            if (blendMode)
                this.globalCompositeOperation = oldcomp;
        }
        drawTriangles(tex, x, y, vertices, uvs, indices, matrix, alpha, blendMode, colorNum = 0xffffffff) {
            if (alpha == null)
                alpha = 1.0;
            if (!tex._getSource()) {
                if (this.sprite) {
                    ILaya.systemTimer.callLater(this, this._repaintSprite);
                }
                return;
            }
            var oldcomp = null;
            if (blendMode) {
                oldcomp = this.globalCompositeOperation;
                this.globalCompositeOperation = blendMode;
            }
            var webGLImg = tex.bitmap;
            var preKey = this._curSubmit._key;
            var sameKey = preKey.submitType === SubmitBase.KEY_TRIANGLES &&
                preKey.other === webGLImg.id &&
                preKey.blendShader == this._nBlendType &&
                this._mesh.vertexNum + vertices.length / 2 < MAXVERTNUM &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshTex;
            }
            if (!sameKey) {
                var submit = this._curSubmit = SubmitBase.create(this, this._mesh, Value2D.create(exports.RenderSpriteData.Texture2D));
                submit.shaderValue.textureHost = tex;
                this.fillShaderValue(submit.shaderValue);
                submit._key.submitType = SubmitBase.KEY_TRIANGLES;
                submit._key.other = webGLImg.id;
                this._copyClipInfo(submit.shaderValue);
                submit.clipInfoID = this._clipInfoID;
            }
            var rgba = this._mixRGBandAlpha(colorNum, this._alpha * alpha);
            if (!this._drawTriUseAbsMatrix) {
                if (!matrix) {
                    tmpMat$1.a = 1;
                    tmpMat$1.b = 0;
                    tmpMat$1.c = 0;
                    tmpMat$1.d = 1;
                    tmpMat$1.tx = x;
                    tmpMat$1.ty = y;
                }
                else {
                    tmpMat$1.a = matrix.a;
                    tmpMat$1.b = matrix.b;
                    tmpMat$1.c = matrix.c;
                    tmpMat$1.d = matrix.d;
                    tmpMat$1.tx = matrix.tx + x;
                    tmpMat$1.ty = matrix.ty + y;
                }
                Matrix.mul(tmpMat$1, this._curMat, tmpMat$1);
                this._mesh.addData(vertices, uvs, indices, tmpMat$1 || this._curMat, rgba, null);
            }
            else {
                this._mesh.addData(vertices, uvs, indices, matrix, rgba, null);
            }
            this._curSubmit._numEle += indices.length;
            if (blendMode) {
                this.globalCompositeOperation = oldcomp;
            }
        }
        transform(a, b, c, d, tx, ty) {
            SaveTransform.save(this);
            Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
            this._curMat._checkTransform();
        }
        rotate(angle) {
            SaveTransform.save(this);
            this._curMat.rotateEx(angle);
        }
        scale(scaleX, scaleY) {
            SaveTransform.save(this);
            this._curMat.scaleEx(scaleX, scaleY);
        }
        clipRect(x, y, width, height, escape) {
            SaveClipRect.save(this);
            if (this._clipRect == MAXCLIPRECT) {
                this._clipRect = new Rectangle(x, y, width, height);
            }
            else {
                this._clipRect.width = width;
                this._clipRect.height = height;
                this._clipRect.x = x;
                this._clipRect.y = y;
            }
            this._clipID_Gen++;
            this._clipID_Gen %= 10000;
            this._clipInfoID = this._clipID_Gen;
            if (escape) {
                defaultClipMatrix.copyTo(this._globalClipMatrix);
                return;
            }
            var cm = this._globalClipMatrix;
            var minx = cm.tx;
            var miny = cm.ty;
            var maxx = minx + cm.a;
            var maxy = miny + cm.d;
            if (this._clipRect.width >= Const.MAX_CLIP_SIZE) {
                cm.a = cm.d = Const.MAX_CLIP_SIZE;
                cm.b = cm.c = cm.tx = cm.ty = 0;
            }
            else {
                if (this._curMat._bTransform) {
                    cm.tx = this._clipRect.x * this._curMat.a + this._clipRect.y * this._curMat.c + this._curMat.tx;
                    cm.ty = this._clipRect.x * this._curMat.b + this._clipRect.y * this._curMat.d + this._curMat.ty;
                    cm.a = this._clipRect.width * this._curMat.a;
                    cm.b = this._clipRect.width * this._curMat.b;
                    cm.c = this._clipRect.height * this._curMat.c;
                    cm.d = this._clipRect.height * this._curMat.d;
                }
                else {
                    cm.tx = this._clipRect.x + this._curMat.tx;
                    cm.ty = this._clipRect.y + this._curMat.ty;
                    cm.a = this._clipRect.width;
                    cm.b = cm.c = 0;
                    cm.d = this._clipRect.height;
                }
            }
            if (cm.a > 0 && cm.d > 0) {
                var cmaxx = cm.tx + cm.a;
                var cmaxy = cm.ty + cm.d;
                if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                    cm.a = -0.1;
                    cm.d = -0.1;
                }
                else {
                    if (cm.tx < minx) {
                        cm.a -= (minx - cm.tx);
                        cm.tx = minx;
                    }
                    if (cmaxx > maxx) {
                        cm.a -= (cmaxx - maxx);
                    }
                    if (cm.ty < miny) {
                        cm.d -= (miny - cm.ty);
                        cm.ty = miny;
                    }
                    if (cmaxy > maxy) {
                        cm.d -= (cmaxy - maxy);
                    }
                    if (cm.a <= 0)
                        cm.a = -0.1;
                    if (cm.d <= 0)
                        cm.d = -0.1;
                }
            }
        }
        startRender() {
            for (let sv of this._shaderValueNeedRelease) {
                sv.release();
                sv._needRelease = false;
            }
            this._shaderValueNeedRelease.length = 0;
            this._render2D.renderStart(this._clear, this._clearColor);
            this.clear();
        }
        endRender() {
            this.flush();
            if (!this._render2DManager._renderEnd) {
                this._render2DManager.render(Render2DSimple.rendercontext2D);
            }
            this._render2D.renderEnd();
            this._curSubmit = SubmitBase.RENDERBASE;
        }
        drawLeftData() {
            if (!this._render2DManager._renderEnd) {
                this._render2DManager.render(Render2DSimple.rendercontext2D);
            }
            this._drawToRender2D(this._curSubmit);
        }
        flush() {
            this.drawLeftData();
            this._clipID_Gen = 0;
            this._path && this._path.reset();
            this._curSubmit = SubmitBase.RENDERBASE;
            this._flushCnt++;
            if (this._flushCnt % 60 == 0 && this.isMain) {
                Context._textRender.GC();
            }
        }
        beginPath(convex = false) {
            this._getPath().beginPath(convex);
        }
        closePath() {
            this._path.closePath();
        }
        addPath(points, close, convex, dx, dy) {
            let sz = points.length;
            for (let i = 0; i < sz - 1; i += 2) {
                points[i] += dx;
                points[i + 1] += dy;
            }
            if (close && sz > 5 && (points[sz - 2] != points[0] || points[sz - 1] != points[1])) {
                points.push(points[0], points[1]);
            }
            this._getPath().push(points, convex);
        }
        fill() {
            var m = this._curMat;
            var tPath = this._getPath();
            var submit = this._curSubmit;
            var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType) &&
                !this.isStopMerge(submit) &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(submit);
                this._mesh = this._meshVG;
                this._curSubmit = this.addVGSubmit(this._mesh);
                this.fillShaderValue(this._curSubmit.shaderValue);
            }
            var rgba = this.mixRGBandAlpha(this._fillStyle._color.numColor);
            var curEleNum = 0;
            var idx;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                var vertNum = p.path.length / 2;
                if (vertNum < 3 || (vertNum == 3 && !p.convex))
                    continue;
                var cpath = p.path.concat();
                var pi = 0;
                var xp, yp;
                var _x, _y;
                if (m._bTransform) {
                    for (pi = 0; pi < vertNum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = cpath[xp];
                        _y = cpath[yp];
                        cpath[xp] = m.a * _x + m.c * _y + m.tx;
                        cpath[yp] = m.b * _x + m.d * _y + m.ty;
                    }
                }
                else {
                    for (pi = 0; pi < vertNum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = cpath[xp];
                        _y = cpath[yp];
                        cpath[xp] = _x + m.tx;
                        cpath[yp] = _y + m.ty;
                    }
                }
                if (this._mesh.vertexNum + vertNum > MAXVERTNUM) {
                    this._curSubmit._numEle += curEleNum;
                    curEleNum = 0;
                    this._mesh = new MeshVG();
                    this._curSubmit = this.addVGSubmit(this._mesh);
                    this.fillShaderValue(this._curSubmit.shaderValue);
                }
                var curvert = this._mesh.vertexNum;
                if (p.convex) {
                    var faceNum = vertNum - 2;
                    idx = new Array(faceNum * 3);
                    var idxpos = 0;
                    for (var fi = 0; fi < faceNum; fi++) {
                        idx[idxpos++] = curvert;
                        idx[idxpos++] = fi + 1 + curvert;
                        idx[idxpos++] = fi + 2 + curvert;
                    }
                }
                else {
                    idx = Earcut.earcut(cpath, null, 2);
                    if (curvert > 0) {
                        for (var ii = 0; ii < idx.length; ii++) {
                            idx[ii] += curvert;
                        }
                    }
                }
                this._mesh.addVertAndIBToMesh(cpath, rgba, idx);
                curEleNum += idx.length;
            }
            this._curSubmit._numEle += curEleNum;
        }
        addVGSubmit(mesh) {
            var submit = SubmitBase.create(this, mesh, Value2D.create(exports.RenderSpriteData.Primitive));
            this.fillShaderValue(submit.shaderValue);
            submit._key.submitType = SubmitBase.KEY_VG;
            this._copyClipInfo(submit.shaderValue);
            submit.clipInfoID = this._clipInfoID;
            return submit;
        }
        stroke() {
            if (this.lineWidth <= 0)
                return;
            var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
            var tPath = this._getPath();
            var submit = this._curSubmit;
            var sameKey = (submit._key.submitType === SubmitBase.KEY_VG && submit._key.blendShader === this._nBlendType) &&
                !this.isStopMerge(submit) &&
                this._curSubmit.material == this._material;
            if (!sameKey) {
                this._drawToRender2D(this._curSubmit);
                this._mesh = this._meshVG;
                this._curSubmit = this.addVGSubmit(this._mesh);
                this.fillShaderValue(this._curSubmit.shaderValue);
            }
            var curEleNum = 0;
            for (var i = 0, sz = tPath.paths.length; i < sz; i++) {
                var p = tPath.paths[i];
                if (p.path.length <= 0)
                    continue;
                var idx = [];
                var vertex = [];
                var maxVertexNum = p.path.length * 2;
                if (maxVertexNum < 2)
                    continue;
                if (this._mesh.vertexNum + maxVertexNum > MAXVERTNUM) {
                    this._curSubmit._numEle += curEleNum;
                    curEleNum = 0;
                    this._drawToRender2D(this._curSubmit);
                    this._mesh = new MeshVG();
                    this._curSubmit = this.addVGSubmit(this._mesh);
                    this.fillShaderValue(this._curSubmit.shaderValue);
                }
                BasePoly.createLine2(p.path, idx, this.lineWidth, this._mesh.vertexNum, vertex, p.loop);
                var ptnum = vertex.length / 2;
                var m = this._curMat;
                var pi = 0;
                var xp, yp;
                var _x, _y;
                if (m._bTransform) {
                    for (pi = 0; pi < ptnum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = vertex[xp];
                        _y = vertex[yp];
                        vertex[xp] = m.a * _x + m.c * _y + m.tx;
                        vertex[yp] = m.b * _x + m.d * _y + m.ty;
                    }
                }
                else {
                    for (pi = 0; pi < ptnum; pi++) {
                        xp = pi << 1;
                        yp = xp + 1;
                        _x = vertex[xp];
                        _y = vertex[yp];
                        vertex[xp] = _x + m.tx;
                        vertex[yp] = _y + m.ty;
                    }
                }
                this._mesh.addVertAndIBToMesh(vertex, rgba, idx);
                curEleNum += idx.length;
            }
            this._curSubmit._numEle += curEleNum;
        }
        moveTo(x, y) {
            var tPath = this._getPath();
            tPath.newPath();
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        lineTo(x, y) {
            var tPath = this._getPath();
            if (Math.abs(x - tPath._lastOriX) < 1e-3 && Math.abs(y - tPath._lastOriY) < 1e-3)
                return;
            tPath._lastOriX = x;
            tPath._lastOriY = y;
            tPath.addPoint(x, y);
        }
        arcTo(x1, y1, x2, y2, r) {
            var i = 0;
            var x = 0, y = 0;
            var dx = this._path._lastOriX - x1;
            var dy = this._path._lastOriY - y1;
            var len1 = Math.sqrt(dx * dx + dy * dy);
            if (len1 <= 0.000001) {
                return;
            }
            var ndx = dx / len1;
            var ndy = dy / len1;
            var dx2 = x2 - x1;
            var dy2 = y2 - y1;
            var len22 = dx2 * dx2 + dy2 * dy2;
            var len2 = Math.sqrt(len22);
            if (len2 <= 0.000001) {
                return;
            }
            var ndx2 = dx2 / len2;
            var ndy2 = dy2 / len2;
            var odx = ndx + ndx2;
            var ody = ndy + ndy2;
            var olen = Math.sqrt(odx * odx + ody * ody);
            if (olen <= 0.000001) {
                return;
            }
            var nOdx = odx / olen;
            var nOdy = ody / olen;
            var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
            var halfAng = Math.PI / 2 - alpha;
            len1 = r * Math.tan(halfAng);
            var ptx1 = len1 * ndx + x1;
            var pty1 = len1 * ndy + y1;
            var orilen = Math.sqrt(len1 * len1 + r * r);
            var orix = x1 + nOdx * orilen;
            var oriy = y1 + nOdy * orilen;
            var dir = ndx * ndy2 - ndy * ndx2;
            var fChgAng = 0;
            var sinx = 0.0;
            var cosx = 0.0;
            if (dir >= 0) {
                fChgAng = halfAng * 2;
                var fda = fChgAng / SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            else {
                fChgAng = -halfAng * 2;
                fda = fChgAng / SEGNUM;
                sinx = Math.sin(fda);
                cosx = Math.cos(fda);
            }
            var lastx = this._path._lastOriX, lasty = this._path._lastOriY;
            var _x1 = ptx1, _y1 = pty1;
            if (Math.abs(_x1 - this._path._lastOriX) > 0.1 || Math.abs(_y1 - this._path._lastOriY) > 0.1) {
                x = _x1;
                y = _y1;
                lastx = _x1;
                lasty = _y1;
                this._path._lastOriX = x;
                this._path._lastOriY = y;
                this._path.addPoint(x, y);
            }
            var cvx = ptx1 - orix;
            var cvy = pty1 - oriy;
            for (i = 0; i < SEGNUM; i++) {
                var cx = cvx * cosx + cvy * sinx;
                var cy = -cvx * sinx + cvy * cosx;
                x = cx + orix;
                y = cy + oriy;
                if (Math.abs(lastx - x) > 0.1 || Math.abs(lasty - y) > 0.1) {
                    this._path._lastOriX = x;
                    this._path._lastOriY = y;
                    this._path.addPoint(x, y);
                    lastx = x;
                    lasty = y;
                }
                cvx = cx;
                cvy = cy;
            }
        }
        arc(cx, cy, rx, ry, startAngle, endAngle, counterclockwise = false, b = true, minNum = 20) {
            if (startAngle > endAngle) {
                [startAngle, endAngle] = [endAngle, startAngle];
            }
            var sx = this.getMatScaleX();
            var sy = this.getMatScaleY();
            var sr = rx * (sx > sy ? sx : sy);
            var cl = 2 * Math.PI * sr;
            let ndivs = (Math.max(cl / 5, minNum)) | 0;
            let stepAng = Math.PI * 2 / ndivs;
            var tPath = this._getPath();
            let x = cx + Math.cos(startAngle) * rx;
            let y = cy + Math.sin(startAngle) * ry;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
            let curAng = Math.ceil(startAngle / stepAng) * stepAng;
            while (endAngle - curAng >= stepAng) {
                x = cx + Math.cos(curAng) * rx;
                y = cy + Math.sin(curAng) * ry;
                tPath.addPoint(x, y);
                curAng += stepAng;
            }
            x = cx + Math.cos(endAngle) * rx;
            y = cy + Math.sin(endAngle) * ry;
            if (x != this._path._lastOriX || y != this._path._lastOriY) {
                tPath.addPoint(x, y);
            }
        }
        quadraticCurveTo(cpx, cpy, x, y) {
            var tArray = Bezier.getPoints([this._path._lastOriX, this._path._lastOriY, cpx, cpy, x, y], 30, 2);
            for (var i = 0, n = tArray.length / 2; i < n; i++) {
                this.lineTo(tArray[i * 2], tArray[i * 2 + 1]);
            }
            this.lineTo(x, y);
        }
        mixRGBandAlpha(color) {
            return this._mixRGBandAlpha(color, this._alpha);
        }
        _mixRGBandAlpha(color, alpha) {
            if (alpha >= 1) {
                return color;
            }
            var a = ((color & 0xff000000) >>> 24);
            if (a != 0) {
                a *= alpha;
            }
            else {
                a = alpha * 255;
            }
            return (color & 0x00ffffff) | (a << 24);
        }
        strokeRect(x, y, width, height, parameterLineWidth) {
            if (this.lineWidth > 0) {
                var rgba = this.mixRGBandAlpha(this.strokeStyle._color.numColor);
                var hw = this.lineWidth / 2;
                this._fillRect(x - hw, y - hw, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y - hw + height, width + this.lineWidth, this.lineWidth, rgba);
                this._fillRect(x - hw, y + hw, this.lineWidth, height - this.lineWidth, rgba);
                this._fillRect(x - hw + width, y + hw, this.lineWidth, height - this.lineWidth, rgba);
            }
        }
        drawParticle(x, y, pt) {
        }
        _getPath() {
            return this._path || (this._path = new Path());
        }
        get canvas() {
            return this._canvas;
        }
        _fillTexture_h(tex, imgid, uv, oriw, orih, x, y, w, color) {
            if (oriw <= 0)
                return;
            var stx = x;
            var num = Math.floor(w / oriw);
            var left = w % oriw;
            for (var i = 0; i < num; i++) {
                this._inner_drawTexture(tex, imgid, stx, y, oriw, orih, this._curMat, uv, 1, false, color);
                stx += oriw;
            }
            if (left > 0) {
                var du = uv[2] - uv[0];
                var uvr = uv[0] + du * (left / oriw);
                var tuv = tmpuv1;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uvr;
                tuv[3] = uv[3];
                tuv[4] = uvr;
                tuv[5] = uv[5];
                tuv[6] = uv[6];
                tuv[7] = uv[7];
                this._inner_drawTexture(tex, imgid, stx, y, left, orih, this._curMat, tuv, 1, false, color);
            }
        }
        _fillTexture_v(tex, imgid, uv, oriw, orih, x, y, h, color) {
            if (orih <= 0)
                return;
            var sty = y;
            var num = Math.floor(h / orih);
            var left = h % orih;
            for (var i = 0; i < num; i++) {
                this._inner_drawTexture(tex, imgid, x, sty, oriw, orih, this._curMat, uv, 1, false, color);
                sty += orih;
            }
            if (left > 0) {
                var dv = uv[7] - uv[1];
                var uvb = uv[1] + dv * (left / orih);
                var tuv = tmpuv1;
                tuv[0] = uv[0];
                tuv[1] = uv[1];
                tuv[2] = uv[2];
                tuv[3] = uv[3];
                tuv[4] = uv[4];
                tuv[5] = uvb;
                tuv[6] = uv[6];
                tuv[7] = uvb;
                this._inner_drawTexture(tex, imgid, x, sty, oriw, left, this._curMat, tuv, 1, false, color);
            }
        }
        _gridCut(left, right, width, out) {
            let c = (left + right) / 2;
            let d = (left + right - width) / 2;
            let ll = 0, lr = left;
            let rl = left, rr = left + right;
            let cl = c - d, cr = c + d;
            let hl = Math.max(ll, cl);
            let hr = Math.min(lr, cr);
            if (hr > hl) {
                left -= (hr - hl);
            }
            hl = Math.max(rl, cl);
            hr = Math.min(rr, cr);
            if (hr > hl) {
                right -= (hr - hl);
            }
            out.x = left;
            out.y = right;
        }
        drawTextureWithSizeGrid(tex, tx, ty, width, height, sizeGrid, gx, gy, color) {
            if (!tex._getSource())
                return;
            tx += gx;
            ty += gy;
            var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
            var top = sizeGrid[0];
            var left = sizeGrid[3];
            var right = sizeGrid[1];
            var bottom = sizeGrid[2];
            var repeat = sizeGrid[4];
            if (width == tex.width) {
                left = right = 0;
            }
            if (height == tex.height) {
                top = bottom = 0;
            }
            var imgid = tex.bitmap.id;
            var mat = this._curMat;
            var tuv = this._tempUV;
            let hasmidx = true;
            if (left + right > width) {
                hasmidx = false;
                this._gridCut(left, right, width, _clipResult);
                left = _clipResult.x;
                right = _clipResult.y;
            }
            let hasmidy = true;
            if (top + bottom > height) {
                hasmidy = false;
                this._gridCut(top, bottom, height, _clipResult);
                top = _clipResult.x;
                bottom = _clipResult.y;
            }
            var d_top = top / h;
            var d_left = left / w;
            var d_right = right / w;
            var d_bottom = bottom / h;
            var uvl = uv[0];
            var uvt = uv[1];
            var uvr = uv[4];
            var uvb = uv[5];
            var uvl_ = uvl;
            var uvt_ = uvt;
            var uvr_ = uvr;
            var uvb_ = uvb;
            if (left && top) {
                uvr_ = uvl + d_left;
                uvb_ = uvt + d_top;
                tuv[0] = uvl, tuv[1] = uvt, tuv[2] = uvr_, tuv[3] = uvt,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, tx, ty, left, top, mat, tuv, 1, false, color);
            }
            if (right && top) {
                uvl_ = uvr - d_right;
                uvt_ = uvt;
                uvr_ = uvr;
                uvb_ = uvt + d_top;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, width - right + tx, 0 + ty, right, top, mat, tuv, 1, false, color);
            }
            if (left && bottom) {
                uvl_ = uvl;
                uvt_ = uvb - d_bottom;
                uvr_ = uvl + d_left;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, 0 + tx, height - bottom + ty, left, bottom, mat, tuv, 1, false, color);
            }
            if (right && bottom) {
                uvl_ = uvr - d_right;
                uvt_ = uvb - d_bottom;
                uvr_ = uvr;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                this._inner_drawTexture(tex, imgid, width - right + tx, height - bottom + ty, right, bottom, mat, tuv, 1, false, color);
            }
            if (top && hasmidx) {
                uvl_ = uvl + d_left;
                uvt_ = uvt;
                uvr_ = uvr - d_right;
                uvb_ = uvt + d_top;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, top, left + tx, ty, width - left - right, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, ty, width - left - right, top, mat, tuv, 1, false, color);
                }
            }
            if (bottom && hasmidx) {
                uvl_ = uvl + d_left;
                uvt_ = uvb - d_bottom;
                uvr_ = uvr - d_right;
                uvb_ = uvb;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_h(tex, imgid, tuv, tex.width - left - right, bottom, left + tx, height - bottom + ty, width - left - right, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, height - bottom + ty, width - left - right, bottom, mat, tuv, 1, false, color);
                }
            }
            if (left && hasmidy) {
                uvl_ = uvl;
                uvt_ = uvt + d_top;
                uvr_ = uvl + d_left;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_v(tex, imgid, tuv, left, tex.height - top - bottom, tx, top + ty, height - top - bottom, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, tx, top + ty, left, height - top - bottom, mat, tuv, 1, false, color);
                }
            }
            if (right && hasmidy) {
                uvl_ = uvr - d_right;
                uvt_ = uvt + d_top;
                uvr_ = uvr;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    this._fillTexture_v(tex, imgid, tuv, right, tex.height - top - bottom, width - right + tx, top + ty, height - top - bottom, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, width - right + tx, top + ty, right, height - top - bottom, mat, tuv, 1, false, color);
                }
            }
            if (hasmidx && hasmidy) {
                uvl_ = uvl + d_left;
                uvt_ = uvt + d_top;
                uvr_ = uvr - d_right;
                uvb_ = uvb - d_bottom;
                tuv[0] = uvl_, tuv[1] = uvt_, tuv[2] = uvr_, tuv[3] = uvt_,
                    tuv[4] = uvr_, tuv[5] = uvb_, tuv[6] = uvl_, tuv[7] = uvb_;
                if (repeat) {
                    var tuvr = Context.tmpUVRect;
                    tuvr[0] = uvl_;
                    tuvr[1] = uvt_;
                    tuvr[2] = uvr_ - uvl_;
                    tuvr[3] = uvb_ - uvt_;
                    this._fillTexture(tex, tex.width - left - right, tex.height - top - bottom, tuvr, left + tx, top + ty, width - left - right, height - top - bottom, 'repeat', 0, 0, color);
                }
                else {
                    this._inner_drawTexture(tex, imgid, left + tx, top + ty, width - left - right, height - top - bottom, mat, tuv, 1, false, color);
                }
            }
        }
    }
    Context._textRender = null;
    Context._contextcount = 0;
    Context.tmpUVRect = [0, 0, 0, 0];
    class ContextParams {
        constructor() {
            this.lineWidth = 1;
        }
        clear() {
            this.lineWidth = 1;
            this.textAlign = this.textBaseline = null;
        }
        make() {
            return this === ContextParams.DEFAULT ? new ContextParams() : this;
        }
    }
    ContextParams.DEFAULT = new ContextParams();

    class LayaGLQuickRunner {
        static __init__() {
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_transform_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.GRAPHICS] = LayaGLQuickRunner.alpha_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.GRAPHICS] = LayaGLQuickRunner.transform_drawLayaGL;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.CHILDS] = LayaGLQuickRunner.transform_drawNodes;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_transform_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.ALPHA | SpriteConst.TEXTURE] = LayaGLQuickRunner.alpha_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.TRANSFORM | SpriteConst.TEXTURE] = LayaGLQuickRunner.transform_drawTexture;
            LayaGLQuickRunner.map[SpriteConst.GRAPHICS | SpriteConst.CHILDS] = LayaGLQuickRunner.drawLayaGL_drawNodes;
        }
        static transform_drawTexture(sprite, context, x, y) {
            var tex = sprite.texture;
            context.save();
            context.transformByMatrix(sprite.transform, x, y);
            var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
            var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
            var wRate = width / tex.sourceWidth;
            var hRate = height / tex.sourceHeight;
            width = tex.width * wRate;
            height = tex.height * hRate;
            if (width <= 0 || height <= 0)
                return null;
            var px = -sprite.pivotX + tex.offsetX * wRate;
            var py = -sprite.pivotY + tex.offsetY * hRate;
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                context.drawTexture(tex, px, py, width, height);
            context.restore();
        }
        static alpha_drawTexture(sprite, context, x, y) {
            var alpha = sprite.alpha;
            var tex = sprite.texture;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width <= 0 || height <= 0)
                    return null;
                var px = x - sprite.pivotX + tex.offsetX * wRate;
                var py = y - sprite.pivotY + tex.offsetY * hRate;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    context.drawTexture(tex, px, py, width, height);
                context.globalAlpha = temp;
            }
        }
        static alpha_transform_drawTexture(sprite, context, x, y) {
            var alpha = sprite.alpha;
            var tex = sprite.texture;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                context.save();
                context.transformByMatrix(sprite.transform, x, y);
                var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                var wRate = width / tex.sourceWidth;
                var hRate = height / tex.sourceHeight;
                width = tex.width * wRate;
                height = tex.height * hRate;
                if (width <= 0 || height <= 0)
                    return null;
                var px = -sprite.pivotX + tex.offsetX * wRate;
                var py = -sprite.pivotY + tex.offsetY * hRate;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    context.drawTexture(tex, px, py, width, height);
                context.restore();
                context.globalAlpha = temp;
            }
        }
        static alpha_transform_drawLayaGL(sprite, context, x, y) {
            var alpha = sprite.alpha;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                context.save();
                context.transformByMatrix(sprite.transform, x, y);
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    sprite._graphics && sprite._graphics._render(sprite, context, -sprite.pivotX, -sprite.pivotY);
                context.restore();
                context.globalAlpha = temp;
            }
        }
        static alpha_drawLayaGL(sprite, context, x, y) {
            var alpha = sprite.alpha;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                    sprite._graphics && sprite._graphics._render(sprite, context, x - sprite.pivotX, y - sprite.pivotY);
                context.globalAlpha = temp;
            }
        }
        static transform_drawLayaGL(sprite, context, x, y) {
            context.save();
            context.transformByMatrix(sprite.transform, x, y);
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                sprite._graphics && sprite._graphics._render(sprite, context, -sprite.pivotX, -sprite.pivotY);
            context.restore();
        }
        static transform_drawNodes(sprite, context, x, y) {
            var drawcallOptim = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            context.save();
            context.transformByMatrix(sprite.transform, x, y);
            x = -sprite.pivotX;
            y = -sprite.pivotY;
            var childs = sprite._children, n = childs.length;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (sprite.viewport) {
                rect = sprite.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag = ele._getBit(NodeFlags.ACTUAL_VISIBLE);
                if (rect && ((_x = ele._x) >= right ||
                    (_x + ele.width) <= left ||
                    (_y = ele._y) >= bottom ||
                    (_y + ele.height) <= top))
                    visFlag = false;
                if (visFlag)
                    ele.render(context, x, y);
            }
            context.restore();
            drawcallOptim && context.drawCallOptimize(false);
        }
        static drawLayaGL_drawNodes(sprite, context, x, y) {
            let drawcallOptim = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            x = x - sprite.pivotX;
            y = y - sprite.pivotY;
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR))
                sprite._graphics && sprite._graphics._render(sprite, context, x, y);
            let childs = sprite._children;
            let rect;
            let left, top, right, bottom, _x, _y;
            if (sprite.viewport) {
                rect = sprite.viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0, n = childs.length; i < n; ++i) {
                let ele = childs[i];
                let visFlag = ele._getBit(NodeFlags.ACTUAL_VISIBLE);
                if (drawingToTexture && ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE))
                    visFlag = false;
                if (rect && ((_x = ele._x) >= right ||
                    (_x + ele.width) <= left ||
                    (_y = ele._y) >= bottom ||
                    (_y + ele.height) <= top))
                    visFlag = false;
                if (visFlag)
                    ele.render(context, x, y);
            }
            drawcallOptim && context.drawCallOptimize(false);
        }
    }
    LayaGLQuickRunner.map = [];

    var DefferTouchResContextID = 0;
    class DefferTouchResContext extends Context {
        constructor() {
            super(...arguments);
            this.cache = null;
            this.mustTouchRes = [];
            this.randomTouchRes = [];
            this.genID = DefferTouchResContextID++;
        }
        touchRes(res) {
            if (res.isRandomTouch) {
                this.randomTouchRes.push(res);
            }
            else {
                this.mustTouchRes.push(res);
            }
        }
    }

    class RenderToCache extends Render2D {
        constructor() {
            super(null);
            this.renderResult = [];
        }
        clone(out) {
            return null;
        }
        _createMesh() {
        }
        setVertexDecl(decl) {
            if (this._tex_vert_decl != decl) {
                this._tex_vert_decl = decl;
                this._createMesh();
            }
        }
        renderStart() {
        }
        draw(mesh2d, vboff, vblen, iboff, iblen, mtl) {
            this.setVertexDecl(mesh2d.vertexDeclarition);
            let submesh = new RenderObject2D(mesh2d, vboff, vblen, iboff, iblen, mtl);
            let clipPos = mtl.clipMatPos;
            let clipDir = mtl.clipMatDir;
            let clipMat = submesh.localClipMatrix;
            clipMat.a = clipDir.x;
            clipMat.b = clipDir.y;
            clipMat.c = clipDir.z;
            clipMat.d = clipDir.w;
            clipMat.tx = clipPos.x;
            clipMat.ty = clipPos.y;
            mtl.shaderData.addDefine(ShaderDefines2D.WORLDMAT);
            submesh.toNativeMesh();
            this.renderResult.push(submesh);
        }
        drawMesh(mesh, mtl) {
            throw new NotImplementedError();
        }
        drawElement(ele) {
            throw new NotImplementedError();
        }
        renderEnd() {
        }
    }
    class RenderObject2D {
        constructor(mesh, vboff, vblen, iboff, iblen, mtl) {
            this.localClipMatrix = new Matrix();
            this.vertexDeclarition = mesh.vertexDeclarition;
            this.vbBuffer = new ArrayBuffer(vblen);
            this.ibBuffer = new ArrayBuffer(iblen);
            (new Uint8Array(this.vbBuffer)).set(new Uint8Array(mesh.vbBuffer, vboff, vblen));
            (new Uint8Array(this.ibBuffer)).set(new Uint8Array(mesh.ibBuffer, iboff, iblen));
            this.mtl = mtl;
            this.vboff = 0;
            this.vblen = vblen;
            this.iboff = 0;
            this.iblen = iblen;
        }
        toNativeMesh() {
            let renderDevice = LayaGL.renderDeviceFactory;
            let geo = this.geo = renderDevice.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            let mesh = geo.bufferState = renderDevice.createBufferState();
            let vb = renderDevice.createVertexBuffer(exports.BufferUsage.Dynamic);
            vb.vertexDeclaration = this.vertexDeclarition;
            let ib = renderDevice.createIndexBuffer(exports.BufferUsage.Dynamic);
            mesh.applyState([vb], ib);
            geo.indexFormat = exports.IndexFormat.UInt16;
            vb.setDataLength(this.vblen);
            vb.setData(this.vbBuffer, this.vboff, 0, this.vblen);
            ib._setIndexDataLength(this.iblen);
            ib._setIndexData(new Uint16Array(this.ibBuffer, this.iboff, this.iblen / 2), 0);
            geo.clearRenderParams();
            geo.setDrawElemenParams(this.iblen / 2, 0);
            this.renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
            this.renderElement.geometry = geo;
            this.renderElement.value2DShaderData = this.mtl.shaderData;
            this.renderElement.subShader = this.mtl._defaultShader.getSubShaderAt(0);
            this.renderElement.materialShaderData = null;
            this.renderElement.nodeCommonMap = ["Sprite2D"];
        }
        destroyGPUResource() {
            this.renderElement && this.renderElement.destroy();
            let geo = this.geo;
            if (geo) {
                geo.bufferState._vertexBuffers[0].destroy();
                geo.bufferState._bindedIndexBuffer.destroy();
                geo.bufferState.destroy();
                geo.bufferState;
                geo.destroy();
                this.geo = null;
            }
        }
    }

    class Cache_Info {
        constructor() {
            this.page = null;
        }
        reset() {
            this.page && this.page.reset();
            this.page = null;
        }
    }
    function mergeClipMatrix(a, b, out) {
        let amaxx = a.tx + a.a;
        let amaxy = a.ty + a.d;
        let bmaxx = b.tx + b.a;
        let bmaxy = b.ty + b.d;
        let minx = out.tx = Math.max(a.tx, b.tx);
        let miny = out.ty = Math.max(a.ty, b.ty);
        out.b = out.c = 0;
        out.tx = minx;
        out.ty = miny;
        if (amaxx <= b.tx || amaxy <= b.ty || bmaxx <= a.tx || bmaxy <= a.ty) {
            out.a = -0.1;
            out.d = -0.1;
        }
        else {
            let maxx = Math.min(amaxx, bmaxx);
            let maxy = Math.min(amaxy, bmaxy);
            out.a = maxx - minx;
            out.d = maxy - miny;
        }
        return out;
    }
    class RenderPageContext {
        constructor(ctx, x, y) {
            this.alpha = 1;
            this.width = 0;
            this.height = 0;
            this.blend = 0;
            let mat = this.curMatrix = ctx._curMat.clone();
            mat.tx += mat.a * x + mat.c * y;
            mat.ty += mat.b * x + mat.d * y;
            this.alpha = ctx.globalAlpha;
            this.render2d = ctx.render2D;
            this.width = ctx.width;
            this.height = ctx.height;
            this.clipInfo = ctx._globalClipMatrix.clone();
            this.blend = ctx._nBlendType;
        }
        _copyClipInfo(shaderValue) {
            let clipInfo = this.clipInfo;
            var cm = shaderValue.clipMatDir;
            cm.x = clipInfo.a;
            cm.y = clipInfo.b;
            cm.z = clipInfo.c;
            cm.w = clipInfo.d;
            shaderValue.clipMatDir = cm;
            var cmp = shaderValue.clipMatPos;
            cmp.x = clipInfo.tx;
            cmp.y = clipInfo.ty;
            shaderValue.clipMatPos = cmp;
        }
        clipRect(rect) {
            let x = rect.x;
            let y = rect.y;
            let width = rect.width;
            let height = rect.height;
            var cm = this.clipInfo;
            var minx = cm.tx;
            var miny = cm.ty;
            var maxx = minx + cm.a;
            var maxy = miny + cm.d;
            if (width >= Const.MAX_CLIP_SIZE) {
                cm.a = cm.d = Const.MAX_CLIP_SIZE;
                cm.b = cm.c = cm.tx = cm.ty = 0;
            }
            else {
                let mat = this.curMatrix;
                if (mat._bTransform) {
                    cm.tx = x * mat.a + y * mat.c + mat.tx;
                    cm.ty = x * mat.b + y * mat.d + mat.ty;
                    cm.a = width * mat.a;
                    cm.b = width * mat.b;
                    cm.c = height * mat.c;
                    cm.d = height * mat.d;
                }
                else {
                    cm.tx = x + mat.tx;
                    cm.ty = y + mat.ty;
                    cm.a = width;
                    cm.b = cm.c = 0;
                    cm.d = height;
                }
            }
            if (cm.a > 0 && cm.d > 0) {
                var cmaxx = cm.tx + cm.a;
                var cmaxy = cm.ty + cm.d;
                if (cmaxx <= minx || cmaxy <= miny || cm.tx >= maxx || cm.ty >= maxy) {
                    cm.a = -0.1;
                    cm.d = -0.1;
                }
                else {
                    if (cm.tx < minx) {
                        cm.a -= (minx - cm.tx);
                        cm.tx = minx;
                    }
                    if (cmaxx > maxx) {
                        cm.a -= (cmaxx - maxx);
                    }
                    if (cm.ty < miny) {
                        cm.d -= (miny - cm.ty);
                        cm.ty = miny;
                    }
                    if (cmaxy > maxy) {
                        cm.d -= (cmaxy - maxy);
                    }
                    if (cm.a <= 0)
                        cm.a = -0.1;
                    if (cm.d <= 0)
                        cm.d = -0.1;
                }
            }
        }
        setBlendMode(blend) {
            this.blend = BlendMode.TOINT[blend];
        }
        _applyBlend(shaderValue) {
            let shaderdata = shaderValue.shaderData;
            switch (this.blend) {
                case 1:
                case 3:
                case 5:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE);
                    break;
                case 2:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_DST_COLOR);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                case 6:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_SRC_ALPHA);
                    break;
                case 7:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ZERO);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ZERO);
                    break;
                case 9:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_SRC_ALPHA);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                    break;
                default:
                    shaderdata.setInt(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                    shaderdata.setInt(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
            }
        }
    }
    class CachePage {
        constructor() {
            this.sprite = null;
            this.meshes = null;
            this.defferTouchRes = null;
            this.defferTouchResRand = null;
            this.children = null;
        }
        reset() {
            this.clearGPUObject();
        }
        clearGPUObject() {
            if (this.meshes) {
                this.meshes.forEach(m => {
                    m.destroyGPUResource();
                });
            }
        }
        render(sprite, context, isRoot) {
            let spriteTrans = sprite.transform;
            let curMat = context.curMatrix;
            if (isRoot) {
                curMat.copyTo(worldMat);
            }
            else {
                let x = sprite._x;
                let y = sprite._y;
                if (spriteTrans) {
                    spriteTrans.copyTo(tmpMat);
                    tmpMat.tx = x;
                    tmpMat.ty = y;
                    Matrix.mul(tmpMat, curMat, worldMat);
                }
                else {
                    worldMat.a = curMat.a;
                    worldMat.b = curMat.b;
                    worldMat.c = curMat.c;
                    worldMat.d = curMat.d;
                    worldMat.tx = curMat.a * x + curMat.c * y + curMat.tx;
                    worldMat.ty = curMat.b * x + curMat.d * y + curMat.ty;
                }
                context.alpha *= sprite.alpha;
                if (sprite.blendMode) {
                    context.setBlendMode(sprite.blendMode);
                }
            }
            vec21.setValue(context.width, context.height);
            let wMat4 = tmpMat4;
            let mate = wMat4.elements;
            mate[0] = worldMat.a;
            mate[1] = worldMat.b;
            mate[4] = worldMat.c;
            mate[5] = worldMat.d;
            mate[12] = worldMat.tx;
            mate[13] = worldMat.ty;
            this.meshes.forEach(renderinfo => {
                let render = context.render2d;
                let curMtl = renderinfo.mtl;
                if (curMtl.textureHost instanceof TextTexture) {
                    curMtl.textureHost.touchTexture();
                }
                curMtl.size = vec21;
                let clipMat = renderinfo.localClipMatrix;
                if (clipMat.a == Const.MAX_CLIP_SIZE && clipMat.d == Const.MAX_CLIP_SIZE) {
                    context.clipInfo.copyTo(tmpMat1);
                }
                else {
                    Matrix.mul(clipMat, worldMat, tmpMat1);
                    mergeClipMatrix(context.clipInfo, tmpMat1, tmpMat1);
                }
                let clipDir = curMtl.clipMatDir;
                let clipPos = curMtl.clipMatPos;
                clipDir.x = tmpMat1.a;
                clipDir.y = tmpMat1.b;
                clipDir.z = tmpMat1.c;
                clipDir.w = tmpMat1.d;
                curMtl.clipMatDir = clipDir;
                clipPos.x = tmpMat1.tx;
                clipPos.y = tmpMat1.ty;
                curMtl.clipMatPos = clipPos;
                curMtl.mmat = wMat4;
                curMtl.vertAlpha = context.alpha;
                context._applyBlend(curMtl);
                render.drawElement(renderinfo.renderElement);
            });
            this.defferTouchRes.forEach(res => { res.touch(); });
            this.defferTouchResRand.forEach(res => res.touch());
            this.children && this.children.forEach(sp => {
                let oldMat = context.curMatrix.clone();
                let oldAlpha = context.alpha;
                let parentCacheInfo = sp._parent._cacheStyle.cacheInfo;
                let offmat = parentCacheInfo.mat;
                Matrix.mul(offmat, oldMat, context.curMatrix);
                context.alpha *= parentCacheInfo.alpha;
                let oldBlend = context.blend;
                if (parentCacheInfo.blend != undefined) {
                    context.setBlendMode(parentCacheInfo.blend);
                }
                let oldClipMatrix = context.clipInfo.clone();
                let clipMat = parentCacheInfo.clipMatrix;
                Matrix.mul(clipMat, context.curMatrix, tmpMat1);
                mergeClipMatrix(context.clipInfo, tmpMat1, context.clipInfo);
                sp._cacheStyle.cacheInfo.page.render(sp, context, false);
                context.curMatrix = oldMat;
                context.alpha = oldAlpha;
                context.blend = oldBlend;
                context.clipInfo = oldClipMatrix;
            });
        }
    }
    var vec21 = new Vector2();
    class SpriteCache {
        static curMatSubSpriteMat(sprite, curMat, outMat) {
            if (sprite._renderType & SpriteConst.TRANSFORM) {
                sprite.transform.copyTo(invMat);
                invMat.tx = sprite._x;
                invMat.ty = sprite._y;
                invMat.invert();
                Matrix.mul(invMat, curMat, outMat);
            }
            else {
                curMat.copyTo(outMat);
                let cx = -sprite._x;
                let cy = -sprite._y;
                outMat.tx += (outMat.a * cx + outMat.c * cy);
                outMat.ty += (outMat.b * cx + outMat.d * cy);
            }
            return outMat;
        }
        static renderCacheAsNormal(context, sprite, next, x, y) {
            let rebuild = false;
            var cache = sprite._getCacheStyle().cacheInfo.page;
            if (!cache || sprite._needRepaint() || Render.isGlobalRepaint()) {
                if (sprite.alpha <= 1e-6) {
                    sprite.alpha = 0.001;
                }
                rebuild = true;
                if (context instanceof DefferTouchResContext) {
                    let parentPage = context.cache;
                    if (!parentPage.children) {
                        parentPage.children = [sprite];
                    }
                    else if (parentPage.children.indexOf(sprite) < 0) {
                        parentPage.children.push(sprite);
                    }
                    let parentNode = sprite._parent;
                    let parentCacheInfo = parentNode._cacheStyle.cacheInfo;
                    parentCacheInfo.page = parentPage;
                    if (context.genID != parentCacheInfo.contextID) {
                        parentCacheInfo.contextID = context.genID;
                        let curMat = context._curMat.clone();
                        if (x != 0 || y != 0) {
                            curMat.tx += x * curMat.a + y * curMat.c;
                            curMat.ty += x * curMat.b + y * curMat.d;
                        }
                        parentCacheInfo.mat = SpriteCache.curMatSubSpriteMat(sprite, curMat, curMat);
                        parentCacheInfo.alpha = context.globalAlpha / sprite.alpha;
                        let pageRootSprite = parentPage.sprite;
                        if (parentNode.blendMode) {
                            parentCacheInfo.blend = parentNode.blendMode;
                        }
                        else {
                            let curNode = parentNode;
                            while (curNode != pageRootSprite) {
                                curNode = curNode._parent;
                                if (curNode.blendMode) {
                                    parentCacheInfo.blend = curNode.blendMode;
                                    break;
                                }
                            }
                        }
                        parentCacheInfo.clipMatrix = context._globalClipMatrix.clone();
                    }
                }
                cache = sprite._cacheStyle.cacheInfo.page = new CachePage();
                cache.sprite = sprite;
                Stat.canvasNormal++;
                let ctx = new DefferTouchResContext();
                ctx.cache = cache;
                let renderer = new RenderToCache();
                ctx.render2D = renderer;
                ctx.startRender();
                next._fun(sprite, ctx, 0, 0);
                ctx.endRender();
                cache.meshes = renderer.renderResult;
                cache.defferTouchRes = ctx.mustTouchRes;
                cache.defferTouchResRand = ctx.randomTouchRes;
                sprite.once(Event.REMOVED, () => {
                    cache = sprite._cacheStyle.cacheInfo.page;
                    cache.reset();
                });
            }
            if (!(context instanceof DefferTouchResContext)) {
                let ctx = new RenderPageContext(context, x, y);
                cache.render(sprite, ctx, true);
            }
            return rebuild;
        }
    }
    var worldMat = new Matrix;
    var invMat = new Matrix;
    var tmpMat = new Matrix;
    var tmpMat4 = new Matrix4x4;
    var tmpMat1 = new Matrix();

    const INIT = 0x11111;
    class RenderSprite {
        static __init__() {
            LayaGLQuickRunner.__init__();
            var initRender = new RenderSprite(INIT, null);
            let len = RenderSprite.renders.length = SpriteConst.CHILDS * 2;
            for (let i = 0; i < len; i++)
                RenderSprite.renders[i] = initRender;
            RenderSprite.renders[0] = new RenderSprite(0, null);
        }
        static _initRenderFun(sprite, context, x, y) {
            var type = sprite._renderType;
            var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
            r._fun(sprite, context, x, y);
        }
        static _getTypeRender(type) {
            if (LayaGLQuickRunner.map[type] && LayaEnv.isPlaying)
                return new RenderSprite(type, null);
            var rst = null;
            var tType = SpriteConst.CHILDS;
            while (tType > 0) {
                if (tType & type)
                    rst = new RenderSprite(tType, rst);
                tType = tType >> 1;
            }
            return rst;
        }
        constructor(type, next) {
            this._maskRect_TextureSpace = new Rectangle();
            if (LayaGLQuickRunner.map[type] && LayaEnv.isPlaying) {
                this._fun = LayaGLQuickRunner.map[type];
                this._next = RenderSprite.NORENDER;
                return;
            }
            this._next = next || RenderSprite.NORENDER;
            switch (type) {
                case 0:
                    this._fun = this._no;
                    return;
                case SpriteConst.ALPHA:
                    this._fun = this._alpha;
                    return;
                case SpriteConst.TRANSFORM:
                    this._fun = this._transform;
                    return;
                case SpriteConst.BLEND:
                    this._fun = this._blend;
                    return;
                case SpriteConst.CANVAS:
                    this._fun = this._canvas;
                    return;
                case SpriteConst.MASK:
                    this._fun = this._mask;
                    return;
                case SpriteConst.CLIP:
                    this._fun = this._clip;
                    return;
                case SpriteConst.GRAPHICS:
                    this._fun = this._graphics;
                    return;
                case SpriteConst.CHILDS:
                    this._fun = this._children;
                    return;
                case SpriteConst.CUSTOM:
                    this._fun = this._custom;
                    return;
                case SpriteConst.TEXTURE:
                    this._fun = this._texture;
                    return;
                case SpriteConst.FILTERS:
                    this._fun = Filter._filter;
                    return;
                case SpriteConst.HITAREA:
                    this._fun = this._hitarea;
                    return;
                case SpriteConst.RENDERNODE2D:
                    this._fun = this._renderNode2D;
                    break;
                case INIT:
                    this._fun = RenderSprite._initRenderFun;
                    return;
            }
        }
        _renderNode2D(sprite, context, x, y) {
            if (sprite._renderNode.addCMDCall)
                sprite._renderNode.addCMDCall(context, x, y);
            context.drawLeftData();
            if (context._render2DManager._renderEnd) {
                context._render2DManager._renderEnd = false;
                context._render2DManager.addRenderObject(sprite._renderNode);
            }
            else {
                context._render2DManager.addRenderObject(sprite._renderNode);
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _no(sprite, context, x, y) {
        }
        _custom(sprite, context, x, y) {
            sprite.customRender(context, x, y);
            this._next._fun(sprite, context, 0, 0);
        }
        _clip(sprite, context, x, y) {
            let next = this._next;
            if (next == RenderSprite.NORENDER)
                return;
            if (sprite._getBit(NodeFlags.DISABLE_INNER_CLIPPING) && !context._drawingToTexture) {
                next._fun(sprite, context, x, y);
                return;
            }
            let r = sprite._scrollRect;
            let width = r.width;
            let height = r.height;
            if (width === 0)
                width = 0.001;
            if (height === 0)
                height = 0.001;
            context.save();
            context.clipRect(x, y, width, height);
            next._fun(sprite, context, x - r.x, y - r.y);
            context.restore();
        }
        _texture(sprite, context, x, y) {
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                var tex = sprite.texture;
                if (tex._getSource()) {
                    var width = sprite._isWidthSet ? sprite._width : tex.sourceWidth;
                    var height = sprite._isHeightSet ? sprite._height : tex.sourceHeight;
                    var wRate = width / tex.sourceWidth;
                    var hRate = height / tex.sourceHeight;
                    width = tex.width * wRate;
                    height = tex.height * hRate;
                    if (width > 0 && height > 0) {
                        let px = x - sprite.pivotX + tex.offsetX * wRate;
                        let py = y - sprite.pivotY + tex.offsetY * hRate;
                        context._material = sprite.graphics.material;
                        context.drawTexture(tex, px, py, width, height, 0xffffffff);
                        context._material = null;
                    }
                }
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _graphics(sprite, context, x, y) {
            if (!sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                let g = sprite._graphics;
                g && g._render(sprite, context, x - sprite._pivotX, y - sprite._pivotY);
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _hitarea(sprite, context, x, y) {
            if (!context._drawingToTexture && sprite.hitArea) {
                let g = sprite.hitArea._hit;
                let temp = context.globalAlpha;
                context.globalAlpha *= 0.5;
                g && g._render(sprite, context, x - sprite._pivotX, y - sprite._pivotY);
                g = sprite.hitArea._unHit;
                g && g._render(sprite, context, x - sprite._pivotX, y - sprite._pivotY);
                context.globalAlpha = temp;
            }
            if (this._next != RenderSprite.NORENDER)
                this._next._fun(sprite, context, x, y);
        }
        _alpha(sprite, context, x, y) {
            let alpha = sprite._alpha;
            if (alpha > 0.01 || sprite._needRepaint()) {
                var temp = context.globalAlpha;
                context.globalAlpha *= alpha;
                if (this._next != RenderSprite.NORENDER)
                    this._next._fun(sprite, context, x, y);
                context.globalAlpha = temp;
            }
        }
        _transform(sprite, context, x, y) {
            let transform = sprite.transform, _next = this._next;
            if (transform && _next != RenderSprite.NORENDER) {
                context.save();
                context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
                _next._fun(sprite, context, 0, 0);
                context.restore();
            }
            else {
                if (_next != RenderSprite.NORENDER)
                    _next._fun(sprite, context, x, y);
            }
        }
        _children(sprite, context, x, y) {
            let childs = sprite._children, n = childs.length;
            x = x - sprite.pivotX;
            y = y - sprite.pivotY;
            let textLastRender = sprite._getBit(NodeFlags.DRAWCALL_OPTIMIZE) && context.drawCallOptimize(true);
            let drawingToTexture = context._drawingToTexture;
            let rect;
            let left, top, right, bottom, x2, y2;
            if (sprite._viewport) {
                rect = sprite._viewport;
                left = rect.x;
                top = rect.y;
                right = rect.right;
                bottom = rect.bottom;
            }
            for (let i = 0; i < n; ++i) {
                let ele = childs[i];
                let visFlag = ele._getBit(NodeFlags.ACTUAL_VISIBLE);
                if (drawingToTexture && ele._getBit(NodeFlags.ESCAPE_DRAWING_TO_TEXTURE))
                    visFlag = false;
                if (visFlag) {
                    if (rect && ((x2 = ele._x) >= right || (x2 + ele.width) <= left || (y2 = ele._y) >= bottom || (y2 + ele.height) <= top))
                        visFlag = false;
                    else if (sprite._cacheStyle.mask == ele && (!ele._getBit(NodeFlags.FORCE_VISIBLE) || drawingToTexture))
                        visFlag = false;
                }
                if (visFlag) {
                    if (ele._getBit(NodeFlags.DISABLE_OUTER_CLIPPING))
                        context.clipRect(0, 0, 1, 1, true);
                    ele.render(context, x, y);
                }
            }
            textLastRender && context.drawCallOptimize(false);
        }
        _renderNextToCacheRT(sprite, context, marginLeft = 0, marginTop = 0, marginRight = 0, marginBottom = 0) {
            let cache = sprite._getCacheStyle();
            if (sprite._needRepaint() || !cache.renderTexture || Render.isGlobalRepaint()) {
                if (cache.renderTexture) {
                    cache.renderTexture.destroy();
                }
                let scaleInfo = cache._calculateCacheRect(sprite, "bitmap", 0, 0);
                let tRec = cache.cacheRect;
                if (tRec.width <= 0 || tRec.height <= 0) {
                    cache.renderTexture = null;
                    return false;
                }
                Stat.canvasBitmap++;
                let w = tRec.width * scaleInfo.x + marginLeft + marginRight;
                let h = tRec.height * scaleInfo.y + marginTop + marginBottom;
                let rt = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8);
                let ctx = new Context();
                ctx.copyState(context);
                ctx.size(w, h);
                ctx.clearBG(0, 0, 0, 0);
                ctx.render2D = new Render2DSimple(rt);
                ctx.startRender();
                tRec.x -= marginLeft;
                tRec.y -= marginTop;
                this._next._fun(sprite, ctx, -tRec.x, -tRec.y);
                ctx.endRender();
                ctx.destroy();
                cache.renderTexture = rt;
                return true;
            }
            return false;
        }
        _canvas(sprite, context, x, y) {
            let cache = sprite._cacheStyle;
            let next = this._next;
            if (sprite._getBit(NodeFlags.HIDE_BY_EDITOR)) {
                next._fun(sprite, context, x, y);
                return;
            }
            let isbmp = sprite.cacheAs === 'bitmap';
            if (isbmp) {
                context.drawLeftData();
                this._renderNextToCacheRT(sprite, context);
                let tRec = cache.cacheRect;
                context._material = sprite.graphics.material;
                let rt = cache.renderTexture;
                rt && context._drawRenderTexture(rt, x + tRec.x, y + tRec.y, rt.width, rt.height, null, 1, [0, 1, 1, 1, 1, 0, 0, 0]);
                context._material = null;
            }
            else {
                if (!RenderSprite.cacheNormalEnable) {
                    next._fun(sprite, context, x, y);
                    return;
                }
                else {
                    context.drawLeftData();
                    SpriteCache.renderCacheAsNormal(context, sprite, this._next, x, y);
                }
            }
        }
        static RenderToRenderTexture(sprite, context, x, y, renderTexture = null, isDrawRenderRect = true) {
            let scaleInfo = sprite._getCacheStyle()._calculateCacheRect(sprite, "bitmap", 0, 0);
            this._transBound(sprite._cacheStyle.cacheRect, sprite.transform);
            let tRec = sprite._cacheStyle.cacheRect;
            let ctx = new Context();
            ctx._drawingToTexture = true;
            context && ctx.copyState(context);
            let rt = renderTexture;
            if (rt) {
                ctx.size(rt.width, rt.height);
                ctx.clearBG(RenderTexture2D._clearColor.r, RenderTexture2D._clearColor.g, RenderTexture2D._clearColor.b, RenderTexture2D._clearColor.a);
            }
            else {
                let w = tRec.width * scaleInfo.x + (isDrawRenderRect ? 0 : tRec.x);
                let h = tRec.height * scaleInfo.y + (isDrawRenderRect ? 0 : tRec.y);
                rt = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8);
                ctx.size(w, h);
                ctx.clearBG(0, 0, 0, 0);
            }
            ctx.render2D = ctx.render2D.clone(rt);
            ctx.startRender();
            if (isDrawRenderRect) {
                sprite.render(ctx, x - sprite.x - tRec.x, y - sprite.y - tRec.y);
            }
            else {
                sprite.render(ctx, x - sprite.x, y - sprite.y);
            }
            ctx.endRender();
            ctx._drawingToTexture = false;
            ctx.destroy();
            return rt;
        }
        static RenderToCacheTexture(sprite, context, x, y, isDrawRenderRect = true) {
            let cache = sprite._getCacheStyle();
            if (sprite._needRepaint() || !cache.renderTexture || Render.isGlobalRepaint()) {
                if (cache.renderTexture) {
                    cache.renderTexture.destroy();
                }
                cache.renderTexture = RenderSprite.RenderToRenderTexture(sprite, context, x, y, null, isDrawRenderRect);
                return true;
            }
            return false;
        }
        _blend(sprite, context, x, y) {
            context.save();
            context.globalCompositeOperation = sprite._blendMode;
            this._next._fun(sprite, context, x, y);
            context.restore();
        }
        static _transBound(bound, trans) {
            if (!trans || !bound)
                return;
            let a = trans.a, b = trans.b, c = trans.c, d = trans.d;
            let x1 = bound.x;
            let y1 = bound.y;
            let x2 = x1 + bound.width;
            let y2 = y1 + bound.height;
            let tx1 = x1 * a;
            let tx2 = x2 * a;
            let ty1 = y1 * c;
            let ty2 = y2 * c;
            let px1 = x1 * b;
            let px2 = x2 * b;
            let py1 = y1 * d;
            let py2 = y2 * d;
            let minX = Math.min(tx1 + ty1, tx1 + ty2, tx2 + ty1, tx2 + ty2);
            let maxX = Math.max(tx1 + ty1, tx1 + ty2, tx2 + ty1, tx2 + ty2);
            let minY = Math.min(px1 + py1, px1 + py2, px2 + py1, px2 + py2);
            let maxY = Math.max(px1 + py1, px1 + py2, px2 + py1, px2 + py2);
            bound.setTo(minX, minY, maxX - minX, maxY - minY);
        }
        _mask(sprite, ctx, x, y) {
            let mask = sprite.mask;
            if (mask._getBit(NodeFlags.FORCE_VISIBLE) && !ctx._drawingToTexture) {
                if (this._next != RenderSprite.NORENDER)
                    this._next._fun(sprite, ctx, x, y);
                return;
            }
            let cache = sprite._getCacheStyle();
            if (sprite._needRepaint() || !cache.renderTexture || cache.renderTexture.destroyed || Render.isGlobalRepaint()) {
                if (cache.renderTexture) {
                    cache.renderTexture.destroy();
                }
                cache._calculateCacheRect(sprite, "bitmap", 0, 0);
                spRect_TS.copyFrom(cache.cacheRect);
                if (spRect_TS.width <= 0 || spRect_TS.height <= 0)
                    return;
                spRect_TS.x += sprite.pivotX;
                spRect_TS.y += sprite.pivotY;
                let maskcache = mask._getCacheStyle();
                maskcache._calculateCacheRect(mask, "bitmap", 0, 0);
                RenderSprite._transBound(maskcache.cacheRect, mask.transform);
                let maskRect_TS = this._maskRect_TextureSpace.copyFrom(maskcache.cacheRect);
                maskRect_TS.x += mask._x;
                maskRect_TS.y += mask._y;
                let x1 = Math.max(spRect_TS.x, maskRect_TS.x);
                let y1 = Math.max(spRect_TS.y, maskRect_TS.y);
                let x2 = Math.min(spRect_TS.x + spRect_TS.width, maskRect_TS.x + maskRect_TS.width);
                let y2 = Math.min(spRect_TS.y + spRect_TS.height, maskRect_TS.y + maskRect_TS.height);
                let width1 = x2 - x1;
                let height1 = y2 - y1;
                if (width1 <= 0 || height1 <= 0)
                    return;
                RenderSprite.RenderToCacheTexture(mask, ctx, 0, 0);
                let rt = new RenderTexture2D(width1, height1, exports.RenderTargetFormat.R8G8B8A8);
                rt._invertY = LayaGL.renderEngine._screenInvertY;
                let ctx1 = new Context();
                ctx1.clearBG(0, 0, 0, 0);
                ctx1.size(width1, height1);
                ctx1.render2D = new Render2DSimple(rt);
                ctx1.startRender();
                ctx1._drawingToTexture = ctx._drawingToTexture;
                this._next._fun(sprite, ctx1, sprite.pivotX - x1, sprite.pivotY - y1);
                ctx1._drawingToTexture = false;
                let maskRT = maskcache.renderTexture;
                ctx1.globalCompositeOperation = 'mask';
                ctx1._drawRenderTexture(maskRT, maskRect_TS.x - x1, maskRect_TS.y - y1, maskRect_TS.width, maskRect_TS.height, null, 1, [0, 1, 1, 1, 1, 0, 0, 0]);
                ctx1.endRender();
                ctx1.destroy();
                cache.renderTexture = rt;
                cache.cacheRect.x = x1 - sprite.pivotX;
                cache.cacheRect.y = y1 - sprite.pivotY;
                cache.cacheRect.width = rt.width;
                cache.cacheRect.height = rt.height;
            }
            let tex = cache.renderTexture;
            let rect = cache.cacheRect;
            ctx._drawRenderTexture(tex, x + rect.x, y + rect.y, tex.width, tex.height, null, 1, [0, 1, 1, 1, 1, 0, 0, 0]);
        }
    }
    RenderSprite.cacheNormalEnable = true;
    RenderSprite.renders = [];
    RenderSprite.NORENDER = new RenderSprite(0, null);
    const spRect_TS = new Rectangle();
    new Rectangle();

    class HTMLCanvas extends Resource {
        constructor(createCanvas = false) {
            super();
            this.width = 0;
            this.height = 0;
            if (createCanvas)
                this.source = Browser.createElement("canvas");
            else {
                this.source = this;
            }
            this.lock = true;
        }
        clear() {
            if (this._ctx) {
                if (this._ctx.clear) {
                    this._ctx.clear();
                }
                else {
                    this._ctx.clearRect(0, 0, this.width, this.height);
                }
            }
            if (this._texture) {
                this._texture.destroy();
                this._texture = null;
            }
        }
        destroy() {
            super.destroy();
            this._setCPUMemory(0);
            this._ctx && this._ctx.destroy && this._ctx.destroy();
            this._ctx = null;
        }
        release() {
        }
        get context() {
            if (this._ctx)
                return this._ctx;
            if (this.source == this)
                this._ctx = new Context();
            else
                this._ctx = this.source.getContext(LayaEnv.isConch ? 'layagl' : '2d');
            this._ctx._canvas = this;
            return this._ctx;
        }
        set context(value) {
            this._ctx = value;
        }
        getContext(contextID, other) {
            return this.context;
        }
        size(w, h) {
            if (this.width != w || this.height != h || (this.source && (this.source.width != w || this.source.height != h))) {
                this.width = w;
                this.height = h;
                this._setCPUMemory(w * h * 4);
                this._ctx && this._ctx.size && this._ctx.size(w, h);
                if (this.source) {
                    this.source.height = h;
                    this.source.width = w;
                }
                if (this._texture) {
                    this._texture.destroy();
                    this._texture = null;
                }
            }
        }
        _getSource() {
            return this.source;
        }
        getTexture() {
            if (!this._texture) {
                var bitmap = new Texture2D(this.source.width, this.source.height, exports.TextureFormat.R8G8B8A8, true, false, false);
                bitmap.setImageData(this.source, false, false);
                this._texture = new Texture(bitmap);
            }
            return this._texture;
        }
        toBase64(type, encoderOptions) {
            if (this.source)
                return this.source.toDataURL(type, encoderOptions);
            else
                return null;
        }
    }

    class CacheStyle {
        constructor() {
            this.renderTexOffx = 0;
            this.renderTexOffy = 0;
            this.cacheInfo = new Cache_Info();
            this.reset();
        }
        onInvisible() {
        }
        set renderTexture(rt) {
            if (this._renderTexture && rt != this._renderTexture) {
                this._renderTexture.destroy();
            }
            this._renderTexture = rt;
        }
        get renderTexture() {
            return this._renderTexture;
        }
        recover() {
            if (this === CacheStyle.EMPTY)
                return;
            Pool.recover("SpriteCache", this.reset());
        }
        reset() {
            this.userSetCache = "none";
            this.staticCache = false;
            this.mask = null;
            this.maskParent = null;
            this.cacheRect = null;
            this.cacheInfo.reset();
            return this;
        }
        static create() {
            return Pool.getItemByClass("SpriteCache", CacheStyle);
        }
        _calculateCacheRect(sprite, tCacheType, x, y) {
            var _cacheStyle = sprite._getCacheStyle();
            if (!_cacheStyle.cacheRect)
                _cacheStyle.cacheRect = new Rectangle();
            var tRec;
            if (tCacheType === "bitmap") {
                tRec = sprite.getSelfBounds();
                tRec.width = tRec.width;
                tRec.height = tRec.height;
                tRec.x = tRec.x - sprite.pivotX;
                tRec.y = tRec.y - sprite.pivotY;
                tRec.x = Math.floor(tRec.x + x) - x;
                tRec.y = Math.floor(tRec.y + y) - y;
                tRec.width = Math.floor(tRec.width);
                tRec.height = Math.floor(tRec.height);
                _cacheStyle.cacheRect.copyFrom(tRec);
            }
            else {
                _cacheStyle.cacheRect.setTo(-sprite.pivotX, -sprite.pivotY, 1, 1);
            }
            tRec = _cacheStyle.cacheRect;
            if (sprite.scrollRect) {
                var scrollRect = sprite.scrollRect;
                tRec.x -= scrollRect.x;
                tRec.y -= scrollRect.y;
            }
            CacheStyle._scaleInfo.setTo(1, 1);
            return CacheStyle._scaleInfo;
        }
    }
    CacheStyle.EMPTY = new CacheStyle();
    CacheStyle._scaleInfo = new Point();
    CacheStyle.CANVAS_EXTEND_EDGE = 16;

    class RestoreCmd {
        static create() {
            return Pool.getItemByClass("RestoreCmd", RestoreCmd);
        }
        recover() {
            Pool.recover("RestoreCmd", this);
        }
        run(context) {
            context.restore();
        }
        get cmdID() {
            return RestoreCmd.ID;
        }
    }
    RestoreCmd.ID = "Restore";

    class SaveCmd {
        static create() {
            return Pool.getItemByClass("SaveCmd", SaveCmd);
        }
        recover() {
            Pool.recover("SaveCmd", this);
        }
        run(context) {
            context.save();
        }
        get cmdID() {
            return SaveCmd.ID;
        }
    }
    SaveCmd.ID = "Save";

    class GraphicsBounds {
        constructor() {
            this._cacheType = null;
        }
        destroy() {
            this._cacheType = null;
            this._affectBySize = false;
            this._bounds = null;
            this._bound2 = null;
            Pool.recover("GraphicsBounds", this);
        }
        static create() {
            return Pool.getItemByClass("GraphicsBounds", GraphicsBounds);
        }
        reset() {
            this._cacheType = null;
        }
        getBounds(g, realSize) {
            realSize = !!realSize;
            if (realSize !== this._cacheType) {
                this._bound2 = this._getCmdPoints(g, realSize);
                this._bounds = Rectangle._getWrapRec(this._bound2, this._bounds);
                this._cacheType = realSize;
            }
            return this._bounds;
        }
        getBoundPoints(g, realSize) {
            this.getBounds(g, realSize);
            return this._bound2;
        }
        _getCmdPoints(g, realSize) {
            this._affectBySize = false;
            let points = this._bound2 || (this._bound2 = []);
            points.length = 0;
            let cmds = g.cmds;
            let sp = g._sp;
            if (cmds.length == 0)
                return points;
            _assembler.allPoints = points;
            _assembler.width = sp._width;
            _assembler.height = sp._height;
            _assembler.affectBySize = false;
            _assembler.matrix.identity();
            let matrixs = _tempMatrixArrays;
            matrixs.length = 0;
            for (let i = 0, n = cmds.length; i < n; i++) {
                let cmd = cmds[i];
                switch (cmd.cmdID) {
                    case SaveCmd.ID:
                        matrixs.push(_assembler.matrix);
                        _assembler.matrix = _assembler.matrix.clone();
                        break;
                    case RestoreCmd.ID:
                        _assembler.matrix = matrixs.pop();
                        break;
                    default:
                        _assembler.points.length = 0;
                        if (cmd.getBounds)
                            cmd.getBounds(_assembler);
                        else
                            _tempRect$1.setTo(sp.x, sp.y, sp._width, sp._height).getBoundPoints(_assembler.points);
                        if (_assembler.points.length > 0)
                            _assembler.flushPoints();
                        break;
                }
            }
            if (points.length > 200) {
                let rect = Rectangle._getWrapRec(points, _tempRect$1);
                points.length = 0;
                rect.getBoundPoints(points);
            }
            else if (points.length > 8)
                GrahamScan.scanPList(points);
            this._affectBySize = _assembler.affectBySize;
            return points;
        }
    }
    class GraphicsBoundsAssembler {
        constructor() {
            this.points = [];
            this.matrix = new Matrix();
        }
        flushPoints(dx, dy, matrix) {
            if (dx == null)
                dx = 0;
            if (dy == null)
                dy = 0;
            if (matrix) {
                this.matrix.copyTo(_tempMatrix);
                _tempMatrix.concat(matrix);
                matrix = _tempMatrix;
            }
            else
                matrix = this.matrix;
            let len = this.points.length;
            let _tempPoint = Point.TEMP;
            for (let i = 0; i < len; i += 2) {
                _tempPoint.setTo(this.points[i] + dx, this.points[i + 1] + dy);
                if (_tempPoint.x == null)
                    _tempPoint.x = 0;
                if (_tempPoint.y == null)
                    _tempPoint.y = 0;
                matrix.transformPoint(_tempPoint);
                this.allPoints.push(_tempPoint.x, _tempPoint.y);
            }
            this.points.length = 0;
        }
        concatMatrix(matrix) {
            matrix.copyTo(_tempMatrix);
            _tempMatrix.concat(this.matrix);
            _tempMatrix.copyTo(this.matrix);
        }
    }
    const _assembler = new GraphicsBoundsAssembler();
    const _tempMatrix = new Matrix();
    const _tempMatrixArrays = [];
    const _tempRect$1 = new Rectangle();

    class AlphaCmd {
        static create(alpha) {
            var cmd = Pool.getItemByClass("AlphaCmd", AlphaCmd);
            cmd.alpha = alpha;
            return cmd;
        }
        recover() {
            Pool.recover("AlphaCmd", this);
        }
        run(context, gx, gy) {
            context.alpha(this.alpha);
        }
        getBounds(assembler) {
        }
        get cmdID() {
            return AlphaCmd.ID;
        }
    }
    AlphaCmd.ID = "Alpha";

    class ClipRectCmd {
        static create(x, y, width, height) {
            var cmd = Pool.getItemByClass("ClipRectCmd", ClipRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            return cmd;
        }
        recover() {
            Pool.recover("ClipRectCmd", this);
        }
        run(context, gx, gy) {
            context.clipRect(this.x + gx, this.y + gy, this.width, this.height);
        }
        get cmdID() {
            return ClipRectCmd.ID;
        }
    }
    ClipRectCmd.ID = "ClipRect";

    class Draw9GridTextureCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.color = 0xffffffff;
            this.percent = true;
        }
        static create(texture, x, y, width, height, sizeGrid, percent, color) {
            let cmd = Pool.getItemByClass("Draw9GridTextureCmd", Draw9GridTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.sizeGrid = sizeGrid;
            cmd.percent = percent;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            var _a;
            (_a = this.texture) === null || _a === void 0 ? void 0 : _a._removeReference();
            this.texture = null;
            Pool.recover("Draw9GridTextureCmd", this);
        }
        run(context, gx, gy) {
            if (this.texture) {
                let sizeGrid = this.sizeGrid || this.texture._sizeGrid || EMPTY_SIZE_GRID;
                if (this.percent && context.sprite) {
                    let w = context.sprite.width;
                    let h = context.sprite.height;
                    context.drawTextureWithSizeGrid(this.texture, this.x * w, this.y * h, this.width * w, this.height * h, sizeGrid, gx, gy, this.color);
                }
                else
                    context.drawTextureWithSizeGrid(this.texture, this.x, this.y, this.width, this.height, sizeGrid, gx, gy, this.color);
            }
        }
        get cmdID() {
            return Draw9GridTextureCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    Draw9GridTextureCmd.ID = "Draw9GridTexture";
    const EMPTY_SIZE_GRID = [0, 0, 0, 0, 0];
    ClassUtils.regClass("Draw9GridTextureCmd", Draw9GridTextureCmd);

    class DrawCircleCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, radius, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawCircleCmd", DrawCircleCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawCircleCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawCircle(this.x * w + gx, this.y * h + gy, this.radius * Math.min(w, h) - offset, this.fillColor, this.lineColor, this.lineWidth, 0);
            }
            else
                context._drawCircle(this.x + gx, this.y + gy, this.radius - offset, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawCircleCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x - this.radius, this.y - this.radius, this.radius + this.radius, this.radius + this.radius);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawCircleCmd.ID = "DrawCircle";
    ClassUtils.regClass("DrawCircleCmd", DrawCircleCmd);

    class DrawCurvesCmd {
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawCurvesCmd", DrawCurvesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover("DrawCurvesCmd", this);
        }
        run(context, gx, gy) {
            if (this.points)
                context.drawCurves(this.x + gx, this.y + gy, this.points, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawCurvesCmd.ID;
        }
        getBounds(assembler) {
            Bezier.getPoints(this.points, 5, 2, assembler.points);
            assembler.flushPoints(this.x, this.y);
        }
    }
    DrawCurvesCmd.ID = "DrawCurves";
    ClassUtils.regClass("DrawCurvesCmd", DrawCurvesCmd);

    class DrawImageCmd {
        constructor() {
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, color) {
            let cmd = Pool.getItemByClass("DrawImageCmd", DrawImageCmd);
            cmd.texture = texture;
            texture && texture._addReference();
            cmd.x = x !== null && x !== void 0 ? x : 0;
            cmd.y = y !== null && y !== void 0 ? y : 0;
            cmd.width = width !== null && width !== void 0 ? width : texture.sourceWidth;
            cmd.height = height !== null && height !== void 0 ? height : texture.sourceHeight;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            Pool.recover("DrawImageCmd", this);
        }
        run(context, gx, gy) {
            let tex = this.texture;
            if (!tex)
                return;
            let x = this.x, y = this.y, w = this.width, h = this.height;
            let wRate = w / tex.sourceWidth;
            let hRate = h / tex.sourceHeight;
            w = tex.width * wRate;
            h = tex.height * hRate;
            x += tex.offsetX * wRate;
            y += tex.offsetY * hRate;
            context.drawTexture(this.texture, x + gx, y + gy, w, h, this.color);
        }
        getBounds(assembler) {
            Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height).getBoundPoints(assembler.points);
        }
        get cmdID() {
            return DrawImageCmd.ID;
        }
    }
    DrawImageCmd.ID = "DrawImage";

    class DrawLineCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(fromX, fromY, toX, toY, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawLineCmd", DrawLineCmd);
            cmd.fromX = fromX;
            cmd.fromY = fromY;
            cmd.toX = toX;
            cmd.toY = toY;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            Pool.recover("DrawLineCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth < 1 || this.lineWidth % 2 === 0) ? 0 : 0.5;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawLine(gx, gy, this.fromX * w + offset, this.fromY * h + offset, this.toX * w + offset, this.toY * h + offset, this.lineColor, this.lineWidth, 0);
            }
            else
                context._drawLine(gx, gy, this.fromX + offset, this.fromY + offset, this.toX + offset, this.toY + offset, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawLineCmd.ID;
        }
        getBounds(assembler) {
            let lineWidth;
            lineWidth = this.lineWidth * 0.5;
            let fromX = this.fromX, fromY = this.fromY, toX = this.toX, toY = this.toY;
            if (this.percent) {
                fromX *= assembler.width;
                fromY *= assembler.height;
                toX *= assembler.width;
                toY *= assembler.height;
                assembler.affectBySize = true;
            }
            if (fromX == toX) {
                assembler.points.push(fromX + lineWidth, fromY, toX + lineWidth, toY, fromX - lineWidth, fromY, toX - lineWidth, toY);
            }
            else if (fromY == toY) {
                assembler.points.push(fromX, fromY + lineWidth, toX, toY + lineWidth, fromX, fromY - lineWidth, toX, toY - lineWidth);
            }
            else {
                assembler.points.push(fromX, fromY, toX, toY);
            }
        }
    }
    DrawLineCmd.ID = "DrawLine";
    ClassUtils.regClass("DrawLineCmd", DrawLineCmd);

    class DrawLinesCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, points, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawLinesCmd", DrawLinesCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.lineColor = null;
            Pool.recover("DrawLinesCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth < 1 || this.lineWidth % 2 === 0) ? 0 : 0.5;
            this.points && context._drawLines(this.x + offset + gx, this.y + offset + gy, this.points, this.lineColor, this.lineWidth, 0);
        }
        getBounds(assembler) {
            assembler.points.push(...this.points);
            assembler.flushPoints(this.x, this.y);
        }
        get cmdID() {
            return DrawLinesCmd.ID;
        }
    }
    DrawLinesCmd.ID = "DrawLines";
    ClassUtils.regClass("DrawLinesCmd", DrawLinesCmd);

    class DrawPathCmd {
        static create(x, y, paths, brush, pen) {
            var cmd = Pool.getItemByClass("DrawPathCmd", DrawPathCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.paths = paths;
            cmd.brush = brush;
            cmd.pen = pen;
            return cmd;
        }
        recover() {
            this.paths = null;
            this.brush = null;
            this.pen = null;
            Pool.recover("DrawPathCmd", this);
        }
        run(context, gx, gy) {
            this.paths && context._drawPath(this.x + gx, this.y + gy, this.paths, this.brush, this.pen);
        }
        get cmdID() {
            return DrawPathCmd.ID;
        }
        getBounds(assembler) {
            let paths = this.paths;
            let len = paths.length;
            for (let i = 0; i < len; i++) {
                let tCMD = paths[i];
                if (tCMD.length > 1) {
                    assembler.points.push(tCMD[1], tCMD[2]);
                    if (tCMD.length > 3) {
                        assembler.points.push(tCMD[3], tCMD[4]);
                    }
                }
            }
            assembler.flushPoints(this.x, this.y);
        }
    }
    DrawPathCmd.ID = "DrawPath";
    ClassUtils.regClass("DrawPathCmd", DrawPathCmd);

    class DrawPieCmd {
        constructor() {
            this.radius = 0;
            this.lineWidth = 0;
        }
        static create(x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawPieCmd", DrawPieCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.radius = radius;
            cmd._startAngle = startAngle;
            cmd._endAngle = endAngle;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawPieCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            context._drawPie(this.x + offset + gx, this.y + offset + gy, this.radius - lineOffset, this._startAngle, this._endAngle, this.fillColor, this.lineColor, this.lineWidth, 0);
        }
        get cmdID() {
            return DrawPieCmd.ID;
        }
        get startAngle() {
            return this._startAngle * 180 / Math.PI;
        }
        set startAngle(value) {
            this._startAngle = value * Math.PI / 180;
        }
        get endAngle() {
            return this._endAngle * 180 / Math.PI;
        }
        set endAngle(value) {
            this._endAngle = value * Math.PI / 180;
        }
        getBounds(assembler) {
            let rst = assembler.points;
            let k = Math.PI / 180;
            let d1 = this.endAngle - this.startAngle;
            let x = this.x, y = this.y, radius = this.radius;
            if (d1 >= 360 || d1 <= -360) {
                rst.push(x - radius, y - radius);
                rst.push(x + radius, y - radius);
                rst.push(x + radius, y + radius);
                rst.push(x - radius, y + radius);
                return;
            }
            rst.push(x, y);
            var delta = d1 % 360;
            if (delta < 0)
                delta += 360;
            var end1 = this.startAngle + delta;
            var st = this.startAngle * k;
            var ed = end1 * k;
            rst.push(x + radius * Math.cos(st), y + radius * Math.sin(st));
            rst.push(x + radius * Math.cos(ed), y + radius * Math.sin(ed));
            var s1 = Math.ceil(this.startAngle / 90) * 90;
            var s2 = Math.floor(end1 / 90) * 90;
            for (var cs = s1; cs <= s2; cs += 90) {
                var csr = cs * k;
                rst.push(x + radius * Math.cos(csr), y + radius * Math.sin(csr));
            }
        }
    }
    DrawPieCmd.ID = "DrawPie";
    ClassUtils.regClass("DrawPieCmd", DrawPieCmd);

    class DrawPolyCmd {
        static create(x, y, points, fillColor, lineColor, lineWidth) {
            var cmd = Pool.getItemByClass("DrawPolyCmd", DrawPolyCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.points = points;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            return cmd;
        }
        recover() {
            this.points = null;
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawPolyCmd", this);
        }
        run(context, gx, gy) {
            let isConvexPolygon = this.points.length <= 6;
            let offset = (this.lineWidth >= 1 && this.lineColor) ? (this.lineWidth % 2 === 0 ? 0 : 0.5) : 0;
            this.points && context._drawPoly(this.x + offset + gx, this.y + offset + gy, this.points, this.fillColor, this.lineColor, this.lineWidth, isConvexPolygon, 0);
        }
        getBounds(assembler) {
            assembler.points.push(...this.points);
            assembler.flushPoints(this.x, this.y);
        }
        get cmdID() {
            return DrawPolyCmd.ID;
        }
    }
    DrawPolyCmd.ID = "DrawPoly";
    ClassUtils.regClass("DrawPolyCmd", DrawPolyCmd);

    class DrawRectCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.lineWidth = 0;
            this.percent = true;
        }
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawRectCmd", DrawRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawRectCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context.drawRect(this.x * w + offset + gx, this.y * h + offset + gy, this.width * w - lineOffset, this.height * h - lineOffset, this.fillColor, this.lineColor, this.lineWidth);
            }
            else
                context.drawRect(this.x + offset + gx, this.y + offset + gy, this.width - lineOffset, this.height - lineOffset, this.fillColor, this.lineColor, this.lineWidth);
        }
        get cmdID() {
            return DrawRectCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawRectCmd.ID = "DrawRect";
    ClassUtils.regClass("DrawRectCmd", DrawRectCmd);

    class DrawTextureCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.percent = true;
            this.alpha = 1;
            this.color = 0xffffffff;
            this.uv = null;
        }
        static create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv, percent) {
            let cmd = Pool.getItemByClass("DrawTextureCmd", DrawTextureCmd);
            cmd.texture = texture;
            texture && texture._addReference();
            cmd.x = x !== null && x !== void 0 ? x : 0;
            cmd.y = y !== null && y !== void 0 ? y : 0;
            cmd.width = width !== null && width !== void 0 ? width : texture.sourceWidth;
            cmd.height = height !== null && height !== void 0 ? height : texture.sourceHeight;
            cmd.percent = percent;
            cmd.matrix = matrix;
            cmd.alpha = alpha !== null && alpha !== void 0 ? alpha : 1;
            cmd.blendMode = blendMode;
            cmd.uv = uv || null;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.matrix = null;
            Pool.recover("DrawTextureCmd", this);
        }
        run(context, gx, gy) {
            let tex = this.texture;
            if (!tex)
                return;
            let x = this.x, y = this.y, w = this.width, h = this.height;
            if (this.percent && context.sprite) {
                x *= context.sprite.width;
                y *= context.sprite.height;
                w *= context.sprite.width;
                h *= context.sprite.height;
            }
            let wRate = w / tex.sourceWidth;
            let hRate = h / tex.sourceHeight;
            w = tex.width * wRate;
            h = tex.height * hRate;
            x += tex.offsetX * wRate;
            y += tex.offsetY * hRate;
            context.drawTextureWithTransform(this.texture, x, y, w, h, this.matrix, gx, gy, this.alpha, this.blendMode, this.uv, this.color);
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
        get cmdID() {
            return DrawTextureCmd.ID;
        }
    }
    DrawTextureCmd.ID = "DrawTexture";
    ClassUtils.regClass("DrawTextureCmd", DrawTextureCmd);

    class DrawTexturesCmd {
        static create(texture, pos, colors) {
            var cmd = Pool.getItemByClass("DrawTexturesCmd", DrawTexturesCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.pos = pos;
            cmd.colors = colors || [];
            return cmd;
        }
        recover() {
            this.texture._removeReference();
            this.texture = null;
            this.pos = null;
            Pool.recover("DrawTexturesCmd", this);
        }
        run(context, gx, gy) {
            context.drawTextures(this.texture, this.pos, gx, gy, this.colors);
        }
        getBounds(assembler) {
            if (this.texture) {
                let w = this.texture.width;
                let h = this.texture.height;
                for (let i = 0, n = this.pos.length; i < n; i += 2) {
                    let x = this.pos[i];
                    let y = this.pos[i + 1];
                    Rectangle.TEMP.setTo(x, y, w, h).getBoundPoints(assembler.points);
                }
            }
        }
        get cmdID() {
            return DrawTexturesCmd.ID;
        }
    }
    DrawTexturesCmd.ID = "DrawTextures";

    class DrawTrianglesCmd {
        static create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
            var cmd = Pool.getItemByClass("DrawTrianglesCmd", DrawTrianglesCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.vertices = vertices;
            cmd.uvs = uvs;
            cmd.indices = indices;
            cmd.matrix = matrix;
            cmd.alpha = alpha;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            cmd.blendMode = blendMode;
            return cmd;
        }
        recover() {
            var _a;
            (_a = this.texture) === null || _a === void 0 ? void 0 : _a._removeReference();
            this.texture = null;
            this.vertices = null;
            this.uvs = null;
            this.indices = null;
            this.matrix = null;
            Pool.recover("DrawTrianglesCmd", this);
        }
        run(context, gx, gy) {
            context.drawTriangles(this.texture, this.x + gx, this.y + gy, this.vertices, this.uvs, this.indices, this.matrix, this.alpha, this.blendMode, this.color);
        }
        get cmdID() {
            return DrawTrianglesCmd.ID;
        }
        getBounds(assembler) {
            let vert = this.vertices;
            var vnum = vert.length;
            if (vnum < 2)
                return;
            var minx = vert[0];
            var miny = vert[1];
            var maxx = minx;
            var maxy = miny;
            for (var i = 2; i < vnum;) {
                var cx = vert[i++];
                var cy = vert[i++];
                if (minx > cx)
                    minx = cx;
                if (miny > cy)
                    miny = cy;
                if (maxx < cx)
                    maxx = cx;
                if (maxy < cy)
                    maxy = cy;
            }
            assembler.points.push(minx, miny, maxx, miny, maxx, maxy, minx, maxy);
        }
    }
    DrawTrianglesCmd.ID = "DrawTriangles";
    ClassUtils.regClass("DrawTrianglesCmd", DrawTrianglesCmd);

    class FillTextCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this._strokeColor = '#000000';
            this._loosyBound = null;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            this._text = value;
        }
        get strokeColor() {
            return this._strokeColor;
        }
        set strokeColor(value) {
            this._strokeColor = value;
        }
        get stroke() {
            return this._stroke;
        }
        set stroke(value) {
            this._stroke = value;
        }
        get align() {
            return this._align;
        }
        set align(value) {
            this._align = value;
        }
        static create(text, x, y, font, color, align, stroke, strokeColor) {
            var cmd = Pool.getItemByClass("FillTextCmd", FillTextCmd);
            cmd._text = null;
            cmd._wordText = null;
            cmd.x = x;
            cmd.y = y;
            cmd.font = font;
            cmd.color = color;
            cmd._stroke = stroke;
            cmd._strokeColor = strokeColor;
            switch (align) {
                case 'center':
                    cmd._align = Const.ENUM_TEXTALIGN_CENTER;
                    break;
                case 'right':
                    cmd._align = Const.ENUM_TEXTALIGN_RIGHT;
                    break;
                default:
                    cmd._align = Const.ENUM_TEXTALIGN_DEFAULT;
            }
            if (text instanceof WordText$1) {
                cmd._wordText = text;
                text.cleanCache();
            }
            else
                cmd._text = text;
            return cmd;
        }
        recover() {
            Pool.recover("FillTextCmd", this);
        }
        run(context, gx, gy) {
            if (Render.isGlobalRepaint()) {
                this._wordText && this._wordText.cleanCache();
            }
            if (null == this._text)
                this._text = '';
            if (null == this._fontObj) {
                this.font = null;
            }
            if (null == this._color) {
                this._color = '#ffffff';
            }
            context._fast_filltext(this._wordText || this._text, this.x + gx, this.y + gy, this._fontObj, this._color, this._strokeColor, this._stroke, this._align);
        }
        get cmdID() {
            return FillTextCmd.ID;
        }
        get font() {
            return this._font;
        }
        set font(value) {
            this._font = value;
            if (!value)
                value = Config.defaultFontSize + "px " + Config.defaultFont;
            this._fontObj = FontInfo.parse(value);
            this._wordText && this._wordText.cleanCache();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this._wordText && this._wordText.cleanCache();
        }
        getBounds(assembler) {
            if (!this._loosyBound) {
                let ctx = Browser.context;
                ctx.save();
                ctx.font = this.font;
                let size = ctx.measureText(this.text);
                let w = size.width;
                ctx.restore();
                let x = this.x;
                let y = this.y;
                switch (this._align) {
                    case Const.ENUM_TEXTALIGN_CENTER:
                        x -= w / 2;
                        break;
                    case Const.ENUM_TEXTALIGN_RIGHT:
                        x -= w;
                        break;
                }
                if (!this._fontObj)
                    this.font = null;
                x -= 4;
                y -= this._fontObj._size;
                this._loosyBound = new Rectangle(x, y, w + 8, this._fontObj._size * 2);
            }
            Rectangle.TEMP.setTo(this._loosyBound.x, this._loosyBound.y, this._loosyBound.width, this._loosyBound.height).getBoundPoints(assembler.points);
        }
    }
    FillTextCmd.ID = "FillText";
    ClassUtils.regClass("FillTextCmd", FillTextCmd);

    class FillTextureCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.type = "repeat";
            this.percent = true;
            this.color = 0xffffffff;
        }
        static create(texture, x, y, width, height, type, offset, color, percent) {
            if (width == null)
                width = texture.width;
            if (height == null)
                height = texture.height;
            var cmd = Pool.getItemByClass("FillTextureCmd", FillTextureCmd);
            cmd.texture = texture;
            texture._addReference();
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.type = type;
            cmd.offset = offset;
            cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.texture && this.texture._removeReference();
            this.texture = null;
            this.offset = null;
            Pool.recover("FillTextureCmd", this);
        }
        run(context, gx, gy) {
            if (!this.texture)
                return;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context.fillTexture(this.texture, this.x * w + gx, this.y * h + gy, this.width * w, this.height * h, this.type, this.offset || Point.EMPTY, this.color);
            }
            else
                context.fillTexture(this.texture, this.x + gx, this.y + gy, this.width, this.height, this.type, this.offset || Point.EMPTY, this.color);
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
        get cmdID() {
            return FillTextureCmd.ID;
        }
    }
    FillTextureCmd.ID = "FillTexture";
    ClassUtils.regClass("FillTextureCmd", FillTextureCmd);

    class RotateCmd {
        static create(angle, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("RotateCmd", RotateCmd);
            cmd.angle = angle;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover("RotateCmd", this);
        }
        run(context, gx, gy) {
            context._rotate(this.angle, this.pivotX + gx, this.pivotY + gy);
        }
        getBounds(assembler) {
            tempMatrix$3.identity();
            tempMatrix$3.translate(-this.pivotX, -this.pivotY);
            tempMatrix$3.rotate(this.angle);
            tempMatrix$3.translate(this.pivotX, this.pivotY);
            assembler.concatMatrix(tempMatrix$3);
        }
        get cmdID() {
            return RotateCmd.ID;
        }
    }
    RotateCmd.ID = "Rotate";
    const tempMatrix$3 = new Matrix();

    class ScaleCmd {
        static create(scaleX, scaleY, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("ScaleCmd", ScaleCmd);
            cmd.scaleX = scaleX;
            cmd.scaleY = scaleY;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            Pool.recover("ScaleCmd", this);
        }
        run(context, gx, gy) {
            context._scale(this.scaleX, this.scaleY, this.pivotX + gx, this.pivotY + gy);
        }
        getBounds(assembler) {
            tempMatrix$2.identity();
            tempMatrix$2.translate(-this.pivotX, -this.pivotY);
            tempMatrix$2.scale(this.scaleX, this.scaleY);
            tempMatrix$2.translate(this.pivotX, this.pivotY);
            assembler.concatMatrix(tempMatrix$2);
        }
        get cmdID() {
            return ScaleCmd.ID;
        }
    }
    ScaleCmd.ID = "Scale";
    const tempMatrix$2 = new Matrix();

    class TransformCmd {
        static create(matrix, pivotX, pivotY) {
            var cmd = Pool.getItemByClass("TransformCmd", TransformCmd);
            cmd.matrix = matrix;
            cmd.pivotX = pivotX;
            cmd.pivotY = pivotY;
            return cmd;
        }
        recover() {
            this.matrix = null;
            Pool.recover("TransformCmd", this);
        }
        run(context, gx, gy) {
            context._transform(this.matrix, this.pivotX + gx, this.pivotY + gy);
        }
        getBounds(assembler) {
            tempMatrix$1.identity();
            tempMatrix$1.translate(-this.pivotX, -this.pivotY);
            tempMatrix$1.concat(this.matrix);
            tempMatrix$1.translate(this.pivotX, this.pivotY);
            assembler.concatMatrix(tempMatrix$1);
        }
        get cmdID() {
            return TransformCmd.ID;
        }
    }
    TransformCmd.ID = "Transform";
    const tempMatrix$1 = new Matrix();

    class TranslateCmd {
        static create(tx, ty) {
            var cmd = Pool.getItemByClass("TranslateCmd", TranslateCmd);
            cmd.tx = tx;
            cmd.ty = ty;
            return cmd;
        }
        recover() {
            Pool.recover("TranslateCmd", this);
        }
        run(context) {
            context.translate(this.tx, this.ty);
        }
        getBounds(assembler) {
            tempMatrix.identity();
            tempMatrix.translate(this.tx, this.ty);
            assembler.concatMatrix(tempMatrix);
        }
        get cmdID() {
            return TranslateCmd.ID;
        }
    }
    TranslateCmd.ID = "Translate";
    const tempMatrix = new Matrix();

    class DrawEllipseCmd {
        constructor() {
            this.lineWidth = 0;
        }
        static create(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawEllipseCmd", DrawEllipseCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawEllipseCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawEllipse(this.x * w + gx, this.y * h + gy, this.width * w - offset, this.height * h - offset, this.fillColor, this.lineColor, this.lineWidth);
            }
            else {
                context._drawEllipse(this.x + gx, this.y + gy, this.width - offset, this.height - offset, this.fillColor, this.lineColor, this.lineWidth);
            }
        }
        get cmdID() {
            return DrawEllipseCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x - this.width, this.y - this.height, this.width * 2, this.height * 2);
            if (this.percent) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawEllipseCmd.ID = "DrawEllipse";
    ClassUtils.regClass("DrawEllipseCmd", DrawEllipseCmd);

    class DrawRoundRectCmd {
        constructor() {
            this.x = 0;
            this.y = 0;
            this.width = 1;
            this.height = 1;
            this.lt = 6;
            this.rt = 6;
            this.lb = 6;
            this.rb = 6;
            this.lineWidth = 0;
            this.percent = true;
        }
        static create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent) {
            var cmd = Pool.getItemByClass("DrawRoundRectCmd", DrawRoundRectCmd);
            cmd.x = x;
            cmd.y = y;
            cmd.width = width;
            cmd.height = height;
            cmd.lt = lt;
            cmd.rt = rt;
            cmd.lb = lb;
            cmd.rb = rb;
            cmd.fillColor = fillColor;
            cmd.lineColor = lineColor;
            cmd.lineWidth = lineWidth;
            cmd.percent = percent;
            return cmd;
        }
        recover() {
            this.fillColor = null;
            this.lineColor = null;
            Pool.recover("DrawRoundRectCmd", this);
        }
        run(context, gx, gy) {
            let offset = (this.lineWidth >= 1 && this.lineColor) ? this.lineWidth / 2 : 0;
            let lineOffset = this.lineColor ? this.lineWidth : 0;
            if (this.percent && context.sprite) {
                let w = context.sprite.width;
                let h = context.sprite.height;
                context._drawRoundRect(this.x * w + offset + gx, this.y * h + offset + gy, this.width * w - lineOffset, this.height * h - lineOffset, this.lt, this.rt, this.lb, this.rb, this.fillColor, this.lineColor, this.lineWidth);
            }
            else {
                context._drawRoundRect(this.x + offset + gx, this.y + offset + gy, this.width - lineOffset, this.height - lineOffset, this.lt, this.rt, this.lb, this.rb, this.fillColor, this.lineColor, this.lineWidth);
            }
        }
        get cmdID() {
            return DrawRoundRectCmd.ID;
        }
        getBounds(assembler) {
            let rect = Rectangle.TEMP.setTo(this.x, this.y, this.width, this.height);
            if (this) {
                rect.scale(assembler.width, assembler.height);
                assembler.affectBySize = true;
            }
            rect.getBoundPoints(assembler.points);
        }
    }
    DrawRoundRectCmd.ID = "DrawRoundRect";
    ClassUtils.regClass("DrawRoundRectCmd", DrawRoundRectCmd);

    class Graphics {
        static add2DGlobalUniformData(propertyID, propertyKey, uniformtype) {
            let sceneUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DGlobal");
            sceneUniformMap.addShaderUniform(propertyID, propertyKey, uniformtype);
        }
        constructor() {
            this._sp = null;
            this._render = this._renderEmpty;
            this._cmds = [];
            this._vectorgraphArray = null;
            this._graphicBounds = null;
            this._createData();
        }
        _createData() {
        }
        _clearData() {
        }
        _destroyData() {
        }
        destroy() {
            this.clear(true);
            if (this._graphicBounds)
                this._graphicBounds.destroy();
            this._graphicBounds = null;
            this._vectorgraphArray = null;
            if (this._sp) {
                this._sp._renderType = 0;
                this._sp = null;
            }
            if (this._material) {
                this._material._removeReference();
                this._material = null;
            }
            this._destroyData();
        }
        clear(recoverCmds = true) {
            if (recoverCmds) {
                for (let cmd of this._cmds) {
                    if (!cmd.lock)
                        cmd.recover();
                }
            }
            this._cmds.length = 0;
            this._render = this._renderEmpty;
            this._clearData();
            if (this._sp) {
                this._sp._renderType &= ~SpriteConst.GRAPHICS;
            }
            this._repaint();
        }
        _clearBoundsCache(onSizeChanged) {
            if (this._graphicBounds) {
                if (!onSizeChanged || this._graphicBounds._affectBySize)
                    this._graphicBounds.reset();
            }
        }
        _repaint() {
            this._clearBoundsCache();
            this._sp && this._sp.repaint();
        }
        _isOnlyOne() {
            return this._cmds.length === 1;
        }
        get cmds() {
            return this._cmds;
        }
        set cmds(value) {
            this._cmds = value;
            this.onCmdsChanged();
        }
        addCmd(cmd, index) {
            if (cmd == null) {
                console.warn("null cmd");
                return;
            }
            if (index == null || index >= this._cmds.length)
                this._cmds.push(cmd);
            else
                this._cmds.splice(index, 0, cmd);
            this.onCmdsChanged();
            return cmd;
        }
        removeCmd(cmd) {
            let i = this.cmds.indexOf(cmd);
            if (i != -1) {
                this._cmds.splice(i, 1);
                this.onCmdsChanged();
            }
        }
        replaceCmd(oldCmd, newCmd, recover) {
            let index = this._cmds.indexOf(oldCmd);
            if (newCmd != null) {
                if (index !== -1) {
                    this._cmds[index] = newCmd;
                    this._repaint();
                }
                else {
                    this._cmds.push(newCmd);
                    this.onCmdsChanged();
                }
            }
            else if (index != -1) {
                this._cmds.splice(index, 1);
                this.onCmdsChanged();
            }
            if (oldCmd && recover)
                oldCmd.recover();
            return newCmd;
        }
        onCmdsChanged() {
            let len = this._cmds.length;
            if (this._sp && len > 0)
                this._sp._renderType |= SpriteConst.GRAPHICS;
            this._render = len === 0 ? this._renderEmpty : len === 1 ? this._renderOne : this._renderAll;
            this._repaint();
        }
        getBounds(realSize) {
            if (!this._graphicBounds)
                this._graphicBounds = GraphicsBounds.create();
            return this._graphicBounds.getBounds(this, realSize);
        }
        getBoundPoints(realSize) {
            if (!this._graphicBounds)
                this._graphicBounds = GraphicsBounds.create();
            return this._graphicBounds.getBoundPoints(this, realSize);
        }
        get material() {
            return this._material;
        }
        set material(value) {
            if (this._material == value)
                return;
            this._material && this._material._removeReference();
            this._material = value;
            if (value != null)
                value._addReference();
        }
        drawImage(texture, x = 0, y = 0, width = null, height = null, color = null) {
            if (!texture)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawImageCmd.create(texture, x, y, width, height, color));
        }
        drawTexture(texture, x = 0, y = 0, width = null, height = null, matrix = null, alpha = 1, color = null, blendMode = null, uv) {
            if (!texture || alpha < 0.01)
                return null;
            if (!texture.bitmap)
                return null;
            return this.addCmd(DrawTextureCmd.create(texture, x, y, width, height, matrix, alpha, color, blendMode, uv));
        }
        drawTextures(texture, pos, colors) {
            if (!texture)
                return null;
            return this.addCmd(DrawTexturesCmd.create(texture, pos, colors));
        }
        drawTriangles(texture, x, y, vertices, uvs, indices, matrix = null, alpha = 1, color = null, blendMode = null) {
            return this.addCmd(DrawTrianglesCmd.create(texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode));
        }
        fillTexture(texture, x, y, width = 0, height = 0, type = "repeat", offset = null, color = null, percent = false) {
            if (texture && texture.bitmap)
                return this.addCmd(FillTextureCmd.create(texture, x, y, width, height, type, offset || Point.EMPTY, color, percent));
            else
                return null;
        }
        clipRect(x, y, width, height) {
            return this.addCmd(ClipRectCmd.create(x, y, width, height));
        }
        fillText(text, x, y, font, color, textAlign) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, color, textAlign, 0, ""));
        }
        fillBorderText(text, x, y, font, fillColor, textAlign, lineWidth, borderColor) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, fillColor, textAlign, lineWidth, borderColor));
        }
        strokeText(text, x, y, font, color, lineWidth, textAlign) {
            return this.addCmd(FillTextCmd.create(text, x, y, font, null, textAlign, lineWidth, color));
        }
        alpha(alpha) {
            return this.addCmd(AlphaCmd.create(alpha));
        }
        transform(matrix, pivotX = 0, pivotY = 0) {
            return this.addCmd(TransformCmd.create(matrix, pivotX, pivotY));
        }
        rotate(angle, pivotX = 0, pivotY = 0) {
            return this.addCmd(RotateCmd.create(angle, pivotX, pivotY));
        }
        scale(scaleX, scaleY, pivotX = 0, pivotY = 0) {
            return this.addCmd(ScaleCmd.create(scaleX, scaleY, pivotX, pivotY));
        }
        translate(tx, ty) {
            return this.addCmd(TranslateCmd.create(tx, ty));
        }
        save() {
            return this.addCmd(SaveCmd.create());
        }
        restore() {
            return this.addCmd(RestoreCmd.create());
        }
        replaceTextColor(color) {
            this._repaint();
            let cmds = this._cmds;
            for (let i = cmds.length - 1; i > -1; i--) {
                let cmd = cmds[i];
                var cmdID = cmd.cmdID;
                switch (cmdID) {
                    case FillTextCmd.ID:
                        cmd.color = color;
                        break;
                    case DrawImageCmd.ID:
                        cmd.color = color != null ? ColorUtils.create(color).numColor : 0xffffffff;
                        break;
                }
            }
        }
        loadImage(url, x = 0, y = 0, width = null, height = null, complete = null) {
            let tex = ILaya.loader.getRes(url);
            if (tex) {
                this.drawImage(tex, x, y, width, height);
                complete && complete.call(this._sp);
            }
            else {
                ILaya.loader.load(url).then((tex) => {
                    this.drawImage(tex, x, y, width, height);
                    complete && complete.call(this._sp);
                });
            }
        }
        _renderEmpty(sprite, context, x, y) {
        }
        _renderAll(sprite, context, x, y) {
            context.sprite = sprite;
            context._material = this._material;
            var cmds = this._cmds;
            for (let i = 0, n = cmds.length; i < n; i++) {
                cmds[i].run(context, x, y);
            }
            context._material = null;
        }
        _renderOne(sprite, context, x, y) {
            context.sprite = sprite;
            context._material = this._material;
            this._cmds[0].run(context, x, y);
            context._material = null;
        }
        drawLine(fromX, fromY, toX, toY, lineColor, lineWidth = 1) {
            return this.addCmd(DrawLineCmd.create(fromX, fromY, toX, toY, lineColor, lineWidth));
        }
        drawLines(x, y, points, lineColor, lineWidth = 1) {
            if (!points || points.length < 4)
                return null;
            return this.addCmd(DrawLinesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawCurves(x, y, points, lineColor, lineWidth = 1) {
            return this.addCmd(DrawCurvesCmd.create(x, y, points, lineColor, lineWidth));
        }
        drawRect(x, y, width, height, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRectCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawRoundRect(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawRoundRectCmd.create(x, y, width, height, lt, rt, lb, rb, fillColor, lineColor, lineWidth, percent));
        }
        drawCircle(x, y, radius, fillColor, lineColor = null, lineWidth = 1, percent) {
            return this.addCmd(DrawCircleCmd.create(x, y, radius, fillColor, lineColor, lineWidth, percent));
        }
        drawEllipse(x, y, width, height, fillColor, lineColor, lineWidth, percent) {
            return this.addCmd(DrawEllipseCmd.create(x, y, width, height, fillColor, lineColor, lineWidth, percent));
        }
        drawPie(x, y, radius, startAngle, endAngle, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPieCmd.create(x, y, radius, Utils.toRadian(startAngle), Utils.toRadian(endAngle), fillColor, lineColor, lineWidth));
        }
        drawPoly(x, y, points, fillColor, lineColor = null, lineWidth = 1) {
            return this.addCmd(DrawPolyCmd.create(x, y, points, fillColor, lineColor, lineWidth));
        }
        drawPath(x, y, paths, brush = null, pen = null) {
            return this.addCmd(DrawPathCmd.create(x, y, paths, brush, pen));
        }
        draw9Grid(texture, x = 0, y = 0, width = 0, height = 0, sizeGrid, color) {
            this.addCmd(Draw9GridTextureCmd.create(texture, x, y, width, height, sizeGrid, false, color));
        }
    }

    const ARRAY_EMPTY = [];
    const initBits = NodeFlags.ACTIVE | NodeFlags.ACTUAL_VISIBLE;
    const reactiveBits = NodeFlags.DISPLAY;
    class Node extends EventDispatcher {
        get url() {
            return this._url;
        }
        set url(path) {
            this._url = path;
        }
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        get is3D() {
            return this._nodeType === 1;
        }
        get destroyed() {
            return this._destroyed;
        }
        constructor() {
            super();
            this._bits = 0;
            this._reactiveBits = 0;
            this._hideFlags = 0;
            this._parent = null;
            this._destroyed = false;
            this._nodeType = 0;
            this.name = "";
            this._bits = initBits;
            this._reactiveBits = reactiveBits;
            this._children = [];
            this._$children = this._children;
            this._$container = this;
            this._initialize();
        }
        _initialize() {
            this._extra = {};
        }
        _setBit(bit, value) {
            if (((this._bits & bit) === 0) === !value)
                return false;
            if (value)
                this._bits |= bit;
            else
                this._bits &= ~bit;
            if ((bit & this._reactiveBits) != 0)
                this._onSetBit(bit, value);
            return true;
        }
        _getBit(bit) {
            return (this._bits & bit) !== 0;
        }
        _onSetBit(bit, value) {
            if ((bit & NodeFlags.DISPLAY) !== 0) {
                let ele = this._parent;
                let stage = ILaya.stage;
                let displayedInStage = this === stage;
                while (ele) {
                    if ((ele._bits & NodeFlags.DISPLAY) !== 0) {
                        displayedInStage = (ele._bits & NodeFlags.DISPLAYED_INSTAGE) !== 0;
                        break;
                    }
                    if (ele === stage) {
                        displayedInStage = true;
                        break;
                    }
                    ele = ele._parent;
                }
                this._setBit(NodeFlags.DISPLAYED_INSTAGE, displayedInStage);
            }
        }
        _setBitUp(type) {
            let ele = this;
            ele._setBit(type, true);
            ele = ele._parent;
            while (ele) {
                if ((ele._bits & type) !== 0)
                    return;
                ele._setBit(type, true);
                ele = ele._parent;
            }
        }
        onStartListeningToType(type) {
            if ((type === Event.DISPLAY || type === Event.UNDISPLAY) && (this._bits & NodeFlags.DISPLAY) === 0) {
                this._setBitUp(NodeFlags.DISPLAY);
            }
        }
        bubbleEvent(type, data) {
            let arr = [];
            arr.length = 0;
            let obj = this;
            while (obj) {
                if (obj.activeInHierarchy)
                    arr.push(obj);
                obj = obj._parent;
            }
            let evt;
            if (data instanceof Event) {
                evt = data;
                evt._stopped = false;
            }
            for (let obj of arr) {
                if (evt) {
                    evt.setTo(type, obj, this);
                    obj.event(type, data);
                    if (evt._stopped)
                        break;
                }
                else
                    obj.event(type, data);
            }
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this.destroyAllComponent();
            this._parent && this._parent._removeChild(this);
            for (let i = 0, n = this._children.length; i < n; i++) {
                let node = this._children[0];
                this._children.shift();
                if (!node)
                    continue;
                node._setParent(null);
                if (destroyChild)
                    node.destroy();
            }
            this.onDestroy();
            this.offAll();
        }
        onDestroy() {
        }
        destroyChildren() {
            for (let i = 0, n = this._$children.length; i < n; i++) {
                this._$children[0].destroy(true);
            }
        }
        get children() {
            return this._$children;
        }
        addChild(node) {
            return this.addChildAt(node, this._$children.length);
        }
        addChildren(...args) {
            let i = 0, n = args.length;
            while (i < n) {
                this.addChildAt(args[i++], this._$children.length);
            }
        }
        addChildAt(node, index) {
            if (index >= 0 && index <= this._$children.length) {
                if (node._$parent === this) {
                    this.setChildIndex(node, index);
                }
                else {
                    node._parent && node._parent.removeChild(node);
                    this._$children.splice(index, 0, node);
                    node._$parent = this;
                    node._setParent(this._$container);
                }
                return node;
            }
            else {
                throw new OutOfRangeError(index);
            }
        }
        getChildIndex(node) {
            return this._$children.indexOf(node);
        }
        getChild(name, classType) {
            for (let child of this._$children) {
                if (child.name === name)
                    return child;
            }
            return null;
        }
        getChildByName(name, classType) {
            return this.getChild(name, classType);
        }
        getChildAt(index, classType) {
            if (index >= 0 && index < this.numChildren)
                return this._$children[index];
            else
                throw new OutOfRangeError(index);
        }
        getChildByPath(path, classType) {
            let arr = path.split(".");
            let cnt = arr.length;
            let p = this;
            let obj;
            for (let i = 0; i < cnt; ++i) {
                obj = p.getChild(arr[i], classType);
                if (!obj)
                    break;
                p = obj;
            }
            return obj;
        }
        findChild(name, classType) {
            for (let c of this.children) {
                if (c.name == name)
                    return c;
                if (!c.url) {
                    c = c.findChild(name, classType);
                    if (c)
                        return c;
                }
            }
            return null;
        }
        setChildIndex(node, index) {
            let oldIndex = this._$children.indexOf(node);
            if (oldIndex < 0)
                throw new Error("not a child of this node");
            this._setChildIndex(node, oldIndex, index);
            return node;
        }
        setChildIndexBefore(node, index) {
            let oldIndex = this._$children.indexOf(node);
            if (oldIndex == -1)
                throw new Error("not a child of this node");
            if (oldIndex < index)
                return this._setChildIndex(node, oldIndex, index - 1);
            else
                return this._setChildIndex(node, oldIndex, index);
        }
        _setChildIndex(node, oldIndex, index) {
            let cnt = this._$children.length;
            if (index > cnt)
                index = cnt;
            if (oldIndex == index)
                return oldIndex;
            this._$children.splice(oldIndex, 1);
            if (index >= this._$children.length)
                this._$children.push(node);
            else
                this._$children.splice(index, 0, node);
            this._$container._childChanged();
            return index;
        }
        _childChanged(child) {
        }
        removeChild(node, destroy) {
            let index = this._$children.indexOf(node);
            if (index == -1)
                throw new Error("not a child of this node");
            this._$children.splice(index, 1);
            node._setParent(null);
            if (destroy)
                node.destroy();
            return node;
        }
        removeSelf() {
            this._parent && this._parent._removeChild(this);
            return this;
        }
        removeChildByName(name, destroy) {
            let node = this.getChild(name);
            node && this.removeChild(node, destroy);
            return node;
        }
        removeChildAt(index, destroy) {
            let node = this._$children[index];
            this._$children.splice(index, 1);
            node._setParent(null);
            if (destroy)
                node.destroy();
            return node;
        }
        removeChildren(beginIndex, endIndex, destroy) {
            beginIndex = beginIndex || 0;
            if (endIndex == null)
                endIndex = -1;
            if (endIndex < 0 || endIndex >= this._$children.length)
                endIndex = this._$children.length - 1;
            for (let i = beginIndex; i <= endIndex; ++i)
                this.removeChildAt(beginIndex, destroy);
        }
        replaceChild(newNode, oldNode) {
            let index = this._$children.indexOf(oldNode);
            if (index == -1)
                throw new Error("not a child of this node");
            this.removeChildAt(index);
            return this.addChildAt(newNode, index);
        }
        _setContainer(container) {
            this._$container = container;
            this._$children = container._children;
        }
        _addChild(node, index) {
            let children = this._children;
            if (index == null)
                index = children.length;
            if (index >= 0 && index <= children.length) {
                if (node._parent === this) {
                    let oldIndex = children.indexOf(node);
                    children.splice(oldIndex, 1);
                    if (index >= children.length)
                        children.push(node);
                    else
                        children.splice(index, 0, node);
                    this._childChanged(node);
                }
                else {
                    node._parent && node._parent.removeChild(node);
                    children.splice(index, 0, node);
                    node._$parent = this;
                    node._setParent(this);
                }
                return node;
            }
            else {
                throw new OutOfRangeError(index);
            }
        }
        _removeChild(node) {
            let index = this._children.indexOf(node);
            if (index == -1)
                throw new Error("not a child of this node");
            this._children.splice(index, 1);
            node._setParent(null);
            return node;
        }
        get numChildren() {
            return this._$children.length;
        }
        get parent() {
            return this._$parent;
        }
        isAncestorOf(node) {
            if (!node)
                return false;
            let p = node._parent;
            while (p) {
                if (p == this)
                    return true;
                p = p._parent;
            }
            return false;
        }
        _setParent(value) {
            if (value) {
                this._parent = value;
                this._onAdded();
                this.event(Event.ADDED);
                if ((this._bits & NodeFlags.DISPLAY) !== 0) {
                    this._setBitUp(NodeFlags.DISPLAY);
                    if (value.displayedInStage)
                        this._displayChild(this, true);
                }
                value._childChanged(this);
            }
            else {
                this._onRemoved();
                this.event(Event.REMOVED);
                let p = this._parent;
                if ((this._bits & NodeFlags.DISPLAY) !== 0)
                    this._displayChild(this, false);
                this._parent = null;
                this._$parent = null;
                if (!p._destroyed)
                    p._childChanged(this);
            }
        }
        get displayedInStage() {
            if ((this._bits & NodeFlags.DISPLAY) === 0)
                this._setBitUp(NodeFlags.DISPLAY);
            return (this._bits & NodeFlags.DISPLAYED_INSTAGE) !== 0;
        }
        _setDisplay(value) {
            if (((this._bits & NodeFlags.DISPLAYED_INSTAGE) !== 0) !== value) {
                this._setBit(NodeFlags.DISPLAYED_INSTAGE, value);
                if (value)
                    this.event(Event.DISPLAY);
                else
                    this.event(Event.UNDISPLAY);
            }
        }
        _displayChild(node, display) {
            for (let child of node._children) {
                if ((child._bits & NodeFlags.DISPLAY) === 0)
                    continue;
                if (child._children.length > 0) {
                    this._displayChild(child, display);
                }
                else {
                    child._setDisplay(display);
                }
            }
            node._setDisplay(display);
        }
        contains(node) {
            if (node === this)
                return true;
            while (node) {
                if (node._parent === this)
                    return true;
                node = node._parent;
            }
            return false;
        }
        timerLoop(delay, caller, method, args = null, coverBefore = true, jumpFrame = false) {
            this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
        }
        timerOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(false, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, true, delay, caller, method, args, coverBefore);
        }
        frameOnce(delay, caller, method, args = null, coverBefore = true) {
            this.timer._create(true, false, delay, caller, method, args, coverBefore);
        }
        clearTimer(caller, method) {
            this.timer.clear(caller, method);
        }
        callLater(method, args = null) {
            this.timer.callLater(this, method, args);
        }
        runCallLater(method) {
            this.timer.runCallLater(this, method);
        }
        get scene() {
            return this._scene;
        }
        get stage() {
            return ILaya.stage;
        }
        get active() {
            return (this._bits & NodeFlags.ACTIVE) !== 0;
        }
        set active(value) {
            var _a;
            value = !!value;
            if (((this._bits & NodeFlags.ACTIVE) !== 0) !== value) {
                if (this._activeChangeScripts && this._activeChangeScripts.length !== 0)
                    throw new Error("recursive set active");
                this._setBit(NodeFlags.ACTIVE, value);
                if (((_a = this._parent) === null || _a === void 0 ? void 0 : _a.activeInHierarchy) && (this._bits & NodeFlags.NOT_IN_PAGE) == 0) {
                    this._processActive(value, true);
                }
            }
        }
        get activeInHierarchy() {
            return (this._bits & NodeFlags.ACTIVE_INHIERARCHY) !== 0;
        }
        _onActive() {
            Stat.spriteCount++;
        }
        _onInActive() {
            Stat.spriteCount--;
        }
        _onActiveInScene() {
        }
        _onInActiveInScene() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        _parse(data, spriteMap) {
        }
        _setBelongScene(scene) {
            if (!this._scene || this.scene != scene) {
                this._scene = scene;
                this._onActiveInScene();
                for (let child of this._children)
                    child._setBelongScene(scene);
            }
        }
        _setUnBelongScene() {
            if (this._scene !== this) {
                this._onInActiveInScene();
                this._scene = null;
                for (let child of this._children)
                    child._setUnBelongScene();
            }
        }
        _processActive(active, fromSetter) {
            (this._activeChangeScripts) || (this._activeChangeScripts = []);
            let arr = this._activeChangeScripts;
            if (active)
                this._activeHierarchy(arr, fromSetter);
            else
                this._inActiveHierarchy(arr, fromSetter);
            for (let i = 0, n = arr.length; i < n; i++) {
                let comp = arr[i];
                comp.owner && comp._setActive(active);
            }
            arr.length = 0;
        }
        _activeHierarchy(activeChangeScripts, fromSetter) {
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        (comp._enabled) && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(true);
                }
            }
            this._onActive();
            for (let child of this._children) {
                if ((child._bits & NodeFlags.ACTIVE) !== 0 && (child._bits & NodeFlags.NOT_IN_PAGE) === 0)
                    child._activeHierarchy(activeChangeScripts, fromSetter);
            }
            if ((this._bits & NodeFlags.AWAKED) === 0) {
                this._setBit(NodeFlags.AWAKED, true);
                this.onAwake();
            }
            this.onEnable();
        }
        _inActiveHierarchy(activeChangeScripts, fromSetter) {
            this._onInActive();
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp._isScript())
                        comp._enabled && (activeChangeScripts.push(comp));
                    else
                        comp._setActive(false);
                }
            }
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, false);
            for (let child of this._children) {
                if ((child._bits & NodeFlags.ACTIVE) !== 0)
                    child._inActiveHierarchy(activeChangeScripts, fromSetter);
            }
            this.onDisable();
        }
        _onAdded() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw new Error("recursive set active");
            }
            else {
                let parentScene = this._parent.scene;
                if (parentScene)
                    this._setBelongScene(parentScene);
                if (this._parent.activeInHierarchy
                    && (this._bits & NodeFlags.ACTIVE) !== 0
                    && (this._bits & NodeFlags.NOT_IN_PAGE) === 0)
                    this._processActive(true);
            }
        }
        _onRemoved() {
            if (this._activeChangeScripts && this._activeChangeScripts.length !== 0) {
                throw new Error("recursive set active");
            }
            else {
                if (this._parent.activeInHierarchy
                    && (this._bits & NodeFlags.ACTIVE) !== 0
                    && (this._bits & NodeFlags.NOT_IN_PAGE) === 0)
                    this._processActive(false);
                if (this._parent.scene)
                    this._setUnBelongScene();
            }
        }
        _addComponentInstance(comp) {
            var _a;
            if (comp._singleton && this.getComponent(comp.constructor)) {
                console.warn("the component is singleton, can't add the second one.", comp);
                return;
            }
            if (!this._components)
                this._components = [];
            this._components.push(comp);
            comp._setOwner(this);
            if (this.activeInHierarchy)
                comp._setActive(true);
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 0);
        }
        _destroyComponent(comp) {
            var _a;
            if (!this._components)
                return;
            let i = this._components.indexOf(comp);
            if (i != -1) {
                this._components.splice(i, 1);
                comp._destroy();
                (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, comp, 1);
            }
        }
        destroyAllComponent() {
            var _a;
            if (!this._components)
                return;
            for (let i = 0, n = this._components.length; i < n; i++) {
                let item = this._components[i];
                item && !item.destroyed && item._destroy();
            }
            this._components.length = 0;
            (_a = this._componentsChanged) === null || _a === void 0 ? void 0 : _a.call(this, null, 2);
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let destComponent = destObject.addComponent(this._components[i].constructor);
                    this._components[i]._cloneTo(destComponent);
                }
            }
        }
        addComponentInstance(component) {
            if (component.owner)
                throw new Error("the component is belong to other node.");
            this._addComponentInstance(component);
            return component;
        }
        addComponent(componentType) {
            let comp = Pool.createByClass(componentType);
            if (!comp)
                throw new Error("missing " + componentType.toString());
            this._addComponentInstance(comp);
            return comp;
        }
        getComponent(componentType) {
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType)
                        return comp;
                }
            }
            return null;
        }
        get components() {
            return this._components || ARRAY_EMPTY;
        }
        getComponents(componentType) {
            let arr = [];
            if (this._components) {
                for (let i = 0, n = this._components.length; i < n; i++) {
                    let comp = this._components[i];
                    if (comp instanceof componentType) {
                        arr = arr || [];
                        arr.push(comp);
                    }
                }
            }
            return arr;
        }
        get timer() {
            return this._scene ? this._scene.timer : ILaya.timer;
        }
        onAfterDeserialize() { }
    }

    var Ease = {
        linear,
        linearNone: linear,
        linearIn,
        linearInOut,
        linearOut,
        bounceIn,
        bounceInOut,
        bounceOut,
        backIn,
        backInOut,
        backOut,
        elasticIn,
        elasticInOut,
        elasticOut,
        strongIn,
        strongInOut,
        strongOut,
        sineInOut,
        sineIn,
        sineOut,
        quintIn,
        quintInOut,
        quintOut,
        quartIn,
        quartInOut,
        quartOut,
        cubicIn,
        cubicInOut,
        cubicOut,
        quadIn,
        quadInOut,
        quadOut,
        expoIn,
        expoInOut,
        expoOut,
        circIn,
        circInOut,
        circOut,
    };
    const HALF_PI = Math.PI * 0.5;
    const PI2 = Math.PI * 2;
    function linear(t, b, c, d) {
        return c * t / d + b;
    }
    function linearIn(t, b, c, d) {
        return c * t / d + b;
    }
    function linearInOut(t, b, c, d) {
        return c * t / d + b;
    }
    function linearOut(t, b, c, d) {
        return c * t / d + b;
    }
    function bounceIn(t, b, c, d) {
        return c - Ease.bounceOut(d - t, 0, c, d) + b;
    }
    function bounceInOut(t, b, c, d) {
        if (t < d * 0.5)
            return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
        else
            return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
    }
    function bounceOut(t, b, c, d) {
        if ((t /= d) < (1 / 2.75))
            return c * (7.5625 * t * t) + b;
        else if (t < (2 / 2.75))
            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
        else if (t < (2.5 / 2.75))
            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
        else
            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
    }
    function backIn(t, b, c, d, s = 1.70158) {
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
    }
    function backInOut(t, b, c, d, s = 1.70158) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
    }
    function backOut(t, b, c, d, s = 1.70158) {
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    }
    function elasticIn(t, b, c, d, a = 0, p = 0) {
        var s;
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        if (!p)
            p = d * .3;
        if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
            a = c;
            s = p / 4;
        }
        else
            s = p / PI2 * Math.asin(c / a);
        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
    }
    function elasticInOut(t, b, c, d, a = 0, p = 0) {
        var s;
        if (t == 0)
            return b;
        if ((t /= d * 0.5) == 2)
            return b + c;
        if (!p)
            p = d * (.3 * 1.5);
        if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
            a = c;
            s = p / 4;
        }
        else
            s = p / PI2 * Math.asin(c / a);
        if (t < 1)
            return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p)) + b;
        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * PI2 / p) * .5 + c + b;
    }
    function elasticOut(t, b, c, d, a = 0, p = 0) {
        var s;
        if (t == 0)
            return b;
        if ((t /= d) == 1)
            return b + c;
        if (!p)
            p = d * .3;
        if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
            a = c;
            s = p / 4;
        }
        else
            s = p / PI2 * Math.asin(c / a);
        return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * PI2 / p) + c + b);
    }
    function strongIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    }
    function strongInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t * t * t + b;
        return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
    }
    function strongOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }
    function sineInOut(t, b, c, d) {
        return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
    }
    function sineIn(t, b, c, d) {
        return -c * Math.cos(t / d * HALF_PI) + c + b;
    }
    function sineOut(t, b, c, d) {
        return c * Math.sin(t / d * HALF_PI) + b;
    }
    function quintIn(t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
    }
    function quintInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t * t * t + b;
        return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
    }
    function quintOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    }
    function quartIn(t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
    }
    function quartInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t * t + b;
        return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
    }
    function quartOut(t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
    }
    function cubicIn(t, b, c, d) {
        return c * (t /= d) * t * t + b;
    }
    function cubicInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t * t + b;
        return c * 0.5 * ((t -= 2) * t * t + 2) + b;
    }
    function cubicOut(t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
    }
    function quadIn(t, b, c, d) {
        return c * (t /= d) * t + b;
    }
    function quadInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * t * t + b;
        return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
    }
    function quadOut(t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
    }
    function expoIn(t, b, c, d) {
        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
    }
    function expoInOut(t, b, c, d) {
        if (t == 0)
            return b;
        if (t == d)
            return b + c;
        if ((t /= d * 0.5) < 1)
            return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
        return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
    }
    function expoOut(t, b, c, d) {
        return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
    }
    function circIn(t, b, c, d) {
        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
    }
    function circInOut(t, b, c, d) {
        if ((t /= d * 0.5) < 1)
            return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
        return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
    }
    function circOut(t, b, c, d) {
        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
    }

    class TweenValue {
        constructor(props) {
            this._props = props;
            this.nums = [];
        }
        get(name) {
            let prop = this._props.find(e => e.name == name);
            if (!prop)
                throw new Error(`Property '${name}' is not in tween.`);
            return this.read(prop.type, prop.offset);
        }
        set(name, value) {
            let prop = this._props.find(e => e.name == name);
            if (!prop)
                throw new Error(`Property '${name}' is not in tween.`);
            this.write(prop.type, prop.offset, value);
        }
        getAt(index) {
            let prop = this._props[index];
            if (!prop)
                throw new OutOfRangeError(index);
            return this.read(prop.type, prop.offset);
        }
        setAt(index, value) {
            let prop = this._props[index];
            if (!prop)
                throw new OutOfRangeError(index);
            this.write(prop.type, prop.offset, value);
        }
        get count() {
            return this._props.length;
        }
        copy(source) {
            this.nums.length = 0;
            this.nums.push(...source.nums);
            return this;
        }
        read(type, offset) {
            switch (type) {
                case 0:
                    return this.nums[offset];
                case 1:
                    return !!this.nums[offset];
                case 2:
                    return Color.hexToString(this.nums[offset]);
                default:
                    return type.read(this.nums, offset);
            }
        }
        write(type, offset, value) {
            switch (type) {
                case 0:
                    this.nums[offset] = value;
                    break;
                case 1:
                    this.nums[offset] = value ? 1 : 0;
                    break;
                case 2:
                    this.nums[offset] = Color.stringToHex(value);
                    break;
                default: {
                    if (offset === this.nums.length)
                        type.write(this.nums, value);
                    else {
                        tmpArr.length = 0;
                        type.write(tmpArr, value);
                        tmpArr.forEach((v, i) => this.nums[offset + i] = v);
                    }
                }
            }
        }
    }
    const tmpArr = [];
    function write(array, value) {
        value.writeTo(array, array.length);
    }
    const TweenValueAdapterKey = Symbol();
    const vec2 = new Vector2();
    Vector2.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return vec2.setValue(array[offset], array[offset + 1]);
        },
    };
    const vec3 = new Vector3();
    Vector3.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return vec3.setValue(array[offset], array[offset + 1], array[offset + 2]);
        },
    };
    const vec4 = new Vector4();
    Vector4.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return vec4.setValue(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
        },
    };
    const color = new Color();
    Color.prototype[TweenValueAdapterKey] = {
        write,
        read: (array, offset) => {
            return color.setValue(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
        },
    };
    const pt = new Point();
    Point.prototype[TweenValueAdapterKey] = {
        write: (array, value) => {
            array.push(value.x, value.y);
        },
        read: (array, offset) => {
            return pt.setTo(array[offset], array[offset + 1]);
        },
    };

    class Tweener {
        static create(owner) {
            let tweener = Tweener._pool.take();
            _activeTweens[_totalActiveTweens++] = tweener;
            tweener.owner = owner;
            return tweener;
        }
        static getTween(id) {
            return _activeTweenMap.get(id);
        }
        static isTweening(target) {
            if (target == null)
                return false;
            for (let i = 0; i < _totalActiveTweens; i++) {
                let tweener = _activeTweens[i];
                if (tweener && tweener.target == target && !tweener._killed)
                    return true;
            }
            return false;
        }
        static getTweens(target, out) {
            out = out || [];
            if (target == null)
                return out;
            let cnt = _totalActiveTweens;
            for (let i = 0; i < cnt; i++) {
                let tweener = _activeTweens[i];
                if (tweener && tweener.target == target && !tweener._killed) {
                    out.push(tweener.owner);
                }
            }
            return out;
        }
        static kill(tweenId, complete) {
            let tween = _activeTweenMap.get(tweenId);
            if (!tween || tween._killed)
                return false;
            tween.kill(complete);
            return true;
        }
        static killAll(target, completed) {
            if (target == null)
                return false;
            let flag = false;
            let cnt = _totalActiveTweens;
            for (let i = 0; i < cnt; i++) {
                let tweener = _activeTweens[i];
                if (tweener && tweener.target == target && !tweener._killed) {
                    tweener.kill(completed);
                    flag = true;
                }
            }
            return flag;
        }
        constructor() {
            this.props = [];
            this.easeArgs = [];
            this.interpArgs = [];
            this.startValue = new TweenValue(this.props);
            this.endValue = new TweenValue(this.props);
            this.value = new TweenValue(this.props);
            this.deltaValue = new TweenValue(this.props);
        }
        go(propName, startValue, endValue) {
            let prop = _propsPool.take();
            this.props.push(prop);
            prop.name = propName;
            prop.offset = this.startValue.nums.length;
            if (this._active) {
                prop.renewFlags = 0;
                if (startValue === undefined)
                    startValue = this.target[propName];
                if (endValue === undefined)
                    endValue = this.target[propName];
            }
            else
                prop.renewFlags = startValue === undefined ? 1 : endValue === undefined ? 2 : 0;
            const type = startValue != null ? typeof (startValue) : typeof (endValue);
            let adapter;
            if (type === "number")
                prop.type = 0;
            else if (type === "string")
                prop.type = 2;
            else if (type == "object" && (adapter = startValue[TweenValueAdapterKey]) != null)
                prop.type = adapter;
            else
                prop.type = 1;
            this.startValue.write(prop.type, prop.offset, startValue !== undefined ? startValue : endValue);
            this.endValue.write(prop.type, prop.offset, endValue !== undefined ? endValue : startValue);
            return this;
        }
        get normalizedTime() {
            return this._normalizedTime;
        }
        get breaking() {
            return this._ended == 1;
        }
        get remainTime() {
            if (this.breakpoint >= 0)
                return this.delay + this.breakpoint - this._elapsedTime;
            else if (this.repeat >= 0)
                return this.delay + this.duration * (this.repeat + 1) - this._elapsedTime;
            else
                return this.delay + this.duration * 2 - this._elapsedTime;
        }
        activate() {
            this._active = true;
            this._startFrame = ILaya.timer.currFrame;
            for (let prop of this.props) {
                if (prop.renewFlags == 1)
                    this.startValue.write(prop.type, prop.offset, this.target[prop.name]);
                else if (prop.renewFlags == 2)
                    this.endValue.write(prop.type, prop.offset, this.target[prop.name]);
            }
        }
        seek(time) {
            if (this._killed)
                return;
            this._elapsedTime = time;
            if (this._elapsedTime < this.delay) {
                if (this._started)
                    this._elapsedTime = this.delay;
                else
                    return;
            }
            this.update2();
        }
        kill(complete) {
            if (this._killed)
                return;
            if (complete) {
                if (this._ended == 0) {
                    this._elapsedTime = 0;
                    this._elapsedTime = this.remainTime;
                    this.update2();
                }
                this.callCompleteCallback();
            }
            this._killed = true;
        }
        init() {
            _idCounter$1++;
            if (_idCounter$1 < 1)
                _idCounter$1 = 1;
            this.id = _idCounter$1;
            _activeTweenMap.set(this.id, this);
            this.name = null;
            this.delay = 0;
            this.duration = 0;
            this.breakpoint = -1;
            this.startValue.nums.length = 0;
            this.endValue.nums.length = 0;
            this.value.nums.length = 0;
            this.ease = Ease.linear;
            this.easeArgs.length = 0;
            this.timeScale = 1;
            this.snapping = false;
            this.repeat = 0;
            this.yoyo = false;
            this.interp = null;
            this.interpArgs.length = 0;
            this._started = false;
            this.paused = false;
            this._killed = false;
            this._startFrame = ILaya.timer.currFrame;
            this._elapsedTime = 0;
            this._normalizedTime = 0;
            this._ended = 0;
            this._active = false;
        }
        reset() {
            this.id = -1;
            this.owner = null;
            this.target = null;
            this.lifecycleOwner = null;
            this.userData = null;
            _propsPool.recover(this.props);
            this.onStart = this.onUpdate = this.onComplete = null;
            this.onStartCaller = this.onUpdateCaller = this.onCompleteCaller = null;
        }
        update(dt) {
            if (this.timeScale != 1)
                dt *= this.timeScale;
            if (dt == 0)
                return;
            if (this._ended != 0) {
                this.callCompleteCallback();
                this._killed = true;
                return;
            }
            this._elapsedTime += dt;
            this.update2();
            if (this._ended != 0) {
                if (!this._killed) {
                    this.callCompleteCallback();
                    this._killed = true;
                }
            }
        }
        update2() {
            this._ended = 0;
            if (!this._started) {
                if (this._elapsedTime < this.delay)
                    return;
                this._started = true;
                this.value.copy(this.startValue);
                this.deltaValue.nums.length = this.startValue.nums.length;
                this.deltaValue.nums.fill(0);
                this.callStartCallback();
                if (this._killed)
                    return;
            }
            let reversed = false;
            let dur = this.duration;
            let tt = this._elapsedTime - this.delay;
            if (this.breakpoint >= 0 && tt >= this.breakpoint) {
                tt = this.breakpoint;
                this._ended = 2;
            }
            if (this.repeat != 0) {
                let round = Math.floor(tt / dur);
                tt -= dur * round;
                if (this.yoyo)
                    reversed = round % 2 == 1;
                if (this.repeat > 0 && this.repeat - round < 0) {
                    if (this.yoyo)
                        reversed = this.repeat % 2 == 1;
                    tt = dur;
                    this._ended = 1;
                }
            }
            else if (tt >= dur) {
                tt = dur;
                this._ended = 1;
            }
            let t = dur > 0 ? this.ease(reversed ? (dur - tt) : tt, 0, 1, dur, ...this.easeArgs) : 1;
            this._normalizedTime = t;
            let startNums = this.startValue.nums;
            let endNums = this.endValue.nums;
            let valueNums = this.value.nums;
            let deltaNums = this.deltaValue.nums;
            valueNums.fill(0);
            deltaNums.fill(0);
            if (this.interp) {
                this.interp(t, startNums, endNums, valueNums, ...this.interpArgs);
                for (let i = 0, n = startNums.length; i < n; i++) {
                    let f = valueNums[i];
                    if (this.snapping)
                        f = Math.round(f);
                    deltaNums[i] = f - valueNums[i];
                }
            }
            else {
                for (let i = 0, n = startNums.length; i < n; i++) {
                    let n1 = startNums[i];
                    let n2 = endNums[i];
                    let f = n1 + (n2 - n1) * t;
                    if (this.snapping)
                        f = Math.round(f);
                    deltaNums[i] = f - valueNums[i];
                    valueNums[i] = f;
                }
            }
            if (this.target != null) {
                for (let prop of this.props) {
                    if (prop.name) {
                        let v = prop.type === 1 ? (this._ended === 1 ? this.endValue.read(prop.type, prop.offset)
                            : this.startValue.read(prop.type, prop.offset))
                            : this.value.read(prop.type, prop.offset);
                        if ((prop.type === 0 || prop.type === 1 || prop.type === 2)
                            && this.target[prop.name] === v)
                            continue;
                        this.target[prop.name] = v;
                    }
                }
            }
            this.callUpdateCallback();
        }
        callStartCallback() {
            if (this.onStart) {
                try {
                    this.onStart.call(this.onStartCaller, this);
                }
                catch (err) {
                    console.error("error in start callback > ", err);
                }
            }
        }
        callUpdateCallback() {
            if (this.onUpdate) {
                try {
                    this.onUpdate.call(this.onUpdateCaller, this);
                }
                catch (err) {
                    console.error("error in update callback > ", err);
                }
            }
        }
        callCompleteCallback() {
            if (this.onComplete) {
                try {
                    this.onComplete.call(this.onCompleteCaller, this);
                }
                catch (err) {
                    console.error("error in complete callback > ", err);
                }
            }
        }
        static _runAll() {
            var _a;
            let cnt = _totalActiveTweens;
            if (cnt == 0)
                return;
            let frame = ILaya.timer.currFrame;
            let dt = ILaya.timer.delta;
            let udt = ILaya.timer.unscaledDelta;
            let freePosStart = -1;
            for (let i = 0; i < cnt; i++) {
                let tweener = _activeTweens[i];
                if (tweener == null) {
                    if (freePosStart == -1)
                        freePosStart = i;
                }
                else if (tweener._killed) {
                    _activeTweenMap.delete(tweener.id);
                    (_a = tweener.owner) === null || _a === void 0 ? void 0 : _a._check();
                    Tweener._pool.recover(tweener);
                    _activeTweens[i] = null;
                    if (freePosStart == -1)
                        freePosStart = i;
                }
                else {
                    if (tweener.target && tweener.target.destroyed
                        || tweener.lifecycleOwner && tweener.lifecycleOwner.destroyed)
                        tweener._killed = true;
                    else if (!tweener.paused && tweener._active)
                        tweener.update(tweener._startFrame == frame ? 0 : tweener.ignoreEngineTimeScale ? udt : dt);
                    if (freePosStart != -1) {
                        _activeTweens[freePosStart] = tweener;
                        _activeTweens[i] = null;
                        freePosStart++;
                    }
                }
            }
            if (freePosStart >= 0) {
                if (_totalActiveTweens != cnt) {
                    let j = cnt;
                    cnt = _totalActiveTweens - cnt;
                    for (let i = 0; i < cnt; i++) {
                        _activeTweens[freePosStart++] = _activeTweens[j];
                        _activeTweens[j] = null;
                        j++;
                    }
                }
                _totalActiveTweens = freePosStart;
            }
        }
        static _getMap() {
            return _activeTweenMap;
        }
    }
    Tweener._pool = Pool.createPool(Tweener, e => e.init(), e => e.reset());
    var _idCounter$1 = 0;
    var _totalActiveTweens = 0;
    const _activeTweens = [];
    const _activeTweenMap = new Map();
    const _propsPool = Pool.createPool(Object);

    class Tween {
        static create(target, lifecycleOwner) {
            let tween = Tween._pool.take();
            tween._target = target;
            tween._lo = lifecycleOwner;
            return tween;
        }
        static isTweening(target) {
            return Tweener.isTweening(target);
        }
        static getTween(target) {
            tmpArray.length = 0;
            this.getTweens(target, tmpArray);
            return tmpArray.length > 0 ? tmpArray[0] : null;
        }
        static getTweens(target, out) {
            return Tweener.getTweens(target, out);
        }
        static kill(tween) {
            if (tween)
                tween.kill();
        }
        static clear(tween) {
            if (tween)
                tween.kill();
        }
        static killAll(target, completed) {
            return Tweener.killAll(target, completed);
        }
        static clearAll(target) {
            Tween.killAll(target);
        }
        static to(target, props, duration, ease, complete, delay, coverBefore) {
            if (coverBefore)
                Tween.killAll(target);
            let tween = Tween.create(target);
            Tween.tweenLegacy(tween.cur(true), props, duration, ease, complete, delay, true);
            return tween;
        }
        static from(target, props, duration, ease, complete, delay, coverBefore) {
            if (coverBefore)
                Tween.killAll(target);
            let tween = Tween.create(target);
            Tween.tweenLegacy(tween.cur(true), props, duration, ease, complete, delay, false);
            return tween;
        }
        static tweenLegacy(tweener, props, duration, ease, complete, delay, isTo) {
            tweener.duration = duration;
            for (let p in props) {
                let value = props[p];
                if (p in tweener.target) {
                    isTo ? tweener.go(p, tweener.target[p], value) : tweener.go(p, value, tweener.target[p]);
                }
            }
            if (props.ease) {
                tweener.ease = props.ease;
                if (props.easeArgs)
                    tweener.easeArgs.push(...props.easeArgs);
            }
            if (props.update) {
                tweener.onUpdate = props.update.runWith;
                tweener.onUpdateCaller = props.update;
            }
            if (props.complete) {
                tweener.onComplete = props.complete.runWith;
                tweener.onCompleteCaller = props.complete;
            }
            if (ease != null)
                tweener.ease = ease;
            if (delay != null)
                tweener.delay = delay;
            if (complete) {
                tweener.onComplete = complete.runWith;
                tweener.onCompleteCaller = complete;
            }
        }
        to(propName, value) {
            this.cur(true).go(propName, undefined, value);
            return this;
        }
        from(propName, value) {
            this.cur(true).go(propName, value, undefined);
            return this;
        }
        go(propName, startValue, endValue) {
            this.cur(true).go(propName, startValue, endValue);
            return this;
        }
        chain(target, lifecycleOwner) {
            if (target !== undefined) {
                this._target = target;
                this._lo = lifecycleOwner;
            }
            if (this._queue.length == 0)
                return this;
            if (this._par != null) {
                this._queue.push(-2);
                this._par = null;
            }
            this._cur = Tweener.create(this);
            this._cur.target = this._target;
            this._cur.lifecycleOwner = this._lo;
            this._queue.push(this._cur.id);
            return this;
        }
        parallel(target, lifecycleOwner) {
            if (this._queue.length == 0) {
                if (target !== undefined) {
                    this._target = target;
                    this._lo = lifecycleOwner;
                }
                return this;
            }
            if (this._par == null) {
                this._queue.push(-1);
                this._par = this._cur;
            }
            this._cur = Tweener.create(this);
            if (target !== undefined) {
                this._cur.target = target;
                this._cur.lifecycleOwner = lifecycleOwner;
            }
            else {
                this._cur.target = this._par.target;
                this._cur.lifecycleOwner = this._par.lifecycleOwner;
            }
            this._cur.duration = this._par.duration;
            if (this._par._active)
                this._cur.activate();
            this._queue.push(this._cur.id);
            return this;
        }
        delay(value) {
            this.cur(false).delay = value;
            return this;
        }
        duration(value) {
            this.cur(false).duration = value;
            return this;
        }
        breakpoint(value) {
            this.cur(false).breakpoint = value;
            return this;
        }
        ease(value, ...args) {
            let cur = this.cur(false);
            if (typeof (value) === "string")
                cur.ease = Ease[value];
            else
                cur.ease = value;
            cur.easeArgs.length = 0;
            if (args)
                cur.easeArgs.push(...args);
            return this;
        }
        interp(value, ...args) {
            let cur = this.cur(false);
            cur.interp = value;
            cur.interpArgs.length = 0;
            if (args)
                cur.interpArgs.push(...args);
            return this;
        }
        repeat(repeat, yoyo) {
            let cur = this.cur(false);
            cur.repeat = repeat;
            cur.yoyo = yoyo;
            return this;
        }
        timeScale(value) {
            this.cur(false).timeScale = value;
            return this;
        }
        ignoreEngineTimeScale(value) {
            this.cur(false).ignoreEngineTimeScale = value;
            return this;
        }
        snapping(value) {
            this.cur(false).snapping = value;
            return this;
        }
        userData(value) {
            this.cur(false).userData = value;
            return this;
        }
        name(value) {
            this.cur(false).name = value;
            return this;
        }
        onUpdate(callback, callbackThis) {
            let cur = this.cur(false);
            cur.onUpdate = callback;
            cur.onUpdateCaller = callbackThis;
            return this;
        }
        onStart(callback, callbackThis) {
            let cur = this.cur(false);
            cur.onStart = callback;
            cur.onStartCaller = callbackThis;
            return this;
        }
        then(callback, callbackThis) {
            let cur = this.cur(false);
            cur.onComplete = callback;
            cur.onCompleteCaller = callbackThis;
            return this;
        }
        seek(time) {
            this.cur(false).seek(time);
            return this;
        }
        pause() {
            forEach(this._queue, tween => tween.paused = true);
            return this;
        }
        resume() {
            forEach(this._queue, tween => tween.paused = false);
            return this;
        }
        findTweener(name) {
            for (let i = 0, n = this._queue.length; i < n; i++) {
                if (i < 0)
                    continue;
                let tween = Tweener.getTween(this._queue[i]);
                if (tween && tween.name == name)
                    return tween;
            }
            return null;
        }
        kill(complete) {
            if (this._queue.length == 0)
                return;
            let arr;
            for (let e of this._queue) {
                if (e > 0) {
                    let tweener = Tweener.getTween(e);
                    if (tweener) {
                        if (!tweener._killed) {
                            if (!arr)
                                arr = [];
                            arr.push(tweener);
                        }
                        tweener.owner = null;
                    }
                }
            }
            this._head = -1;
            this._cur = null;
            this._queue.length = 0;
            if (arr != null)
                arr.forEach(t => t.kill(complete));
        }
        get completed() {
            return this._head >= 0 && this._queue.length === 0;
        }
        complete() {
            this.kill(true);
        }
        clear() {
            this.kill(false);
        }
        recover() {
            this.kill(false);
            Tween._pool.recover(this);
        }
        constructor() {
            this._queue = [];
            this._head = -1;
        }
        cur(call) {
            if (!this._cur) {
                if (this._head != -1) {
                    if (call)
                        this.kill(false);
                    else
                        throw new Error("Tween has been started. clear first!");
                }
                this._cur = Tweener.create(this);
                this._cur.target = this._target;
                this._cur.lifecycleOwner = this._lo;
                this._cur.activate();
                this._queue.push(this._cur.id);
            }
            return this._cur;
        }
        _check() {
            if (this._cur) {
                this._head = 0;
                this._cur = null;
            }
            let i = this._head, cnt = this._queue.length;
            for (; i < cnt; i++) {
                let id = this._queue[i];
                if (id < 0)
                    continue;
                let tween = Tweener.getTween(id);
                if (tween && !tween._killed) {
                    if (tween._active)
                        break;
                    tween.activate();
                    if (this._queue[i + 1] == -1) {
                        for (let j = i + 2; j < cnt; j++) {
                            let id = this._queue[j];
                            if (id < 0)
                                break;
                            let tween = Tweener.getTween(id);
                            if (tween && !tween._killed)
                                tween.activate();
                            else
                                this._queue[i] = -3;
                        }
                    }
                    break;
                }
                else
                    this._queue[i] = -3;
            }
            this._head = i;
            if (i >= cnt)
                this._queue.length = 0;
        }
        static shake(time, start, end, result, amplitude) {
            if (time == 1) {
                result.length = 0;
                result.push(...start);
            }
            else {
                let am = amplitude * (1 - time);
                let am2 = am * (Math.random() > 0.5 ? 1 : -1);
                for (let i = 0; i < start.length; i++)
                    result[i] = start[i] + am2;
            }
        }
        static seperateChannel(time, start, end, result, channels) {
            channels = channels || 3;
            for (let i = 0; i < start.length; i++)
                result[i] = interpByChannel(time, start[i], end[i], channels);
        }
        static useCurvePath(time, start, end, result, path) {
            let pt = path.getPointAt(time);
            result[0] = pt.x;
            if (result.length > 1)
                result[1] = pt.y;
            if (result.length > 2)
                result[2] = pt.z;
        }
    }
    Tween._pool = Pool.createPool(Tween);
    const tmpArray = [];
    function forEach(all, callback) {
        for (let e of all) {
            if (e > 0) {
                let tween = Tweener.getTween(e);
                if (tween && !tween._killed)
                    callback(tween);
            }
        }
    }
    function interpByChannel(time, start, end, channels) {
        let v = 0;
        for (let i = 0; i < channels; i++) {
            let j = i * 8;
            let n0 = (start >> j) & 0xFF;
            let n1 = (end >> j) & 0xFF;
            v += (n0 + (n1 - n0) * time) << j;
        }
        return v;
    }

    class DragSupport {
        constructor(owner) {
            this.ratio = 0.92;
            this.maxOffset = 60;
            this.hasInertia = false;
            this.elasticDistance = 0;
            this.elasticBackTime = 300;
            this.autoStart = false;
            this._testing = false;
            this._dragging = false;
            this.target = owner;
            this.area = new Rectangle();
            this._points = [];
            this.target.on(Event.MOUSE_DOWN, this, this.onMouseDown);
            this.target.on(Event.MOUSE_DRAG, this, this.onMouseDrag);
            this.target.on(Event.MOUSE_DRAG_END, this, this.onMouseDragEnd);
        }
        get dragging() {
            return this._dragging;
        }
        start(data) {
            this.reset();
            this._touchId = ILaya.InputManager.lastTouchId;
            this._dragging = true;
            this._testing = false;
            this._elasticRateX = this._elasticRateY = 1;
            let pt = this.target._parent.getMousePoint();
            this._points.length = 0;
            this._points.push(pt.x, pt.y, Browser.now());
            this._data = data;
        }
        reset() {
            this._dragging = false;
            this._testing = false;
            this._data = null;
            ILaya.systemTimer.clear(this, this.tweenMove);
            if (this._tween != null) {
                this._tween.kill();
                this._tween = null;
            }
        }
        stop() {
            if (!this._dragging) {
                this._testing = false;
                return;
            }
            if (!this._testing) {
                this._dragging = false;
                this.moveTarget(0, 0);
                this.clear();
            }
        }
        onMouseDown() {
            if (this.autoStart && !this._dragging && !this._testing) {
                this.start();
                this._testing = true;
            }
        }
        onMouseDrag(evt) {
            if (!this._testing && !this._dragging)
                return;
            if (this._touchId != evt.touchId)
                return;
            let point = this.target._parent.getMousePoint();
            let mouseX = point.x;
            let mouseY = point.y;
            let offsetX = mouseX - this._points[this._points.length - 3];
            let offsetY = mouseY - this._points[this._points.length - 2];
            if (this._testing) {
                if (Math.abs(offsetX * ILaya.stage._canvasTransform.getScaleX()) < 1 && Math.abs(offsetY * ILaya.stage._canvasTransform.getScaleY()) < 1)
                    return;
                this._dragging = true;
                this.target.event(Event.DRAG_START, this._data);
                if (!this._dragging)
                    return;
                this._testing = false;
            }
            let now = Browser.now();
            while (this._points.length > 0 && this._points[2] < now - 100)
                this._points.splice(0, 3);
            this._points.push(mouseX, mouseY, now);
            this.moveTarget(offsetX * this._elasticRateX, offsetY * this._elasticRateY);
            this.target.event(Event.DRAG_MOVE, this._data);
        }
        onMouseDragEnd(evt) {
            if (!this._dragging) {
                this._testing = false;
                return;
            }
            if (this._touchId != evt.touchId)
                return;
            if (this.hasInertia) {
                let v = DragSupport.computeVelocity(this._points, this.maxOffset);
                this._points[0] = v.x;
                this._points[1] = v.y;
                ILaya.systemTimer.frameLoop(1, this, this.tweenMove);
            }
            else if (!this.area.isEmpty() && this.elasticDistance > 0) {
                this.checkElastic();
            }
            else {
                this.clear();
            }
        }
        moveTarget(dx, dy) {
            let nx = this.target._x + dx;
            let ny = this.target._y + dy;
            if (this.area.isEmpty())
                this.target.pos(nx, ny);
            else if (this.elasticDistance > 0 && this._dragging) {
                this.target.pos(nx, ny);
                this.updateElasticRate();
            }
            else
                this.target.pos(Math.min(Math.max(nx, this.area.x), this.area.x + this.area.width), Math.min(Math.max(ny, this.area.y), this.area.y + this.area.height));
        }
        updateElasticRate() {
            let left;
            let top;
            if (this.target._x < this.area.x)
                left = this.area.x - this.target._x;
            else if (this.target._x > this.area.x + this.area.width)
                left = this.target._x - this.area.x - this.area.width;
            else
                left = 0;
            if (this.target._y < this.area.y)
                top = this.area.y - this.target._y;
            else if (this.target._y > this.area.y + this.area.height)
                top = this.target._y - this.area.y - this.area.height;
            else
                top = 0;
            this._elasticRateX = Math.max(0, 1 - (left / this.elasticDistance));
            this._elasticRateY = Math.max(0, 1 - (top / this.elasticDistance));
        }
        checkElastic() {
            let tx;
            let ty;
            if (this.target._x < this.area.x)
                tx = this.area.x;
            else if (this.target._x > this.area.x + this.area.width)
                tx = this.area.x + this.area.width;
            if (this.target._y < this.area.y)
                ty = this.area.y;
            else if (this.target._y > this.area.y + this.area.height)
                ty = this.area.y + this.area.height;
            if (tx != null || ty != null) {
                this._tween = Tween.create(this.target).duration(this.elasticBackTime).ease(Ease.sineOut).then(this.clear, this);
                if (tx != null)
                    this._tween.to("x", tx);
                if (ty != null)
                    this._tween.to("y", ty);
            }
            else {
                this.clear();
            }
        }
        tweenMove() {
            let n = Math.pow(this.ratio, ILaya.timer.delta / 16.6);
            let s = this.ratio * (1 - n) / (1 - this.ratio);
            let dx = this._points[0] * s * this._elasticRateX;
            let dy = this._points[1] * s * this._elasticRateY;
            if (dx < 0)
                dx = Math.ceil(dx);
            else
                dx = Math.floor(dx);
            if (dy < 0)
                dy = Math.ceil(dy);
            else
                dy = Math.floor(dy);
            this._points[0] *= n * this._elasticRateX;
            this._points[1] *= n * this._elasticRateY;
            if (Math.abs(dx) < 1 && Math.abs(dy) < 1 || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
                ILaya.systemTimer.clear(this, this.tweenMove);
                if (!this.area.isEmpty() && this.elasticDistance > 0)
                    this.checkElastic();
                else
                    this.clear();
            }
            else {
                this.moveTarget(dx, dy);
                this.target.event(Event.DRAG_MOVE, this._data);
            }
        }
        clear() {
            let d = this._data;
            this.reset();
            this.target.event(Event.DRAG_END, d);
        }
        static computeVelocity(points, max) {
            let now = Browser.now();
            while (points.length > 0 && points[2] < now - 100)
                points.splice(0, 3);
            let len = points.length / 3;
            let x = 0, y = 0;
            let t = 0;
            for (let i = 1; i < len; i++) {
                x += points[i * 3] - points[i * 3 - 3];
                y += points[i * 3 + 1] - points[i * 3 - 2];
                t += points[i * 3 + 2] - points[i * 3 - 1];
            }
            if (t != 0) {
                t = t / 16.6;
                x = x / t;
                y = y / t;
            }
            else
                x = y = 0;
            if (max != null) {
                if (Math.abs(x) > max)
                    x = x > 0 ? max : -max;
                if (Math.abs(y) > max)
                    y = y > 0 ? max : -max;
            }
            _velocity.setTo(x, y);
            return _velocity;
        }
    }
    const _velocity = new Point();

    class SpriteUtils {
        static getGlobalRecByPoints(sprite, x0, y0, x1, y1, out) {
            let newLTPoint;
            newLTPoint = Point.create().setTo(x0, y0);
            newLTPoint = sprite.localToGlobal(newLTPoint);
            let newRBPoint;
            newRBPoint = Point.create().setTo(x1, y1);
            newRBPoint = sprite.localToGlobal(newRBPoint);
            let rst = Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y], out);
            newLTPoint.recover();
            newRBPoint.recover();
            return rst;
        }
        static getGlobalPosAndScale(sprite) {
            let tmpRect = Rectangle.create();
            SpriteUtils.getGlobalRecByPoints(sprite, 0, 0, 1, 1, tmpRect);
            let ret = { x: tmpRect.x, y: tmpRect.y, scaleX: tmpRect.width, scaleY: tmpRect.height };
            tmpRect.recover();
            return ret;
        }
        static getTransformRelativeToWindow(coordinateSpace, x, y) {
            let stage = ILaya.stage;
            let globalTransform = SpriteUtils.getGlobalPosAndScale(coordinateSpace);
            let canvasMatrix = Matrix.create();
            stage._canvasTransform.copyTo(canvasMatrix);
            let canvasLeft = canvasMatrix.tx;
            let canvasTop = canvasMatrix.ty;
            canvasMatrix.rotate(-Math.PI / 180 * stage.canvasDegree);
            canvasMatrix.scale(stage.clientScaleX, stage.clientScaleY);
            let perpendicular = (stage.canvasDegree % 180 != 0);
            let tx, ty;
            if (perpendicular) {
                tx = y + globalTransform.y;
                ty = x + globalTransform.x;
                tx *= canvasMatrix.d;
                ty *= canvasMatrix.a;
                if (stage.canvasDegree == 90) {
                    tx = canvasLeft - tx;
                    ty += canvasTop;
                }
                else {
                    tx += canvasLeft;
                    ty = canvasTop - ty;
                }
            }
            else {
                tx = x + globalTransform.x;
                ty = y + globalTransform.y;
                tx *= canvasMatrix.a;
                ty *= canvasMatrix.d;
                tx += canvasLeft;
                ty += canvasTop;
            }
            let domScaleX, domScaleY;
            if (perpendicular) {
                domScaleX = canvasMatrix.d * globalTransform.scaleY;
                domScaleY = canvasMatrix.a * globalTransform.scaleX;
            }
            else {
                domScaleX = canvasMatrix.a * globalTransform.scaleX;
                domScaleY = canvasMatrix.d * globalTransform.scaleY;
            }
            canvasMatrix.recover();
            globalTransform.x = Math.round(tx);
            globalTransform.y = Math.round(ty);
            globalTransform.scaleX = Math.round(domScaleX * 100000) / 100000;
            globalTransform.scaleY = Math.round(domScaleY * 100000) / 100000;
            return globalTransform;
        }
        static fitDOMElementInArea(dom, coordinateSpace, x, y, width, height) {
            if (!dom._fitLayaAirInitialized) {
                dom._fitLayaAirInitialized = true;
                PAL.browser.setStyleTransformOrigin(dom.style, "left top");
                dom.style.position = "absolute";
            }
            let transform = SpriteUtils.getTransformRelativeToWindow(coordinateSpace, x, y);
            PAL.browser.setStyleTransform(dom.style, "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)");
            dom.style.width = width + 'px';
            dom.style.height = height + 'px';
            dom.style.left = transform.x + 'px';
            dom.style.top = transform.y + 'px';
        }
        static updateOrder(array) {
            if (!array || array.length < 2)
                return false;
            let i = 1, j, len = array.length, key, c;
            while (i < len) {
                j = i;
                c = array[j];
                key = array[j]._zOrder;
                while (--j > -1) {
                    if (array[j]._zOrder > key)
                        array[j + 1] = array[j];
                    else
                        break;
                }
                array[j + 1] = c;
                i++;
            }
            return true;
        }
        static localToGlobalRect(sp, rect) {
            let pt = sp.localToGlobal(Point.TEMP.setTo(rect.x, rect.y));
            let x = pt.x;
            let y = pt.y;
            sp.localToGlobal(pt.setTo(rect.right, rect.bottom));
            return rect.setTo(x, y, x + pt.x, y + pt.y);
        }
        static globalToLocalRect(sp, rect) {
            let pt = sp.globalToLocal(Point.TEMP.setTo(rect.x, rect.y));
            let x = pt.x;
            let y = pt.y;
            sp.globalToLocal(pt.setTo(rect.right, rect.bottom));
            return rect.setTo(x, y, x + pt.x, y + pt.y);
        }
        static transformRect(sp, rect, targetSpace) {
            let pt = sp.localToGlobal(Point.TEMP.setTo(rect.x, rect.y), false, targetSpace);
            let x = pt.x;
            let y = pt.y;
            sp.localToGlobal(pt.setTo(rect.right, rect.bottom), false, targetSpace);
            return rect.setTo(x, y, x + pt.x, y + pt.y);
        }
    }

    class Component {
        get hideFlags() {
            return this._hideFlags;
        }
        set hideFlags(value) {
            this._hideFlags = value;
        }
        constructor() {
            var _a;
            this._hideFlags = 0;
            this._status = 0;
            this._enabled = true;
            this._id = _idCounter++;
            this._singleton = (_a = Object.getPrototypeOf(this)._$singleton) !== null && _a !== void 0 ? _a : true;
            this._initialize();
        }
        _initialize() {
            this._extra = {};
        }
        hasHideFlag(flag) {
            return (this._hideFlags & flag) != 0;
        }
        get id() {
            return this._id;
        }
        get enabled() {
            return this._enabled;
        }
        set enabled(value) {
            if (this._enabled != value) {
                this._enabled = value;
                if (this.owner)
                    this._setActive(value && this.owner.activeInHierarchy);
            }
        }
        get awaked() {
            return this._status > 0;
        }
        get destroyed() {
            return this._status == 4;
        }
        _isScript() {
            return false;
        }
        _resetComp() {
            this._enabled = true;
            this._status = 0;
            this._enableState = false;
            this.owner = null;
        }
        _setOwner(node) {
            if (this._status != 0) {
                throw new Error('reuse a destroyed component');
            }
            this.owner = node;
            if (this._isScript())
                node._setBit(NodeFlags.HAS_SCRIPT, true);
            this._onAdded();
            this.onAdded();
        }
        _onAdded() {
        }
        _onAwake() {
        }
        _onEnable() {
            this.onEnable();
        }
        _onDisable() {
            this.onDisable();
        }
        _onDestroy() {
        }
        _parse(data, interactMap = null) {
        }
        _parseInteractive(data = null, spriteMap = null) {
        }
        _cloneTo(dest) {
        }
        _setActive(value) {
            var _a;
            if (value) {
                if (this._status == 0) {
                    this._status = 1;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._onAwake();
                        this.onAwake();
                    }
                }
                if (this._enabled && !this._enableState) {
                    this._enableState = true;
                    if (LayaEnv.isPlaying || this.runInEditor) {
                        this._driver = ((_a = this.owner._scene) === null || _a === void 0 ? void 0 : _a._componentDriver) || ILaya.stage._componentDriver;
                        this._driver.add(this);
                        if (LayaEnv.isPlaying && this._isScript())
                            this.setupScript();
                        this._onEnable();
                    }
                }
            }
            else if (this._enableState) {
                this._enableState = false;
                if (LayaEnv.isPlaying || this.runInEditor) {
                    if (this._driver)
                        this._driver.remove(this);
                    ILaya.stage.offAllCaller(this);
                    this._onDisable();
                }
            }
        }
        setupScript() {
        }
        destroy() {
            if (this._status == 4)
                return;
            if (this.owner)
                this.owner._destroyComponent(this);
            else if (!this.destroyed)
                this._destroy(true);
        }
        _destroy(second) {
            if (second) {
                if (LayaEnv.isPlaying || this.runInEditor) {
                    this._onDestroy();
                    this.onDestroy();
                    if (this.onReset) {
                        this.onReset();
                        this._resetComp();
                        Pool.recoverByClass(this);
                    }
                }
                return;
            }
            this._setActive(false);
            this._status = 4;
            if (LayaEnv.isPlaying || this.runInEditor)
                (this._driver || ILaya.stage._componentDriver)._toDestroys.add(this);
            this._driver = null;
        }
        onAdded() {
        }
        onAwake() {
        }
        onEnable() {
        }
        onDisable() {
        }
        onDestroy() {
        }
    }
    var _idCounter = 0;

    exports.BaseRender2DType = void 0;
    (function (BaseRender2DType) {
        BaseRender2DType[BaseRender2DType["baseRenderNode"] = 0] = "baseRenderNode";
        BaseRender2DType[BaseRender2DType["spine"] = 1] = "spine";
        BaseRender2DType[BaseRender2DType["particle"] = 2] = "particle";
        BaseRender2DType[BaseRender2DType["spineSimple"] = 3] = "spineSimple";
    })(exports.BaseRender2DType || (exports.BaseRender2DType = {}));
    exports.Render2DOrderMode = void 0;
    (function (Render2DOrderMode) {
        Render2DOrderMode[Render2DOrderMode["elementIndex"] = 0] = "elementIndex";
        Render2DOrderMode[Render2DOrderMode["ysort"] = 1] = "ysort";
    })(exports.Render2DOrderMode || (exports.Render2DOrderMode = {}));
    class BaseRenderNode2D extends Component {
        static initBaseRender2DCommandEncoder() {
            BaseRenderNode2D.NMATRIX_0 = Shader3D.propertyNameToID("u_NMatrix_0");
            BaseRenderNode2D.NMATRIX_1 = Shader3D.propertyNameToID("u_NMatrix_1");
            BaseRenderNode2D.BASERENDER2DCOLOR = Shader3D.propertyNameToID("u_baseRenderColor");
            BaseRenderNode2D.BASERENDER2DTEXTURE = Shader3D.propertyNameToID("u_baseRender2DTexture");
            BaseRenderNode2D.BASERENDER2DTEXTURERANGE = Shader3D.propertyNameToID("u_baseRender2DTextureRange");
            BaseRenderNode2D.BASERENDERSIZE = Shader3D.propertyNameToID("u_baseRenderSize2D");
            BaseRenderNode2D.NORMAL2DTEXTURE = Shader3D.propertyNameToID("u_normal2DTexture");
            BaseRenderNode2D.NORMAL2DSTRENGTH = Shader3D.propertyNameToID("u_normal2DStrength");
            BaseRenderNode2D.SHADERDEFINE_BASERENDER2D = Shader3D.getDefineByName("BASERENDER2D");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_ENABLE = Shader3D.getDefineByName("LIGHT2D_ENABLE");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_EMPTY = Shader3D.getDefineByName("LIGHT2D_EMPTY");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_ADDMODE = Shader3D.getDefineByName("LIGHT2D_SCENEMODE_ADD");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_SUBMODE = Shader3D.getDefineByName("LIGHT2D_SCENEMODE_SUB");
            BaseRenderNode2D.SHADERDEFINE_LIGHT2D_NORMAL_PARAM = Shader3D.getDefineByName("LIGHT2D_NORMAL_PARAM");
            BaseRenderNode2D.SHADERDEFINE_CLIPMODE = Shader3D.getDefineByName("CLIPMODE");
            const commandUniform = LayaGL.renderDeviceFactory.createGlobalUniformMap("BaseRender2D");
            commandUniform.addShaderUniform(BaseRenderNode2D.NMATRIX_0, "u_NMatrix_0", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(BaseRenderNode2D.NMATRIX_1, "u_NMatrix_1", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(BaseRenderNode2D.BASERENDER2DCOLOR, "u_baseRenderColor", exports.ShaderDataType.Color);
            commandUniform.addShaderUniform(BaseRenderNode2D.BASERENDER2DTEXTURE, "u_baseRender2DTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(BaseRenderNode2D.BASERENDER2DTEXTURERANGE, "u_baseRender2DTextureRange", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(BaseRenderNode2D.BASERENDERSIZE, "u_baseRenderSize2D", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(BaseRenderNode2D.NORMAL2DTEXTURE, "u_normal2DTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(BaseRenderNode2D.NORMAL2DSTRENGTH, "u_normal2DStrength", exports.ShaderDataType.Float);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATDIR, "u_clipMatDir", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_CLIPMATPOS, "u_clipMatPos", exports.ShaderDataType.Vector2);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORALPHA, "u_colorAlpha", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(ShaderDefines2D.UNIFORM_COLORMAT, "u_colorMat", exports.ShaderDataType.Matrix4x4);
        }
        static _setRenderElement2DMaterial(element, material) {
            element.subShader = material._shader.getSubShaderAt(0);
            material._setOwner2DElement(element);
            element.materialShaderData = material._shaderValues;
        }
        get renderLayer() {
            return this._renderLayer;
        }
        set renderLayer(value) {
            this._renderLayer = value;
        }
        get rect() {
            return this._rect;
        }
        set rect(value) {
            this._rect = value;
        }
        _getcommonUniformMap() {
            return ["BaseRender2D"];
        }
        _getRect() {
            return this._rect;
        }
        _transformChange() {
        }
        _changeMaterialReference(lastValue, value) {
            (lastValue) && (lastValue._removeReference());
            (value) && (value._addReference());
        }
        _setRenderSize(x, y) {
            if (x == this._rtsize.x && y == this._rtsize.y)
                return;
            this._rtsize.setValue(x, y);
            this._spriteShaderData.setVector2(BaseRenderNode2D.BASERENDERSIZE, this._rtsize);
        }
        constructor() {
            super();
            this._renderType = exports.BaseRender2DType.baseRenderNode;
            this._renderUpdateMask = 0;
            this._layer = 0;
            this._rtsize = new Vector2();
            this._lightReceive = false;
            this._lightUpdateMark = 0;
            this._lightRecord = false;
            this._renderLayer = 1;
            this._rect = new Vector4();
            this._renderid = BaseRenderNode2D._uniqueIDCounter++;
            this._spriteShaderData = LayaGL.renderDeviceFactory.createShaderData(null);
            this._spriteShaderData.setVector(ShaderDefines2D.UNIFORM_CLIPMATDIR, new Vector4(Const.MAX_CLIP_SIZE, 0, 0, Const.MAX_CLIP_SIZE));
            this._renderType = exports.BaseRender2DType.baseRenderNode;
            this._ordingMode = exports.Render2DOrderMode.elementIndex;
        }
        _onEnable() {
            super._onEnable();
            this.owner.renderNode2D = this;
            if (this._lightReceive)
                this._addRenderToLightManager();
        }
        _onDisable() {
            this.owner.renderNode2D = null;
            if (this._lightReceive)
                this._removeRenderFromLightManager();
            super._onDisable();
        }
        _onDestroy() {
            for (var i = 0, n = this._materials.length; i < n; i++) {
                let m = this._materials[i];
                m && !m.destroyed && m._removeReference();
            }
            this._spriteShaderData.destroy();
        }
        get layer() {
            return this._layer;
        }
        set layer(value) {
            if (this._layer !== value) {
                if (value >= 0 && value <= 30) {
                    this._removeRenderFromLightManager();
                    this._layer = value;
                    this._addRenderToLightManager();
                    this._resetUpdateMark();
                }
                else {
                    throw new Error("Layer value must be 0-30.");
                }
            }
        }
        set lightReceive(value) {
            if (value === this._lightReceive)
                return;
            this._lightReceive = value;
            if (value) {
                this._addRenderToLightManager();
                this._spriteShaderData.addDefine(BaseRenderNode2D.SHADERDEFINE_LIGHT2D_ENABLE);
            }
            else {
                this._removeRenderFromLightManager();
                this._spriteShaderData.removeDefine(BaseRenderNode2D.SHADERDEFINE_LIGHT2D_ENABLE);
            }
            this._resetUpdateMark();
        }
        get lightReceive() {
            return this._lightReceive;
        }
        _resetUpdateMark() {
            this._lightUpdateMark = 0;
        }
        _updateLight() {
            if (!this.lightReceive || !this.owner.scene || !this.owner.scene._light2DManager)
                return;
            const light2DManager = this.owner.scene._light2DManager;
            const updateMark = light2DManager._getLayerUpdateMark(this.layer);
            if (this._lightUpdateMark !== updateMark) {
                this._lightUpdateMark = updateMark;
                light2DManager._updateShaderDataByLayer(this.layer, this._spriteShaderData);
            }
        }
        _addRenderToLightManager() {
            if (this.owner.scene) {
                let light2DManager = this.owner.scene._light2DManager;
                if (light2DManager && !this._lightRecord) {
                    light2DManager.addRender(this);
                    this._lightRecord = true;
                }
            }
        }
        _removeRenderFromLightManager() {
            if (this.owner.scene) {
                const light2DManager = this.owner.scene._light2DManager;
                if (light2DManager && this._lightRecord) {
                    light2DManager.removeRender(this);
                    this._lightRecord = false;
                }
            }
        }
        get sharedMaterial() {
            return this._materials[0];
        }
        set sharedMaterial(value) {
            const lastValue = this._materials[0];
            if (lastValue !== value) {
                this._materials[0] = value;
                this._changeMaterialReference(lastValue, value);
                this._renderElements[0] && BaseRenderNode2D._setRenderElement2DMaterial(this._renderElements[0], value);
            }
        }
        getRenderID() {
            return this._renderid;
        }
        clear() {
            this._renderElements.length = 0;
        }
    }
    BaseRenderNode2D._uniqueIDCounter = 0;

    class SpriteGlobalTransform {
        constructor(sp) {
            this._flags = 0;
            this._x = 0.0;
            this._y = 0.0;
            this._rot = 0.0;
            this._scaleX = 1.0;
            this._scaleY = 1.0;
            this._cache = false;
            this._sp = sp;
        }
        get cache() {
            return this._cache;
        }
        set cache(value) {
            if (this._cache != value) {
                this._cache = value;
                if (value) {
                    this._setFlag(exports.TransformKind.Matrix | exports.TransformKind.TRS, true);
                    let parent = this._sp._parent;
                    if (parent != null && parent != ILaya.stage)
                        parent.globalTrans.cache = true;
                }
                else {
                    for (let child of this._sp._children) {
                        if (child._globalTrans)
                            child._globalTrans.cache = false;
                    }
                }
            }
        }
        getMatrix() {
            if (this._matrix == null)
                this._matrix = new Matrix();
            if (this._cache && !this._getFlag(exports.TransformKind.Matrix))
                return this._matrix;
            let sp = this._sp;
            this._matrix.setMatrix(sp._x, sp._y, sp._scaleX, sp._scaleY, sp._rotation, sp._skewX, sp._skewY, sp._pivotX, sp._pivotY);
            if (sp._parent) {
                Matrix.mul(this._matrix, sp._parent.globalTrans.getMatrix(), this._matrix);
                this._setFlag(exports.TransformKind.Matrix, false);
                this._syncFlag(exports.TransformKind.Matrix, true);
            }
            return this._matrix;
        }
        getMatrixInv(out) {
            this.getMatrix().copyTo(out);
            out.invert();
            return out;
        }
        get x() {
            return this.getPos(tmpPoint$1).x;
        }
        get y() {
            return this.getPos(tmpPoint$1).y;
        }
        getSceneMatrix(out) {
            if (!this._sp.scene)
                return this.getMatrix();
            this._sp.scene.globalTrans.getMatrix().invert().copyTo(out);
            Matrix.mul(this.getMatrix(), out, out);
            return out;
        }
        getScenePos(out) {
            if (!this._sp.scene)
                return this.getPos(out);
            return this._sp.scene.globalTrans.getMatrixInv(tmpMarix).transformPoint(this.getPos(out));
        }
        getSceneScale(out) {
            out.x = this.scaleX;
            out.y = this.scaleY;
            if (this._sp.scene) {
                const mat = this._sp.scene.globalTrans.getMatrix();
                out.x /= mat.getScaleX();
                out.y /= mat.getScaleY();
            }
            return out;
        }
        getSceneRotation() {
            let angle = this.rotation;
            if (this._sp.scene)
                angle -= this._sp.scene.globalTrans.rotation;
            return angle;
        }
        getPos(out) {
            if (this._cache) {
                this._cachePos();
                out.x = this._x;
                out.y = this._y;
            }
            else {
                this._sp.localToGlobal(out.setTo(0, 0), false, null);
            }
            return out;
        }
        setPos(x, y) {
            let sp = this._sp;
            if (this._cache) {
                this._cachePos();
                if (x == this._x && y == this._y)
                    return;
                let point = sp._parent.globalTrans.getMatrix().invertTransformPoint(tmpPoint$1.setTo(x, y));
                this._cache = false;
                sp.pos(point.x, point.y);
                this._cache = true;
                this._x = x;
                this._y = y;
                this._setFlag(exports.TransformKind.Pos, false);
                this._setFlag(exports.TransformKind.Matrix, true);
                this._syncFlag(exports.TransformKind.Pos | exports.TransformKind.Matrix, true);
            }
            else {
                tmpPoint$1.setTo(x, y);
                let point = sp.globalToLocal(tmpPoint$1, false, null);
                point = sp.toParentPoint(point);
                sp.pos(point.x, point.y);
            }
        }
        get rotation() {
            let sp = this._sp;
            if (this._cache) {
                if (this._getFlag(exports.TransformKind.Rotation)) {
                    this._setFlag(exports.TransformKind.Rotation, false);
                    if (sp._parent == sp._scene || !sp._parent)
                        this._rot = sp._rotation;
                    else
                        this._rot = sp._rotation + sp._parent.globalTrans.rotation;
                }
                return this._rot;
            }
            else {
                let angle = 0;
                let ele = sp;
                while (ele) {
                    if (ele === sp._scene)
                        break;
                    angle += ele._rotation;
                    ele = ele._parent;
                }
                return angle;
            }
        }
        set rotation(value) {
            if (value == this.rotation) {
                return;
            }
            let sp = this._sp;
            if (sp._parent == sp._scene || !sp._parent) {
                sp.rotation = value;
            }
            else {
                sp.rotation = value - sp._parent.globalTrans.rotation;
            }
            if (this._cache) {
                this._rot = value;
                this._setFlag(exports.TransformKind.Rotation, false);
                this._setFlag(exports.TransformKind.Matrix, true);
                this._syncFlag(exports.TransformKind.Matrix, true);
            }
        }
        get scaleX() {
            if (this._cache) {
                this._cacheScale();
                return this._scaleX;
            }
            else {
                let scale = 1;
                let ele = this._sp;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    scale *= ele._scaleX;
                    ele = ele._parent;
                }
                return scale;
            }
        }
        get scaleY() {
            if (this._cache) {
                this._cacheScale();
                return this._scaleY;
            }
            else {
                let scale = 1;
                let ele = this._sp;
                while (ele) {
                    if (ele === ILaya.stage)
                        break;
                    scale *= ele._scaleY;
                    ele = ele._parent;
                }
                return scale;
            }
        }
        _cachePos() {
            if (this._getFlag(exports.TransformKind.Matrix | exports.TransformKind.Pos)) {
                this._setFlag(exports.TransformKind.Pos, false);
                let p = this.getMatrix().transformPoint(tmpPoint$1.setTo(this._sp.pivotX, this._sp.pivotY));
                this._x = p.x;
                this._y = p.y;
            }
        }
        _cacheScale() {
            if (this._getFlag(exports.TransformKind.Matrix | exports.TransformKind.Scale)) {
                this._setFlag(exports.TransformKind.Scale, false);
                let mat = this.getMatrix();
                this._scaleX = mat.getScaleX();
                this._scaleY = mat.getScaleY();
            }
        }
        _getFlag(type) {
            return (this._flags & type) != 0;
        }
        _setFlag(type, value) {
            if (value)
                this._flags |= type;
            else
                this._flags &= ~type;
            if (value) {
                this._sp.event(SpriteGlobalTransform.CHANGED, type);
            }
        }
        _syncFlag(flag, value) {
            if (this._cache) {
                for (let child of this._sp._children) {
                    if (child._globalTrans) {
                        child._globalTrans._setFlag(flag, value);
                        child._globalTrans._syncFlag(flag, value);
                    }
                }
            }
        }
        _spTransChanged(kind) {
            if (this._cache)
                this._setFlag(kind | exports.TransformKind.Matrix, true);
            this._syncFlag(kind | exports.TransformKind.Matrix, true);
        }
        localToGlobal(x, y) {
            if (this._cache) {
                return this.getMatrix().transformPoint(tmpPoint$1.setTo(this._sp.pivotX + x, this._sp.pivotY + y));
            }
            else {
                return this._sp.localToGlobal(tmpPoint$1.setTo(x, y));
            }
        }
        globalToLocal(x, y) {
            if (this._cache) {
                let point = this.getMatrix().invertTransformPoint(tmpPoint$1.setTo(x, y));
                point.x -= this._sp.pivotX;
                point.y -= this._sp.pivotY;
                return point;
            }
            else {
                return this._sp.globalToLocal(tmpPoint$1.setTo(x, y));
            }
        }
    }
    SpriteGlobalTransform.CHANGED = "globalTransChanged";
    const tmpPoint$1 = new Point();
    const tmpMarix = new Matrix();

    const hiddenBits = NodeFlags.FORCE_HIDDEN | NodeFlags.NOT_IN_PAGE;
    class Sprite extends Node {
        constructor() {
            super();
            this._x = 0;
            this._y = 0;
            this._width = 0;
            this._height = 0;
            this._scaleX = 1;
            this._scaleY = 1;
            this._skewX = 0;
            this._skewY = 0;
            this._pivotX = 0;
            this._pivotY = 0;
            this._anchorX = 0;
            this._anchorY = 0;
            this._rotation = 0;
            this._alpha = 1;
            this._visible = true;
            this._mouseState = 0;
            this._zOrder = 0;
            this._renderType = 0;
            this._cacheStyle = CacheStyle.EMPTY;
            this.mouseThrough = false;
            this.hitTestPrior = false;
            this._autosize = false;
            this._repaint = 0;
            this._sizeFlag = 0;
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            this._cacheStyle && this._cacheStyle.recover();
            this._cacheStyle = null;
            this._texture && this._texture._removeReference();
            this._texture = null;
            this._graphics && this._ownGraphics && this._graphics.destroy();
            this._graphics = null;
        }
        get parent() {
            return this._$parent;
        }
        get scene() {
            return this._scene;
        }
        get x() {
            return this._x;
        }
        set x(value) {
            this.pos(value, this._y);
        }
        get y() {
            return this._y;
        }
        set y(value) {
            this.pos(this._x, value);
        }
        get width() {
            if (this._autosize)
                return this.getSelfBounds(tmpRect).width;
            else if ((this._sizeFlag & 1) == 0)
                return this.measureWidth();
            else
                return this._width;
        }
        set width(value) {
            this.size(value, (this._sizeFlag & 2) == 0 ? null : this._height);
        }
        get height() {
            if (this._autosize)
                return this.getSelfBounds(tmpRect).height;
            else if ((this._sizeFlag & 2) == 0)
                return this.measureHeight();
            else
                return this._height;
        }
        set height(value) {
            this.size((this._sizeFlag & 1) == 0 ? null : this._width, value);
        }
        get _isWidthSet() {
            return (this._sizeFlag & 1) != 0;
        }
        get _isHeightSet() {
            return (this._sizeFlag & 2) != 0;
        }
        measureWidth() {
            return this._texture ? this._texture.width : 0;
        }
        measureHeight() {
            return this._texture ? this._texture.height : 0;
        }
        get displayWidth() {
            return this.width * this.scaleX;
        }
        get displayHeight() {
            return this.height * this.scaleY;
        }
        get scaleX() {
            return this._scaleX;
        }
        set scaleX(value) {
            this.scale(value, this._scaleY);
        }
        get scaleY() {
            return this._scaleY;
        }
        set scaleY(value) {
            this.scale(this._scaleX, value);
        }
        get rotation() {
            return this._rotation;
        }
        set rotation(value) {
            if (this._rotation !== value) {
                this._rotation = value;
                this._transChanged(exports.TransformKind.Rotation);
            }
        }
        get skewX() {
            return this._skewX;
        }
        set skewX(value) {
            this.skew(value, this._skewY);
        }
        get skewY() {
            return this._skewY;
        }
        set skewY(value) {
            this.skew(this._skewX, value);
        }
        get transform() {
            if (!this._tfChanged)
                return this._transform;
            this._tfChanged = false;
            let m = this._transform || (this._transform = new Matrix());
            let sx = this._scaleX, sy = this._scaleY;
            let sskx = this._skewX;
            let ssky = this._skewY;
            let rot = this._rotation;
            if (rot || sx !== 1 || sy !== 1 || sskx !== 0 || ssky !== 0) {
                m._bTransform = true;
                let skx = (rot - sskx) * 0.0174532922222222;
                let sky = (rot + ssky) * 0.0174532922222222;
                let cx = Math.cos(sky);
                let ssx = Math.sin(sky);
                let cy = Math.sin(skx);
                let ssy = Math.cos(skx);
                m.a = sx * cx;
                m.b = sx * ssx;
                m.c = -sy * cy;
                m.d = sy * ssy;
                m.tx = m.ty = 0;
            }
            else {
                m.identity();
                this._renderType &= ~SpriteConst.TRANSFORM;
            }
            return m;
        }
        set transform(value) {
            this._tfChanged = false;
            let m = this._transform || (this._transform = new Matrix());
            if (value !== m)
                value.copyTo(m);
            if (value) {
                this._x = m.tx;
                this._y = m.ty;
                m.tx = m.ty = 0;
            }
            this._renderType |= SpriteConst.TRANSFORM;
            this.parentRepaint();
        }
        get globalTrans() {
            return this._globalTrans || (this._globalTrans = new SpriteGlobalTransform(this));
        }
        get pivotX() {
            return this._pivotX;
        }
        set pivotX(value) {
            this.pivot(value, this._pivotY);
        }
        get pivotY() {
            return this._pivotY;
        }
        set pivotY(value) {
            this.pivot(this._pivotX, value);
        }
        get anchorX() {
            return this._anchorX;
        }
        set anchorX(value) {
            this.anchor(value, this._anchorY);
        }
        get anchorY() {
            return this._anchorY;
        }
        set anchorY(value) {
            this.anchor(this._anchorX, value);
        }
        get alpha() {
            return this._alpha;
        }
        set alpha(value) {
            value = value < 0 ? 0 : (value > 1 ? 1 : value);
            if (this._alpha !== value) {
                this._alpha = value;
                if (value !== 1)
                    this._renderType |= SpriteConst.ALPHA;
                else
                    this._renderType &= ~SpriteConst.ALPHA;
                this.parentRepaint();
            }
        }
        get visible() {
            return this._visible;
        }
        set visible(value) {
            if (this._visible !== value) {
                this._visible = value;
                this._processVisible();
            }
        }
        get blendMode() {
            return this._blendMode;
        }
        set blendMode(value) {
            if (this._blendMode != value) {
                this._blendMode = value;
                if (value && value != "source-over")
                    this._renderType |= SpriteConst.BLEND;
                else
                    this._renderType &= ~SpriteConst.BLEND;
                this.parentRepaint();
            }
        }
        get graphics() {
            if (!this._graphics) {
                this.graphics = new Graphics();
                this._ownGraphics = true;
            }
            return this._graphics;
        }
        set graphics(value) {
            this.setGraphics(value, false);
        }
        setGraphics(value, transferOwnership) {
            if (this._graphics) {
                this._graphics._sp = null;
                if (this._ownGraphics)
                    this._graphics.destroy();
            }
            this._ownGraphics = transferOwnership;
            this._graphics = value;
            if (value) {
                this._renderType |= SpriteConst.GRAPHICS;
                value._sp = this;
            }
            else {
                this._renderType &= ~SpriteConst.GRAPHICS;
            }
            this.repaint();
        }
        get filters() {
            return this._filterArr;
        }
        set filters(value) {
            value && value.length === 0 && (value = null);
            if (this._filterArr) {
                for (let f of this._filterArr) {
                    f && f.off(Event.CHANGED, this, this.repaint);
                }
            }
            this._filterArr = value ? value.slice() : null;
            if (value) {
                for (let f of value) {
                    f && f.on(Event.CHANGED, this, this.repaint);
                }
            }
            if (value)
                this._renderType |= SpriteConst.FILTERS;
            else
                this._renderType &= ~SpriteConst.FILTERS;
            if (value && value.length > 0) {
                if (!this._getBit(NodeFlags.DISPLAY))
                    this._setBitUp(NodeFlags.DISPLAY);
            }
            this.repaint();
        }
        get cacheAs() {
            return this._getCacheStyle().userSetCache;
        }
        set cacheAs(value) {
            if (value === this._cacheStyle.userSetCache)
                return;
            this._getCacheStyle().userSetCache = value;
            if (this.mask && value === 'normal')
                return;
            if (value == 'bitmap' || value == 'normal') {
                this._renderType |= SpriteConst.CANVAS;
            }
            else {
                this._renderType &= ~SpriteConst.CANVAS;
            }
            this.repaint();
        }
        get staticCache() {
            return this._getCacheStyle().staticCache;
        }
        set staticCache(value) {
            this._getCacheStyle().staticCache = value;
            if (!value)
                this.reCache();
        }
        get mask() {
            return this._cacheStyle.mask;
        }
        set mask(value) {
            if (value == this || (value && this.mask == value && value._cacheStyle.maskParent == this))
                return;
            if (this.mask)
                this.mask._getCacheStyle().maskParent = null;
            this._getCacheStyle().mask = value;
            if (value) {
                value._getCacheStyle().maskParent = this;
                this._renderType |= SpriteConst.MASK;
            }
            else
                this._renderType &= ~SpriteConst.MASK;
            this.repaint();
        }
        get scrollRect() {
            return this._scrollRect;
        }
        set scrollRect(value) {
            if (this._scrollRect == null && value == null)
                return;
            this._scrollRect = value;
            if (value) {
                this._renderType |= SpriteConst.CLIP;
            }
            else {
                this._renderType &= ~SpriteConst.CLIP;
            }
            this.repaint();
        }
        get viewport() {
            return this._viewport;
        }
        set viewport(value) {
            if (typeof (value) == 'string') {
                let recArr = value.split(",");
                if (recArr.length > 3) {
                    value = new Rectangle(parseFloat(recArr[0]), parseFloat(recArr[1]), parseFloat(recArr[2]), parseFloat(recArr[3]));
                }
            }
            this._viewport = value;
        }
        set drawCallOptimize(value) {
            this._setBit(NodeFlags.DRAWCALL_OPTIMIZE, value);
        }
        get drawCallOptimize() {
            return this._getBit(NodeFlags.DRAWCALL_OPTIMIZE);
        }
        get hitArea() {
            return this._hitArea;
        }
        set hitArea(value) {
            this._hitArea = value;
        }
        get mouseEnabled() {
            return this._mouseState === 2;
        }
        set mouseEnabled(value) {
            let i = value ? 2 : 1;
            if (this._mouseState !== i) {
                this._mouseState = i;
                if (i === 2)
                    this.setMouseEnabledUp();
            }
        }
        setMouseEnabledUp() {
            let p = this._parent;
            while (p && p !== ILaya.stage) {
                if (p._mouseState !== 0 || !p._setBit(NodeFlags.CHECK_INPUT, true))
                    break;
                p = p._parent;
            }
        }
        getMousePoint() {
            return this.globalToLocal(tmpPoint.setTo(ILaya.stage.mouseX, ILaya.stage.mouseY));
        }
        get mouseX() {
            return this.getMousePoint().x;
        }
        get mouseY() {
            return this.getMousePoint().y;
        }
        get globalScaleX() {
            return this.globalTrans.scaleX;
        }
        get globalScaleY() {
            return this.globalTrans.scaleY;
        }
        get zOrder() {
            return this._zOrder;
        }
        set zOrder(value) {
            if (this._zOrder != value) {
                this._zOrder = value;
                if (this._parent) {
                    value && this._parent._setBit(NodeFlags.HAS_ZORDER, true);
                    ILaya.systemTimer.callLater(this._parent, this.updateZOrder);
                }
            }
        }
        updateZOrder() {
            SpriteUtils.updateOrder(this._children) && this.repaint();
        }
        get texture() {
            return this._texture;
        }
        set texture(value) {
            if (this._texture == value)
                return;
            this._texture && this._texture._removeReference();
            this._texture = value;
            if (value) {
                value._addReference();
                this._renderType |= SpriteConst.TEXTURE;
            }
            else
                this._renderType &= ~SpriteConst.TEXTURE;
            this.repaint();
        }
        get material() {
            var _a;
            return (_a = this._graphics) === null || _a === void 0 ? void 0 : _a.material;
        }
        set material(value) {
            if (this._graphics == null && value == null)
                return;
            this.graphics.material = value;
        }
        get renderNode2D() {
            return this._renderNode;
        }
        set renderNode2D(value) {
            this._renderNode = value;
            if (value) {
                this._renderType |= SpriteConst.RENDERNODE2D;
            }
            else {
                this._renderType &= ~SpriteConst.RENDERNODE2D;
            }
        }
        set customRenderEnable(b) {
            if (b) {
                this._renderType |= SpriteConst.CUSTOM;
            }
        }
        get autoSize() {
            return this._autosize;
        }
        set autoSize(value) {
            this._autosize = value;
        }
        pos(x, y) {
            if (this._x != x || this._y != y) {
                this._x = x;
                this._y = y;
                this._transChanged(exports.TransformKind.Pos);
            }
            return this;
        }
        pivot(x, y) {
            if (this._pivotX != x || this._pivotY != y) {
                this._pivotX = x;
                this._pivotY = y;
                let t = this.width;
                if (t != 0)
                    this._anchorX = x / t;
                t = this.height;
                if (t != 0)
                    this._anchorY = y / t;
                this._transChanged(exports.TransformKind.Anchor);
            }
            return this;
        }
        anchor(x, y) {
            if (this._anchorX != x || this._anchorY != y) {
                this._anchorX = x;
                this._anchorY = y;
                this._pivotX = x * this.width;
                this._pivotY = y * this.height;
                this._transChanged(exports.TransformKind.Anchor);
            }
            return this;
        }
        size(width, height) {
            let bw, bh;
            if (width == null) {
                bw = (this._sizeFlag & 1) != 0;
                this._sizeFlag &= ~1;
            }
            else {
                bw = this._width != width || (this._sizeFlag & 1) == 0;
                this._width = width;
                this._pivotX = this._anchorX * width;
                this._sizeFlag |= 1;
            }
            if (height == null) {
                bh = (this._sizeFlag & 2) != 0;
                this._sizeFlag &= ~2;
            }
            else {
                bh = this._height != height || (this._sizeFlag & 2) == 0;
                this._height = height;
                this._pivotY = this._anchorY * height;
                this._sizeFlag |= 2;
            }
            if (bw || bh)
                this._transChanged((bw ? exports.TransformKind.Width : 0) | (bh ? exports.TransformKind.Height : 0));
            return this;
        }
        scale(x, y) {
            if (this._scaleX !== x || this._scaleY !== y) {
                this._scaleX = x;
                this._scaleY = y;
                this._transChanged(exports.TransformKind.Scale);
            }
            return this;
        }
        skew(x, y) {
            if (this._skewX !== x || this._skewY !== y) {
                this._skewX = x;
                this._skewY = y;
                this._transChanged(exports.TransformKind.Skew);
            }
            return this;
        }
        _transChanged(kind) {
            var _a;
            if (this._destroyed)
                return;
            this.parentRepaint(SpriteConst.REPAINT_CACHE);
            if (kind != exports.TransformKind.Pos && kind != exports.TransformKind.Anchor) {
                this._tfChanged = true;
                this._renderType |= SpriteConst.TRANSFORM;
                if ((kind & exports.TransformKind.Size) != 0)
                    (_a = this._graphics) === null || _a === void 0 ? void 0 : _a._clearBoundsCache(true);
            }
            else {
                let p = this._cacheStyle.maskParent;
                if (p)
                    p.repaint(SpriteConst.REPAINT_CACHE);
            }
            if ((kind & exports.TransformKind.TRS) != 0) {
                if (this._globalTrans)
                    this._globalTrans._spTransChanged(kind);
                if (this._getBit(NodeFlags.DEMAND_TRANS_EVENT))
                    notifyTransChanged(this);
            }
        }
        render(ctx, x, y) {
            RenderSprite.renders[this._renderType]._fun(this, ctx, x + this._x, y + this._y);
            this._repaint = 0;
        }
        customRender(context, x, y) {
            this._repaint = SpriteConst.REPAINT_ALL;
        }
        drawToCanvas(canvasWidth, canvasHeight, offsetX, offsetY) {
            return Sprite.drawToCanvas(this, canvasWidth, canvasHeight, offsetX, offsetY);
        }
        static drawToCanvas(sprite, canvasWidth, canvasHeight, offsetX, offsetY, isDrawRenderRect = true) {
            let rt = Sprite.drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, null);
            var dt = rt.getData(0, 0, canvasWidth, canvasHeight);
            var imgdata = new ImageData(canvasWidth, canvasHeight);
            var lineLen = canvasWidth * 4;
            var dst = imgdata.data;
            var y = canvasHeight - 1;
            var off = y * lineLen;
            var srcoff = 0;
            for (; y >= 0; y--) {
                dst.set(dt.subarray(srcoff, srcoff + lineLen), off);
                off -= lineLen;
                srcoff += lineLen;
            }
            let canv = new HTMLCanvas(true);
            canv.size(canvasWidth, canvasHeight);
            let ctx2d = canv.context;
            ctx2d.putImageData(imgdata, 0, 0);
            rt.destroy();
            return canv;
        }
        drawToTexture(canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true) {
            let res = Sprite.drawToTexture(this, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect);
            return res;
        }
        static drawToTexture(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true) {
            let renderout = rt || new RenderTexture2D(canvasWidth, canvasHeight, exports.RenderTargetFormat.R8G8B8A8);
            let ctx = new Context();
            if (rt) {
                ctx.size(rt.width, rt.height);
            }
            else {
                ctx.size(canvasWidth, canvasHeight);
            }
            ctx.render2D = ctx.render2D.clone(null);
            let outrt = RenderSprite.RenderToRenderTexture(sprite, ctx, offsetX, offsetY, renderout, isDrawRenderRect);
            ctx._drawingToTexture = false;
            ctx.destroy();
            if (!rt) {
                let outTexture = new Texture(outrt, Texture.INV_UV);
                return outTexture;
            }
            return outrt;
        }
        drawToRenderTexture2D(canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true, flipY = false) {
            let res = Sprite.drawToRenderTexture2D(this, canvasWidth, canvasHeight, offsetX, offsetY, rt, isDrawRenderRect, flipY);
            return res;
        }
        static drawToRenderTexture2D(sprite, canvasWidth, canvasHeight, offsetX, offsetY, rt = null, isDrawRenderRect = true, flipY = false) {
            let renderout = rt || new RenderTexture2D(canvasWidth, canvasHeight, exports.RenderTargetFormat.R8G8B8A8);
            let ctx = new Context();
            if (rt) {
                ctx.size(rt.width, rt.height);
            }
            else {
                ctx.size(canvasWidth, canvasHeight);
            }
            ctx.render2D = ctx.render2D.clone(renderout);
            ctx._drawingToTexture = true;
            if (flipY) {
                renderout._invertY = true;
            }
            let outrt = RenderSprite.RenderToRenderTexture(sprite, ctx, offsetX, offsetY, renderout, isDrawRenderRect);
            ctx._drawingToTexture = false;
            ctx.destroy();
            return outrt;
        }
        hitTestPoint(x, y) {
            let point = this.globalToLocal(tmpPoint.setTo(x, y));
            x = point.x;
            y = point.y;
            var rect = this._hitArea ? this._hitArea :
                (this._isWidthSet && this._isHeightSet) ? tmpRect.setTo(0, 0, this._width, this._height) : this.getSelfBounds(tmpRect);
            return rect.contains(x, y, this);
        }
        setSelfBounds(bound) {
            this._userBounds = bound;
        }
        getBounds(out) {
            return Rectangle._getWrapRec(this._boundPointsToParent(), out);
        }
        getSelfBounds(out) {
            out = out || new Rectangle();
            if (this._userBounds)
                return out.copyFrom(this._userBounds);
            if (!this._graphics && this._children.length === 0 && !this._texture)
                return out.setTo(0, 0, this._width, this._height);
            else {
                tmpPoints.length = 0;
                return Rectangle._getWrapRec(this._getBoundPointsM(false, tmpPoints), out);
            }
        }
        getChildrenBounds(recursive, ignoreInvisibles, ignoreScale, out) {
            out = out || new Rectangle();
            out.setTo(0, 0, 0, 0);
            let children = recursive ? this._children : this._$children;
            for (let child of children) {
                if (ignoreInvisibles && !child._getBit(NodeFlags.ACTUAL_VISIBLE))
                    continue;
                let w = child.width;
                let h = child.height;
                if (!ignoreScale) {
                    w *= Math.abs(child._scaleX);
                    h *= Math.abs(child._scaleY);
                }
                out.union(tmpRect2.setTo(child._x - w * child._anchorX, child._y - h * child._anchorY, w, h), out);
                if (recursive && child._children.length > 0) {
                    let rect = child.getChildrenBounds(recursive, ignoreInvisibles, ignoreScale);
                    rect.x += child._x;
                    rect.y += child._y;
                    out.union(rect, out);
                }
            }
            return out;
        }
        _boundPointsToParent(ifRotate) {
            let px = this._pivotX, py = this._pivotY;
            ifRotate = ifRotate || (this._rotation !== 0);
            if (this._scrollRect != null) {
                px += this._scrollRect.x;
                py += this._scrollRect.y;
            }
            let pts = this._tmpBounds || (this._tmpBounds = []);
            pts.length = 0;
            this._getBoundPointsM(ifRotate, pts);
            if (pts.length == 0)
                return pts;
            if (pts.length != 8) {
                if (ifRotate)
                    GrahamScan.scanPList(pts);
                else {
                    Rectangle._getWrapRec(pts, tmpRect2);
                    pts.length = 0;
                    tmpRect2.getBoundPoints(pts);
                }
            }
            if (!this.transform) {
                let len = pts.length;
                for (let i = 0; i < len; i += 2) {
                    tmpPoint.x = pts[i];
                    tmpPoint.y = pts[i + 1];
                    this.toParentPoint(tmpPoint);
                    pts[i] = tmpPoint.x;
                    pts[i + 1] = tmpPoint.y;
                }
            }
            else {
                let dx = this._x - px;
                let dy = this._y - py;
                let len = pts.length;
                for (let i = 0; i < len; i += 2) {
                    pts[i] += dx;
                    pts[i + 1] += dy;
                }
            }
            return pts;
        }
        _getBoundPointsM(ifRotate, out) {
            var _a, _b;
            out = out || [];
            if (this._userBounds != null)
                return this._userBounds.getBoundPoints(out);
            if (this._scrollRect != null && !this._getBit(NodeFlags.DISABLE_INNER_CLIPPING))
                return this._scrollRect.getBoundPoints(out);
            if (this._graphics != null)
                out.push(...this._graphics.getBoundPoints());
            if (this._renderNode != null || this._texture != null)
                tmpRect2.setTo(0, 0, this._width || ((_a = this._texture) === null || _a === void 0 ? void 0 : _a.width), this._height || ((_b = this._texture) === null || _b === void 0 ? void 0 : _b.height)).getBoundPoints(out);
            let chidren = this._children;
            for (let i = 0, n = chidren.length; i < n; i++) {
                let child = chidren[i];
                if (child._getBit(NodeFlags.ACTUAL_VISIBLE) && child._cacheStyle.maskParent != this) {
                    out.push(...child._boundPointsToParent(ifRotate));
                }
            }
            return out;
        }
        getGraphicBounds(realSize, out) {
            out = out || new Rectangle();
            if (this._graphics)
                return out.copyFrom(this._graphics.getBounds(realSize));
            else
                return out.setTo(0, 0, 0, 0);
        }
        localToGlobal(point, createNewPoint, globalNode) {
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            var ele = this;
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                point = ele.toParentPoint(point);
                ele = ele._parent;
            }
            return point;
        }
        globalToLocal(point, createNewPoint, globalNode) {
            if (createNewPoint) {
                point = new Point(point.x, point.y);
            }
            var ele = this;
            var list = [];
            globalNode = globalNode || ILaya.stage;
            while (ele && !ele._destroyed) {
                if (ele == globalNode)
                    break;
                list.push(ele);
                ele = ele._parent;
            }
            var i = list.length - 1;
            while (i >= 0) {
                ele = list[i];
                point = ele.fromParentPoint(point);
                i--;
            }
            return point;
        }
        toParentPoint(point) {
            if (!point)
                return point;
            point.x -= this.pivotX;
            point.y -= this.pivotY;
            if (this.transform)
                this._transform.transformPoint(point);
            point.x += this._x;
            point.y += this._y;
            var scroll = this._scrollRect;
            if (scroll) {
                point.x -= scroll.x * this._scaleX;
                point.y -= scroll.y * this._scaleY;
            }
            return point;
        }
        fromParentPoint(point) {
            if (!point)
                return point;
            point.x -= this._x;
            point.y -= this._y;
            var scroll = this._scrollRect;
            if (scroll) {
                point.x += scroll.x * this._scaleX;
                point.y += scroll.y * this._scaleY;
            }
            if (this.transform)
                this._transform.invertTransformPoint(point);
            point.x += this.pivotX;
            point.y += this.pivotY;
            return point;
        }
        loadImage(url, complete) {
            if (!url) {
                this.texture = null;
                this.repaint(SpriteConst.REPAINT_ALL);
                complete && complete.run();
            }
            else {
                let tex = ILaya.loader.getRes(url);
                if (tex) {
                    this.texture = tex;
                    this.repaint(SpriteConst.REPAINT_ALL);
                    complete && complete.run();
                }
                else {
                    if (this._skinBaseUrl)
                        url = URL.formatURL(url, this._skinBaseUrl);
                    ILaya.loader.load(url).then((tex) => {
                        this.texture = tex;
                        this.repaint(SpriteConst.REPAINT_ALL);
                        complete && complete.run();
                    });
                }
            }
            return this;
        }
        static fromImage(url) {
            return new Sprite().loadImage(url);
        }
        _getCacheStyle() {
            this._cacheStyle === CacheStyle.EMPTY && (this._cacheStyle = CacheStyle.create());
            return this._cacheStyle;
        }
        reCache() {
            this._repaint |= SpriteConst.REPAINT_CACHE;
        }
        getRepaint() {
            return this._repaint;
        }
        repaint(type = SpriteConst.REPAINT_CACHE) {
            if (!(this._repaint & type)) {
                this._repaint |= type;
                this.parentRepaint(type);
            }
            if (this._cacheStyle) {
                this._cacheStyle.renderTexture = null;
                if (this._cacheStyle.maskParent)
                    this._cacheStyle.maskParent.repaint(type);
            }
        }
        _needRepaint() {
            return !!(this._repaint & SpriteConst.REPAINT_CACHE);
        }
        parentRepaint(type = SpriteConst.REPAINT_CACHE) {
            var p = this._parent;
            if (p && !(p._repaint & type)) {
                p._repaint |= type;
                p.parentRepaint(type);
            }
        }
        get dragSupport() {
            return this._dragSupport || (this._dragSupport = new DragSupport(this));
        }
        startDrag(area, hasInertia, elasticDistance, elasticBackTime, data, ratio) {
            let d = this.dragSupport;
            area != null && d.area.copyFrom(area);
            hasInertia != null && (d.hasInertia = hasInertia);
            elasticDistance != null && (d.elasticDistance = elasticDistance);
            elasticBackTime != null && (d.elasticBackTime = elasticBackTime);
            ratio != null && (d.ratio = ratio);
            d.start(data);
        }
        stopDrag() {
            this._dragSupport && this._dragSupport.stop();
        }
        onAfterDeserialize() {
            super.onAfterDeserialize();
            if (LayaEnv.isPlaying) {
                if (this._gcmds) {
                    this.graphics.cmds = this._gcmds;
                    delete this._gcmds;
                }
                if (this._filters) {
                    this.filters = this._filters;
                    delete this._filters;
                }
            }
            if (this._mouseState === 2)
                this.setMouseEnabledUp();
        }
        onStartListeningToType(type) {
            super.onStartListeningToType(type);
            if (Event.isMouseEvent(type)) {
                if (this._mouseState === 0) {
                    this._setBit(NodeFlags.CHECK_INPUT, true);
                    this.setMouseEnabledUp();
                }
            }
            else if (type === Event.TRANSFORM_CHANGED) {
                this._setBit(NodeFlags.DEMAND_TRANS_EVENT, true);
                this.setDemandTransEventUp();
            }
        }
        setDemandTransEventUp() {
            let p = this._parent;
            while (p && p !== ILaya.stage) {
                if (!p._setBit(NodeFlags.DEMAND_TRANS_EVENT, true))
                    break;
                p = p._parent;
            }
        }
        _setDisplay(value) {
            if (!value && this._cacheStyle)
                this._cacheStyle.onInvisible();
            super._setDisplay(value);
        }
        _processVisible() {
            if (this._setBit(NodeFlags.ACTUAL_VISIBLE, this._visible && !this._getBit(hiddenBits) || this._getBit(NodeFlags.FORCE_VISIBLE))) {
                this.parentRepaint(SpriteConst.REPAINT_ALL);
                return true;
            }
            else
                return false;
        }
        _setParent(value) {
            super._setParent(value);
            if (value && (this._mouseState === 2 || this._mouseState === 0 && this._getBit(NodeFlags.CHECK_INPUT))
                && !value._getBit(NodeFlags.CHECK_INPUT)) {
                this.setMouseEnabledUp();
            }
            if (value && this._getBit(NodeFlags.DEMAND_TRANS_EVENT) && !value._getBit(NodeFlags.DEMAND_TRANS_EVENT))
                this.setDemandTransEventUp();
        }
        _childChanged(child) {
            super._childChanged(child);
            if (this._children.length)
                this._renderType |= SpriteConst.CHILDS;
            else
                this._renderType &= ~SpriteConst.CHILDS;
            if (child) {
                if (child._zOrder)
                    this._setBit(NodeFlags.HAS_ZORDER, true);
            }
            if (this._getBit(NodeFlags.HAS_ZORDER))
                ILaya.systemTimer.callLater(this, this.updateZOrder);
            this.repaint(SpriteConst.REPAINT_ALL);
        }
        _addComponentInstance(comp) {
            var _a;
            if (comp instanceof BaseRenderNode2D &&
                ((_a = this._components) === null || _a === void 0 ? void 0 : _a.some((c) => c instanceof BaseRenderNode2D))) {
                console.warn(`${this.name} add RenderNode2D invalid, one sprite can only add one RenderNode`);
                return;
            }
            super._addComponentInstance(comp);
        }
    }
    const tmpRect = new Rectangle();
    const tmpRect2 = new Rectangle();
    const tmpPoint = new Point();
    const tmpPoints = [];
    function notifyTransChanged(sp) {
        sp.event(Event.TRANSFORM_CHANGED);
        for (let child of sp._children) {
            if (child._getBit(NodeFlags.DEMAND_TRANS_EVENT))
                notifyTransChanged(child);
        }
    }

    var _isFirstTouch = true;
    const _tempPoint = new Point();
    const _tempRect = new Rectangle();
    const _rollOverChain = [];
    const _rollOutChain = [];
    var _inst;
    class InputManager {
        constructor() {
            this._touches = [];
            this._touchPool = [];
            this._mouseTouch = new TouchInfo(this._touches);
            this._pressKeys = new Set();
            this._keyEvent = new Event();
            this._keyEvent._touches = this._touches;
        }
        static get inst() {
            return _inst;
        }
        static getTouchPos(touchId) {
            var _a;
            if (touchId == null)
                touchId = InputManager.lastTouchId;
            return ((_a = _inst.getTouch(touchId)) === null || _a === void 0 ? void 0 : _a.pos) || _inst._mouseTouch.pos;
        }
        static get touchTarget() {
            return _inst._touchTarget;
        }
        static get touches() {
            return _inst._touches;
        }
        static get touchCount() {
            return _inst._touches.length;
        }
        static cancelClick(touchId) {
            if (touchId == null)
                touchId = InputManager.lastTouchId;
            let touch = _inst.getTouch(touchId);
            if (touch)
                touch.clickCancelled = true;
        }
        static hasKeyDown(key) {
            return _inst._pressKeys.has(key);
        }
        static __init__() {
            let inst = _inst = new InputManager();
            inst._stage = ILaya.stage;
            let canvas = Browser.mainCanvas.source;
            let passiveOption = { passive: false };
            canvas.oncontextmenu = () => {
                return false;
            };
            canvas.addEventListener("mousedown", ev => {
                if (!Browser.onIE)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 0);
            }, passiveOption);
            canvas.addEventListener("mouseup", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 1);
            }, passiveOption);
            canvas.addEventListener("mousemove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleMouse(ev, 2);
            }, passiveOption);
            canvas.addEventListener("mouseout", ev => {
                inst.handleMouse(ev, 3);
            }, passiveOption);
            canvas.addEventListener("touchstart", ev => {
                if (!_isFirstTouch && !PAL.textInput.target)
                    (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 0);
            }, passiveOption);
            canvas.addEventListener("touchend", ev => {
                if (!_isFirstTouch && !PAL.textInput.target)
                    (ev.cancelable) && (ev.preventDefault());
                _isFirstTouch = false;
                inst.handleTouch(ev, 1);
            }, passiveOption);
            canvas.addEventListener("touchmove", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 2);
            }, passiveOption);
            canvas.addEventListener("touchcancel", ev => {
                (ev.cancelable) && (ev.preventDefault());
                inst.handleTouch(ev, 3);
            }, passiveOption);
            canvas.addEventListener("wheel", ev => {
                inst.handleMouse(ev, 4);
            }, passiveOption);
            if (typeof (canvas.setPointerCapture) === 'function') {
                canvas.addEventListener("pointerdown", ev => {
                    canvas.setPointerCapture(ev.pointerId);
                });
                canvas.addEventListener("pointerup", ev => {
                    canvas.releasePointerCapture(ev.pointerId);
                }, true);
            }
            let doc = Browser.document;
            doc.addEventListener("keydown", ev => {
                inst.handleKeys(ev);
            }, true);
            doc.addEventListener("keypress", ev => {
                inst.handleKeys(ev);
            }, true);
            doc.addEventListener("keyup", ev => {
                inst.handleKeys(ev);
            }, true);
        }
        handleMouse(ev, type) {
            this._eventType = type;
            this._nativeEvent = ev;
            InputManager.lastTouchId = 0;
            let now = Browser.now();
            if (this._lastTouchTime != null && now - this._lastTouchTime < 100)
                return;
            let touch = this._mouseTouch;
            _tempPoint.setTo(ev.pageX || ev.clientX, ev.pageY || ev.clientY);
            this._stage._canvasTransform.invertTransformPoint(_tempPoint);
            InputManager.mouseX = _tempPoint.x;
            InputManager.mouseY = _tempPoint.y;
            let x = _tempPoint.x / this._stage.clientScaleX;
            let y = _tempPoint.y / this._stage.clientScaleY;
            touch.event.nativeEvent = ev;
            if (type == 3 || !InputManager.mouseEventsEnabled)
                touch.target = this._touchTarget = null;
            else {
                touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                let ix = Math.round(x);
                let iy = Math.round(y);
                if (ix != touch.pos.x || iy != touch.pos.y) {
                    InputManager.lastMouseTime = now;
                    touch.pos.setTo(ix, iy);
                    touch.move();
                    if (InputManager.mouseEventsEnabled) {
                        touch.bubble(Event.MOUSE_MOVE);
                        for (let t of touch.downTargets) {
                            touch.event._stopped = false;
                            t.event(Event.MOUSE_DRAG, touch.event);
                            if (touch.event._stopped)
                                break;
                        }
                    }
                }
            }
            if (touch.lastRollOver != touch.target)
                this.handleRollOver(touch);
            if (type == 0) {
                if (!touch.began) {
                    touch.begin();
                    this._touches[0] = touch;
                    touch.event.button = ev.button;
                    touch.downButton = ev.button;
                    InputManager.onMouseDownCapture.invoke(touch.touchId);
                    if (InputManager.mouseEventsEnabled) {
                        if (ev.button == 0)
                            touch.bubble(Event.MOUSE_DOWN);
                        else
                            touch.bubble(Event.RIGHT_MOUSE_DOWN);
                    }
                }
            }
            else if (type == 1) {
                if (touch.began && ev.button == touch.downButton) {
                    touch.end();
                    this._touches.length = 0;
                    touch.event.button = ev.button;
                    if (InputManager.mouseEventsEnabled) {
                        if (ev.button == 0)
                            touch.bubble(Event.MOUSE_UP);
                        else
                            touch.bubble(Event.RIGHT_MOUSE_UP);
                        if (touch.moved) {
                            for (let t of touch.downTargets)
                                t.event(Event.MOUSE_DRAG_END, touch.event);
                        }
                        let clickTarget = touch.clickTest();
                        if (clickTarget) {
                            if (ev.button == 0) {
                                touch.event.isDblClick = touch.clickCount == 2;
                                touch.bubble(Event.CLICK, clickTarget);
                                if (touch.clickCount == 2)
                                    touch.bubble(Event.DOUBLE_CLICK, clickTarget);
                                touch.event.isDblClick = false;
                            }
                            else {
                                touch.event.isDblClick = touch.clickCount == 2;
                                touch.bubble(Event.RIGHT_CLICK, clickTarget);
                                touch.event.isDblClick = false;
                            }
                        }
                    }
                    touch.event.button = 0;
                }
            }
            else if (type == 4) {
                if (InputManager.mouseEventsEnabled) {
                    touch.event.delta = ev.deltaY * 0.025;
                    touch.bubble(Event.MOUSE_WHEEL);
                    touch.event.delta = 0;
                }
            }
        }
        handleTouch(ev, type) {
            this._eventType = type;
            this._nativeEvent = ev;
            this._lastTouchTime = Browser.now();
            let touches = ev.changedTouches;
            for (let i = 0; i < touches.length; ++i) {
                let uTouch = touches[i];
                if (!InputManager.multiTouchEnabled
                    && this._touches.length > 0
                    && this._touches[0].touchId != uTouch.identifier)
                    continue;
                _tempPoint.setTo(uTouch.pageX, uTouch.pageY);
                this._stage._canvasTransform.invertTransformPoint(_tempPoint);
                InputManager.mouseX = _tempPoint.x;
                InputManager.mouseY = _tempPoint.y;
                let x = _tempPoint.x / this._stage.clientScaleX;
                let y = _tempPoint.y / this._stage.clientScaleY;
                let touch = this.getTouch(uTouch.identifier, type == 0);
                if (!touch)
                    continue;
                touch.event.nativeEvent = ev;
                touch.event.touchId = touch.touchId;
                InputManager.lastTouchId = touch.touchId;
                if (type == 3 || !InputManager.mouseEventsEnabled)
                    touch.target = this._touchTarget = null;
                else {
                    touch.target = this._touchTarget = this.getNodeUnderPoint(x, y);
                    InputManager.lastMouseTime = this._lastTouchTime;
                    let ix = Math.round(x);
                    let iy = Math.round(y);
                    if (Math.abs(ix - touch.pos.x) > 1.5 || Math.abs(iy - touch.pos.y) > 1.5) {
                        touch.pos.setTo(ix, iy);
                        if (type == 2) {
                            touch.move();
                            if (InputManager.mouseEventsEnabled) {
                                touch.bubble(Event.MOUSE_MOVE);
                                for (let t of touch.downTargets) {
                                    touch.event._stopped = false;
                                    t.event(Event.MOUSE_DRAG, touch.event);
                                    if (touch.event._stopped)
                                        break;
                                }
                            }
                        }
                    }
                }
                if (touch.lastRollOver != touch.target)
                    this.handleRollOver(touch);
                if (type == 0) {
                    if (!touch.began) {
                        touch.begin();
                        InputManager.onMouseDownCapture.invoke(touch.touchId);
                        if (InputManager.mouseEventsEnabled) {
                            touch.bubble(Event.MOUSE_DOWN);
                        }
                    }
                }
                else if (type == 1 || type == 3) {
                    if (touch.began) {
                        touch.end();
                        if (InputManager.mouseEventsEnabled) {
                            touch.bubble(Event.MOUSE_UP);
                            if (touch.moved) {
                                for (let t of touch.downTargets)
                                    t.event(Event.MOUSE_DRAG_END, touch.event);
                            }
                            if (type != 3) {
                                let clickTarget = touch.clickTest();
                                if (clickTarget != null) {
                                    touch.event.isDblClick = touch.clickCount == 2;
                                    touch.bubble(Event.CLICK, clickTarget);
                                    if (touch.clickCount == 2)
                                        touch.bubble(Event.DOUBLE_CLICK, clickTarget);
                                    touch.event.isDblClick = false;
                                }
                            }
                        }
                        touch.target = null;
                        this.handleRollOver(touch);
                    }
                    touch.reset();
                    this._touches.splice(this._touches.indexOf(touch), 1);
                    this._touchPool.push(touch);
                }
            }
        }
        getTouch(touchId, shouldCreate) {
            let touch = this._touches.find(e => e.touchId == touchId);
            if (touch || !shouldCreate)
                return touch;
            touch = this._touchPool.length > 0 ? this._touchPool.pop() : new TouchInfo(this._touches);
            touch.touchId = touchId;
            this._touches.push(touch);
            return touch;
        }
        handleKeys(ev) {
            let type = ev.type;
            let keyCode = ev.keyCode;
            if (type === "keydown") {
                if (keyCode != 0)
                    this._pressKeys.add(keyCode);
                this._pressKeys.add(ev.key);
            }
            else if (type === "keyup") {
                if (keyCode != 0)
                    this._pressKeys.delete(keyCode);
                this._pressKeys.delete(ev.key);
            }
            this._keyEvent.nativeEvent = ev;
            this._keyEvent._defaultPrevented = false;
            if (InputManager.keyEventsEnabled) {
                let target = (this._stage.focus && this._stage.focus.displayedInStage) ? this._stage.focus : this._stage;
                let ct = target;
                while (ct) {
                    ct.event(type, this._keyEvent.setTo(type, ct, target));
                    ct = ct._parent;
                }
            }
            if (this._keyEvent._defaultPrevented)
                ev.preventDefault();
            this._keyEvent.nativeEvent = null;
        }
        getNodeUnderPoint(x, y) {
            let target = this.getSpriteUnderPoint(this._stage, x, y);
            if (!target)
                target = this.getSprite3DUnderPoint(x, y);
            return target || this._stage;
        }
        getSpriteUnderPoint(sp, x, y) {
            if (sp._getBit(NodeFlags.AREA_2D)) {
                sp.transformPoint(x, y, Point.TEMP);
                x = Point.TEMP.x;
                y = Point.TEMP.y;
            }
            let scrollRect = sp._scrollRect;
            if (scrollRect && !sp._getBit(NodeFlags.DISABLE_INNER_CLIPPING)) {
                _tempRect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
                if (!_tempRect.contains(x, y))
                    return null;
            }
            let editing = sp._getBit(NodeFlags.EDITING_NODE);
            if (!editing && sp.hitTestPrior && !sp.mouseThrough && sp != this._stage && !this.hitTest(sp, x, y))
                return null;
            for (let i = sp._children.length - 1; i > -1; i--) {
                let child = sp._children[i];
                let childEditing = editing || child._getBit(NodeFlags.EDITING_NODE);
                if (!child._destroyed
                    && child._nodeType !== 1
                    && (childEditing ? ((!child.hasHideFlag(HideFlags.HideInHierarchy) || child.mouseThrough) && !child._getBit(NodeFlags.HIDE_BY_EDITOR))
                        : (child._mouseState === 2 || child._mouseState === 0 && child._getBit(NodeFlags.CHECK_INPUT)))
                    && child._getBit(NodeFlags.ACTUAL_VISIBLE)) {
                    _tempPoint.setTo(x, y);
                    child.fromParentPoint(_tempPoint);
                    let ret = this.getSpriteUnderPoint(child, _tempPoint.x, _tempPoint.y);
                    if (ret)
                        return ret;
                }
            }
            if (editing) {
                if (!sp._getBit(NodeFlags.LOCK_BY_EDITOR)
                    && !sp.hasHideFlag(HideFlags.HideInHierarchy)
                    && this.hitTest(sp, x, y, editing))
                    return sp;
            }
            else if (sp != this._stage) {
                if (sp.hitTestPrior && !sp.mouseThrough || this.hitTest(sp, x, y))
                    return sp;
            }
            return null;
        }
        getSprite3DUnderPoint(x, y) {
            return null;
        }
        hitTest(sp, x, y, editing) {
            let isHit = false;
            if (sp._scrollRect) {
                x -= sp._scrollRect.x;
                y -= sp._scrollRect.y;
            }
            let hitArea = sp._hitArea;
            let mouseThrough = sp.mouseThrough;
            if (editing) {
                hitArea = null;
                mouseThrough = false;
            }
            if (hitArea) {
                return hitArea.contains(x, y, sp);
            }
            if (sp.width > 0 && sp.height > 0 || mouseThrough || hitArea) {
                if (!mouseThrough)
                    isHit = (hitArea ? hitArea : _tempRect.setTo(0, 0, sp.width, sp.height)).contains(x, y, sp);
                else
                    isHit = sp.getGraphicBounds(false, Rectangle.TEMP).contains(x, y);
            }
            return isHit;
        }
        handleRollOver(touch) {
            if (!InputManager.mouseEventsEnabled) {
                touch.lastRollOver = touch.target;
                return;
            }
            _rollOverChain.length = 0;
            _rollOutChain.length = 0;
            let ele = touch.lastRollOver;
            while (ele) {
                _rollOutChain.push(ele);
                ele = ele._parent;
            }
            touch.lastRollOver = touch.target;
            ele = touch.target;
            while (ele) {
                let i = _rollOutChain.indexOf(ele);
                if (i != -1) {
                    _rollOutChain.splice(i, _rollOutChain.length - i);
                    break;
                }
                _rollOverChain.push(ele);
                ele = ele._parent;
            }
            let cnt = _rollOutChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOutChain[i];
                    if (!ele._destroyed)
                        ele.event(Event.MOUSE_OUT, touch.event.setTo(Event.MOUSE_OUT, ele, ele));
                }
                _rollOutChain.length = 0;
            }
            cnt = _rollOverChain.length;
            if (cnt > 0) {
                for (let i = 0; i < cnt; i++) {
                    ele = _rollOverChain[i];
                    if (ele.activeInHierarchy)
                        ele.event(Event.MOUSE_OVER, touch.event.setTo(Event.MOUSE_OVER, ele, ele));
                }
                _rollOverChain.length = 0;
            }
        }
    }
    InputManager.multiTouchEnabled = true;
    InputManager.mouseEventsEnabled = true;
    InputManager.keyEventsEnabled = true;
    InputManager.clickTestThreshold = 10;
    InputManager.mouseX = 0;
    InputManager.mouseY = 0;
    InputManager.lastMouseTime = 0;
    InputManager.lastTouchId = 0;
    InputManager.onMouseDownCapture = new Delegate();
    const clickTrack = {};
    class TouchInfo {
        constructor(touches) {
            this.downPos = new Point();
            this.downTargets = [];
            this.bubbleChain = [];
            this.event = new Event();
            this.event._touches = touches;
            this.pos = this.event.touchPos;
            this.touchId = 0;
            this.reset();
        }
        begin() {
            this.began = true;
            this.clickCancelled = false;
            this.moved = false;
            this.downPos.copy(this.pos);
            this.downTargets.length = 0;
            if (this.target) {
                let ele = this.target;
                while (ele) {
                    this.downTargets.push(ele);
                    ele = ele._parent;
                }
            }
        }
        move() {
            this.moved = true;
            let ox = Math.abs(this.pos.x - this.downPos.x) * ILaya.stage._canvasTransform.getScaleX();
            let oy = Math.abs(this.pos.y - this.downPos.y) * ILaya.stage._canvasTransform.getScaleY();
            if (ox > InputManager.clickTestThreshold || oy > InputManager.clickTestThreshold)
                this.clickCancelled = true;
        }
        end() {
            this.began = false;
            let now = performance.now();
            let lastClick = clickTrack[this.touchId];
            if (!lastClick) {
                lastClick = { pos: new Point(), time: 0, button: 0 };
                clickTrack[this.touchId] = lastClick;
            }
            if (this.downTargets.length == 0
                || this.clickCancelled
                || Math.abs(this.pos.x - this.downPos.x) > InputManager.clickTestThreshold
                || Math.abs(this.pos.y - this.downPos.y) > InputManager.clickTestThreshold) {
                this.clickCancelled = true;
                lastClick.time = 0;
                this.clickCount = 1;
            }
            else {
                if (now - lastClick.time < 350
                    && Math.abs(this.pos.x - lastClick.pos.x) < InputManager.clickTestThreshold
                    && Math.abs(this.pos.y - lastClick.pos.y) < InputManager.clickTestThreshold
                    && lastClick.button == this.event.button) {
                    this.clickCount = 2;
                }
                else
                    this.clickCount = 1;
                lastClick.time = now;
                lastClick.pos.copy(this.pos);
                lastClick.button = this.event.button;
            }
        }
        clickTest() {
            if (this.clickCancelled) {
                this.downTargets.length = 0;
                return null;
            }
            let obj = this.downTargets[0];
            if (obj.activeInHierarchy) {
                this.downTargets.length = 0;
                return obj;
            }
            obj = this.target;
            while (obj) {
                let i = this.downTargets.indexOf(obj);
                if (i != -1 && obj.activeInHierarchy)
                    break;
                obj = obj._parent;
            }
            this.downTargets.length = 0;
            return obj;
        }
        reset() {
            this.pos.setTo(0, 0);
            this.touchId = 0;
            this.clickCount = 0;
            this.began = false;
            this.moved = false;
            this.target = null;
            this.downTargets.length = 0;
            this.lastRollOver = null;
            this.clickCancelled = false;
            this.downButton = 0;
        }
        bubble(type, target) {
            let arr = this.bubbleChain;
            arr.length = 0;
            target = target || this.target || ILaya.stage;
            let obj = target;
            while (obj) {
                if (obj.activeInHierarchy)
                    arr.push(obj);
                obj = obj._parent;
            }
            let evt = this.event;
            evt._stopped = false;
            for (let obj of arr) {
                evt.setTo(type, obj, target);
                obj.event(type, evt);
                if (evt._stopped) {
                    if (type === Event.MOUSE_DOWN || type === Event.RIGHT_MOUSE_DOWN) {
                        let i = this.downTargets.indexOf(obj);
                        if (i != -1)
                            this.downTargets.splice(i + 1, this.downTargets.length - i - 1);
                    }
                    break;
                }
            }
            if (type === Event.MOUSE_UP || type === Event.RIGHT_MOUSE_UP) {
                for (let obj of this.downTargets) {
                    if (obj && arr.indexOf(obj) == -1) {
                        evt.setTo(type, obj, target);
                        obj.event(type, evt);
                        if (evt && evt._stopped)
                            break;
                    }
                }
            }
        }
    }

    class ComponentDriver {
        constructor() {
            this._onUpdates = new Set();
            this._onLateUpdates = new Set();
            this._onPreRenders = new Set();
            this._onPostRenders = new Set();
            this._toStarts = new Set();
            this._toDestroys = new Set();
        }
        callStart() {
            for (let ele of this._toStarts) {
                if (ele._status == 2) {
                    ele._status = 3;
                    try {
                        ele.onStart();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
            this._toStarts.clear();
        }
        callUpdate() {
            for (let ele of this._onUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onUpdate();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callLateUpdate() {
            for (let ele of this._onLateUpdates) {
                if (ele._status == 3) {
                    try {
                        ele.onLateUpdate();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callPreRender() {
            for (let ele of this._onPreRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPreRender();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callPostRender() {
            for (let ele of this._onPostRenders) {
                if (ele._status == 3) {
                    try {
                        ele.onPostRender();
                    }
                    catch (err) {
                        this.onError(err);
                    }
                }
            }
        }
        callDestroy() {
            for (let ele of this._toDestroys) {
                try {
                    ele._destroy(true);
                }
                catch (err) {
                    this.onError(err);
                }
            }
            this._toDestroys.clear();
        }
        add(comp) {
            if (comp._status == 1) {
                if (comp.onStart) {
                    comp._status = 2;
                    this._toStarts.add(comp);
                }
                else
                    comp._status = 3;
            }
            if (comp.onUpdate)
                this._onUpdates.add(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.add(comp);
            if (comp.onPreRender)
                this._onPreRenders.add(comp);
            if (comp.onPostRender)
                this._onPostRenders.add(comp);
        }
        remove(comp) {
            if (comp._status == 2)
                comp._status = 1;
            if (comp.onUpdate)
                this._onUpdates.delete(comp);
            if (comp.onLateUpdate)
                this._onLateUpdates.delete(comp);
            if (comp.onPreRender)
                this._onPreRenders.delete(comp);
            if (comp.onPostRender)
                this._onPostRenders.delete(comp);
        }
        destroy() {
        }
        onError(err) {
            console.error(err);
        }
    }

    class Timer {
        constructor(autoActive, greedyMode) {
            this.scale = 1;
            this.currFrame = 0;
            this.delta = 0;
            this.unscaledDelta = 0;
            this._map = {};
            this._handlers = [];
            (autoActive || autoActive == null) && Timer.gSysTimer && Timer.gSysTimer.frameLoop(1, this, this._update);
            this.currTimer = Date.now();
            this._lastTimer = Date.now();
            this._greedy = !!greedyMode;
        }
        get totalTime() {
            return this._lastTimer;
        }
        _update() {
            if (this.scale <= 0) {
                this._lastTimer = Date.now();
                this.delta = 0;
                return;
            }
            let frame = this.currFrame = this.currFrame + this.scale;
            let now = Date.now();
            this.unscaledDelta = now - this._lastTimer;
            let awake = this.unscaledDelta > 30000;
            this.delta = this.unscaledDelta * this.scale;
            let timer = this.currTimer = this.currTimer + this.delta;
            this._lastTimer = now;
            let handlers = this._handlers;
            let killed = 0;
            for (let i = 0, n = handlers.length - 1; i <= n; i++) {
                let handler = handlers[i];
                if (handler.method) {
                    let t = handler.userFrame ? frame : timer;
                    if (t >= handler.exeTime) {
                        if (handler.repeat) {
                            if (!handler.jumpFrame || awake) {
                                handler.exeTime += handler.delay;
                                handler.run(false);
                                if (t > handler.exeTime) {
                                    handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
                                }
                            }
                            else {
                                while (t >= handler.exeTime) {
                                    handler.exeTime += handler.delay;
                                    handler.run(false);
                                }
                            }
                        }
                        else {
                            handler.run(true);
                        }
                    }
                }
                else
                    killed++;
                i === n && this._greedy && (n = handlers.length - 1);
            }
            if (killed > 30 || frame % 200 === 0)
                this._clearHandlers();
        }
        _clearHandlers() {
            let handlers = this._handlers;
            let j = 0;
            for (let i = 0, n = handlers.length; i < n; i++) {
                let handler = handlers[i];
                if (handler.method !== null) {
                    if (j !== i)
                        handlers[j++] = handler;
                    else
                        j++;
                }
                else {
                    if (this._map[handler.key] == handler)
                        delete this._map[handler.key];
                    handler.clear();
                    Timer._pool.push(handler);
                }
            }
            handlers.length = j;
        }
        _create(useFrame, repeat, delay, caller, method, args, coverBefore) {
            let key = Utils.getGID(caller, method);
            if (coverBefore == null || coverBefore) {
                let handler = this._map[key];
                if (handler) {
                    handler.repeat = repeat;
                    handler.userFrame = useFrame;
                    handler.delay = delay;
                    handler.caller = caller;
                    handler.method = method;
                    handler.args = args;
                    handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
                    return handler;
                }
            }
            let handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
            handler.key = key;
            handler.repeat = repeat;
            handler.userFrame = useFrame;
            handler.delay = delay;
            handler.caller = caller;
            handler.method = method;
            handler.args = args;
            handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + Date.now() - this._lastTimer);
            this._map[key] = handler;
            this._handlers.push(handler);
            return handler;
        }
        once(delay, caller, method, args, coverBefore) {
            this._create(false, false, delay, caller, method, args, coverBefore);
        }
        loop(delay, caller, method, args, coverBefore, jumpFrame) {
            let handler = this._create(false, true, delay, caller, method, args, coverBefore);
            if (handler)
                handler.jumpFrame = jumpFrame;
        }
        frameOnce(delay, caller, method, args, coverBefore) {
            this._create(true, false, delay, caller, method, args, coverBefore);
        }
        frameLoop(delay, caller, method, args, coverBefore) {
            this._create(true, true, delay, caller, method, args, coverBefore);
        }
        toString() {
            return " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
        }
        clear(caller, method) {
            let handler = this._map[Utils.getGID(caller, method)];
            if (handler) {
                handler.clear();
            }
        }
        clearAll(caller) {
            if (!caller)
                return;
            for (let i = 0, n = this._handlers.length; i < n; i++) {
                let handler = this._handlers[i];
                if (handler.caller === caller) {
                    handler.clear();
                }
            }
        }
        callLater(caller, method, args) {
            Timer.callLaters._create(false, false, 0, caller, method, args, true).exeTime = 0;
        }
        runCallLater(caller, method, forceRun) {
            if (!Timer.callLaters.runTimer(caller, method) && forceRun)
                method.apply(caller);
        }
        clearCallLater(caller, method) {
            Timer.callLaters.clear(caller, method);
        }
        runTimer(caller, method) {
            let handler = this._map[Utils.getGID(caller, method)];
            if (handler && handler.method != null) {
                this._map[handler.key] = null;
                handler.run(true);
                return true;
            }
            else
                return false;
        }
        pause() {
            this.scale = 0;
        }
        resume() {
            this.scale = 1;
        }
        destroy() {
            for (let i = 0, n = this._handlers.length; i < n; i++) {
                let handler = this._handlers[i];
                handler.clear();
            }
            this._handlers.length = 0;
        }
    }
    Timer.gSysTimer = null;
    Timer.callLaters = new Timer(false, true);
    Timer._pool = [];
    class TimerHandler {
        clear() {
            this.caller = null;
            this.method = null;
            this.args = null;
        }
        run(withClear) {
            let caller = this.caller;
            if (caller && caller.destroyed)
                return this.clear();
            let method = this.method;
            let args = this.args;
            withClear && this.clear();
            if (method == null)
                return;
            args ? method.apply(caller, args) : method.call(caller);
        }
    }

    class Stage extends Sprite {
        constructor() {
            super();
            this.offset = new Point();
            this.designWidth = 0;
            this.designHeight = 0;
            this.canvasRotation = false;
            this.canvasDegree = 0;
            this.renderingEnabled = true;
            this.screenAdaptationEnabled = true;
            this._canvasTransform = new Matrix();
            this._scene3Ds = [];
            this._scene2Ds = [];
            this._frameRate = "fast";
            this._screenMode = "none";
            this._scaleMode = "noscale";
            this._alignV = "top";
            this._alignH = "left";
            this._bgColor = "gray";
            this._renderCount = 0;
            this._frameStartTime = 0;
            this._wgColor = new Color(0, 0, 0, 0);
            this._needUpdateCanvasSize = false;
            this.mouseEnabled = true;
            this.hitTestPrior = true;
            this._setBit(NodeFlags.DISPLAYED_INSTAGE, true);
            this._setBit(NodeFlags.ACTIVE_INHIERARCHY, true);
            this._isFocused = true;
            this._transform = new Matrix();
            this._componentDriver = new ComponentDriver();
            PAL.browser.on(Event.FOCUS, () => {
                if (!this._isFocused) {
                    this._isFocused = true;
                    this.event(Event.FOCUS);
                    this.event(Event.FOCUS_CHANGE);
                }
            });
            PAL.browser.on(Event.BLUR, () => {
                if (this._isFocused) {
                    this._isFocused = false;
                    this.event(Event.BLUR);
                    this.event(Event.FOCUS_CHANGE);
                }
            });
            PAL.browser.on(Event.VISIBILITY_CHANGE, (visible) => {
                this.renderingEnabled = visible;
                this.event(Event.VISIBILITY_CHANGE, visible);
            });
            PAL.browser.on(Event.RESIZE, () => {
                if (PAL.textInput.target)
                    return;
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize(true);
                }
            });
            PAL.browser.on(Event.ORIENTATION_CHANGE, (e) => {
                if (this.screenAdaptationEnabled) {
                    this.event(Event.WILL_RESIZE);
                    this.updateCanvasSize(true);
                }
            });
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Size) != 0) {
                this.designWidth = this._width;
                this.designHeight = this._height;
                this.updateCanvasSize(true);
            }
        }
        measureWidth() {
            this.needUpdateCanvasSize();
            return this._width;
        }
        measureHeight() {
            this.needUpdateCanvasSize();
            return this._height;
        }
        get isFocused() {
            return this._isFocused;
        }
        get isVisibility() {
            return PAL.browser.getVisibility();
        }
        updateCanvasSize(delay) {
            if (delay) {
                if (!this._needUpdateCanvasSize) {
                    this._needUpdateCanvasSize = true;
                    ILaya.systemTimer.callLater(this, this.updateCanvasSize);
                }
            }
            else {
                this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
            }
        }
        needUpdateCanvasSize() {
            if (this._needUpdateCanvasSize)
                this.updateCanvasSize();
        }
        setScreenSize(screenWidth, screenHeight) {
            var _a;
            this._needUpdateCanvasSize = false;
            let pixelRatio = Browser.pixelRatio;
            screenWidth /= pixelRatio;
            screenHeight /= pixelRatio;
            if (this._screenMode !== Stage.SCREEN_NONE) {
                let screenType = screenWidth / screenHeight < 1 ? Stage.SCREEN_VERTICAL : Stage.SCREEN_HORIZONTAL;
                this.canvasRotation = screenType !== this._screenMode;
                if (this.canvasRotation) {
                    let temp = screenHeight;
                    screenHeight = screenWidth;
                    screenWidth = temp;
                }
            }
            else
                this.canvasRotation = false;
            let canvas = Browser.mainCanvas;
            let mat = this._canvasTransform.identity();
            let scaleMode = this._scaleMode;
            let canvasWidth = this.designWidth;
            let canvasHeight = this.designHeight;
            let canvasScale = 1;
            if (!Browser.isDomSupported
                && (scaleMode === Stage.SCALE_NOSCALE || scaleMode == Stage.SCALE_SHOWALL || scaleMode === Stage.SCALE_NOBORDER)) {
                scaleMode = Stage.SCALE_FIXED_AUTO;
            }
            switch (scaleMode) {
                case Stage.SCALE_NOSCALE:
                    break;
                case Stage.SCALE_FULL:
                    canvasWidth = screenWidth;
                    canvasHeight = screenHeight;
                    break;
                case Stage.SCALE_SHOWALL:
                    canvasScale = Math.min(screenWidth / canvasWidth, screenHeight / canvasHeight);
                    break;
                case Stage.SCALE_NOBORDER:
                    canvasScale = Math.max(screenWidth / canvasWidth, screenHeight / canvasHeight);
                    break;
                case Stage.SCALE_FIXED_WIDTH:
                case Stage.SCALE_FIXED_HEIGHT:
                case Stage.SCALE_FIXED_AUTO:
                    if (scaleMode === Stage.SCALE_FIXED_WIDTH
                        || scaleMode === Stage.SCALE_FIXED_AUTO && (screenWidth / screenHeight) < (canvasWidth / canvasHeight)) {
                        canvasScale = screenWidth / canvasWidth;
                        canvasHeight = screenHeight / canvasScale;
                    }
                    else {
                        canvasScale = screenHeight / canvasHeight;
                        canvasWidth = screenWidth / canvasScale;
                    }
                    break;
            }
            this._width = canvasWidth;
            this._height = canvasHeight;
            if (Config.useRetinalCanvas || !Browser.isDomSupported) {
                canvasWidth *= canvasScale;
                canvasHeight *= canvasScale;
                canvasScale = 1;
                if (pixelRatio > 4 && Browser.isDomSupported)
                    pixelRatio = 4;
                canvasWidth *= pixelRatio;
                canvasHeight *= pixelRatio;
                canvasScale /= pixelRatio;
            }
            mat.scale(canvasScale, canvasScale);
            if (Browser.isDomSupported) {
                let offsetX = 0;
                let offsetY = 0;
                if (this._alignH === Stage.ALIGN_LEFT)
                    offsetX = 0;
                else if (this._alignH === Stage.ALIGN_RIGHT)
                    offsetX = screenWidth - canvasWidth * canvasScale;
                else
                    offsetX = (screenWidth - canvasWidth * canvasScale) * 0.5;
                if (this._alignV === Stage.ALIGN_TOP)
                    offsetY = 0;
                else if (this._alignV === Stage.ALIGN_BOTTOM)
                    offsetY = screenHeight - canvasHeight * canvasScale;
                else
                    offsetY = (screenHeight - canvasHeight * canvasScale) * 0.5;
                offsetX += this.offset.x;
                offsetY += this.offset.y;
                mat.translate(Math.round(offsetX), Math.round(offsetY));
            }
            if (this.canvasRotation) {
                if (this._screenMode === Stage.SCREEN_HORIZONTAL) {
                    mat.rotate(Math.PI / 2);
                    mat.translate(screenHeight, 0);
                    this.canvasDegree = 90;
                }
                else {
                    mat.rotate(-Math.PI / 2);
                    mat.translate(0, screenWidth);
                    this.canvasDegree = -90;
                }
            }
            else
                this.canvasDegree = 0;
            mat.a = formatData(mat.a);
            mat.d = formatData(mat.d);
            mat.tx = formatData(mat.tx);
            mat.ty = formatData(mat.ty);
            canvasWidth = Math.round(canvasWidth);
            canvasHeight = Math.round(canvasHeight);
            canvas.size(canvasWidth, canvasHeight);
            if (Browser.isDomSupported) {
                let canvasStyle = Browser.mainCanvas.source.style;
                PAL.browser.setStyleTransformOrigin(canvasStyle, "0px 0px 0px");
                PAL.browser.setStyleTransform(canvasStyle, "matrix(" + mat.toString() + ")");
                canvasStyle.width = canvasWidth + "px";
                canvasStyle.height = canvasHeight + "px";
                mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
            }
            this.transform.a = formatData(canvasWidth / this._width * this.scaleX);
            this.transform.d = formatData(canvasHeight / this._height * this.scaleY);
            this.transform = this.transform;
            RenderState2D.width = canvasWidth;
            RenderState2D.height = canvasHeight;
            (_a = window['Laya3D']) === null || _a === void 0 ? void 0 : _a._changeWebGLSize(canvasWidth, canvasHeight);
            LayaGL.renderEngine.resizeOffScreen(canvasWidth, canvasHeight);
            this.visible = true;
            this.repaint();
            this.event(Event.RESIZE);
        }
        get scaleMode() {
            return this._scaleMode;
        }
        set scaleMode(value) {
            this._scaleMode = value;
            this.updateCanvasSize(true);
        }
        get alignH() {
            this.needUpdateCanvasSize();
            return this._alignH;
        }
        set alignH(value) {
            this._alignH = value;
            this.updateCanvasSize(true);
        }
        get alignV() {
            this.needUpdateCanvasSize();
            return this._alignV;
        }
        set alignV(value) {
            this._alignV = value;
            this.updateCanvasSize(true);
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            if (value) {
                let colorArr = ColorUtils.create(value).arrColor;
                this._wgColor.setValue(colorArr[0], colorArr[1], colorArr[2], colorArr[3]);
            }
            else
                this._wgColor = null;
            if (Browser.isDomSupported)
                Browser.mainCanvas.source.style.background = value !== null && value !== void 0 ? value : "none";
        }
        get mouseX() {
            return Math.round(InputManager.mouseX / this.clientScaleX);
        }
        get mouseY() {
            return Math.round(InputManager.mouseY / this.clientScaleY);
        }
        getMousePoint() {
            return Point.TEMP.setTo(this.mouseX, this.mouseY);
        }
        get clientScaleX() {
            this.needUpdateCanvasSize();
            return this._transform ? this._transform.getScaleX() : 1;
        }
        get clientScaleY() {
            this.needUpdateCanvasSize();
            return this._transform ? this._transform.getScaleY() : 1;
        }
        get screenMode() {
            return this._screenMode;
        }
        set screenMode(value) {
            this._screenMode = value;
        }
        getFrameTm() {
            return this._frameStartTime;
        }
        getTimeFromFrameStart() {
            return Browser.now() - this._frameStartTime;
        }
        get visible() {
            return super.visible;
        }
        set visible(value) {
            super.visible = value;
            if (Browser.isDomSupported)
                Browser.mainCanvas.source.style.visibility = value ? "visible" : "hidden";
        }
        render(context2D, x, y) {
            if (this._frameRate === Stage.FRAME_SLEEP) {
                var now = Browser.now();
                if (now - this._frameStartTime < 1000)
                    return;
                this._frameStartTime = now;
            }
            else {
                if (!this._visible) {
                    this._renderCount++;
                    if (this._renderCount % 5 === 0) {
                        Timer.callLaters._update();
                        Stat.loopCount++;
                        RenderInfo.loopCount = Stat.loopCount;
                        this._runComponents();
                        this._updateTimers();
                    }
                    return;
                }
                this._frameStartTime = Browser.now();
                RenderInfo.loopStTm = this._frameStartTime;
            }
            this._renderCount++;
            let frameMode = this._frameRate === Stage.FRAME_MOUSE ? (((this._frameStartTime - InputManager.lastMouseTime) < 2000) ? Stage.FRAME_FAST : Stage.FRAME_SLOW) : this._frameRate;
            let isFastMode = (frameMode !== Stage.FRAME_SLOW);
            let isDoubleLoop = (this._renderCount % 2 === 0);
            Stat.renderSlow = !isFastMode;
            if (!isFastMode && !isDoubleLoop)
                return;
            Timer.callLaters._update();
            Stat.loopCount++;
            RenderInfo.loopCount = Stat.loopCount;
            LayaGL.renderEngine.startFrame();
            if (this.renderingEnabled) {
                for (let i = 0, n = this._scene2Ds.length; i < n; i++) {
                    this._scene2Ds[i]._update();
                }
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i]._update();
                this._runComponents();
                this._componentDriver.callPreRender();
                context2D.render2D.renderStart(!Config.preserveDrawingBuffer, this._wgColor);
                for (let i = 0, n = this._scene3Ds.length; i < n; i++)
                    this._scene3Ds[i].renderSubmit();
                this._render2d(context2D, x, y);
                this._componentDriver.callPostRender();
            }
            else
                this._runComponents();
            this._updateTimers();
            LayaGL.renderEngine.endFrame();
        }
        _render2d(context2D, x, y) {
            Stat.draw2D = 0;
            context2D.startRender();
            super.render(context2D, x, y);
            Stat.render(context2D, x, y);
            context2D.endRender();
        }
        _runComponents() {
            this._componentDriver.callStart();
            this._componentDriver.callUpdate();
            this._componentDriver.callLateUpdate();
            this._componentDriver.callDestroy();
        }
        _updateTimers() {
            ILaya.systemTimer._update();
            ILaya.physicsTimer._update();
            ILaya.timer._update();
            Tweener._runAll();
        }
        set fullScreenEnabled(value) {
            let canvas = Browser.mainCanvas.source;
            if (value) {
                canvas.addEventListener('mousedown', requestFullscreen);
                canvas.addEventListener('touchstart', requestFullscreen);
                PAL.browser.on("fullscreenchange", this, this.fullScreenChanged);
            }
            else {
                canvas.removeEventListener('mousedown', requestFullscreen);
                canvas.removeEventListener('touchstart', requestFullscreen);
                PAL.browser.off("fullscreenchange", this, this.fullScreenChanged);
            }
        }
        fullScreenChanged() {
            this.event(Event.FULL_SCREEN_CHANGE);
        }
        exitFullscreen() {
            PAL.browser.exitFullscreen();
        }
        get frameRate() {
            return this._frameRate;
        }
        set frameRate(value) {
            this._frameRate = value;
        }
    }
    Stage.SCALE_NOSCALE = "noscale";
    Stage.SCALE_SHOWALL = "showall";
    Stage.SCALE_NOBORDER = "noborder";
    Stage.SCALE_FULL = "full";
    Stage.SCALE_FIXED_WIDTH = "fixedwidth";
    Stage.SCALE_FIXED_HEIGHT = "fixedheight";
    Stage.SCALE_FIXED_AUTO = "fixedauto";
    Stage.ALIGN_LEFT = "left";
    Stage.ALIGN_RIGHT = "right";
    Stage.ALIGN_CENTER = "center";
    Stage.ALIGN_TOP = "top";
    Stage.ALIGN_MIDDLE = "middle";
    Stage.ALIGN_BOTTOM = "bottom";
    Stage.SCREEN_NONE = "none";
    Stage.SCREEN_HORIZONTAL = "horizontal";
    Stage.SCREEN_VERTICAL = "vertical";
    Stage.FRAME_FAST = "fast";
    Stage.FRAME_SLOW = "slow";
    Stage.FRAME_MOUSE = "mouse";
    Stage.FRAME_SLEEP = "sleep";
    function requestFullscreen() {
        PAL.browser.requestFullscreen();
        let canvas = Browser.mainCanvas.source;
        canvas.removeEventListener('mousedown', requestFullscreen);
        canvas.removeEventListener('touchstart', requestFullscreen);
    }
    function formatData(value) {
        if (Math.abs(value) < 0.000001)
            return 0;
        if (Math.abs(1 - value) < 0.001)
            return value > 0 ? 1 : -1;
        return value;
    }

    class PrimitiveSV extends Value2D {
        constructor() {
            super(exports.RenderSpriteData.Primitive);
            PrimitiveSV.prototype.initialize.call(this);
        }
        initialize() {
            this._defaultShader = Shader3D.find("Sprite2DPrimitive");
        }
        reinit() {
            super.initialize();
            this.initialize();
        }
    }

    class TextureSV extends Value2D {
        constructor() {
            super(exports.RenderSpriteData.Texture2D);
            TextureSV.prototype.initialize.call(this);
        }
        initialize() {
            this._blurInfo = new Vector2();
            this._u_blurInfo1 = new Vector4();
            this._u_blurInfo2 = new Vector4();
            this._u_TexRange = new Vector4();
            this._colorMat = new Matrix4x4();
            this._colorAlpha = new Vector4();
            this._strength_sig2_2sig2_gauss1 = new Vector4();
            this._defaultShader = Shader3D.find("Sprite2DTexture");
            this.blurInfo = this._blurInfo;
            this.u_blurInfo1 = this._u_blurInfo1;
            this.u_blurInfo2 = this._u_blurInfo2;
            this.u_TexRange = this._u_TexRange;
            this.colorMat = this._colorMat;
            this.colorAlpha = this._colorAlpha;
            this.strength_sig2_2sig2_gauss1 = this._strength_sig2_2sig2_gauss1;
        }
        reinit() {
            super.initialize();
            this.initialize();
        }
        get blurInfo() {
            return this.shaderData.getVector2(ShaderDefines2D.UNIFORM_BLURINFO);
        }
        set blurInfo(value) {
            this.shaderData.setVector2(ShaderDefines2D.UNIFORM_BLURINFO, value);
        }
        get u_blurInfo1() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_BLURINFO1);
        }
        set u_blurInfo1(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_BLURINFO1, value);
        }
        get u_blurInfo2() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_BLURINFO2);
        }
        set u_blurInfo2(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_BLURINFO2, value);
        }
        get u_TexRange() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_TEXRANGE);
        }
        set u_TexRange(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_TEXRANGE, value);
        }
        get colorMat() {
            return this.shaderData.getMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT);
        }
        set colorMat(value) {
            this.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT, value);
        }
        get colorAlpha() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_COLORALPHA);
        }
        set colorAlpha(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_COLORALPHA, value);
        }
        get strength_sig2_2sig2_gauss1() {
            return this.shaderData.getVector(ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1);
        }
        set strength_sig2_2sig2_gauss1(value) {
            this.shaderData.setVector(ShaderDefines2D.UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1, value);
        }
    }

    exports.MaterialRenderMode = void 0;
    (function (MaterialRenderMode) {
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_OPAQUE"] = 0] = "RENDERMODE_OPAQUE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUTOUT"] = 1] = "RENDERMODE_CUTOUT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_TRANSPARENT"] = 2] = "RENDERMODE_TRANSPARENT";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ADDTIVE"] = 3] = "RENDERMODE_ADDTIVE";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_ALPHABLENDED"] = 4] = "RENDERMODE_ALPHABLENDED";
        MaterialRenderMode[MaterialRenderMode["RENDERMODE_CUSTOME"] = 5] = "RENDERMODE_CUSTOME";
    })(exports.MaterialRenderMode || (exports.MaterialRenderMode = {}));
    class Material extends Resource {
        static load(url, complete) {
            ILaya.loader.load(url, complete, null, Loader.MATERIAL);
        }
        static __initDefine__() {
            Material.SHADERDEFINE_ALPHATEST = Shader3D.getDefineByName("ALPHATEST");
            Material.SHADERDEFINE_MAINTEXTURE = Shader3D.getDefineByName("MAINTEXTURE");
            Material.SHADERDEFINE_ADDTIVEFOG = Shader3D.getDefineByName("ADDTIVEFOG");
            Material.ALPHATESTVALUE = Shader3D.propertyNameToID("u_AlphaTestValue");
            Shader3D.CULL = Shader3D.propertyNameToID("s_Cull");
            Shader3D.BLEND = Shader3D.propertyNameToID("s_Blend");
            Shader3D.BLEND_SRC = Shader3D.propertyNameToID("s_BlendSrc");
            Shader3D.BLEND_DST = Shader3D.propertyNameToID("s_BlendDst");
            Shader3D.BLEND_SRC_RGB = Shader3D.propertyNameToID("s_BlendSrcRGB");
            Shader3D.BLEND_DST_RGB = Shader3D.propertyNameToID("s_BlendDstRGB");
            Shader3D.BLEND_SRC_ALPHA = Shader3D.propertyNameToID("s_BlendSrcAlpha");
            Shader3D.BLEND_DST_ALPHA = Shader3D.propertyNameToID("s_BlendDstAlpha");
            Shader3D.BLEND_EQUATION = Shader3D.propertyNameToID("s_BlendEquation");
            Shader3D.BLEND_EQUATION_RGB = Shader3D.propertyNameToID("s_BlendEquationRGB");
            Shader3D.BLEND_EQUATION_ALPHA = Shader3D.propertyNameToID("s_BlendEquationAlpha");
            Shader3D.DEPTH_TEST = Shader3D.propertyNameToID("s_DepthTest");
            Shader3D.DEPTH_WRITE = Shader3D.propertyNameToID("s_DepthWrite");
            Shader3D.STENCIL_Ref = Shader3D.propertyNameToID("s_StencilRef");
            Shader3D.STENCIL_TEST = Shader3D.propertyNameToID("s_StencilTest");
            Shader3D.STENCIL_WRITE = Shader3D.propertyNameToID("s_StencilWrite");
            Shader3D.STENCIL_Op = Shader3D.propertyNameToID("s_StencilOp");
        }
        get renderQueue() {
            return this._renderQueue;
        }
        set renderQueue(value) {
            this._renderQueue = value;
            this._notifyOwnerElements();
        }
        _setOwner3DElement(element) {
            this.ownerElements.add(element);
            element.materialShaderData = this._shaderValues;
            element.materialRenderQueue = this.renderQueue;
            element.subShader = this._shader.getSubShaderAt(0);
            element.materialId = this.id;
        }
        _setOwner2DElement(element) {
            this.ownerElements.add(element);
            element.materialShaderData = this._shaderValues;
            element.subShader = this._shader.getSubShaderAt(0);
        }
        _removeOwnerElement(element) {
            this.ownerElements.delete(element);
        }
        _notifyOwnerElements() {
            this.ownerElements.forEach(element => {
                element.materialId ? this._setOwner3DElement(element) : this._setOwner2DElement(element);
            });
        }
        get shaderData() {
            return this._shaderValues;
        }
        get alphaTestValue() {
            return this._shaderValues.getNumber(Material.ALPHATESTVALUE);
        }
        set alphaTestValue(value) {
            this._shaderValues.setNumber(Material.ALPHATESTVALUE, value);
        }
        get alphaTest() {
            return this.shaderData.hasDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        set alphaTest(value) {
            if (value)
                this._shaderValues.addDefine(Material.SHADERDEFINE_ALPHATEST);
            else
                this._shaderValues.removeDefine(Material.SHADERDEFINE_ALPHATEST);
        }
        addDefine(define) {
            this._shaderValues.addDefine(define);
        }
        removeDefine(define) {
            this._shaderValues.removeDefine(define);
        }
        setDefine(define, value) {
            if (value) {
                this._shaderValues.addDefine(define);
            }
            else {
                this._shaderValues.removeDefine(define);
            }
        }
        hasDefine(define) {
            return this._shaderValues.hasDefine(define);
        }
        get depthWrite() {
            return this._shaderValues.getBool(Shader3D.DEPTH_WRITE);
        }
        set depthWrite(value) {
            this._shaderValues.setBool(Shader3D.DEPTH_WRITE, value);
        }
        get cull() {
            return this._shaderValues.getInt(Shader3D.CULL);
        }
        set cull(value) {
            this._shaderValues.setInt(Shader3D.CULL, value);
        }
        get blend() {
            return this._shaderValues.getInt(Shader3D.BLEND);
        }
        set blend(value) {
            this._shaderValues.setInt(Shader3D.BLEND, value);
        }
        get blendSrc() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC);
        }
        set blendSrc(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC, value);
        }
        get blendDst() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST);
        }
        set blendDst(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST, value);
        }
        get blendSrcAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC_ALPHA);
        }
        set blendSrcAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC_ALPHA, value);
        }
        get blendSrcRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_SRC_RGB);
        }
        set blendSrcRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_SRC_RGB, value);
        }
        get blendDstRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST_RGB);
        }
        set blendDstRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST_RGB, value);
        }
        get blendDstAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_DST_ALPHA);
        }
        set blendDstAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_DST_ALPHA, value);
        }
        get blendEquation() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION);
        }
        set blendEquation(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION, value);
        }
        get blendEquationRGB() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION_RGB);
        }
        set blendEquationRGB(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION_RGB, value);
        }
        get blendEquationAlpha() {
            return this._shaderValues.getInt(Shader3D.BLEND_EQUATION_ALPHA);
        }
        set blendEquationAlpha(value) {
            this._shaderValues.setInt(Shader3D.BLEND_EQUATION_ALPHA, value);
        }
        get depthTest() {
            return this._shaderValues.getInt(Shader3D.DEPTH_TEST);
        }
        set depthTest(value) {
            this._shaderValues.setInt(Shader3D.DEPTH_TEST, value);
        }
        get stencilTest() {
            return this._shaderValues.getInt(Shader3D.STENCIL_TEST);
        }
        set stencilTest(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_TEST, value);
        }
        get stencilWrite() {
            return this._shaderValues.getBool(Shader3D.STENCIL_WRITE);
        }
        set stencilWrite(value) {
            this._shaderValues.setBool(Shader3D.STENCIL_WRITE, value);
        }
        get stencilRef() {
            return this._shaderValues.getInt(Shader3D.STENCIL_Ref);
        }
        set stencilRef(value) {
            this._shaderValues.setInt(Shader3D.STENCIL_Ref, value);
        }
        get stencilOp() {
            return this._shaderValues.getVector3(Shader3D.STENCIL_Op);
        }
        set stencilOp(value) {
            this._shaderValues.setVector3(Shader3D.STENCIL_Op, value);
        }
        get MaterialProperty() {
            let propertyMap = {};
            var shaderValues = this._shaderValues.getData();
            for (let key in shaderValues) {
                propertyMap[LayaGL.renderEngine.propertyIDToName(parseInt(key))] = shaderValues[key];
            }
            return propertyMap;
        }
        get MaterialDefine() {
            let shaderDefineArray = new Array();
            let defineData = this._shaderValues.getDefineData();
            Shader3D._getNamesByDefineData(defineData, shaderDefineArray);
            return shaderDefineArray;
        }
        get materialRenderMode() {
            return this._matRenderNode;
        }
        set materialRenderMode(value) {
            this._matRenderNode = value;
            switch (value) {
                case exports.MaterialRenderMode.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUTOUT:
                    this.renderQueue = Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ADDTIVE:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.addDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case exports.MaterialRenderMode.RENDERMODE_CUSTOME:
                    break;
                default:
                    console.warn(`Material : renderMode value error - (${value}).`);
                    break;
            }
        }
        constructor() {
            super();
            this.ownerElements = new Set();
            this._shaderValues = LayaGL.renderDeviceFactory.createShaderData(this);
            this.renderQueue = Material.RENDERQUEUE_OPAQUE;
            this._matRenderNode = 0;
            this.alphaTest = false;
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.blendSrc = RenderState.BLENDPARAM_ONE;
            this.blendDst = RenderState.BLENDPARAM_ZERO;
            this.blendSrcRGB = RenderState.BLENDPARAM_ONE;
            this.blendDstRGB = RenderState.BLENDPARAM_ZERO;
            this.blendSrcAlpha = RenderState.BLENDPARAM_ONE;
            this.blendDstAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
        }
        _disposeResource() {
            this._shaderValues.destroy();
            this._shaderValues = null;
            this.ownerElements.clear();
        }
        get shader() {
            return this._shader;
        }
        effectiveProperty() {
            return this._shader.getSubShaderAt(0)._uniformMap;
        }
        setShaderName(name) {
            this._shader = Shader3D.find(name);
            if (!this._shader) {
                console.warn(`Material: unknown shader name '${name}'`);
                this._shader = Shader3D.find("BLINNPHONG");
            }
            this.shaderData.clearDefine();
            this.shaderData.clearData();
            let subShader = this._shader.getSubShaderAt(0);
            let defaultValue = subShader._uniformDefaultValue;
            let typeMap = subShader._uniformMap;
            this.applyUniformDefaultValue(typeMap, defaultValue);
            this._notifyOwnerElements();
        }
        applyUniformDefaultValue(uniformMap, defaultValue) {
            uniformMap.forEach((uniform, id) => {
                if (uniform.arrayLength <= 0) {
                    let type = uniform.uniformtype;
                    let uniformName = uniform.propertyName;
                    if (defaultValue && defaultValue[uniformName] != undefined) {
                        let value = defaultValue[uniformName];
                        this.setShaderData(uniformName, type, value);
                    }
                    else {
                        let value = ShaderDataDefaultValue(type);
                        if (value) {
                            this.setShaderData(uniformName, type, value);
                        }
                    }
                }
            });
        }
        getBoolByIndex(uniformIndex) {
            return this.shaderData.getBool(uniformIndex);
        }
        setBoolByIndex(uniformIndex, value) {
            this.shaderData.setBool(uniformIndex, value);
        }
        getBool(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getBoolByIndex(uniformIndex);
        }
        setBool(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setBoolByIndex(uniformIndex, value);
        }
        getFloatByIndex(uniformIndex) {
            return this.shaderData.getNumber(uniformIndex);
        }
        setFloatByIndex(uniformIndex, value) {
            this.shaderData.setNumber(uniformIndex, value);
        }
        getFloat(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getFloatByIndex(uniformIndex);
        }
        setFloat(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setFloatByIndex(uniformIndex, value);
        }
        getIntByIndex(uniformIndex) {
            return this.shaderData.getInt(uniformIndex);
        }
        setIntByIndex(uniformIndex, value) {
            this.shaderData.setInt(uniformIndex, value);
        }
        getInt(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getIntByIndex(uniformIndex);
        }
        setInt(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setIntByIndex(uniformIndex, value);
        }
        getVector2ByIndex(uniformIndex) {
            return this.shaderData.getVector2(uniformIndex);
        }
        setVector2ByIndex(uniformIndex, value) {
            this.shaderData.setVector2(uniformIndex, value);
        }
        getVector2(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector2ByIndex(uniformIndex);
        }
        setVector2(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector2ByIndex(uniformIndex, value);
        }
        getVector3ByIndex(uniformIndex) {
            return this.shaderData.getVector3(uniformIndex);
        }
        setVector3ByIndex(uniformIndex, value) {
            this.shaderData.setVector3(uniformIndex, value);
        }
        getVector3(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector3ByIndex(uniformIndex);
        }
        setVector3(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector3ByIndex(uniformIndex, value);
        }
        setVector4ByIndex(uniformIndex, value) {
            this.shaderData.setVector(uniformIndex, value);
        }
        getVector4ByIndex(uniformIndex) {
            return this.shaderData.getVector(uniformIndex);
        }
        setVector4(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setVector4ByIndex(uniformIndex, value);
        }
        getVector4(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getVector4ByIndex(uniformIndex);
        }
        getColorByIndex(uniformIndex) {
            return this.shaderData.getColor(uniformIndex);
        }
        setColorByIndex(uniformIndex, value) {
            this.shaderData.setColor(uniformIndex, value);
        }
        getColor(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.shaderData.getColor(uniformIndex);
        }
        setColor(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setColorByIndex(uniformIndex, value);
        }
        getMatrix4x4ByIndex(uniformIndex) {
            return this.shaderData.getMatrix4x4(uniformIndex);
        }
        setMatrix4x4ByIndex(uniformIndex, value) {
            this.shaderData.setMatrix4x4(uniformIndex, value);
        }
        getMatrix4x4(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getMatrix4x4ByIndex(uniformIndex);
        }
        setMatrix4x4(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setMatrix4x4ByIndex(uniformIndex, value);
        }
        getMatrix3x3ByIndex(index) {
            return this.shaderData.getMatrix3x3(index);
        }
        setMatrix3x3ByIndex(index, value) {
            this.shaderData.setMatrix3x3(index, value);
        }
        getMatrix3x3(name) {
            let index = Shader3D.propertyNameToID(name);
            return this.getMatrix3x3ByIndex(index);
        }
        setMatrix3x3(name, value) {
            let index = Shader3D.propertyNameToID(name);
            this.setMatrix3x3ByIndex(index, value);
        }
        setTextureByIndex(uniformIndex, texture) {
            this.shaderData.setTexture(uniformIndex, texture);
            if (texture && !texture._texture)
                texture.once(Event.READY, this, this.reSetTexture, [uniformIndex, texture]);
        }
        reSetTexture(uniformIndex, texture) {
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTextureByIndex(uniformIndex) {
            return this.shaderData.getTexture(uniformIndex);
        }
        setTexture(name, texture) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setTextureByIndex(uniformIndex, texture);
        }
        getTexture(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getTextureByIndex(uniformIndex);
        }
        getBufferByIndex(uniformIndex) {
            return this.shaderData.getBuffer(uniformIndex);
        }
        setBufferByIndex(uniformIndex, value) {
            this.shaderData.setBuffer(uniformIndex, value);
        }
        getBuffer(name) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getBufferByIndex(uniformIndex);
        }
        setBuffer(name, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setBufferByIndex(uniformIndex, value);
        }
        setShaderDataByIndex(uniformIndex, type, value) {
            this.shaderData.setShaderData(uniformIndex, type, value);
        }
        setShaderData(name, type, value) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            this.setShaderDataByIndex(uniformIndex, type, value);
        }
        getShaderData(name, type) {
            let uniformIndex = Shader3D.propertyNameToID(name);
            return this.getShaderDataByIndex(uniformIndex, type);
        }
        getShaderDataByIndex(uniformIndex, type) {
            return this._shaderValues.getShaderData(uniformIndex, type);
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.renderQueue = this.renderQueue;
            destObject.setShaderName(this._shader._name);
            this._shaderValues.cloneTo(destObject._shaderValues);
        }
        clone() {
            var dest = new Material();
            this.cloneTo(dest);
            return dest;
        }
        get _defineDatas() {
            return this._shaderValues.getDefineData();
        }
        oldparseEndEvent() {
        }
    }
    Material.RENDERQUEUE_OPAQUE = 2000;
    Material.RENDERQUEUE_ALPHATEST = 2450;
    Material.RENDERQUEUE_TRANSPARENT = 3000;

    class Area2D extends Sprite {
        constructor() {
            super();
            this._setBit(NodeFlags.AREA_2D, true);
        }
        get mainCamera() {
            return this._mainCamera;
        }
        _setMainCamera(camera) {
            if (camera == this._mainCamera)
                return;
            this._mainCamera && (this._mainCamera._isMain = false);
            this._mainCamera = camera;
            if (this._mainCamera) {
                this._mainCamera._isMain = true;
            }
        }
        _preRenderUpdate(context) {
            let shaderData = this._scene.sceneShaderData;
            if (this._mainCamera) {
                context.drawLeftData();
                if (shaderData) {
                    shaderData.addDefine(Camera2D.SHADERDEFINE_CAMERA2D);
                    shaderData.setMatrix3x3(Camera2D.VIEW2D, this._mainCamera._getCameraTransform());
                }
            }
        }
        render(ctx, x, y) {
            this._preRenderUpdate(ctx);
            this._scene._curCamera = this.mainCamera;
            super.render(ctx, x, y);
            if (this._mainCamera) {
                let shaderData = this._scene.sceneShaderData;
                ctx.drawLeftData();
                if (shaderData) {
                    shaderData.removeDefine(Camera2D.SHADERDEFINE_CAMERA2D);
                }
            }
            this._scene._curCamera = null;
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
            this._scene._area2Ds.push(this);
        }
        _setUnBelongScene() {
            let areaArray = this._scene._area2Ds;
            let index = areaArray.indexOf(this);
            if (index != -1) {
                areaArray.splice(index, 1);
            }
            super._setUnBelongScene();
        }
        transformPoint(x, y, out) {
            out = out || new Point();
            out.setTo(x, y);
            if (!this._mainCamera)
                return out;
            this.localToGlobal(out);
            this.mainCamera.localToGlobal(out);
            out.x -= RenderState2D.width * 0.5;
            out.y -= RenderState2D.height * 0.5;
            this.globalToLocal(out);
            return out;
        }
    }

    class Widget extends Component {
        constructor() {
            super();
            this._top = null;
            this._bottom = null;
            this._left = null;
            this._right = null;
            this._centerX = null;
            this._centerY = null;
            this.runInEditor = true;
            this.hideFlags |= HideFlags.HideAndDontSave;
        }
        onReset() {
            this._top = this._bottom = this._left = this._right = this._centerX = this._centerY = null;
        }
        _onEnable() {
            if (this.owner.parent)
                this._onAdded();
            else
                this.owner.once(Event.ADDED, this, this._onAdded);
        }
        _onDisable() {
            this.owner.off(Event.ADDED, this, this._onAdded);
            if (this.owner.parent)
                this.owner.parent.off(Event.RESIZE, this, this._onParentResize);
        }
        _onAdded() {
            if (this.owner.parent)
                this.owner.parent.on(Event.RESIZE, this, this._onParentResize);
            this.resetLayoutX();
            this.resetLayoutY();
        }
        _onParentResize() {
            var flagX = this.resetLayoutX();
            var flagY = this.resetLayoutY();
            if (flagX || flagY)
                this.owner.event(Event.RESIZE);
        }
        resetLayoutX() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerX != null) {
                    owner.x = Math.round((parent.width - owner.displayWidth) * 0.5 + this._centerX + owner.pivotX * owner.scaleX);
                }
                else if (this._left != null) {
                    owner.x = Math.round(this._left + owner.pivotX * owner.scaleX);
                    if (this._right != null) {
                        if (!parent._width)
                            return false;
                        var temp = (parent._width - this._left - this._right) / (owner.scaleX || 0.01);
                        if (temp != owner._width) {
                            owner.width = temp;
                            return true;
                        }
                    }
                }
                else if (this._right != null) {
                    owner.x = Math.round(parent.width - owner.displayWidth - this._right + owner.pivotX * owner.scaleX);
                }
            }
            return false;
        }
        resetLayoutY() {
            var owner = this.owner;
            if (!owner)
                return false;
            var parent = owner.parent;
            if (parent) {
                if (this._centerY != null) {
                    owner.y = Math.round((parent.height - owner.displayHeight) * 0.5 + this._centerY + owner.pivotY * owner.scaleY);
                }
                else if (this._top != null) {
                    owner.y = Math.round(this._top + owner.pivotY * owner.scaleY);
                    if (this._bottom != null) {
                        if (!parent._height)
                            return false;
                        var temp = (parent._height - this._top - this._bottom) / (owner.scaleY || 0.01);
                        if (temp != owner._height) {
                            owner.height = temp;
                            return true;
                        }
                    }
                }
                else if (this._bottom != null) {
                    owner.y = Math.round(parent.height - owner.displayHeight - this._bottom + owner.pivotY * owner.scaleY);
                }
            }
            return false;
        }
        resetLayout() {
            if (this.owner) {
                this.resetLayoutX();
                this.resetLayoutY();
            }
        }
        get top() {
            return this._top;
        }
        set top(value) {
            if (isNaN(value))
                value = null;
            if (this._top != value) {
                this._top = value;
                this.resetLayoutY();
            }
        }
        get bottom() {
            return this._bottom;
        }
        set bottom(value) {
            if (isNaN(value))
                value = null;
            if (this._bottom != value) {
                this._bottom = value;
                this.resetLayoutY();
            }
        }
        get left() {
            return this._left;
        }
        set left(value) {
            if (isNaN(value))
                value = null;
            if (this._left != value) {
                this._left = value;
                this.resetLayoutX();
            }
        }
        get right() {
            return this._right;
        }
        set right(value) {
            if (isNaN(value))
                value = null;
            if (this._right != value) {
                this._right = value;
                this.resetLayoutX();
            }
        }
        get centerX() {
            return this._centerX;
        }
        set centerX(value) {
            if (isNaN(value))
                value = null;
            if (this._centerX != value) {
                this._centerX = value;
                this.resetLayoutX();
            }
        }
        get centerY() {
            return this._centerY;
        }
        set centerY(value) {
            if (isNaN(value))
                value = null;
            if (this._centerY != value) {
                this._centerY = value;
                this.resetLayoutY();
            }
        }
    }
    Widget.EMPTY = null;
    Widget.EMPTY = new Widget();

    class Scene2DSpecialManager {
        constructor() {
            this.componentElementMap = new Map();
            this._shaderData = LayaGL.renderDeviceFactory.createShaderData(null);
        }
    }

    class Scene extends Sprite {
        static regManager(type, cla) {
            Scene.componentManagerMap.set(type, cla);
        }
        constructor() {
            super();
            this.autoDestroyAtClosed = false;
            this._area2Ds = [];
            this._componentElementDatasMap = {};
            this._specialManager = new Scene2DSpecialManager();
            this._timer = ILaya.timer;
            this._widget = Widget.EMPTY;
            this._scene = this;
            Scene.componentManagerMap.forEach((val, key) => {
                this._specialManager.componentElementMap.set(key, new val(this));
            });
        }
        set componentElementDatasMap(value) {
            this._componentElementDatasMap = value;
            this._specialManager.componentElementMap.forEach((value, key) => {
                this._componentElementDatasMap[key] && value.Init(this._componentElementDatasMap[key]);
            });
        }
        get componentElementDatasMap() {
            return this._componentElementDatasMap;
        }
        _update() {
            var delta = ILaya.timer.delta * 0.001;
            this._specialManager.componentElementMap.forEach((value) => {
                value.update(delta);
            });
        }
        getComponentElementManager(type) {
            return this._specialManager.componentElementMap.get(type);
        }
        getNodeByID(id) {
            if (this._idMap)
                return this._idMap[id];
            return null;
        }
        open(closeOther, param) {
            if (closeOther == null || closeOther)
                Scene.closeAll();
            Scene.root.addChild(this);
            if (this._scene3D)
                ILaya.stage.addChildAt(this._scene3D, 0);
            this.onOpened(param);
        }
        onOpened(param) {
        }
        close(type = null) {
            this.onClosed(type);
            if (this.autoDestroyAtClosed) {
                this.destroy();
                if (this._scene3D)
                    this._scene3D.destroy();
            }
            else {
                this.removeSelf();
                if (this._scene3D)
                    this._scene3D.removeSelf();
            }
        }
        onClosed(type) {
        }
        destroy(destroyChild = true) {
            super.destroy(destroyChild);
            if (this._scene3D) {
                this._scene3D.destroy();
                this._scene3D = null;
            }
            this._idMap = null;
            Scene.unDestroyedScenes.delete(this);
            this._specialManager.componentElementMap.forEach(element => {
                element.destroy();
            });
        }
        get timer() {
            return this._timer;
        }
        set timer(value) {
            this._timer = value;
        }
        get scene3D() {
            return this._scene3D;
        }
        get top() {
            return this._widget.top;
        }
        set top(value) {
            if (value != this._widget.top) {
                this._getWidget().top = value;
            }
        }
        get bottom() {
            return this._widget.bottom;
        }
        set bottom(value) {
            if (value != this._widget.bottom) {
                this._getWidget().bottom = value;
            }
        }
        get left() {
            return this._widget.left;
        }
        set left(value) {
            if (value != this._widget.left) {
                this._getWidget().left = value;
            }
        }
        get right() {
            return this._widget.right;
        }
        set right(value) {
            if (value != this._widget.right) {
                this._getWidget().right = value;
            }
        }
        get centerX() {
            return this._widget.centerX;
        }
        set centerX(value) {
            if (value != this._widget.centerX) {
                this._getWidget().centerX = value;
            }
        }
        get centerY() {
            return this._widget.centerY;
        }
        set centerY(value) {
            if (value != this._widget.centerY) {
                this._getWidget().centerY = value;
            }
        }
        render(ctx, x, y) {
            this._preRenderUpdate(ctx, x, y);
            super.render(ctx, x, y);
            this._recoverRenderSceneState(ctx);
        }
        get sceneShaderData() {
            return this._specialManager._shaderData;
        }
        _preRenderUpdate(ctx, x, y) {
            Render2DSimple.rendercontext2D.sceneData = this._specialManager._shaderData;
            if (this._light2DManager)
                this._light2DManager.preRenderUpdate(ctx);
        }
        _recoverRenderSceneState(ctx) {
            ctx.drawLeftData();
            Render2DSimple.rendercontext2D.sceneData = null;
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Layout) != 0)
                this.callLater(this._sizeChanged);
        }
        _sizeChanged() {
            this.event(Event.RESIZE);
            if (this._widget !== Widget.EMPTY)
                this._widget.resetLayout();
        }
        _onAdded() {
            super._onAdded();
            if (LayaEnv.isPlaying)
                ILaya.stage._scene2Ds.push(this);
        }
        _onRemoved() {
            super._onRemoved();
            if (LayaEnv.isPlaying) {
                let index = ILaya.stage._scene2Ds.indexOf(this);
                ILaya.stage._scene2Ds.splice(index, 1);
            }
        }
        freshLayout() {
            this.refreshLayout();
        }
        refreshLayout() {
            if (this._widget != Widget.EMPTY) {
                this._widget.resetLayout();
            }
        }
        _getWidget() {
            this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
            return this._widget;
        }
        static get root() {
            let root = Scene._root;
            if (!root) {
                root = Scene._root = ILaya.stage.addChild(new Sprite());
                root.name = "root";
                root.mouseThrough = true;
                ILaya.stage.on("resize", null, () => {
                    root.size(ILaya.stage.width, ILaya.stage.height);
                    root.event(Event.RESIZE);
                });
                root.size(ILaya.stage.width, ILaya.stage.height);
                root.event(Event.RESIZE);
            }
            return root;
        }
        static load(url, complete, progress) {
            return Scene._load(url, progress ? value => progress.runWith(value) : null).then(scene => {
                if (complete)
                    complete.runWith(scene);
                return scene;
            });
        }
        static open(url, closeOther, param, complete, progress) {
            if (typeof (complete) === "function") {
                progress = complete;
                complete = null;
            }
            if (typeof (param) === "function") {
                complete = param;
                param = null;
            }
            if (progress instanceof Handler) {
                let h = progress;
                progress = (value) => h.runWith(value);
            }
            return Scene._load(url, progress).then(scene => {
                scene.open(closeOther, param);
                if (complete instanceof Handler)
                    complete.runWith(scene);
                else if (complete)
                    complete(scene);
                return scene;
            });
        }
        static _load(url, progress) {
            Scene.showLoadingPage();
            return ILaya.loader.load(url, null, value => {
                if (Scene._loadPage)
                    Scene._loadPage.event("progress", value);
                if (progress)
                    progress(value);
            }).then((content) => {
                Scene.hideLoadingPage();
                if (!content)
                    throw new Error("Can not find scene:" + url);
                let scene;
                let errors = [];
                let ret = content.create(null, errors);
                if (errors.length > 0)
                    console.warn(`Error loading ${url}: \n${errors.join("\n")}`);
                if (ret instanceof Scene)
                    scene = ret;
                else if (ret._nodeType === 1) {
                    scene = new Scene();
                    scene.left = scene.right = scene.top = scene.bottom = 0;
                    scene._scene3D = ret;
                }
                else
                    throw new Error("Not a scene:" + url);
                if (scene._scene3D)
                    scene._scene3D._scene2D = scene;
                Scene.unDestroyedScenes.add(scene);
                return scene;
            });
        }
        static close(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene && scene.parent && scene.url === url && (name == null || scene.name == name)) {
                    scene.close();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static closeAll() {
            let root = Scene.root;
            for (let i = 0, n = root.numChildren; i < n; i++) {
                var scene = root.getChildAt(0);
                if (scene instanceof Scene)
                    scene.close();
                else
                    scene.removeSelf();
            }
        }
        static destroy(url, name) {
            let flag = false;
            for (let scene of Scene.unDestroyedScenes) {
                if (scene.url === url && (name == null || scene.name == name) && !scene._destroyed) {
                    scene.destroy();
                    flag = true;
                    break;
                }
            }
            return flag;
        }
        static gc() {
            Resource.destroyUnusedResources();
        }
        static setLoadingPage(loadPage) {
            Scene._loadPage = loadPage;
        }
        static showLoadingPage(param = null, delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._showLoading, [param], false);
            }
        }
        static _showLoading(param) {
            ILaya.stage.addChild(Scene._loadPage);
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.onOpened(param);
        }
        static _hideLoading() {
            if (Scene._loadPage instanceof Scene)
                Scene._loadPage.close();
            else
                Scene._loadPage.removeSelf();
        }
        static hideLoadingPage(delay = 500) {
            if (Scene._loadPage) {
                ILaya.systemTimer.clear(null, Scene._showLoading);
                ILaya.systemTimer.clear(null, Scene._hideLoading);
                ILaya.systemTimer.once(delay, null, Scene._hideLoading);
            }
        }
    }
    Scene.unDestroyedScenes = new Set();
    Scene.componentManagerMap = new Map();

    class Camera2D extends Sprite {
        static shaderValueInit() {
            if (!Scene.scene2DUniformMap) {
                Scene.scene2DUniformMap = LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite2DGlobal");
            }
            let scene2DUniformMap = Scene.scene2DUniformMap;
            Camera2D.VIEW2D = Shader3D.propertyNameToID("u_view2D");
            scene2DUniformMap.addShaderUniform(Camera2D.VIEW2D, "u_view2D", exports.ShaderDataType.Matrix3x3);
            Camera2D.SHADERDEFINE_CAMERA2D = Shader3D.getDefineByName("CAMERA2D");
        }
        get ignoreRotation() {
            return this._ignoreRotation;
        }
        set ignoreRotation(value) {
            this._ignoreRotation = value;
        }
        get isMain() {
            return this._isMain;
        }
        set isMain(value) {
            if (this._ownerArea) {
                if (value) {
                    this._ownerArea._setMainCamera(this);
                    this._isMain = true;
                }
                else {
                    if (this._ownerArea.mainCamera == this) {
                        this._ownerArea._setMainCamera(null);
                        this._isMain = false;
                    }
                }
            }
            this._isMain = value;
        }
        _setUnBelongScene() {
            if (this._ownerArea != null) {
                if (this._ownerArea.mainCamera == this)
                    this._ownerArea._setMainCamera(null);
                this._ownerArea = null;
            }
            super._setUnBelongScene();
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
            this._findOwnerArea();
        }
        _findOwnerArea() {
            let ele = this;
            while (ele) {
                if (ele === this._scene || ele === ILaya.stage)
                    break;
                if (ele instanceof Area2D) {
                    this._ownerArea = ele;
                    if (this._isMain && !this._ownerArea.mainCamera)
                        this._ownerArea._setMainCamera(this);
                    break;
                }
                ele = ele._parent;
            }
            if (this._ownerArea == null) {
                console.warn("Camera2D must be a descendant of Area2D");
            }
        }
        get zoom() {
            return this._zoom;
        }
        set zoom(value) {
            if (value) {
                value.cloneTo(this._zoom);
            }
        }
        get limit_Left() {
            return this._limit_Left;
        }
        set limit_Left(value) {
            this._limit_Left = value;
        }
        get limit_Right() {
            return this._limit_Right;
        }
        set limit_Right(value) {
            this._limit_Right = value;
        }
        get limit_Bottom() {
            return this._limit_Bottom;
        }
        set limit_Bottom(value) {
            this._limit_Bottom = value;
        }
        get limit_Top() {
            return this._limit_Top;
        }
        set limit_Top(value) {
            this._limit_Top = value;
        }
        get positionSmooth() {
            return this._positionSmooth;
        }
        set positionSmooth(value) {
            this._positionSmooth = value;
        }
        get positionSpeed() {
            return this._positionSpeed;
        }
        set positionSpeed(value) {
            this._positionSpeed = value;
        }
        get dragHorizontalEnable() {
            return this._dragHorizontalEnable;
        }
        set dragHorizontalEnable(value) {
            this._dragHorizontalEnable = value;
        }
        get dragVerticalEnable() {
            return this._dragVerticalEnable;
        }
        set dragVerticalEnable(value) {
            this._dragVerticalEnable = value;
        }
        get drag_Left() {
            return this._drag_Left;
        }
        set drag_Left(value) {
            this._drag_Left = value;
        }
        get drag_Right() {
            return this._drag_Right;
        }
        set drag_Right(value) {
            this._drag_Right = value;
        }
        get drag_Top() {
            return this._drag_Top;
        }
        set drag_Top(value) {
            this._drag_Top = value;
        }
        get drag_Bottom() {
            return this._drag_Bottom;
        }
        set drag_Bottom(value) {
            this._drag_Bottom = value;
        }
        getCameraPos() {
            return this._cameraPos;
        }
        constructor() {
            super();
            this._cameraPos = new Vector2();
            this._cameraSmoothPos = new Vector2();
            this._firstUpdate = true;
            this._cameraMatrix = new Matrix3x3();
            this._cameraInvertMatrix = new Matrix3x3();
            this._ignoreRotation = true;
            this._viewRect = new Vector2();
            this.limit_Left = -10000000;
            this.limit_Right = 10000000;
            this.limit_Top = -10000000;
            this.limit_Bottom = 10000000;
            this.drag_Left = 0.2;
            this.drag_Right = 0.2;
            this.drag_Top = 0.2;
            this.drag_Bottom = 0.2;
            this.positionSmooth = false;
            this._rect = new Vector4();
            this._zoom = new Vector2(1, 1);
        }
        _getScreenSize() {
            this._viewRect.setValue(RenderState2D.width, RenderState2D.height);
            return this._viewRect;
        }
        _getCameraTransform() {
            let viewport = this._getScreenSize();
            let curPosPoint = Point.TEMP;
            this.globalTrans.getScenePos(curPosPoint);
            let extendHorizental = viewport.x * 0.5;
            let extendVertical = viewport.y * 0.5;
            if (!this._firstUpdate) {
                if (this.dragHorizontalEnable) {
                    this._cameraPos.x = Math.min(this._cameraPos.x, curPosPoint.x + extendHorizental * this.drag_Left);
                    this._cameraPos.x = Math.max(this._cameraPos.x, curPosPoint.x - extendHorizental * this.drag_Right);
                }
                else {
                    this._cameraPos.x = curPosPoint.x;
                }
                if (this.dragVerticalEnable) {
                    this._cameraPos.y = Math.min(this._cameraPos.y, curPosPoint.y + extendVertical * this.drag_Top);
                    this._cameraPos.y = Math.max(this._cameraPos.y, curPosPoint.y - extendVertical * this.drag_Bottom);
                }
                else {
                    this._cameraPos.y = curPosPoint.y;
                }
                let sceneRect_left = this._cameraPos.x - extendHorizental;
                let sceneRect_right = sceneRect_left + viewport.x;
                let sceneRect_top = this._cameraPos.y - extendVertical;
                let sceneRect_bottom = sceneRect_top + viewport.y;
                if (sceneRect_left < this.limit_Left) {
                    this._cameraPos.x -= sceneRect_left - this.limit_Left;
                }
                if (sceneRect_right > this.limit_Right) {
                    this._cameraPos.x -= sceneRect_right - this.limit_Right;
                }
                if (sceneRect_bottom > this.limit_Bottom) {
                    this._cameraPos.y -= sceneRect_bottom - this.limit_Bottom;
                }
                if (sceneRect_top < this.limit_Top) {
                    this._cameraPos.y -= sceneRect_top - this.limit_Top;
                }
                if (this.positionSmooth) {
                    let speed = Math.min(1.0, this.positionSpeed * 0.16);
                    let transX = Math.floor((this._cameraPos.x - this._cameraSmoothPos.x) * speed);
                    let transY = Math.floor((this._cameraPos.y - this._cameraSmoothPos.y) * speed);
                    this._cameraSmoothPos.x += transX;
                    this._cameraSmoothPos.y += transY;
                }
                else {
                    this._cameraSmoothPos.x = this._cameraPos.x;
                    this._cameraSmoothPos.y = this._cameraPos.y;
                }
            }
            else {
                this._cameraSmoothPos.x = this._cameraPos.x = curPosPoint.x;
                this._cameraSmoothPos.y = this._cameraPos.y = curPosPoint.y;
                this._firstUpdate = false;
            }
            if (!this.ignoreRotation) {
                if (this.rotationSmooth) ;
                else {
                    this._cameraRotation = this.globalTrans.rotation;
                }
            }
            else {
                this._cameraRotation = 0;
            }
            this._rect.setValue(this._cameraSmoothPos.x - extendHorizental, this._cameraSmoothPos.x + extendHorizental, this._cameraSmoothPos.y - extendVertical, this._cameraSmoothPos.y + extendVertical);
            Matrix3x3.createMatrixFromValue(this._cameraSmoothPos, this._cameraRotation * Math.PI / 180, this._zoom, this._cameraMatrix);
            this._cameraMatrix.invert(this._cameraInvertMatrix);
            return this._cameraInvertMatrix;
        }
    }

    class Texture2DArray extends BaseTexture {
        static get defaultTexture() {
            return this._defaultTexture;
        }
        static __init__() {
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                this._defaultTexture = new Texture2DArray(1, 1, 1, exports.TextureFormat.R8G8B8A8, false, false, false);
                this._defaultTexture.lock = true;
                this._defaultTexture.setPixelsData(new Uint8Array([255, 255, 255, 255]), false, false);
            }
        }
        constructor(width, height, depth, format, mipmap = true, canRead, sRGB = false) {
            super(width, height, format);
            this._dimension = exports.TextureDimension.Texture2DArray;
            this._gammaSpace = sRGB;
            this.depth = depth;
            let context = LayaGL.textureContext;
            this._texture = context.createTexture3DInternal(this._dimension, width, height, depth, format, mipmap, sRGB, false);
            return;
        }
        setImageData(sources, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DImageData(texture, sources, this.depth, premultiplyAlpha, invertY);
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DPixelsData(texture, source, this.depth, premultiplyAlpha, invertY);
        }
        setSubPixelsData(xOffset, yOffset, zOffset, width, height, depth, pixels, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, zOffset, width, height, depth, premultiplyAlpha, invertY);
        }
    }

    exports.TextureCubeFace = void 0;
    (function (TextureCubeFace) {
        TextureCubeFace[TextureCubeFace["PositiveX"] = 0] = "PositiveX";
        TextureCubeFace[TextureCubeFace["NegativeX"] = 1] = "NegativeX";
        TextureCubeFace[TextureCubeFace["PositiveY"] = 2] = "PositiveY";
        TextureCubeFace[TextureCubeFace["NegativeY"] = 3] = "NegativeY";
        TextureCubeFace[TextureCubeFace["PositiveZ"] = 4] = "PositiveZ";
        TextureCubeFace[TextureCubeFace["NegativeZ"] = 5] = "NegativeZ";
    })(exports.TextureCubeFace || (exports.TextureCubeFace = {}));
    const DEFAULT_PIXELS = new Uint8Array(4);
    class TextureCube extends BaseTexture {
        static get blackTexture() {
            return TextureCube._blackTexture;
        }
        static get grayTexture() {
            return TextureCube._grayTexture;
        }
        static get whiteTexture() {
            return TextureCube._whiteTexture;
        }
        static get errorTexture() {
            return TextureCube._errorTexture;
        }
        static __init__() {
            var blackTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var grayTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var writeTexture = new TextureCube(1, exports.TextureFormat.R8G8B8A8, false);
            var pixels = DEFAULT_PIXELS;
            pixels[0] = 0, pixels[1] = 0, pixels[2] = 0;
            pixels[3] = 255;
            blackTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            blackTexture.lock = true;
            pixels[0] = 128, pixels[1] = 128, pixels[2] = 128;
            pixels[3] = 255;
            grayTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            grayTexture.lock = true;
            pixels[0] = 255, pixels[1] = 255, pixels[2] = 255;
            pixels[3] = 255;
            writeTexture.setPixelsData([pixels, pixels, pixels, pixels, pixels, pixels], false, false);
            writeTexture.lock = true;
            TextureCube._grayTexture = grayTexture;
            TextureCube._blackTexture = blackTexture;
            TextureCube._whiteTexture = writeTexture;
            TextureCube._errorTexture = writeTexture;
        }
        constructor(size, format, mipmap = true, sRGB = false, premultiplyAlpha = false) {
            super(size, size, format);
            this._dimension = exports.TextureDimension.Cube;
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, size, size, format, mipmap, sRGB, premultiplyAlpha);
            return;
        }
        setImageData(source, premultiplyAlpha, invertY) {
            let error = false;
            let k = source.findIndex(s => s != null);
            if (k != -1) {
                let img = source[k];
                if (!source.every(s => s != null && s.width == img.width && s.height == img.height))
                    error = true;
            }
            else
                error = true;
            let texture = this._texture;
            if (!error)
                LayaGL.textureContext.setCubeImageData(texture, source, premultiplyAlpha, invertY);
            else {
                let pixels = DEFAULT_PIXELS;
                LayaGL.textureContext.setCubePixelsData(texture, [pixels, pixels, pixels, pixels, pixels, pixels], premultiplyAlpha, invertY);
            }
        }
        setPixelsData(source, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setCubePixelsData(texture, source, premultiplyAlpha, invertY);
        }
        updateSubPixelsData(source, xOffset, yOffset, width, height, mipmapLevel, generateMipmap, premultiplyAlpha, invertY) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeSubPixelData(texture, source, mipmapLevel, generateMipmap, xOffset, yOffset, width, height, premultiplyAlpha, invertY);
        }
        setDDSData(ddsInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeDDSData(texture, ddsInfo);
        }
        setKTXData(ktxInfo) {
            let texture = this._texture;
            LayaGL.textureContext.setCubeKTXData(texture, ktxInfo);
        }
        get defaultTexture() {
            return TextureCube.grayTexture;
        }
    }

    class MathUtil {
        static lerp(left, right, amount) {
            return left * (1 - amount) + right * amount;
        }
        static repeat(t, length) {
            return t - Math.floor(t / length) * length;
        }
        static distance(x1, y1, x2, y2) {
            return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        }
        static clamp(value, min, max) {
            if (value < min)
                value = min;
            else if (value > max)
                value = max;
            return value;
        }
        static clamp01(value) {
            if (isNaN(value))
                value = 0;
            else if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            return value;
        }
        static slerpQuaternionArray(a, Offset1, b, Offset2, t, out, Offset3) {
            var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
            var omega, cosom, sinom, scale0, scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0.0) {
                cosom = -cosom;
                bx = -bx;
                by = -by;
                bz = -bz;
                bw = -bw;
            }
            if ((1.0 - cosom) > 0.000001) {
                omega = Math.acos(cosom);
                sinom = Math.sin(omega);
                scale0 = Math.sin((1.0 - t) * omega) / sinom;
                scale1 = Math.sin(t * omega) / sinom;
            }
            else {
                scale0 = 1.0 - t;
                scale1 = t;
            }
            out[Offset3 + 0] = scale0 * ax + scale1 * bx;
            out[Offset3 + 1] = scale0 * ay + scale1 * by;
            out[Offset3 + 2] = scale0 * az + scale1 * bz;
            out[Offset3 + 3] = scale0 * aw + scale1 * bw;
            return out;
        }
        static getRotation(x0, y0, x1, y1) {
            return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
        }
        static sortBigFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? 1 : -1;
        }
        static sortSmallFirst(a, b) {
            if (a == b)
                return 0;
            return b > a ? -1 : 1;
        }
        static sortNumBigFirst(a, b) {
            return parseFloat(b) - parseFloat(a);
        }
        static sortNumSmallFirst(a, b) {
            return parseFloat(a) - parseFloat(b);
        }
        static sortByKey(key, bigFirst = false, forceNum = true) {
            var _sortFun;
            if (bigFirst) {
                _sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
            }
            else {
                _sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
            }
            return function (a, b) {
                return _sortFun(a[key], b[key]);
            };
        }
    }

    class SoundManager {
        static __init__() {
            ILaya.stage.on(Event.BLUR, () => {
                if (mgr.autoStopMusic && mgr._musicChannel && !mgr._musicChannel.paused)
                    PAL.media.resumeUntilGotFocus(mgr._musicChannel);
            });
        }
        static get musicVolume() {
            return mgr._musicVolume;
        }
        static set musicVolume(value) {
            value = MathUtil.clamp(value, 0, 1);
            if (value !== mgr._musicVolume) {
                mgr._musicVolume = value;
                if (mgr._musicChannel)
                    mgr._musicChannel.volume = mgr._musicChannel.volume;
            }
        }
        static get soundVolume() {
            return mgr._soundVolume;
        }
        static set soundVolume(value) {
            value = MathUtil.clamp(value, 0, 1);
            if (value !== mgr._soundVolume) {
                mgr._soundVolume = value;
                for (let channel of mgr._channels) {
                    if (channel !== mgr._musicChannel) {
                        channel.volume = channel.volume;
                    }
                }
            }
        }
        static get muted() {
            return mgr._muted;
        }
        static set muted(value) {
            value = !!value;
            if (value !== mgr._muted) {
                mgr._muted = value;
                this.updateMutedStatus();
            }
        }
        static get soundMuted() {
            return mgr._soundMuted;
        }
        static set soundMuted(value) {
            value = !!value;
            if (value !== mgr._soundMuted) {
                mgr._soundMuted = value;
                this.updateMutedStatus();
            }
        }
        static get musicMuted() {
            return mgr._musicMuted;
        }
        static set musicMuted(value) {
            value = !!value;
            if (value !== mgr._musicMuted) {
                mgr._musicMuted = value;
                this.updateMutedStatus();
            }
        }
        static playSound(url, loops, complete, soundClass, startTime) {
            if (!url)
                return null;
            if (typeof (soundClass) === 'number')
                startTime = soundClass;
            let channel = PAL.media.createSoundChannel(url, false);
            channel.loops = loops !== null && loops !== void 0 ? loops : 1;
            channel.startTime = startTime !== null && startTime !== void 0 ? startTime : 0;
            channel.playbackRate = this.playbackRate;
            channel.volume = 1;
            channel.muted = mgr._soundMuted || mgr._muted;
            channel.completeHandler = complete;
            channel._isMusic = false;
            channel.play();
            return channel;
        }
        static playMusic(url, loops, complete, startTime) {
            if (mgr._musicChannel) {
                mgr._musicChannel.stop();
                mgr._musicChannel = null;
            }
            if (!url)
                return null;
            let channel = PAL.media.createSoundChannel(url, mgr.useAudioMusic);
            channel.loops = loops !== null && loops !== void 0 ? loops : 1;
            channel.startTime = startTime !== null && startTime !== void 0 ? startTime : 0;
            channel.playbackRate = this.playbackRate;
            channel.volume = 1;
            channel.muted = mgr._musicMuted || mgr._muted;
            channel.completeHandler = complete;
            channel._isMusic = true;
            channel.play();
            return channel;
        }
        static stopSound(url) {
            for (let channel of mgr._channels) {
                if (channel.url == url) {
                    channel.stop();
                    if (channel === mgr._musicChannel) {
                        mgr._musicChannel = null;
                    }
                }
            }
        }
        static stopAll() {
            mgr._musicChannel = null;
            for (let channel of mgr._channels)
                channel.stop();
        }
        static stopAllSound() {
            for (let channel of mgr._channels) {
                if (channel !== mgr._musicChannel) {
                    channel.stop();
                }
            }
        }
        static stopMusic() {
            if (mgr._musicChannel)
                mgr._musicChannel.stop();
            mgr._musicChannel = null;
        }
        static setSoundVolume(volume, url) {
            if (url) {
                let channel = this.findChannel(url);
                if (channel)
                    channel.volume = volume;
            }
            else {
                this.soundVolume = volume;
            }
        }
        static setMusicVolume(volume) {
            this.musicVolume = volume;
        }
        static findChannel(url) {
            for (let channel of mgr._channels) {
                if (channel.url == url) {
                    return channel;
                }
            }
            return null;
        }
        static updateMutedStatus() {
            let s = mgr._muted || mgr._soundMuted;
            let m = mgr._muted || mgr._musicMuted;
            for (let channel of mgr._channels) {
                if (channel === mgr._musicChannel)
                    channel.muted = m;
                else
                    channel.muted = s;
            }
        }
        static addChannel(channel) {
            mgr._channels.add(channel);
            if (channel._isMusic)
                mgr._musicChannel = channel;
        }
        static removeChannel(channel) {
            mgr._channels.delete(channel);
            if (channel === mgr._musicChannel)
                mgr._musicChannel = null;
        }
    }
    SoundManager.playbackRate = 1;
    SoundManager.useAudioMusic = true;
    SoundManager.autoStopMusic = true;
    SoundManager._muted = false;
    SoundManager._soundMuted = false;
    SoundManager._musicMuted = false;
    SoundManager._musicVolume = 1;
    SoundManager._soundVolume = 1;
    SoundManager._musicChannel = null;
    SoundManager._channels = new Set();
    const mgr = SoundManager;

    class Laya {
        static init(...args) {
            if (Laya._inited)
                return Promise.resolve();
            Laya._inited = true;
            let stageConfig;
            if (typeof (args[0]) === "number") {
                stageConfig = {
                    designWidth: args[0],
                    designHeight: args[1]
                };
            }
            else
                stageConfig = args[0];
            ILaya.systemTimer = Laya.systemTimer = Timer.gSysTimer = exports.systemTimer = new Timer(false);
            ILaya.timer = Laya.timer = exports.timer = new Timer(false);
            ILaya.physicsTimer = Laya.physicsTimer = exports.physicsTimer = new Timer(false);
            ILaya.loader = Laya.loader = exports.loader = new Loader();
            PAL.__init__();
            let steps = [];
            steps.push(() => {
                let mainCanvas = Browser.mainCanvas = new HTMLCanvas(false);
                mainCanvas.source = PAL.browser.createMainCanvas();
                Browser.canvas = new HTMLCanvas(true);
                Browser.context = Browser.canvas.context;
                return PAL.browser.start();
            });
            if (LayaEnv.beforeInit)
                steps.push(() => LayaEnv.beforeInit(stageConfig));
            Laya._beforeInitCallbacks.forEach(func => steps.push(() => func(stageConfig)));
            steps.push(() => LayaGL.renderDeviceFactory.createEngine(null, Browser.mainCanvas));
            steps.push(() => Laya.initRender2D(stageConfig));
            let laya3D = window["Laya3D"];
            if (laya3D)
                steps.push(() => laya3D.__init__());
            steps.push(() => Promise.all(Laya._initCallbacks.map(func => func())));
            steps.push(() => {
                let p = Promise.resolve();
                for (let func of Laya._afterInitCallbacks)
                    p = p.then(func);
                return p;
            });
            if (LayaEnv.afterInit)
                steps.push(() => LayaEnv.afterInit());
            let p = Promise.resolve();
            for (let step of steps)
                p = p.then(step);
            return p;
        }
        static initRender2D(stageConfig) {
            PAL.browser.onInitRender();
            exports.stage = window.stage = ILaya.stage = Laya.stage = new Stage();
            exports.stage.size(stageConfig.designWidth, stageConfig.designHeight);
            if (stageConfig.scaleMode)
                exports.stage.scaleMode = stageConfig.scaleMode;
            if (stageConfig.screenMode)
                exports.stage.screenMode = stageConfig.screenMode;
            if (stageConfig.alignV)
                exports.stage.alignV = stageConfig.alignV;
            if (stageConfig.alignH)
                exports.stage.alignH = stageConfig.alignH;
            if (Config.isAlpha)
                exports.stage.bgColor = "#00000000";
            else if (stageConfig.backgroundColor)
                exports.stage.bgColor = stageConfig.backgroundColor;
            VertexElementFormat.__init__();
            VertexMesh.__init__();
            Shader3D.init();
            MeshQuadTexture.__int__();
            MeshVG.__init__();
            MeshTexture.__init__();
            ShaderDefines2D.__init__();
            Render.__init__();
            Shader2D.__init__();
            BlendMode._init_();
            Texture2D.__init__();
            TextureCube.__init__();
            Texture2DArray.__init__();
            HalfFloatUtils.__init__();
            Camera2D.shaderValueInit();
            BaseRenderNode2D.initBaseRender2DCommandEncoder();
            RenderStateContext.__init__();
            RenderSprite.__init__();
            Material.__initDefine__();
            InputManager.__init__();
            SoundManager.__init__();
            Value2D._initone(exports.RenderSpriteData.Texture2D, TextureSV);
            Value2D._initone(exports.RenderSpriteData.Primitive, PrimitiveSV);
        }
        static alertGlobalError(value) {
            if (value)
                PAL.browser.captureGlobalError(Laya._onGlobalError);
            else
                PAL.browser.captureGlobalError(null);
        }
        static _onGlobalError(ev) {
            var _a;
            let msg = "Something went wrong\n"
                + (ev.message || ev.reason)
                + "\n"
                + (ev.stack || ((_a = ev.error) === null || _a === void 0 ? void 0 : _a.stack));
            if (_erralert++ < 5)
                PAL.browser.alert(msg);
            else
                console.error(msg);
        }
        static addInitCallback(callback) {
            Laya._initCallbacks.push(callback);
        }
        static addBeforeInitCallback(callback) {
            Laya._beforeInitCallbacks.push(callback);
        }
        static addAfterInitCallback(callback) {
            Laya._afterInitCallbacks.push(callback);
        }
        static importNative(name) {
            if (!LayaEnv.isConch)
                return null;
            let path = window.$DLL_PATHS[name];
            let obj = window.importNative(path || name);
            if (!obj)
                throw new Error(`failed to load ${name}`);
            return obj;
        }
    }
    Laya.stage = null;
    Laya.systemTimer = null;
    Laya.physicsTimer = null;
    Laya.timer = null;
    Laya.loader = null;
    Laya._inited = false;
    Laya._initCallbacks = [];
    Laya._beforeInitCallbacks = [];
    Laya._afterInitCallbacks = [];
    var _erralert = 0;
    ILaya.Laya = Laya;
    ILaya.Loader = Loader;
    ILaya.Context = Context;
    ILaya.InputManager = InputManager;
    var init = Laya.init;
    exports.stage = void 0;
    exports.systemTimer = void 0;
    exports.physicsTimer = void 0;
    exports.timer = void 0;
    exports.loader = void 0;
    var alertGlobalError = Laya.alertGlobalError;
    var addInitCallback = Laya.addInitCallback;
    var addBeforeInitCallback = Laya.addBeforeInitCallback;
    var addAfterInitCallback = Laya.addAfterInitCallback;
    var importNative = Laya.importNative;

    exports.AnimationWrapMode = void 0;
    (function (AnimationWrapMode) {
        AnimationWrapMode[AnimationWrapMode["Positive"] = 0] = "Positive";
        AnimationWrapMode[AnimationWrapMode["Reverse"] = 1] = "Reverse";
        AnimationWrapMode[AnimationWrapMode["PingPong"] = 2] = "PingPong";
    })(exports.AnimationWrapMode || (exports.AnimationWrapMode = {}));
    exports.AnimationStretchMode = void 0;
    (function (AnimationStretchMode) {
        AnimationStretchMode[AnimationStretchMode["None"] = 0] = "None";
        AnimationStretchMode[AnimationStretchMode["Fill"] = 1] = "Fill";
        AnimationStretchMode[AnimationStretchMode["ResizeToFit"] = 2] = "ResizeToFit";
    })(exports.AnimationStretchMode || (exports.AnimationStretchMode = {}));
    class FrameAnimation extends Component {
        constructor() {
            super();
            this.repeatDelay = 0;
            this.timeScale = 1;
            this._wrapMode = 0;
            this._loop = true;
            this._frame = 0;
            this._autoPlay = true;
            this._stretchMode = 0;
            this._source = "";
            this._playing = false;
            this._count = 0;
            this._index = 0;
            this._elapsed = 0;
            this._loadId = 0;
            this.interval = Config.animationInterval;
            this._frames = [];
            this._drawCmds = [];
            this._delays = [];
            this._offset = new Point();
            this._color = new Color(1, 1, 1, 1);
            this._singleton = false;
            this.runInEditor = true;
        }
        get frame() {
            return LayaEnv.isPlaying ? this._frame : this._index;
        }
        set frame(value) {
            this._index = this._frame = value;
            this.drawFrame();
        }
        get frames() {
            return this._frames;
        }
        set frames(value) {
            if (this._drawCmd) {
                this.owner.graphics.removeCmd(this._drawCmd);
                this._drawCmd = null;
            }
            for (let cmd of this._drawCmds)
                cmd.recover();
            this._drawCmds.length = 0;
            this._frames.length = 0;
            if (value != null && value.length > 0) {
                this._frames.push(...value);
                let dx = 0, dy = 0;
                if (this._stretchMode === exports.AnimationStretchMode.None) {
                    dx = this._offset.x;
                    dy = this._offset.y;
                }
                let stretch = this._stretchMode === exports.AnimationStretchMode.Fill;
                for (let tex of value) {
                    let cmd = stretch ? DrawTextureCmd.create(tex, 0, 0, 1, 1, null, 1, null, null, null, true)
                        : DrawTextureCmd.create(tex, dx, dy);
                    cmd.lock = true;
                    this._drawCmds.push(cmd);
                }
                this._count = this._frames.length;
                this._elapsed = 0;
                if (this._wrapMode === exports.AnimationWrapMode.Reverse)
                    this._frame = this._count - 1;
                else {
                    this._reversed = false;
                    this._frame = 0;
                }
                if (this._stretchMode === exports.AnimationStretchMode.ResizeToFit) {
                    let w = this.width, h = this.height;
                    if (w > 0 && h > 0 || LayaEnv.isPlaying) {
                        this._changingSize = true;
                        this.owner.size(w, h);
                        this._changingSize = false;
                    }
                }
                this.drawFrame();
            }
            else {
                this._count = 0;
            }
        }
        get frameDelays() {
            return this._delays;
        }
        get isPlaying() {
            return this._playing;
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (this.enabled) {
                if (value)
                    this.play();
                else
                    this.stop();
            }
        }
        get wrapMode() {
            return this._wrapMode;
        }
        set wrapMode(value) {
            if (this._wrapMode != value) {
                this._wrapMode = value;
                if (this._playing) {
                    if (value === exports.AnimationWrapMode.Reverse)
                        this._reversed = true;
                    else if (value === exports.AnimationWrapMode.Positive)
                        this._reversed = false;
                }
            }
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            if (this._loop != value) {
                this._loop = value;
                if (value && !this._playing && this._autoPlay)
                    this.play();
            }
        }
        get stretchMode() {
            return this._stretchMode;
        }
        set stretchMode(value) {
            if (this._changingSize)
                return;
            if (this._stretchMode != value) {
                this._stretchMode = value;
                if (this._count > 0) {
                    if (this._stretchMode === exports.AnimationStretchMode.ResizeToFit) {
                        let w = this.width, h = this.height;
                        if (w > 0 && h > 0 || LayaEnv.isPlaying) {
                            this._changingSize = true;
                            this.owner.size(w, h);
                            this._changingSize = false;
                        }
                    }
                    this.applyStretchMode();
                    this.drawFrame();
                }
            }
        }
        get offset() {
            return this._offset;
        }
        set offset(value) {
            this._offset.copy(value);
            this.applyStretchMode();
            this.drawFrame();
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
            this.drawFrame();
        }
        get width() {
            return this._count > 0 ? this._frames[0].sourceWidth : 0;
        }
        get height() {
            return this._count > 0 ? this._frames[0].sourceHeight : 0;
        }
        applyStretchMode() {
            if (this._stretchMode === exports.AnimationStretchMode.Fill) {
                for (let cmd of this._drawCmds) {
                    cmd.x = cmd.y = 0;
                    cmd.width = cmd.height = 1;
                    cmd.percent = true;
                }
            }
            else {
                let dx = 0, dy = 0;
                if (this._stretchMode === exports.AnimationStretchMode.None) {
                    dx = this._offset.x;
                    dy = this._offset.y;
                }
                for (let cmd of this._drawCmds) {
                    cmd.x = dx;
                    cmd.y = dy;
                    if (cmd.texture) {
                        cmd.width = cmd.texture.sourceWidth;
                        cmd.height = cmd.texture.sourceHeight;
                    }
                    cmd.percent = false;
                }
            }
        }
        play() {
            if (this._playing)
                return;
            this._playing = true;
            this._elapsed = 0;
            this._reversed = this._wrapMode === exports.AnimationWrapMode.Reverse;
        }
        stop() {
            this._playing = false;
            if (!LayaEnv.isPlaying) {
                this._frame = this._index;
                this.drawFrame();
            }
        }
        _onEnable() {
            if (this._autoPlay)
                this.play();
        }
        _onDestroy() {
            super._onDestroy();
            this.frames = null;
            if (this._atlas) {
                if (this.owner._getBit(NodeFlags.EDITING_NODE))
                    this._atlas.off("reload", this, this.onAtlasReload);
                this._atlas = null;
            }
        }
        onUpdate() {
            if (!this._playing || this._count == 0)
                return;
            let dt = ILaya.timer.delta;
            if (dt > 100)
                dt = 100;
            if (this.timeScale != 1)
                dt *= this.timeScale;
            let frame = this._frame;
            this._elapsed += dt;
            let tt = this.interval;
            if (this._reversed) {
                if (frame > 0)
                    tt += this._delays[frame - 1] || 0;
                else
                    tt += this.repeatDelay;
            }
            else {
                tt += this._delays[frame] || 0;
                if (frame === this._count - 1)
                    tt += this.repeatDelay;
            }
            if (this._elapsed < tt)
                return;
            this._elapsed -= tt;
            if (this._elapsed > this.interval)
                this._elapsed = this.interval;
            let emit = false;
            if (this._reversed) {
                frame--;
                if (frame < 0) {
                    if (this._loop) {
                        if (this._wrapMode === exports.AnimationWrapMode.PingPong) {
                            this._reversed = false;
                            frame = 1;
                        }
                        else
                            frame = this._count - 1;
                        emit = true;
                    }
                    else {
                        frame = 0;
                        this._playing = false;
                        emit = true;
                    }
                }
            }
            else {
                frame++;
                if (frame > this._count - 1) {
                    if (this._loop) {
                        if (this._wrapMode === exports.AnimationWrapMode.PingPong) {
                            this._reversed = true;
                            frame = Math.max(0, this._count - 2);
                        }
                        else
                            frame = 0;
                        emit = true;
                    }
                    else {
                        frame = this._count - 1;
                        this._playing = false;
                        emit = true;
                    }
                }
            }
            this._frame = frame;
            if (this._playing)
                this.drawFrame();
            if (emit)
                this.owner.event(Event.COMPLETE);
        }
        drawFrame() {
            let cmd = this._drawCmds[this._frame];
            if (cmd != this._drawCmd)
                this._drawCmd = this.owner.graphics.replaceCmd(this._drawCmd, cmd);
            if (this._drawCmd)
                this._drawCmd.color = this._color.getABGR();
        }
        get source() {
            return this._source;
        }
        set source(value) {
            if (value == null)
                value = "";
            this._source = value;
            this.load();
        }
        get images() {
            return this._images;
        }
        set images(value) {
            this._images = value;
            this.load();
        }
        load() {
            if (this._atlas) {
                if (this.owner._getBit(NodeFlags.EDITING_NODE))
                    this._atlas.off("reload", this, this.onAtlasReload);
                this._atlas = null;
            }
            if (this._source)
                this.loadAtlas(this._source);
            else if (this._images && this._images.length > 0)
                this.loadImages(this._images);
            else
                this.onLoaded(null, ++this._loadId);
        }
        loadImages(urls) {
            let loadId = ++this._loadId;
            let textures = urls.map(url => Loader.getRes(url));
            if (textures.indexOf(null) === -1) {
                this.frames = textures;
                this.owner.event(Event.LOADED);
            }
            else {
                ILaya.loader.load(urls).then((textures) => {
                    if (loadId != this._loadId || this.destroyed)
                        return;
                    this.frames = textures;
                    this.owner.event(Event.LOADED);
                });
            }
            return this;
        }
        loadAtlas(url) {
            let loadId = ++this._loadId;
            let atlas = Loader.getRes(url);
            if (atlas)
                this.onLoaded(atlas, loadId);
            else
                ILaya.loader.load(url, Loader.ATLAS).then(atlas => this.onLoaded(atlas, loadId));
            return this;
        }
        setAtlas(res) {
            this.onLoaded(res, ++this._loadId);
        }
        onLoaded(atlas, loadId) {
            var _a, _b;
            if (loadId != this._loadId || this.destroyed)
                return;
            this._atlas = atlas;
            if (atlas) {
                if (this.owner._getBit(NodeFlags.EDITING_NODE))
                    this._atlas.on("reload", this, this.onAtlasReload);
                let ani = atlas.animation;
                if (ani) {
                    this.interval = ani.interval;
                    this.repeatDelay = (_a = ani.repeatDelay) !== null && _a !== void 0 ? _a : 0;
                    this.wrapMode = (_b = ani.wrapMode) !== null && _b !== void 0 ? _b : 0;
                    this._delays.length = 0;
                    if (ani.frameDelays)
                        this._delays.push(...ani.frameDelays);
                }
                this.frames = atlas.frames;
            }
            else
                this.frames = null;
            this.owner.event(Event.LOADED);
        }
        onAtlasReload() {
            this.onLoaded(this._atlas, this._loadId);
        }
    }

    class Animation extends Sprite {
        constructor() {
            super();
            this._comp = this.addComponent(FrameAnimation);
            this._comp.hideFlags |= HideFlags.HideAndDontSave;
            this._comp.autoPlay = false;
        }
        get loop() {
            return this._comp.loop;
        }
        set loop(value) {
            this._comp.loop = value;
        }
        get wrapMode() {
            return this._comp.wrapMode;
        }
        set wrapMode(value) {
            this._comp.wrapMode = value;
        }
        get interval() {
            return this._comp.interval;
        }
        set interval(value) {
            this._comp.interval = value;
        }
        get index() {
            return this._comp.frame;
        }
        set index(value) {
            this._comp.frame = value;
        }
        get count() {
            return this._comp.frames.length;
        }
        get source() {
            return this._comp.source;
        }
        set source(value) {
            this._comp.source = value;
        }
        get images() {
            return this._comp.images;
        }
        set images(value) {
            this._comp.images = value;
        }
        get isPlaying() {
            return this._comp.isPlaying;
        }
        set autoPlay(value) {
            this._comp.autoPlay = value;
        }
        get autoPlay() {
            return this._comp.autoPlay;
        }
        play(start, loop, name = "") {
            if (name)
                this._setFramesFromCache(name, true);
            if (start != null)
                this._comp.frame = (typeof (start) == 'string') ? this.getFrameByLabel(start) : start;
            if (loop != null)
                this._comp.loop = loop;
            this._comp.play();
        }
        clear() {
            this._comp.stop();
            this._comp.frames = null;
            this._labels = null;
            return this;
        }
        stop() {
            this._comp.stop();
        }
        gotoAndStop(position) {
            this.index = (typeof (position) == 'string') ? this.getFrameByLabel(position) : position;
            this.stop();
        }
        addLabel(label, index) {
            if (!this._labels)
                this._labels = [];
            this._labels[index] = label;
        }
        removeLabel(label) {
            if (!this._labels)
                return;
            for (let i = 0, n = this._labels.length; i < n; i++) {
                if (this._labels[i] == label) {
                    delete this._labels[i];
                }
            }
        }
        loadImages(urls) {
            this._comp.images = urls;
            return this;
        }
        loadAtlas(url) {
            this._comp.source = url;
            return this;
        }
        getFrameByLabel(label) {
            if (!this._labels)
                return 0;
            let i = this._labels.indexOf(label);
            return i != -1 ? i : 0;
        }
        static createFrames(urls, key) {
            Animation.framesMap[key] = urls;
            ILaya.loader.load(urls);
        }
        static clearCache(key) {
            delete Animation.framesMap[key];
        }
        _setFramesFromCache(name, showWarn = false) {
            let urls = Animation.framesMap[name];
            if (urls) {
                this.images = urls;
                return true;
            }
            else {
                if (showWarn)
                    console.log("ani not found:", name);
            }
            return false;
        }
    }
    Animation.framesMap = {};

    class BitmapFont extends Resource {
        static loadFont(path, complete) {
            ILaya.loader.load(path, Loader.FONT).then(font => {
                complete && complete.runWith(font);
            });
        }
        constructor() {
            super(false);
            this.dict = {};
            this.fontSize = 12;
            this.autoScaleSize = false;
            this.tint = true;
            this.maxWidth = 0;
            this.lineHeight = 12;
            this.letterSpacing = 0;
        }
        parseFont(xml, texture) {
            var _a;
            if (xml == null || texture == null)
                return;
            this.texture = texture;
            texture._addReference();
            let scale = 1;
            let info = xml.getNode("info");
            this.fontSize = info.getAttrInt("size", 12);
            this.autoScaleSize = info.getAttrBool("autoScaleSize");
            this.lineHeight = info.getAttrInt("lineHeight", this.fontSize);
            if (this.lineHeight == 0)
                this.lineHeight = this.fontSize;
            let padding = info.getAttrString("padding", "");
            let paddingArray = padding.split(",");
            this.padding = [parseInt(paddingArray[0]), parseInt(paddingArray[1]), parseInt(paddingArray[2]), parseInt(paddingArray[3])];
            let chars = ((_a = xml.getNode("chars")) === null || _a === void 0 ? void 0 : _a.elements("char")) || [];
            let maxWidth = 0;
            let dict = this.dict;
            for (let i = 0, n = chars.length; i < n; i++) {
                let ct = chars[i];
                let id = ct.getAttrInt("id");
                let xOffset = ct.getAttrInt("xoffset") / scale;
                let yOffset = ct.getAttrInt("yoffset") / scale;
                let advance = ct.getAttrInt("xadvance") / scale;
                let x = ct.getAttrInt("x");
                let y = ct.getAttrInt("y");
                let width = ct.getAttrInt("width");
                let height = ct.getAttrInt("height");
                let tex = Texture.create(texture, x, y, width, height, xOffset, yOffset);
                if (advance == 0)
                    advance = width;
                advance += this.letterSpacing;
                maxWidth = Math.max(maxWidth, advance);
                dict[id] = { x: 0, y: 0, width, height, advance, texture: tex };
            }
            if (maxWidth > 0)
                this.maxWidth = maxWidth;
            else
                this.maxWidth = this.fontSize;
            if (!dict[32])
                dict[32] = { x: 0, y: 0, advance: Math.floor(this.fontSize * 0.5) + this.letterSpacing };
        }
        _disposeResource() {
            var _a;
            if (this.texture) {
                for (let k in this.dict) {
                    (_a = this.dict[k].texture) === null || _a === void 0 ? void 0 : _a.destroy();
                }
                this.texture._removeReference();
                this.dict = null;
                this.texture = null;
                this.padding = null;
            }
        }
        getTextWidth(text, fontSize) {
            let w = 0;
            for (let i = 0, n = text.length; i < n; i++) {
                let g = this.dict[text.charCodeAt(i)];
                if (g) {
                    let scale = this.autoScaleSize ? (fontSize / this.fontSize) : 1;
                    w += Math.round(g.advance * scale);
                }
            }
            return w;
        }
        getMaxWidth(fontSize) {
            if (fontSize != null && this.autoScaleSize)
                return Math.round(this.maxWidth * (fontSize / this.fontSize));
            else
                return this.maxWidth;
        }
        getMaxHeight(fontSize) {
            if (fontSize != null && this.autoScaleSize)
                return Math.round(this.lineHeight * (fontSize / this.fontSize));
            else
                return this.lineHeight;
        }
    }

    class TextStyle {
        constructor() {
            this.font = "";
            this.fontSize = 12;
            this.color = "#000000";
            this.bold = false;
            this.italic = false;
            this.underline = false;
            this.underlineColor = null;
            this.strikethrough = false;
            this.strikethroughColor = null;
            this.align = 'left';
            this.valign = 'top';
            this.leading = 2;
            this.stroke = 0;
            this.strokeColor = '#000000';
            this.font = "";
            this.fontSize = 12;
            this.color = "#000000";
            this.bold = false;
            this.italic = false;
            this.underline = false;
            this.underlineColor = null;
            this.align = "left";
            this.valign = "top";
            this.alignItems = "middle";
            this.leading = 2;
            this.stroke = 0;
            this.strokeColor = "#000000";
        }
    }

    exports.HtmlElementType = void 0;
    (function (HtmlElementType) {
        HtmlElementType[HtmlElementType["Text"] = 0] = "Text";
        HtmlElementType[HtmlElementType["Link"] = 1] = "Link";
        HtmlElementType[HtmlElementType["Image"] = 2] = "Image";
        HtmlElementType[HtmlElementType["Input"] = 3] = "Input";
        HtmlElementType[HtmlElementType["Select"] = 4] = "Select";
        HtmlElementType[HtmlElementType["Object"] = 5] = "Object";
        HtmlElementType[HtmlElementType["LinkEnd"] = 6] = "LinkEnd";
    })(exports.HtmlElementType || (exports.HtmlElementType = {}));
    class HtmlElement {
        constructor() {
            this.style = new TextStyle();
        }
        getAttr(attrName) {
            if (this._attrs == null)
                return null;
            return this._attrs[attrName];
        }
        setAttr(attrName, attrValue) {
            if (this._attrs == null)
                this._attrs = {};
            this._attrs[attrName] = attrValue;
        }
        getAttrString(attrName, defValue) {
            return XMLUtils.getString(this._attrs, attrName, defValue);
        }
        getAttrInt(attrName, defValue) {
            return XMLUtils.getInt(this._attrs, attrName, defValue);
        }
        getAttrFloat(attrName, defValue) {
            return XMLUtils.getFloat(this._attrs, attrName, defValue);
        }
        getAttrBool(attrName, defValue) {
            return XMLUtils.getBool(this._attrs, attrName, defValue);
        }
        fetchAttributes() {
            this._attrs = Object.assign({}, XMLIterator.attributes);
        }
        reset() {
            this.name = null;
            this.text = null;
            if (this.obj) {
                this.obj.release();
                Pool.recoverByClass(this.obj);
                this.obj = null;
            }
            this._attrs = null;
        }
        static getFromPool(type) {
            let ele;
            if (this.pool.length > 0)
                ele = this.pool.pop();
            else
                ele = new HtmlElement();
            ele.type = type;
            if (ele.type != exports.HtmlElementType.Text && !ele._attrs)
                ele._attrs = {};
            return ele;
        }
        static returnToPool(ele) {
            if (Array.isArray(ele)) {
                for (let e of ele)
                    e.reset();
                this.pool.push(...ele);
                ele.length = 0;
            }
            else {
                ele.reset();
                this.pool.push(ele);
            }
        }
    }
    HtmlElement.pool = [];

    class HtmlImage {
        constructor() {
            this._v = 0;
            this.obj = new Sprite();
        }
        get element() {
            return this._element;
        }
        get width() {
            return this.obj.width;
        }
        get height() {
            return this.obj.height;
        }
        create(owner, element) {
            this._owner = owner;
            this._element = element;
            this._owner.objContainer.addChild(this.obj);
            let src = this._element.getAttrString("src");
            if (src)
                this.loadTexture(src);
        }
        loadTexture(src) {
            let width = this._element.getAttrInt("width", -1);
            let height = this._element.getAttrInt("height", -1);
            if (width != -1)
                this.obj.width = width;
            if (height != -1)
                this.obj.height = height;
            this._w = width;
            this._h = height;
            let res = Loader.getRes(src);
            if (res) {
                this.onLoaded(res, ++this._v);
            }
            else {
                let ver = ++this._v;
                ILaya.loader.load(src, { silent: true }).then(res => this.onLoaded(res, ver, true));
            }
        }
        onLoaded(res, ver, delayed) {
            if (!this._owner || this.obj.destroyed)
                return;
            if (ver != this._v)
                return;
            let obj = this.obj;
            let ani = this._ani;
            if (res instanceof Texture) {
                obj.texture = res;
                if (ani)
                    ani.setAtlas(null);
                if (this._w == -1)
                    obj.width = res.sourceWidth;
                if (this._h == -1)
                    obj.height = res.sourceHeight;
            }
            else if (res instanceof AtlasResource) {
                obj.texture = null;
                if (!ani) {
                    ani = this._ani = obj.addComponent(FrameAnimation);
                    ani.stretchMode = exports.AnimationStretchMode.Fill;
                    ani.autoPlay = true;
                    ani.loop = true;
                }
                ani.setAtlas(res);
                if (this._w == -1)
                    obj.width = ani.width;
                if (this._h == -1)
                    obj.height = ani.height;
            }
            else {
                obj.texture = null;
                if (ani)
                    ani.setAtlas(null);
                if (this._w == -1)
                    obj.width = 0;
                if (this._h == -1)
                    obj.height = 0;
            }
            if (delayed)
                this._owner.refreshLayout();
        }
        pos(x, y) {
            this.obj.pos(x, y);
        }
        release() {
            this.obj.removeSelf();
            this.obj.offAll();
            this.obj.texture = null;
            if (this._ani)
                this._ani.setAtlas(null);
            this._owner = null;
            this._element = null;
            this._v++;
        }
        destroy() {
            this.obj.destroy();
        }
    }

    class HtmlLink {
        constructor() {
            this._shape = new Sprite();
            this._shape.hitArea = this;
            this._shape.on(Event.CLICK, () => {
                this._owner.bubbleEvent(Event.LINK, this._element.getAttrString("href"));
            });
            this._rects = [];
            this._rectCnt = 0;
        }
        get element() {
            return this._element;
        }
        get width() {
            return 0;
        }
        get height() {
            return 0;
        }
        create(owner, element) {
            this._owner = owner;
            this._element = element;
            this._owner.objContainer.addChild(this._shape);
        }
        resetArea() {
            this._rectCnt = 0;
        }
        addRect(x, y, width, height) {
            let rect = this._rects[this._rectCnt];
            if (!rect)
                rect = this._rects[this._rectCnt] = new Rectangle();
            this._rectCnt++;
            rect.setTo(x, y, width, height);
        }
        contains(x, y) {
            for (let i = 0; i < this._rectCnt; i++) {
                if (this._rects[i].contains(x, y))
                    return true;
            }
            return false;
        }
        pos(x, y) {
        }
        release() {
            this._shape.removeSelf();
            this._owner = null;
            this._element = null;
        }
        destroy() {
            this._shape.destroy();
        }
    }

    class HtmlParseOptions {
        constructor() {
            this.linkUnderline = HtmlParseOptions.defaultLinkUnderline;
            this.linkColor = HtmlParseOptions.defaultLinkColor;
        }
    }
    HtmlParseOptions.defaultLinkUnderline = true;
    HtmlParseOptions.defaultLinkColor = null;
    ClassUtils.regClass("HtmlParseOptions", HtmlParseOptions);

    const s_list1 = new Array();
    const s_list2 = new Array();
    class HtmlParser {
        constructor() {
            this._styleStack = new Array();
            this._style = new TextStyle();
            this._options = new HtmlParseOptions();
        }
        parse(aSource, style, out, options) {
            if (options == null)
                options = this._options;
            this._elements = out;
            this._styleStackTop = 0;
            Object.assign(this._style, style);
            this._style.colorChanged = false;
            let skipText = 0;
            let ignoreWhiteSpace = options.ignoreWhiteSpace;
            let skipNextCR = false;
            let text;
            XMLIterator.begin(aSource, true);
            while (XMLIterator.nextTag()) {
                if (skipText == 0) {
                    text = XMLIterator.getText(ignoreWhiteSpace);
                    if (text.length > 0) {
                        if (skipNextCR && text[0] == '\n')
                            text = text.substring(1);
                        this.appendText(text);
                    }
                }
                skipNextCR = false;
                switch (XMLIterator.tagName) {
                    case "b":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.bold = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "i":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.italic = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "u":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.underline = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "strike":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.strikethrough = true;
                        }
                        else
                            this.popStyle();
                        break;
                    case "font":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.fontSize = XMLUtils.getInt(XMLIterator.attributes, "size", this._style.fontSize);
                            let color = XMLIterator.getAttribute("color");
                            if (color != null) {
                                this._style.color = color;
                                this._style.colorChanged = true;
                            }
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End)
                            this.popStyle();
                        break;
                    case "br":
                        this.appendText("\n");
                        break;
                    case "img":
                        if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Image);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            element.style.align = this._style.align;
                            element.style.underline = this._style.underline;
                            element.style.underlineColor = this._style.underlineColor;
                            this._elements.push(element);
                        }
                        break;
                    case "a":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.underline = this._style.underline || options.linkUnderline;
                            if (!this._style.colorChanged && options.linkColor != null)
                                this._style.color = options.linkColor;
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Link);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            element.style.align = this._style.align;
                            this._elements.push(element);
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End) {
                            this.popStyle();
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.LinkEnd);
                            this._elements.push(element);
                        }
                        break;
                    case "input":
                        {
                            let element = HtmlElement.getFromPool(exports.HtmlElementType.Input);
                            element.fetchAttributes();
                            element.name = element.getAttrString("name");
                            Object.assign(element.style, this._style);
                            this._elements.push(element);
                        }
                        break;
                    case "select":
                        {
                            if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void) {
                                let element = HtmlElement.getFromPool(exports.HtmlElementType.Select);
                                element.fetchAttributes();
                                if (XMLIterator.tagType == exports.XMLTagType.Start) {
                                    s_list1.length = 0;
                                    s_list2.length = 0;
                                    while (XMLIterator.nextTag()) {
                                        if (XMLIterator.tagName == "select")
                                            break;
                                        if (XMLIterator.tagName == "option") {
                                            if (XMLIterator.tagType == exports.XMLTagType.Start || XMLIterator.tagType == exports.XMLTagType.Void)
                                                s_list2.push(XMLUtils.getString(XMLIterator.attributes, "value", ""));
                                            else
                                                s_list1.push(XMLIterator.getText());
                                        }
                                    }
                                    element.setAttr("items", s_list1.slice());
                                    element.setAttr("values", s_list2.slice());
                                }
                                element.name = element.getAttrString("name");
                                Object.assign(element.style, this._style);
                                this._elements.push(element);
                            }
                        }
                        break;
                    case "p":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            this.pushStyle();
                            this._style.align = XMLIterator.getAttribute("align");
                            if (!this.isNewLine())
                                this.appendText("\n");
                        }
                        else if (XMLIterator.tagType == exports.XMLTagType.End) {
                            this.appendText("\n");
                            skipNextCR = true;
                            this.popStyle();
                        }
                        break;
                    case "ui":
                    case "div":
                    case "li":
                        if (XMLIterator.tagType == exports.XMLTagType.Start) {
                            if (!this.isNewLine())
                                this.appendText("\n");
                        }
                        else {
                            this.appendText("\n");
                            skipNextCR = true;
                        }
                        break;
                    case "html":
                    case "body":
                        ignoreWhiteSpace = true;
                        break;
                    case "head":
                    case "style":
                    case "script":
                    case "form":
                        if (XMLIterator.tagType == exports.XMLTagType.Start)
                            skipText++;
                        else if (XMLIterator.tagType == exports.XMLTagType.End)
                            skipText--;
                        break;
                }
            }
            if (skipText == 0) {
                text = XMLIterator.getText(ignoreWhiteSpace);
                if (text.length > 0) {
                    if (skipNextCR && text[0] == '\n')
                        text = text.substring(1);
                    this.appendText(text);
                }
            }
            this._elements = null;
        }
        pushStyle() {
            let tf;
            if (this._styleStack.length <= this._styleStackTop) {
                tf = new TextStyle();
                this._styleStack.push(tf);
            }
            else
                tf = this._styleStack[this._styleStackTop];
            Object.assign(tf, this._style);
            this._styleStackTop++;
        }
        popStyle() {
            if (this._styleStackTop > 0) {
                let tf = this._styleStack[this._styleStackTop - 1];
                Object.assign(this._style, tf);
                this._styleStackTop--;
            }
        }
        isNewLine() {
            if (this._elements.length > 0) {
                let element = this._elements[this._elements.length - 1];
                if (element && element.type == exports.HtmlElementType.Text)
                    return element.text.endsWith("\n");
                else
                    return false;
            }
            return true;
        }
        appendText(text) {
            let element;
            if (this._elements.length > 0) {
                element = this._elements[this._elements.length - 1];
                if (element.type == exports.HtmlElementType.Text && equalStyle(element.style, this._style)) {
                    element.text += text;
                    return;
                }
            }
            element = HtmlElement.getFromPool(exports.HtmlElementType.Text);
            element.text = text;
            Object.assign(element.style, this._style);
            this._elements.push(element);
        }
    }
    HtmlParser.defaultParser = new HtmlParser();
    HtmlParser.classMap = {
        [exports.HtmlElementType.Image]: HtmlImage,
        [exports.HtmlElementType.Link]: HtmlLink
    };
    function equalStyle(s1, s2) {
        for (let k in s1) {
            if (!k.startsWith("_") && s1[k] != s2[k])
                return false;
        }
        return true;
    }

    class UBBParser {
        constructor() {
            this._readPos = 0;
            this.defaultImgWidth = 0;
            this.defaultImgHeight = 0;
            this._handlers = {};
            this._handlers["url"] = this.onTag_URL;
            this._handlers["img"] = this.onTag_IMG;
            this._handlers["b"] = this.onTag_B;
            this._handlers["i"] = this.onTag_I;
            this._handlers["u"] = this.onTag_U;
            this._handlers["sup"] = this.onTag_Simple;
            this._handlers["sub"] = this.onTag_Simple;
            this._handlers["color"] = this.onTag_COLOR;
            this._handlers["font"] = this.onTag_FONT;
            this._handlers["size"] = this.onTag_SIZE;
        }
        onTag_URL(tagName, end, attr) {
            if (!end) {
                if (attr != null)
                    return "<a href=\"" + attr + "\">";
                else {
                    var href = this.getTagText();
                    return "<a href=\"" + href + "\">";
                }
            }
            else
                return "</a>";
        }
        onTag_IMG(tagName, end, attr) {
            if (!end) {
                var src = this.getTagText(true);
                if (!src)
                    return null;
                if (this.defaultImgWidth)
                    return "<img src=\"" + src + "\" width=\"" + this.defaultImgWidth + "\" height=\"" + this.defaultImgHeight + "\"/>";
                else
                    return "<img src=\"" + src + "\"/>";
            }
            else
                return null;
        }
        onTag_B(tagName, end, attr) {
            return end ? ("</b>") : ("<b>");
        }
        onTag_I(tagName, end, attr) {
            return end ? ("</i>") : ("<i>");
        }
        onTag_U(tagName, end, attr) {
            return end ? ("</u>") : ("<u>");
        }
        onTag_Simple(tagName, end, attr) {
            return end ? ("</" + tagName + ">") : ("<" + tagName + ">");
        }
        onTag_COLOR(tagName, end, attr) {
            if (!end) {
                this.lastColor = attr;
                return "<font color=\"" + attr + "\">";
            }
            else
                return "</font>";
        }
        onTag_FONT(tagName, end, attr) {
            if (!end)
                return "<font face=\"" + attr + "\">";
            else
                return "</font>";
        }
        onTag_SIZE(tagName, end, attr) {
            if (!end) {
                this.lastSize = attr;
                return "<font size=\"" + attr + "\">";
            }
            else
                return "</font>";
        }
        getTagText(remove) {
            var pos1 = this._readPos;
            var pos2;
            var result = "";
            while ((pos2 = this._text.indexOf("[", pos1)) != -1) {
                if (this._text.charCodeAt(pos2 - 1) == 92) {
                    result += this._text.substring(pos1, pos2 - 1);
                    result += "[";
                    pos1 = pos2 + 1;
                }
                else {
                    result += this._text.substring(pos1, pos2);
                    break;
                }
            }
            if (pos2 == -1)
                return null;
            if (remove)
                this._readPos = pos2;
            return result;
        }
        parse(text, remove) {
            this._text = text;
            this.lastColor = null;
            this.lastSize = null;
            var pos1 = 0, pos2, pos3;
            var end;
            var tag, attr;
            var repl;
            var func;
            var result = "";
            while ((pos2 = text.indexOf("[", pos1)) != -1) {
                if (pos2 > 0 && text.charCodeAt(pos2 - 1) == 92) {
                    result += text.substring(pos1, pos2 - 1);
                    result += "[";
                    pos1 = pos2 + 1;
                    continue;
                }
                result += text.substring(pos1, pos2);
                pos1 = pos2;
                pos2 = text.indexOf("]", pos1);
                if (pos2 == -1)
                    break;
                end = text.charAt(pos1 + 1) == '/';
                tag = text.substring(end ? pos1 + 2 : pos1 + 1, pos2);
                this._readPos = pos2 + 1;
                attr = null;
                repl = null;
                pos3 = tag.indexOf("=");
                if (pos3 != -1) {
                    attr = tag.substring(pos3 + 1);
                    tag = tag.substring(0, pos3);
                }
                tag = tag.toLowerCase();
                func = this._handlers[tag];
                if (func != null) {
                    if (!remove) {
                        repl = func.call(this, tag, end, attr);
                        if (repl != null)
                            result += repl;
                    }
                }
                else
                    result += text.substring(pos1, this._readPos);
                pos1 = this._readPos;
            }
            if (pos1 < text.length)
                result += text.substring(pos1);
            this._text = null;
            return result;
        }
    }
    UBBParser.defaultParser = new UBBParser();

    class Text extends Sprite {
        constructor() {
            super();
            this._overflow = Text.VISIBLE;
            this._singleCharRender = false;
            this._prompt = '';
            this._wordWrap = false;
            this._asPassword = false;
            this._textWidth = 0;
            this._textHeight = 0;
            this._html = false;
            this._ubb = false;
            this._maxWidth = 0;
            this._hideText = false;
            this._textStyle = new TextStyle();
            this._textStyle.fontSize = Config.defaultFontSize;
            this._text = "";
            this.font = "";
            this._elements = [];
            this._lines = [];
            this._padding = [0, 0, 0, 0];
            this._fontSizeScale = 1;
        }
        static registerBitmapFont(name, bitmapFont) {
            bitmapFont._addReference();
            Text._bitmapFonts[name] = bitmapFont;
        }
        static unregisterBitmapFont(name, destroy = true) {
            let font = Text._bitmapFonts[name];
            if (font) {
                font._removeReference();
                if (destroy)
                    font.destroy();
                delete Text._bitmapFonts[name];
            }
        }
        destroy(destroyChild = true) {
            recoverLines(this._lines);
            HtmlElement.returnToPool(this._elements);
            super.destroy(destroyChild);
        }
        _getBoundPointsM(ifRotate, out) {
            return Rectangle.TEMP.setTo(0, 0, this._isWidthSet ? this._width : this._textWidth, this._isHeightSet ? this._height : this._textHeight).getBoundPoints(out);
        }
        getGraphicBounds(realSize, out) {
            return (out || new Rectangle).setTo(0, 0, this.width, this.height);
        }
        measureWidth() {
            this.typeset();
            return this._textWidth;
        }
        measureHeight() {
            this.typeset();
            return this._textHeight;
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Size) != 0) {
                if (!this._updatingLayout)
                    this.markChanged();
                else
                    this.drawBg();
            }
        }
        get textWidth() {
            this.typeset();
            return this._textWidth;
        }
        get textHeight() {
            this.typeset();
            return this._textHeight;
        }
        get text() {
            return this._text;
        }
        set text(value) {
            if (value == null)
                value = "";
            else if (typeof (value) !== "string")
                value = '' + value;
            if (!this.ignoreLang && Text.langPacks)
                value = Text.langPacks[value] || value;
            if (this._text != value) {
                this._text = value;
                this.markChanged();
                this.event(Event.CHANGE);
            }
        }
        changeText(text) {
            this.text = text;
        }
        get font() {
            return this._textStyle.font;
        }
        set font(value) {
            this._textStyle.font = value;
            if (!value) {
                value = Config.defaultFont;
                if (!value)
                    value = "Arial";
            }
            this._realFont = value;
            this._bitmapFont = Text._bitmapFonts[value];
            if (this._bitmapFont) {
                if (this._text)
                    this.markChanged();
            }
            else if (value && (Utils.getFileExtension(value) || value.startsWith("res://"))) {
                let t = value;
                let fontObj = ILaya.loader.getRes(value);
                if (!fontObj || fontObj.obsolute) {
                    ILaya.loader.load(value).then(fontObj => {
                        if (this._realFont != t)
                            return;
                        if (!fontObj)
                            this._realFont = "arial";
                        else if (fontObj instanceof BitmapFont)
                            this._bitmapFont = fontObj;
                        else
                            this._realFont = fontObj.family;
                        if (this._text)
                            this.markChanged();
                    });
                }
                else {
                    if (fontObj instanceof BitmapFont)
                        this._bitmapFont = fontObj;
                    else
                        this._realFont = fontObj.family;
                    if (this._text)
                        this.markChanged();
                }
            }
            else {
                this._realFont = (Browser.onIPhone ? (Config.fontFamilyMap[value] || value) : value);
                if (this._text)
                    this.markChanged();
            }
        }
        get realFont() {
            return this._realFont;
        }
        get fontSize() {
            return this._textStyle.fontSize;
        }
        set fontSize(value) {
            if (this._textStyle.fontSize != value) {
                this._textStyle.fontSize = value;
                this.markChanged();
            }
        }
        get color() {
            return this._textStyle.color;
        }
        set color(value) {
            if (this._textStyle.color != value) {
                this._textStyle.color = value;
                if (!this._isChanged && this._graphics && this._elements.length == 0)
                    this._graphics.replaceTextColor(this._textStyle.color);
                else
                    this.markChanged();
            }
        }
        get bold() {
            return this._textStyle.bold;
        }
        set bold(value) {
            if (this._textStyle.bold != value) {
                this._textStyle.bold = value;
                this.markChanged();
            }
        }
        get italic() {
            return this._textStyle.italic;
        }
        set italic(value) {
            if (this._textStyle.italic != value) {
                this._textStyle.italic = value;
                this.markChanged();
            }
        }
        get align() {
            return this._textStyle.align;
        }
        set align(value) {
            if (this._textStyle.align != value) {
                this._textStyle.align = value;
                this.markChanged();
            }
        }
        get valign() {
            return this._textStyle.valign;
        }
        set valign(value) {
            if (this._textStyle.valign != value) {
                this._textStyle.valign = value;
                this.markChanged();
            }
        }
        get alignItems() {
            return this._textStyle.alignItems;
        }
        set alignItems(value) {
            if (this._textStyle.alignItems != value) {
                this._textStyle.alignItems = value;
                this.markChanged();
            }
        }
        get wordWrap() {
            return this._wordWrap;
        }
        set wordWrap(value) {
            if (this._wordWrap != value) {
                this._wordWrap = value;
                this.markChanged();
            }
        }
        get leading() {
            return this._textStyle.leading;
        }
        set leading(value) {
            if (this._textStyle.leading != value) {
                this._textStyle.leading = value;
                this.markChanged();
            }
        }
        get padding() {
            return this._padding;
        }
        set padding(value) {
            if (typeof (value) == 'string') {
                let arr = value.split(",");
                this._padding.length = 0;
                for (let i = 0; i < 4; i++) {
                    let v = parseFloat(arr[i]);
                    if (isNaN(v))
                        v = 0;
                    this._padding.push(v);
                }
            }
            else
                this._padding = value;
            this.markChanged();
        }
        get bgColor() {
            return this._bgColor;
        }
        set bgColor(value) {
            this._bgColor = value;
            this.drawBg();
        }
        get borderColor() {
            return this._borderColor;
        }
        set borderColor(value) {
            this._borderColor = value;
            this.drawBg();
        }
        get stroke() {
            return this._textStyle.stroke;
        }
        set stroke(value) {
            if (this._textStyle.stroke != value) {
                this._textStyle.stroke = value;
                this.markChanged();
            }
        }
        get strokeColor() {
            return this._textStyle.strokeColor;
        }
        set strokeColor(value) {
            if (this._textStyle.strokeColor != value) {
                this._textStyle.strokeColor = value;
                this.markChanged();
            }
        }
        get overflow() {
            return this._overflow;
        }
        set overflow(value) {
            if (this._overflow != value) {
                this._overflow = value;
                this.markChanged();
            }
        }
        get underline() {
            return this._textStyle.underline;
        }
        set underline(value) {
            if (this._textStyle.underline != value) {
                this._textStyle.underline = value;
                this.markChanged();
            }
        }
        get underlineColor() {
            return this._textStyle.underlineColor;
        }
        set underlineColor(value) {
            if (this._textStyle.underlineColor != value) {
                this._textStyle.underlineColor = value;
                this.markChanged();
            }
        }
        get strikethrough() {
            return this._textStyle.strikethrough;
        }
        set strikethrough(value) {
            if (this._textStyle.strikethrough != value) {
                this._textStyle.strikethrough = value;
                this.markChanged();
            }
        }
        get strikethroughColor() {
            return this._textStyle.strikethroughColor;
        }
        set strikethroughColor(value) {
            if (this._textStyle.strikethroughColor != value) {
                this._textStyle.strikethroughColor = value;
                this.markChanged();
            }
        }
        get singleCharRender() {
            return this._singleCharRender;
        }
        set singleCharRender(value) {
            this._singleCharRender = value;
        }
        get html() {
            return this._html;
        }
        set html(value) {
            if (this._html != value) {
                this._html = value;
                this.markChanged();
            }
        }
        get ubb() {
            return this._ubb;
        }
        set ubb(value) {
            if (this._ubb != value) {
                this._ubb = value;
                this.markChanged();
            }
        }
        get maxWidth() {
            return this._maxWidth;
        }
        set maxWidth(value) {
            if (this._maxWidth != value) {
                this._maxWidth = value;
                this.markChanged();
            }
        }
        get htmlParseOptions() {
            return this._htmlParseOptions;
        }
        set htmlParseOptions(value) {
            this._htmlParseOptions = value;
        }
        get templateVars() {
            return this._templateVars;
        }
        set templateVars(value) {
            if (!this._templateVars && !value)
                return;
            if (value === true)
                this._templateVars = {};
            else if (value === false)
                this._templateVars = null;
            else
                this._templateVars = value;
            this.markChanged();
        }
        setVar(name, value) {
            if (!this._templateVars)
                this._templateVars = {};
            this._templateVars[name] = value;
            this.markChanged();
            return this;
        }
        get scrollX() {
            if (!this._scrollPos)
                return 0;
            return this._scrollPos.x;
        }
        set scrollX(value) {
            this.typeset();
            if (!this._scrollPos)
                return;
            let maxScrollX = this.maxScrollX;
            value = value < 0 ? 0 : value;
            value = value > maxScrollX ? maxScrollX : value;
            this._scrollPos.x = value;
            this.renderText();
        }
        get scrollY() {
            if (!this._scrollPos)
                return 0;
            return this._scrollPos.y;
        }
        set scrollY(value) {
            this.typeset();
            if (!this._scrollPos)
                return;
            let maxScrollY = this.maxScrollY;
            value = value < 0 ? 0 : value;
            value = value > maxScrollY ? maxScrollY : value;
            this._scrollPos.y = value;
            this.renderText();
        }
        get maxScrollX() {
            let r = this.textWidth - this._width;
            return r < 0 ? 0 : r;
        }
        get maxScrollY() {
            let r = this.textHeight - this._height;
            return r < 0 ? 0 : r;
        }
        get lines() {
            this.typeset();
            return this._lines;
        }
        markChanged() {
            if (!this._isChanged) {
                this._isChanged = true;
                ILaya.systemTimer.callLater(this, this._typeset);
            }
        }
        typeset() {
            this._isChanged && ILaya.systemTimer.runCallLater(this, this._typeset);
        }
        refreshLayout() {
            ILaya.systemTimer.callLater(this, this.doLayout);
        }
        get objContainer() {
            if (!this._objContainer) {
                this._objContainer = new Sprite();
                this._objContainer.hideFlags |= HideFlags.HideAndDontSave;
                this.addChild(this._objContainer);
            }
            return this._objContainer;
        }
        hideText(value) {
            this._hideText = value;
            if (value) {
                if (this._bgDrawCmd)
                    this.graphics.removeCmd(this._bgDrawCmd);
                this.graphics.clear(true);
                this.drawBg();
            }
            else {
                this.markChanged();
                this.typeset();
            }
        }
        _typeset() {
            this._isChanged = false;
            if (this._hideText || this._destroyed)
                return;
            HtmlElement.returnToPool(this._elements);
            if (this._objContainer)
                this._objContainer.removeChildren();
            let text = this._text;
            if (this._onTranslate)
                text = this._onTranslate(text, this._templateVars);
            let isPrompt;
            if (!text && this._prompt) {
                text = this._prompt;
                isPrompt = true;
            }
            if (!text) {
                if (this._bgDrawCmd)
                    this.graphics.removeCmd(this._bgDrawCmd);
                this.graphics.clear(true);
                this.drawBg();
                this._textWidth = this._textHeight = 0;
                this._scrollPos = null;
                if (this._onPostLayout) {
                    this._updatingLayout = true;
                    this._onPostLayout();
                    this._updatingLayout = false;
                }
                return;
            }
            let html = this._html;
            text = text.replace(normalizeCR, "\n");
            if (this._parseEscapeChars)
                text = text.replace(escapeCharsPattern, getReplaceStr);
            if (!isPrompt && this._templateVars)
                text = Utils.parseTemplate(text, this._templateVars);
            if (this._ubb) {
                text = UBBParser.defaultParser.parse(text);
                html = true;
            }
            if (!isPrompt && this._asPassword)
                text = Text._passwordChar.repeat(text.length);
            let saveColor;
            if (isPrompt) {
                saveColor = this._textStyle.color;
                this._textStyle.color = this._promptColor;
            }
            if (html)
                HtmlParser.defaultParser.parse(text, this._textStyle, this._elements, this._htmlParseOptions);
            else {
                let ele = HtmlElement.getFromPool(exports.HtmlElementType.Text);
                Object.assign(ele.style, this._textStyle);
                ele.text = text;
                this._elements.push(ele);
            }
            if (isPrompt)
                this._textStyle.color = saveColor;
            this.doLayout();
        }
        doLayout() {
            if (this._destroyed)
                return;
            this._updatingLayout = true;
            this._fontSizeScale = 1;
            let wordWrap = this._wordWrap || this._overflow == Text.ELLIPSIS;
            let noBreakWord = this._wordWrap;
            let padding = this._padding;
            let rectWidth;
            if (this._isWidthSet)
                rectWidth = this._width - padding[3] - padding[1];
            else
                rectWidth = Number.MAX_VALUE;
            if (this._maxWidth > 0) {
                let m = this._maxWidth - padding[3] - padding[1];
                if (!wordWrap || m < rectWidth)
                    rectWidth = m;
                wordWrap = true;
            }
            let rectHeight = this._isHeightSet ? (this._height - padding[0] - padding[2]) : Number.MAX_VALUE;
            let bfont = this._bitmapFont;
            let alignItems = this._textStyle.alignItems == "middle" ? 1 : (this._textStyle.alignItems == "bottom" ? 2 : 0);
            let lineX, lineY;
            let curLine;
            let lastCmd;
            let charWidth, charHeight;
            let fontSize;
            let ctxFont;
            let getTextWidth = (text) => {
                if (bfont)
                    return bfont.getTextWidth(text, fontSize);
                else {
                    let ret = Browser.context.measureText(text);
                    return ret ? ret.width : 100;
                }
            };
            let getTextWidth2 = (text, font, fontSize) => {
                if (bfont) {
                    return bfont.getTextWidth(text, fontSize);
                }
                else {
                    let t = Browser.context.font;
                    Browser.context.font = font;
                    let ret = Browser.context.measureText(text);
                    Browser.context.font = t;
                    return ret ? ret.width : 100;
                }
            };
            let buildLines = (text, style) => {
                fontSize = Math.floor(style.fontSize * this._fontSizeScale);
                if (fontSize == 0)
                    fontSize = 1;
                if (bfont) {
                    charWidth = bfont.getMaxWidth(fontSize);
                    charHeight = bfont.getMaxHeight(fontSize);
                }
                else {
                    Browser.context.font = ctxFont = (style.italic ? "italic " : "") + (style.bold ? "bold " : "") + fontSize + "px " + this._realFont;
                    let mr = Browser.context.measureText(Text._testWord);
                    if (mr) {
                        charWidth = mr.width;
                        charHeight = Math.ceil(mr.height || fontSize);
                    }
                    else {
                        charWidth = 100;
                        charHeight = fontSize;
                    }
                }
                let lines = text.split("\n");
                if (wordWrap) {
                    for (let i = 0, n = lines.length; i < n; i++) {
                        let line = lines[i];
                        if (line.length > 0)
                            wrapText(line, style);
                        if (i != n - 1) {
                            addLine();
                        }
                    }
                }
                else {
                    for (let i = 0, n = lines.length; i < n; i++) {
                        let line = lines[i];
                        if (line.length > 0)
                            addCmd(line, style, null);
                        if (i != n - 1) {
                            addLine();
                        }
                    }
                }
            };
            let addCmd = (target, style, width) => {
                let cmd = cmdPool.length > 0 ? cmdPool.pop() : {};
                cmd.x = lineX;
                cmd.y = lineY;
                if (typeof (target) === "string") {
                    if (!width)
                        width = getTextWidth(target);
                    if (!cmd.wt)
                        cmd.wt = new WordText$1();
                    cmd.wt.setText(target);
                    cmd.wt.width = width;
                    cmd.wt.splitRender = this._singleCharRender;
                    cmd.ctxFont = ctxFont;
                    cmd.fontSize = fontSize;
                    cmd.width = width;
                    cmd.height = charHeight;
                }
                else {
                    cmd.obj = target;
                    cmd.width = target.width;
                    cmd.height = target.height;
                    if (target.width > 0) {
                        cmd.x++;
                        cmd.width += 2;
                    }
                }
                cmd.style = style;
                cmd.linkEnd = false;
                cmd.next = null;
                cmd.prev = lastCmd;
                lineX += Math.round(cmd.width);
                if (lastCmd)
                    lastCmd.next = cmd;
                else
                    curLine.cmd = cmd;
                lastCmd = cmd;
            };
            let moveCmds = (cmd) => {
                while (cmd.linkEnd && cmd.next) {
                    cmd = cmd.next;
                }
                if (!cmd)
                    return;
                cmd.prev.next = null;
                while (cmd) {
                    let next = cmd.next;
                    cmd.x = lineX;
                    cmd.y = lineY;
                    cmd.next = null;
                    cmd.prev = lastCmd;
                    lineX += Math.round(cmd.width);
                    if (lastCmd)
                        lastCmd.next = cmd;
                    else
                        curLine.cmd = cmd;
                    lastCmd = cmd;
                    cmd = next;
                }
            };
            let splitCmd = (cmd, pos) => {
                let ccode = cmd.wt.text.charCodeAt(pos);
                if (isLowSurrogate(ccode))
                    pos--;
                if (pos == 0)
                    return false;
                let str = cmd.wt.text.substring(pos);
                cmd.wt.setText(cmd.wt.text.substring(0, pos));
                cmd.width = cmd.wt.width = getTextWidth2(cmd.wt.text, cmd.ctxFont, cmd.fontSize);
                let cmd2 = cmdPool.length > 0 ? cmdPool.pop() : {};
                if (!cmd2.wt)
                    cmd2.wt = new WordText$1();
                cmd2.wt.setText(str);
                cmd2.style = cmd.style;
                cmd2.ctxFont = cmd.ctxFont;
                cmd2.fontSize = cmd.fontSize;
                cmd2.width = cmd2.wt.width = getTextWidth2(str, cmd.ctxFont, cmd.fontSize);
                cmd2.height = cmd.height;
                cmd2.next = cmd.next;
                cmd2.prev = cmd;
                cmd.next = cmd2;
                return true;
            };
            let addLine = (last) => {
                lineX = 0;
                if (curLine) {
                    let lineHeight = 0;
                    let lineWidth = 0;
                    let cmd = curLine.cmd;
                    while (cmd) {
                        if (cmd.height > lineHeight)
                            lineHeight = cmd.height;
                        lineWidth += cmd.width;
                        cmd = cmd.next;
                    }
                    cmd = curLine.cmd;
                    while (cmd) {
                        if (alignItems == 1)
                            cmd.y = Math.floor((lineHeight - cmd.height) * 0.5);
                        else if (alignItems == 2)
                            cmd.y = Math.floor((lineHeight - cmd.height));
                        else
                            cmd.y = 0;
                        cmd = cmd.next;
                    }
                    if (lineHeight == 0)
                        lineHeight = charHeight;
                    lineHeight++;
                    curLine.height = lineHeight;
                    curLine.width = Math.round(lineWidth);
                    lineY += curLine.height + Math.floor(this._textStyle.leading * this._fontSizeScale);
                }
                if (last)
                    return null;
                curLine = linePool.length > 0 ? linePool.pop() : {};
                curLine.x = 0;
                curLine.y = lineY;
                this._lines.push(curLine);
                lastCmd = null;
                return curLine;
            };
            let wrapText = (text, style) => {
                let remainWidth = Math.max(0, rectWidth - lineX);
                let tw = getTextWidth(text);
                if (tw <= remainWidth) {
                    addCmd(text, style, tw);
                    return;
                }
                let maybeIndex = 0;
                let wordWidth = 0;
                let startIndex = 0;
                let isPunc;
                let testResult;
                let isEmoji = emojiTest.test(text);
                if (!bfont && !isEmoji) {
                    maybeIndex = Math.floor(remainWidth / charWidth);
                    if (maybeIndex != 0)
                        wordWidth = getTextWidth(text.substring(0, maybeIndex));
                }
                let len = text.length;
                for (let j = maybeIndex; j < len; j++) {
                    let cc = text.charAt(j);
                    let ccode = cc.charCodeAt(0);
                    if (isEmoji && isHighSurrogate(ccode) && j + 1 < len)
                        cc += text.charAt(j + 1);
                    tw = getTextWidth(cc);
                    wordWidth += tw;
                    if (wordWidth <= remainWidth || j === startIndex && lineX === 0) {
                        if (cc.length > 1)
                            j++;
                        continue;
                    }
                    let part = text.substring(startIndex, j);
                    wordWidth -= tw;
                    if (noBreakWord && ((ccode >= 65 && ccode <= 90) || (ccode >= 97 && ccode <= 122)
                        || (ccode >= 48 && ccode <= 57)
                        || (isPunc = punctuationChars.includes(ccode)))) {
                        let wb = part.length > 0 ? ((testResult = wordBoundaryTest.exec(part)) ? testResult.index : null) : 0;
                        if (wb > 0) {
                            if (wb > part.length - maxWordLength) {
                                j = startIndex + wb;
                                part = text.substring(startIndex, j);
                                wordWidth = null;
                                tw = null;
                            }
                        }
                        else if (wb != null && lastCmd != null) {
                            let cmd = lastCmd;
                            let totalLen = part.length;
                            let newLine = false;
                            while (cmd) {
                                if (cmd.width > 0) {
                                    if (cmd.obj != null)
                                        break;
                                    testResult = wordBoundaryTest.exec(cmd.wt.text);
                                    let textLen = cmd.wt.text.length;
                                    if (testResult == null) {
                                        addLine();
                                        if (isPunc && totalLen == 0) {
                                            if (splitCmd(cmd, textLen - 1))
                                                moveCmds(cmd.next);
                                            else if (cmd.x > 0)
                                                moveCmds(cmd);
                                        }
                                        else if (cmd.next != null)
                                            moveCmds(cmd.next);
                                        newLine = true;
                                        break;
                                    }
                                    else if (testResult.index > 0) {
                                        if (testResult.index > textLen - (maxWordLength - totalLen)) {
                                            addLine();
                                            splitCmd(cmd, testResult.index);
                                            moveCmds(cmd.next);
                                            newLine = true;
                                        }
                                        break;
                                    }
                                    else {
                                        totalLen += textLen;
                                        if (totalLen >= maxWordLength)
                                            break;
                                    }
                                }
                                cmd = cmd.prev;
                            }
                            if (newLine) {
                                remainWidth = rectWidth - lineX;
                                if (wordWidth + tw < remainWidth) {
                                    wordWidth += tw;
                                    continue;
                                }
                            }
                        }
                        else {
                            if (isPunc) {
                                let b = (isEmoji && j >= 1 && isLowSurrogate(text.charCodeAt(j - 1))) ? 2 : 1;
                                if (j - b > startIndex || lineX > 0) {
                                    j -= b;
                                    part = text.substring(startIndex, j);
                                    wordWidth = null;
                                    tw = null;
                                }
                            }
                        }
                    }
                    if (part.length > 0)
                        addCmd(part, style, wordWidth);
                    addLine();
                    startIndex = j;
                    remainWidth = rectWidth;
                    wordWidth = null;
                    if (maybeIndex > 1)
                        j += maybeIndex - 1;
                    else if (tw != null) {
                        wordWidth = tw;
                        if (cc.length > 1)
                            j++;
                    }
                    else if (isEmoji && isHighSurrogate(text.charCodeAt(j)))
                        j++;
                    if (wordWidth == null && j < len - 1)
                        wordWidth = getTextWidth(text.substring(startIndex, j + 1));
                }
                addCmd(text.substring(startIndex, len), style);
            };
            let calcTextSize = () => {
                let nw = 0, nh = 0;
                for (let line of this._lines) {
                    if (line.width > nw)
                        nw = line.width;
                }
                if (nw > 0)
                    nw += padding[1] + padding[3];
                this._textWidth = nw;
                let lastLine = this._lines[this._lines.length - 1];
                if (lastLine)
                    nh = lastLine.y + lastLine.height;
                if (nh > 0)
                    nh += padding[0] + padding[2];
                this._textHeight = nh;
            };
            let run = () => {
                lineX = lineY = charWidth = charHeight = 0;
                curLine = null;
                lastCmd = null;
                recoverLines(this._lines);
                addLine();
                let elements = this._elements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let ele = elements[i];
                    if (ele.type == exports.HtmlElementType.Text) {
                        buildLines(ele.text, ele.style);
                    }
                    else if (ele.type == exports.HtmlElementType.LinkEnd) {
                        if (lastCmd)
                            lastCmd.linkEnd = true;
                    }
                    else {
                        let htmlObj = ele.obj;
                        if (!htmlObj) {
                            let cls = HtmlParser.classMap[ele.type];
                            if (cls) {
                                htmlObj = Pool.createByClass(cls);
                                htmlObj.create(this, ele);
                                ele.obj = htmlObj;
                            }
                        }
                        if (htmlObj) {
                            if (wordWrap) {
                                let remainWidth = rectWidth - lineX;
                                if (htmlObj.width > 0 && remainWidth < htmlObj.width + 1) {
                                    if (lineX > 0) {
                                        addLine();
                                    }
                                }
                            }
                            addCmd(htmlObj, ele.style);
                        }
                    }
                }
                addLine(true);
                calcTextSize();
            };
            run();
            if (this._overflow == Text.SHRINK) {
                if (this._lines.length > 1 && this._textHeight > rectHeight) {
                    let low = 0;
                    let high = this._textStyle.fontSize;
                    this._fontSizeScale = Math.sqrt(rectHeight / this._textHeight);
                    let cur = Math.floor(this._fontSizeScale * this._textStyle.fontSize);
                    while (true) {
                        run();
                        if (this._textWidth > rectWidth || this._textHeight > rectHeight)
                            high = cur;
                        else
                            low = cur;
                        if (high - low > 1 || high != low && cur == high) {
                            cur = low + (high - low) / 2;
                            this._fontSizeScale = cur / this._textStyle.fontSize;
                        }
                        else
                            break;
                    }
                }
                else if (this._textWidth > rectWidth) {
                    this._fontSizeScale = rectWidth / this._textWidth;
                    run();
                    if (this._textWidth > rectWidth) {
                        let size = Math.floor(this._textStyle.fontSize * this._fontSizeScale);
                        size--;
                        this._fontSizeScale = size / this._textStyle.fontSize;
                        run();
                    }
                }
            }
            else if (this._overflow == Text.ELLIPSIS
                && (this._textWidth > rectWidth || this._textHeight > rectHeight || !this._wordWrap && this._lines.length > 1)) {
                let i;
                if (!this._wordWrap && this._lines.length > 1)
                    i = 1;
                else {
                    i = this._lines.findIndex(line => line.y + line.height > rectHeight);
                    if (i == 0)
                        i = 1;
                }
                let linesDeleted = false;
                if (i != -1 && this._lines.length > i) {
                    recoverLines(this._lines.splice(i, this._lines.length - i), true);
                    linesDeleted = true;
                }
                curLine = this._lines[this._lines.length - 1];
                let cmd = curLine.cmd;
                let next;
                let textCmd;
                let done = false;
                while (cmd) {
                    next = cmd.next;
                    if (!cmd.obj)
                        textCmd = cmd;
                    if (done) {
                        cleanCmd(cmd, true);
                        cmdPool.push(cmd);
                    }
                    else if ((!next && linesDeleted) || cmd.x + cmd.width > rectWidth - 10) {
                        if (cmd.obj) {
                            cleanCmd(cmd, true);
                            cmd.wt = new WordText$1();
                            cmd.wt.setText(ellipsisStr);
                            if (textCmd) {
                                cmd.ctxFont = textCmd.ctxFont;
                                cmd.fontSize = textCmd.fontSize;
                                cmd.height = textCmd.height;
                                cmd.style = textCmd.style;
                            }
                            else {
                                cmd.ctxFont = ctxFont;
                                cmd.fontSize = fontSize;
                                cmd.height = charHeight;
                                cmd.style = this._textStyle;
                            }
                            cmd.wt.splitRender = this._singleCharRender;
                        }
                        else {
                            let space = cmd.x + cmd.width - rectWidth;
                            let remove = space < 5 ? 2 : space < 10 ? 1 : 0;
                            let min = cmd === curLine.cmd ? 1 : 0;
                            let i = cmd.wt.text.length;
                            while (i > min && remove > 0) {
                                if (isLowSurrogate(cmd.wt.text.charCodeAt(i - 1)))
                                    i--;
                                i--;
                                remove--;
                            }
                            cmd.wt.setText(cmd.wt.text.substring(0, i) + ellipsisStr);
                        }
                        cmd.width = cmd.wt.width = getTextWidth2(cmd.wt.text, cmd.ctxFont, cmd.fontSize);
                        cmd.next = null;
                        done = true;
                        addLine(true);
                    }
                    cmd = next;
                }
                if (done || linesDeleted)
                    calcTextSize();
            }
            if (this._onPostLayout)
                this._onPostLayout();
            let align = this._textStyle.align == "center" ? 1 : (this._textStyle.align == "right" ? 2 : 0);
            if (align != 0 && this._isWidthSet) {
                let rectWidth = this._width - padding[3] - padding[1];
                for (let line of this._lines) {
                    let offsetX = 0;
                    if (align == 1)
                        offsetX = Math.floor((rectWidth - line.width) * 0.5);
                    else if (align == 2)
                        offsetX = rectWidth - line.width;
                    if (offsetX > 0)
                        line.x = offsetX;
                }
            }
            if (this._isHeightSet && this._textHeight < this._height) {
                let offsetY = 0;
                if (this._textStyle.valign === "middle")
                    offsetY = Math.floor((this._height - this._textHeight) * 0.5);
                else if (this._textStyle.valign === "bottom")
                    offsetY = this._height - this._textHeight;
                if (offsetY > 0) {
                    for (let line of this._lines) {
                        line.y += offsetY;
                    }
                }
            }
            if (this._overflow == Text.SCROLL
                && (this._isWidthSet && this._textWidth > this._width || this._isHeightSet && this._textHeight > this._height)) {
                if (!this._scrollPos)
                    this._scrollPos = new Point(0, 0);
                else {
                    let maxScrollX = this.maxScrollX;
                    let maxScrollY = this.maxScrollY;
                    if (this._scrollPos.x > maxScrollX)
                        this._scrollPos.x = maxScrollX;
                    if (this._scrollPos.y > maxScrollY)
                        this._scrollPos.y = maxScrollY;
                }
            }
            else
                this._scrollPos = null;
            if (this._objContainer) {
                this._objContainer.size(this._width, this._height);
                if (this._scrollPos || this._overflow == Text.HIDDEN && this._objContainer.numChildren > 0) {
                    if (!this._objContainer.scrollRect)
                        this._objContainer.scrollRect = new Rectangle();
                    this._objContainer.scrollRect.setTo(0, 0, this._width, this._height);
                }
                else
                    this._objContainer.scrollRect = null;
            }
            this._updatingLayout = false;
            this.renderText();
        }
        renderText() {
            let graphics = this.graphics;
            if (this._bgDrawCmd)
                this.graphics.removeCmd(this._bgDrawCmd);
            graphics.clear(true);
            this.drawBg();
            let padding = this._padding;
            let paddingLeft = padding[3];
            let paddingTop = padding[0];
            let bfont = this._bitmapFont;
            let scrollPos = this._scrollPos;
            let rectWidth = this._isWidthSet ? this._width : this._textWidth;
            let rectHeight = this._isHeightSet ? this._height : this._textHeight;
            let bottom = rectHeight - padding[2];
            let clipped = this._overflow == Text.HIDDEN || this._overflow == Text.SCROLL;
            if (clipped) {
                graphics.save();
                graphics.clipRect(0, 0, rectWidth, rectHeight);
                this.repaint();
            }
            rectWidth -= (padding[3] + padding[1]);
            rectHeight -= (padding[0] + padding[2]);
            let x = 0, y = 0;
            let lines = this._lines;
            let lineCnt = lines.length;
            let curLink;
            let linkStartX;
            for (let i = 0; i < lineCnt; i++) {
                let line = lines[i];
                x = paddingLeft + line.x;
                y = paddingTop + line.y;
                if (scrollPos) {
                    x -= scrollPos.x;
                    y -= scrollPos.y;
                }
                let lineClipped = clipped && ((y + line.height) <= paddingTop || y >= bottom);
                let cmd = line.cmd;
                while (cmd) {
                    if (cmd.linkEnd) {
                        if (curLink) {
                            curLink.addRect(linkStartX, y, x + cmd.x + cmd.width - linkStartX, line.height);
                            curLink = null;
                        }
                    }
                    if (cmd.obj) {
                        cmd.obj.pos(x + cmd.x, y + cmd.y);
                        if (cmd.obj.element.type == exports.HtmlElementType.Link) {
                            curLink = cmd.obj;
                            curLink.resetArea();
                            linkStartX = x + cmd.x;
                        }
                    }
                    else if (!lineClipped) {
                        if (bfont) {
                            let tx = 0;
                            let str = cmd.wt.text;
                            let color = bfont.tint ? cmd.style.color : "#FFFFFF";
                            let scale = Math.floor((bfont.autoScaleSize ? cmd.style.fontSize : bfont.fontSize) * this._fontSizeScale) / bfont.fontSize;
                            for (let i = 0, n = str.length; i < n; i++) {
                                let c = str.charCodeAt(i);
                                let g = bfont.dict[c];
                                if (g) {
                                    if (g.texture)
                                        graphics.drawImage(g.texture, x + cmd.x + tx + g.x * scale, y + cmd.y + g.y * scale, g.width * scale, g.height * scale, color);
                                    tx += Math.round(g.advance * scale);
                                }
                            }
                        }
                        else {
                            if (cmd.style.stroke)
                                graphics.fillBorderText(cmd.wt, x + cmd.x, y + cmd.y, cmd.ctxFont, cmd.style.color, null, cmd.style.stroke, cmd.style.strokeColor);
                            else
                                graphics.fillText(cmd.wt, x + cmd.x, y + cmd.y, cmd.ctxFont, cmd.style.color, null);
                        }
                    }
                    if (!lineClipped && cmd.width > 0) {
                        if (cmd.style.underline) {
                            let thickness = Math.max(1, cmd.fontSize / 16);
                            graphics.drawLine(x + cmd.x, y + line.height - thickness, x + cmd.x + cmd.width, y + line.height - thickness, cmd.style.underlineColor || cmd.style.color, thickness);
                        }
                        if (cmd.style.strikethrough) {
                            let thickness = Math.max(1, cmd.fontSize / 16);
                            let stx = x + cmd.x;
                            let sty = (y + line.height / 2 - thickness) | 0;
                            let ext = 4;
                            graphics.drawLine(stx - ext, sty, stx + cmd.width + ext, sty, cmd.style.strikethroughColor || cmd.style.color, thickness);
                        }
                    }
                    cmd = cmd.next;
                }
                if (curLink) {
                    curLink.addRect(linkStartX, y, rectWidth - linkStartX + paddingLeft, line.height);
                    linkStartX = paddingLeft;
                }
            }
            if (clipped)
                graphics.restore();
        }
        drawBg() {
            let cmd = this._bgDrawCmd;
            if (this._bgColor || this._borderColor) {
                if (!cmd) {
                    cmd = new DrawRectCmd();
                    cmd.x = cmd.y = 0;
                    cmd.width = cmd.height = 1;
                    cmd.percent = true;
                    this._bgDrawCmd = cmd;
                }
                cmd.fillColor = this._bgColor;
                cmd.lineColor = this._borderColor;
                cmd.lineWidth = this._borderColor ? 1 : 0;
                let cmds = this.graphics.cmds;
                let i = cmds.indexOf(cmd);
                if (i != 0) {
                    if (i != -1)
                        cmds.splice(i, 1);
                    cmds.unshift(cmd);
                    this.graphics.cmds = cmds;
                }
            }
            else if (cmd) {
                this.graphics.removeCmd(cmd);
            }
        }
    }
    Text.VISIBLE = "visible";
    Text.SCROLL = "scroll";
    Text.HIDDEN = "hidden";
    Text.SHRINK = "shrink";
    Text.ELLIPSIS = "ellipsis";
    Text.RightToLeft = false;
    Text._testWord = "游";
    Text._passwordChar = "●";
    Text._bitmapFonts = {};
    const cmdPool = [];
    const linePool = [];
    function recoverLines(lines, releaseObjs) {
        for (let line of lines) {
            let cmd = line.cmd;
            while (cmd) {
                cleanCmd(cmd, releaseObjs);
                cmdPool.push(cmd);
                cmd = cmd.next;
            }
            line.cmd = null;
        }
        linePool.push(...lines);
        lines.length = 0;
    }
    function cleanCmd(cmd, releaseObj) {
        if (cmd.obj) {
            if (releaseObj) {
                cmd.obj.element.obj = null;
                cmd.obj.release();
                Pool.recoverByClass(cmd.obj);
            }
            cmd.obj = null;
        }
        else if (cmd.wt)
            cmd.wt.cleanCache();
    }
    const emojiTest = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
    const wordBoundaryTest = /[a-zA-Z0-9\!-\+\/_]+$/;
    const punctuationChars = Array.from(".,，。、!！；;”’)）]】}》").map(char => char.charCodeAt(0));
    const normalizeCR = /\r\n/g;
    const escapeCharsPattern = /\\(\w)/g;
    const escapeSequence = { "\\n": "\n", "\\t": "\t" };
    const ellipsisStr = "…";
    const maxWordLength = 20;
    function getReplaceStr(word) {
        return escapeSequence[word];
    }
    function isHighSurrogate(c) {
        return c >= 0xD800 && c <= 0xDBFF;
    }
    function isLowSurrogate(c) {
        return c >= 0xDC00 && c <= 0xDFFF;
    }

    class Input extends Text {
        constructor() {
            super();
            this.confirmType = 'done';
            this.maxChars = 0;
            this._multiline = false;
            this._editable = true;
            this._width = 100;
            this._height = 20;
            this._type = "text";
            this._promptColor = "#a9a9a9";
            this.overflow = Text.SCROLL;
            this.valign = "middle";
            this.mouseEnabled = true;
        }
        get multiline() {
            return this._multiline;
        }
        set multiline(value) {
            if (this._multiline != value) {
                this._multiline = value;
                this.wordWrap = value;
                this.valign = value ? "top" : "middle";
            }
        }
        get focus() {
            return PAL.textInput.target === this;
        }
        set focus(value) {
            if (value)
                PAL.textInput.begin(this);
            else if (this === PAL.textInput.target)
                PAL.textInput.end();
        }
        get text() {
            if (PAL.textInput.target === this)
                PAL.textInput.syncText();
            return super.text;
        }
        set text(value) {
            if (value == null)
                value = "";
            else if (typeof (value) !== "string")
                value = '' + value;
            if (PAL.textInput.target === this) {
                PAL.textInput.setText(value);
                this.event(Event.CHANGE);
            }
            else {
                if (!this._multiline)
                    value = value.replace(/\r?\n/g, '');
                super.text = value;
            }
        }
        get editable() {
            return this._editable;
        }
        set editable(value) {
            this._editable = value;
        }
        get prompt() {
            return this._prompt;
        }
        set prompt(value) {
            var _a;
            if (value == null)
                value = "";
            value = ((_a = Text.langPacks) === null || _a === void 0 ? void 0 : _a[value]) || value;
            if (this._prompt != value) {
                this._prompt = value;
                this.markChanged();
            }
        }
        get promptColor() {
            return this._promptColor;
        }
        set promptColor(value) {
            if (this._promptColor != value) {
                this._promptColor = value;
                this.markChanged();
            }
        }
        get type() {
            return this._type;
        }
        set type(value) {
            this._asPassword = value === "password";
            this._type = value;
            this.markChanged();
        }
        setSelection(startIndex, endIndex) {
            this.focus = true;
            PAL.textInput.setSelection(startIndex, endIndex);
        }
        select() {
            this.focus = true;
            PAL.textInput.setSelection(0, -1);
        }
    }
    Input.TYPE_TEXT = "text";
    Input.TYPE_PASSWORD = "password";
    Input.TYPE_EMAIL = "email";
    Input.TYPE_URL = "url";
    Input.TYPE_NUMBER = "number";
    Input.TYPE_RANGE = "range";
    Input.TYPE_DATE = "date";
    Input.TYPE_MONTH = "month";
    Input.TYPE_WEEK = "week";
    Input.TYPE_TIME = "time";
    Input.TYPE_DATE_TIME = "datetime";
    Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
    Input.TYPE_SEARCH = "search";

    var _definiteIntegralMap = {};
    class BlurFilter extends Filter {
        constructor(strength = 4) {
            super();
            this.shaderData = new TextureSV();
            this._shaderV1 = new Vector4();
            this.strength = strength;
        }
        get strength() {
            return this._strength;
        }
        set strength(v) {
            this._strength = Math.max(Math.abs(v), 2);
            var sigma = this._strength / 3.0;
            var sigma2 = sigma * sigma;
            let v1 = this._shaderV1 = new Vector4(this.strength, sigma2, 2.0 * sigma2, 1.0 / (2.0 * Math.PI * sigma2));
            let s = 0;
            let key = Math.floor(this.strength * 10);
            if (_definiteIntegralMap[key] != undefined) {
                s = _definiteIntegralMap[key];
            }
            else {
                for (let y = -4; y <= 4; ++y) {
                    for (let x = -4; x <= 4; ++x) {
                        s += v1.w * Math.exp(-(x * x + y * y) / v1.z);
                    }
                }
                _definiteIntegralMap[key] = s;
            }
            v1.w /= s;
            this.onChange();
        }
        render(srctexture, width, height) {
            let marginLeft = 50;
            let marginTop = 50;
            this.left = -marginLeft;
            this.top = -marginTop;
            let texwidth = width + 2 * marginLeft;
            let texheight = height + 2 * marginTop;
            this.width = texwidth;
            this.height = texheight;
            if (!this.texture || this.texture.destroyed || this.texture.width != texwidth || this.texture.height != texheight) {
                if (this.texture)
                    this.texture.destroy();
                this.texture = new RenderTexture2D(texwidth, texheight, exports.RenderTargetFormat.R8G8B8A8);
            }
            let render2d = this._render2D.clone(this.texture);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            let rectVB = this._rectMeshVB;
            let stridef32 = this._rectMesh.vertexDeclarition.vertexStride / 4;
            rectVB[0] = marginLeft;
            rectVB[1] = marginTop;
            rectVB[stridef32] = marginLeft + width;
            rectVB[stridef32 + 1] = marginTop;
            rectVB[stridef32 * 2] = marginLeft + width;
            rectVB[stridef32 * 2 + 1] = marginTop + height;
            rectVB[stridef32 * 3] = marginTop;
            rectVB[stridef32 * 3 + 1] = marginTop + height;
            let shadersv = this.shaderData;
            shadersv.shaderData.addDefine(ShaderDefines2D.FILTERBLUR);
            shadersv.size = new Vector2(texwidth, texheight);
            shadersv.textureHost = srctexture;
            shadersv.blurInfo = new Vector2(texwidth, texheight);
            shadersv.strength_sig2_2sig2_gauss1 = this._shaderV1;
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadersv, null);
            render2d.renderEnd();
        }
    }

    const DELTA_INDEX = [0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1, 0.11, 0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24, 0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42, 0.44, 0.46, 0.48, 0.5, 0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98, 1.0, 1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54, 1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0, 2.12, 2.25, 2.37, 2.50, 2.62, 2.75, 2.87, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0, 4.3, 4.7, 4.9, 5.0, 5.5, 6.0, 6.5, 6.8, 7.0, 7.3, 7.5, 7.8, 8.0, 8.4, 8.7, 9.0, 9.4, 9.6, 9.8, 10.0];
    const GRAY_MATRIX = [0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0];
    const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
    const LENGTH = 25;
    class ColorFilter extends Filter {
        constructor(mat = null) {
            super();
            if (!mat)
                mat = this._copyMatrix(IDENTITY_MATRIX);
            this._mat = new Float32Array(16);
            this._alpha = new Float32Array(4);
            this.setByMatrix(mat);
        }
        render(srctexture, width, height) {
            let texwidth = width;
            let texheight = height;
            this.width = texwidth;
            this.height = texheight;
            if (!this.texture || this.texture.destroyed || this.texture.width != texwidth || this.texture.height != texheight) {
                if (this.texture)
                    this.texture.destroy();
                this.texture = new RenderTexture2D(texwidth, texheight, exports.RenderTargetFormat.R8G8B8A8);
            }
            let render2d = this._render2D.clone(this.texture);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            let rectVB = this._rectMeshVB;
            let stridef32 = this._rectMesh.vertexDeclarition.vertexStride / 4;
            rectVB[0] = 0;
            rectVB[1] = 0;
            rectVB[stridef32] = width;
            rectVB[stridef32 + 1] = 0;
            rectVB[stridef32 * 2] = width;
            rectVB[stridef32 * 2 + 1] = height;
            rectVB[stridef32 * 3] = 0;
            rectVB[stridef32 * 3 + 1] = height;
            let shadersv = new TextureSV();
            shadersv.setFilter(this);
            Matrix4x4.TEMP.cloneByArray(this._mat);
            shadersv.shaderData.setMatrix4x4(ShaderDefines2D.UNIFORM_COLORMAT, Matrix4x4.TEMP);
            Vector4.TEMP.setValue(this._alpha[0], this._alpha[1], this._alpha[2], this._alpha[3]);
            shadersv.shaderData.setVector(ShaderDefines2D.UNIFORM_COLORALPHA, Vector4.TEMP);
            shadersv.size = new Vector2(texwidth, texheight);
            shadersv.textureHost = srctexture;
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadersv, null);
            render2d.renderEnd();
        }
        gray() {
            return this.setByMatrix(GRAY_MATRIX);
        }
        color(red = 0, green = 0, blue = 0, alpha = 1) {
            return this.setByMatrix([red, 0, 0, 0, 1, 0, green, 0, 0, 1, 0, 0, blue, 0, 1, 0, 0, 0, alpha, 0]);
        }
        setColor(color) {
            var arr = ColorUtils.create(color).arrColor;
            var mt = [0, 0, 0, 0, 256 * arr[0], 0, 0, 0, 0, 256 * arr[1], 0, 0, 0, 0, 256 * arr[2], 0, 0, 0, 1, 0];
            return this.setByMatrix(mt);
        }
        setByMatrix(matrix) {
            if (this._matrix != matrix)
                this._copyMatrix(matrix);
            var j = 0;
            var z = 0;
            for (var i = 0; i < 20; i++) {
                if (i % 5 != 4) {
                    this._mat[j++] = matrix[i];
                }
                else {
                    this._alpha[z++] = matrix[i];
                }
            }
            this.onChange();
            return this;
        }
        get type() {
            return Filter.COLOR;
        }
        get typeDefine() {
            return ShaderDefines2D.FILTERCOLOR;
        }
        adjustColor(brightness, contrast, saturation, hue) {
            this.adjustHue(hue);
            this.adjustContrast(contrast);
            this.adjustBrightness(brightness);
            this.adjustSaturation(saturation);
            return this;
        }
        adjustBrightness(brightness) {
            brightness = this._clampValue(brightness, 100);
            if (brightness == 0 || isNaN(brightness))
                return this;
            return this._multiplyMatrix([1, 0, 0, 0, brightness, 0, 1, 0, 0, brightness, 0, 0, 1, 0, brightness, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustContrast(contrast) {
            contrast = this._clampValue(contrast, 100);
            if (contrast == 0 || isNaN(contrast))
                return this;
            var x;
            if (contrast < 0) {
                x = 127 + contrast / 100 * 127;
            }
            else {
                x = contrast % 1;
                if (x == 0) {
                    x = DELTA_INDEX[contrast];
                }
                else {
                    x = DELTA_INDEX[(contrast << 0)] * (1 - x) + DELTA_INDEX[(contrast << 0) + 1] * x;
                }
                x = x * 127 + 127;
            }
            var x1 = x / 127;
            var x2 = (127 - x) * 0.5;
            return this._multiplyMatrix([x1, 0, 0, 0, x2, 0, x1, 0, 0, x2, 0, 0, x1, 0, x2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustSaturation(saturation) {
            saturation = this._clampValue(saturation, 100);
            if (saturation == 0 || isNaN(saturation))
                return this;
            var x = 1 + ((saturation > 0) ? 3 * saturation / 100 : saturation / 100);
            var dx = 1 - x;
            var r = 0.3086 * dx;
            var g = 0.6094 * dx;
            var b = 0.0820 * dx;
            return this._multiplyMatrix([r + x, g, b, 0, 0, r, g + x, b, 0, 0, r, g, b + x, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        adjustHue(hue) {
            hue = this._clampValue(hue, 180) / 180 * Math.PI;
            if (hue == 0 || isNaN(hue))
                return this;
            var cos = Math.cos(hue);
            var sin = Math.sin(hue);
            var r = 0.213;
            var g = 0.715;
            var b = 0.072;
            return this._multiplyMatrix([r + cos * (1 - r) + sin * (-r), g + cos * (-g) + sin * (-g), b + cos * (-b) + sin * (1 - b), 0, 0, r + cos * (-r) + sin * (0.143), g + cos * (1 - g) + sin * (0.140), b + cos * (-b) + sin * (-0.283), 0, 0, r + cos * (-r) + sin * (-(1 - r)), g + cos * (-g) + sin * (g), b + cos * (1 - b) + sin * (b), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
        }
        reset() {
            return this.setByMatrix(this._copyMatrix(IDENTITY_MATRIX));
        }
        _multiplyMatrix(matrix) {
            var col = [];
            this._matrix = this._fixMatrix(this._matrix);
            for (var i = 0; i < 5; i++) {
                for (var j = 0; j < 5; j++) {
                    col[j] = this._matrix[j + i * 5];
                }
                for (j = 0; j < 5; j++) {
                    var val = 0;
                    for (var k = 0; k < 5; k++) {
                        val += matrix[j + k * 5] * col[k];
                    }
                    this._matrix[j + i * 5] = val;
                }
            }
            return this.setByMatrix(this._matrix);
        }
        _clampValue(val, limit) {
            return Math.min(limit, Math.max(-limit, val));
        }
        _fixMatrix(matrix = null) {
            if (matrix == null)
                return IDENTITY_MATRIX;
            if (matrix.length < LENGTH)
                matrix = matrix.slice(0, matrix.length).concat(IDENTITY_MATRIX.slice(matrix.length, LENGTH));
            else if (matrix.length > LENGTH)
                matrix = matrix.slice(0, LENGTH);
            return matrix;
        }
        _copyMatrix(matrix) {
            var len = LENGTH;
            if (!this._matrix)
                this._matrix = [];
            for (var i = 0; i < len; i++) {
                this._matrix[i] = matrix[i];
            }
            return this._matrix;
        }
        onAfterDeserialize() {
            let arr = ColorUtils.create(this._color || "#FFFFFF").arrColor;
            this.color(arr[0], arr[1], arr[2], arr[3]);
            this.adjustColor(this._brightness || 0, this._contrast || 0, this._saturation || 0, this._hue || 0);
        }
    }

    class GlowFilter extends Filter {
        constructor(color, blur = 4, offX = 6, offY = 6) {
            super();
            this._sv_blurInfo1 = new Array(4);
            this._sv_blurInfo2 = [0, 0, 1, 0];
            this._flipY = false;
            this._color = new ColorUtils(color || "#000");
            this.blur = Math.min(blur, 20);
            this.offX = offX;
            this.offY = offY;
            this._sv_blurInfo1[1] = this.blur;
            this.shaderDataBlur = new TextureSV();
            this.shaderDataBlur.u_blurInfo1 = new Vector4();
            this.shaderDataBlur.u_blurInfo2 = new Vector4();
            this.shaderDataBlur.color = new Vector4();
            this.shaderDataBlur.size = new Vector2();
            this.shaderDataBlur.blurInfo = new Vector2();
            this.shaderDataCopy = new TextureSV();
            this.shaderDataCopy.size = new Vector2();
            this.shaderDataCopy1 = new TextureSV();
        }
        _fillQuad(x, y, w, h, flipY = false) {
            let uvrect;
            if (flipY) {
                uvrect = [0, 1, 1, 0];
            }
            else {
                uvrect = [0, 0, 1, 1];
            }
            let rectVB = this._rectMeshVB;
            let stridef32 = this._rectMesh.vertexDeclarition.vertexStride / 4;
            rectVB[0] = x;
            rectVB[1] = y;
            rectVB[2] = uvrect[0];
            rectVB[3] = uvrect[1];
            rectVB[stridef32] = x + w;
            rectVB[stridef32 + 1] = y;
            rectVB[stridef32 + 2] = uvrect[2];
            rectVB[stridef32 + 3] = uvrect[1];
            rectVB[stridef32 * 2] = x + w;
            rectVB[stridef32 * 2 + 1] = y + h;
            rectVB[stridef32 * 2 + 2] = uvrect[2];
            rectVB[stridef32 * 2 + 3] = uvrect[3];
            rectVB[stridef32 * 3] = y;
            rectVB[stridef32 * 3 + 1] = y + h;
            rectVB[stridef32 * 3 + 2] = uvrect[0];
            rectVB[stridef32 * 3 + 3] = uvrect[3];
        }
        useFlipY(b) {
            super.useFlipY(b);
            this._flipY = b;
        }
        render(srctexture, width, height) {
            let marginLeft = 50;
            let marginTop = 50;
            this.left = -marginLeft;
            this.top = -marginTop;
            let outTexWidth = width + 2 * marginLeft;
            let outTexHeight = height + 2 * marginTop;
            this.width = outTexWidth;
            this.height = outTexHeight;
            if (!this.textureExtend || this.textureExtend.destroyed || this.textureExtend.width != outTexWidth ||
                this.textureExtend.height != outTexHeight) {
                if (this.textureExtend)
                    this.textureExtend.destroy();
                this.textureExtend = new RenderTexture2D(outTexWidth, outTexHeight, exports.RenderTargetFormat.R8G8B8A8);
                this.textureExtend._invertY = LayaGL.renderEngine._screenInvertY;
            }
            let render2d = this._render2D.clone(this.textureExtend);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            this.shaderDataCopy1.size = new Vector2(outTexWidth, outTexHeight);
            this.shaderDataCopy1.textureHost = srctexture;
            this._fillQuad(marginLeft, marginTop, srctexture.width, srctexture.height, this._flipY);
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, this.shaderDataCopy1, null);
            render2d.renderEnd();
            if (!this.texture || this.texture.destroyed || this.texture.width != outTexWidth || this.texture.height != outTexHeight) {
                if (this.texture)
                    this.texture.destroy();
                this.texture = new RenderTexture2D(outTexWidth, outTexHeight, exports.RenderTargetFormat.R8G8B8A8);
            }
            render2d = render2d.clone(this.texture);
            render2d.renderStart(true, new Color(0, 0, 0, 0));
            this._fillQuad(0, 0, outTexWidth, outTexHeight, true);
            let shadersv = this.shaderDataBlur;
            shadersv.shaderData.addDefine(ShaderDefines2D.FILTERGLOW);
            let size = shadersv.size;
            size.setValue(outTexWidth, outTexHeight);
            shadersv.size = size;
            shadersv.textureHost = this.textureExtend;
            let blurInfo = shadersv.blurInfo;
            blurInfo.setValue(outTexWidth, outTexHeight);
            shadersv.blurInfo = blurInfo;
            let u_blurInfo1 = shadersv.u_blurInfo1;
            u_blurInfo1.setValue(this._sv_blurInfo1[0], this._sv_blurInfo1[1], this._sv_blurInfo1[2], this._sv_blurInfo1[3]);
            shadersv.u_blurInfo1 = u_blurInfo1;
            let u_blurInfo2 = shadersv.u_blurInfo2;
            u_blurInfo2.setValue(srctexture.width, srctexture.height, this._sv_blurInfo2[2], this._sv_blurInfo2[3]);
            shadersv.u_blurInfo2 = u_blurInfo2;
            let color = this._color.arrColor;
            let svColor = shadersv.color;
            svColor.setValue(color[0], color[1], color[2], color[3]);
            shadersv.color = svColor;
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadersv, null);
            let shadercpy = this.shaderDataCopy;
            size = shadercpy.size;
            size.setValue(outTexWidth, outTexHeight);
            shadercpy.size = size;
            shadercpy.textureHost = srctexture;
            this._fillQuad(marginLeft, marginTop, srctexture.width, srctexture.height, this._flipY);
            render2d.draw(this._rectMesh, 0, 4 * this._rectMesh.vertexDeclarition.vertexStride, 0, 12, shadercpy, null);
            render2d.renderEnd();
        }
        get typeDefine() {
            return ShaderDefines2D.FILTERGLOW;
        }
        get offY() {
            return this._sv_blurInfo1[3];
        }
        set offY(value) {
            this._sv_blurInfo1[3] = value;
            this.onChange();
        }
        get offX() {
            return this._sv_blurInfo1[2];
        }
        set offX(value) {
            this._sv_blurInfo1[2] = value;
            this.onChange();
        }
        get color() {
            return this._color.strColor;
        }
        set color(value) {
            this._color = new ColorUtils(value);
            this.onChange();
        }
        get blur() {
            return this._sv_blurInfo1[1];
        }
        set blur(value) {
            this._sv_blurInfo1[0] = this._sv_blurInfo1[1] = value;
            this.onChange();
        }
    }

    class SoundNode extends Sprite {
        constructor() {
            super();
            this._loop = 1;
            if (LayaEnv.isPlaying) {
                this.on(Event.ADDED, () => { this.target = this.parent; });
                this.on(Event.REMOVED, () => { this.target = null; });
                this.on(Event.DISPLAY, this, this.onDisplay);
                this.on(Event.UNDISPLAY, this, this.onUndisplay);
            }
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (value) {
                if (this.activeInHierarchy && (this._autoPlay || this._channel) && LayaEnv.isPlaying)
                    this.play(this._loop);
            }
            else
                this.stop();
        }
        get isMusic() {
            return this._isMusic;
        }
        set isMusic(value) {
            this._isMusic = value;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (this.activeInHierarchy && value && !this._channel && LayaEnv.isPlaying)
                this.play(this._loop);
        }
        play(loops, complete, startTime) {
            if (!this._source)
                return;
            if (loops == null || isNaN(loops))
                loops = this._loop;
            this.stop();
            if (this._isMusic)
                this._channel = SoundManager.playMusic(this._source, loops, complete, startTime);
            else
                this._channel = SoundManager.playSound(this._source, loops, complete, startTime);
        }
        stop() {
            if (this._channel)
                this._channel.stop();
            this._channel = null;
        }
        _setPlayAction(tar, event, action, add = true) {
            if (!this[action])
                return;
            if (!tar)
                return;
            if (add) {
                tar.on(event, this, this[action]);
            }
            else {
                tar.off(event, this, this[action]);
            }
        }
        _setPlayActions(tar, events, action, add = true) {
            if (!tar)
                return;
            if (!events)
                return;
            let eventArr = events.split(",");
            let len = eventArr.length;
            for (let i = 0; i < len; i++) {
                this._setPlayAction(tar, eventArr[i], action, add);
            }
        }
        set playEvent(events) {
            this._playEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "play");
            }
        }
        set target(tar) {
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", false);
                this._setPlayActions(this._tar, this._stopEvents, "stop", false);
            }
            this._tar = tar;
            if (this._tar) {
                this._setPlayActions(this._tar, this._playEvents, "play", true);
                this._setPlayActions(this._tar, this._stopEvents, "stop", true);
            }
        }
        set stopEvent(events) {
            this._stopEvents = events;
            if (!events)
                return;
            if (this._tar) {
                this._setPlayActions(this._tar, events, "stop");
            }
        }
        onDisplay() {
            if (this._autoPlay && !this._channel)
                this.play(this._loop);
        }
        onUndisplay() {
            this.stop();
        }
    }

    class VideoNode extends Sprite {
        constructor() {
            super();
            this.options = { controls: false, objectFit: "contain" };
            this.mode = "decoder";
            this._autoPlay = false;
            this._loop = false;
            this._volume = 1;
            this._muted = false;
            this._playbackRate = 1;
            this._allowBackground = false;
            this._paused = false;
            this.on(Event.DISPLAY, this, this.onDisplay);
            this.on(Event.UNDISPLAY, this, this.onUndisplay);
        }
        get player() {
            return this._api;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            if (value) {
                if (this.activeInHierarchy)
                    this._load();
            }
            else
                this._unload();
        }
        get autoPlay() {
            return this._autoPlay;
        }
        set autoPlay(value) {
            this._autoPlay = value;
            if (this._api && LayaEnv.isPlaying)
                value ? this._api.play() : this._api.pause();
        }
        get allowBackground() {
            return this._allowBackground;
        }
        set allowBackground(value) {
            this._allowBackground = value;
            if (this._api)
                this._api.allowBackground = value;
        }
        get currentTime() {
            var _a;
            return (_a = this._api) === null || _a === void 0 ? void 0 : _a.currentTime;
        }
        set currentTime(value) {
            if (!this._api)
                return;
            this._api.currentTime = value;
        }
        get readyState() {
            var _a, _b;
            return (_b = (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.readyState) !== null && _b !== void 0 ? _b : 0;
        }
        get videoWidth() {
            var _a;
            return (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.videoWidth;
        }
        get videoHeight() {
            var _a;
            return (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.videoHeight;
        }
        get duration() {
            var _a;
            return (_a = this._api) === null || _a === void 0 ? void 0 : _a.duration;
        }
        get ended() {
            var _a;
            return (_a = this._api) === null || _a === void 0 ? void 0 : _a.ended;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
            if (this._api)
                this._api.loop = value;
        }
        get playbackRate() {
            return this._playbackRate;
        }
        set playbackRate(value) {
            this._playbackRate = value;
            if (this._api)
                this._api.playbackRate = value;
        }
        get volume() {
            return this._volume;
        }
        set volume(value) {
            this._volume = value;
            if (this._api)
                this._api.volume = value;
        }
        get muted() {
            return this._muted;
        }
        set muted(value) {
            this._muted = value;
            if (this._api)
                this._api.muted = value;
        }
        get paused() {
            return this._paused;
        }
        load(url) {
            this.source = url;
        }
        play() {
            if (!this._api)
                return;
            this._api.play();
        }
        pause() {
            this._paused = true;
            if (this._api)
                this._api.pause();
        }
        reload() {
            this.source = this._source;
        }
        canPlayType(type) {
            return PAL.media.canPlayType(type);
        }
        _load() {
            let player;
            let vt;
            let backendType = LayaEnv.isPlaying ? this.mode : "decoder";
            if (backendType === "player") {
                player = (this._player || PAL.media.createVideoPlayer());
                if (!player)
                    vt = PAL.media.createVideoTexture();
            }
            else {
                vt = (this._vtex || PAL.media.createVideoTexture());
                if (!vt)
                    player = PAL.media.createVideoPlayer();
            }
            if (player) {
                if (this._player !== player) {
                    this._player = player;
                    this._player.attachTo(this);
                    this._player.options = this.options;
                }
                if (this._vtex) {
                    this._vtex.destroy();
                    this._vtex = null;
                    this.texture = null;
                }
            }
            else {
                if (this._vtex !== vt) {
                    this._vtex = vt;
                    this._vtex.on(Event.READY, () => this._tex.setTo(this._vtex));
                    this._vtex.on("videoUpdate", this, this._repaintCachAs);
                    if (!this._tex)
                        this.texture = this._tex = new Texture();
                }
                if (this._player) {
                    this._player.destroy();
                    this._player = null;
                }
            }
            this._api = player || vt;
            this._api.loop = this._loop;
            this._api.volume = this._volume;
            this._api.muted = this._muted;
            this._api.playbackRate = this._playbackRate;
            this._api.allowBackground = this._allowBackground;
            if (this._autoPlay && !this._paused && LayaEnv.isPlaying)
                this._api.play();
            else
                this._api.pause();
            this._api.load(this._source);
        }
        _unload() {
            var _a, _b;
            (_a = this._vtex) === null || _a === void 0 ? void 0 : _a.destroy();
            this._vtex = null;
            (_b = this._player) === null || _b === void 0 ? void 0 : _b.destroy();
            this._player = null;
            this._api = null;
        }
        _repaintCachAs() {
            if (this.cacheAs != "none" || (!!this._getCacheStyle().mask)) {
                this.repaint();
            }
        }
        onDisplay() {
            if (!this._api && this._source)
                this._load();
        }
        onUndisplay() {
            this._unload();
        }
        destroy(detroyChildren = true) {
            this._unload();
            super.destroy(detroyChildren);
        }
        get currentSrc() {
            return this._source;
        }
        get videoTexture() {
            return this._vtex;
        }
        set videoTexture(value) {
            if (value)
                this.source = value.source;
            else
                this.source = null;
        }
    }

    class AnimatorPlayState2D {
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        constructor() {
            this._currentState = null;
            this._frontPlay = true;
        }
        _resetPlayState(startTime, clipDuration) {
            this._finish = false;
            this._startPlayTime = startTime;
            this._elapsedTime = startTime;
            this._lastIsFront = true;
            this._parentPlayTime = null;
            this._playNum = 0;
            this._playAllTime = 0;
            var playTime = (this._elapsedTime / clipDuration) % 1.0;
            this._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            this._frontPlay = true;
        }
        _cloneTo(dest) {
            dest._finish = this._finish;
            dest._startPlayTime = this._startPlayTime;
            dest._elapsedTime = this._elapsedTime;
            dest._playNum = this._playNum;
            dest._parentPlayTime = this._parentPlayTime;
            dest._normalizedPlayTime = this._normalizedPlayTime;
            dest._lastIsFront = this._lastIsFront;
            dest._frontPlay = this._frontPlay;
            dest._playAllTime = this._playAllTime;
        }
    }

    class AnimatorControllerLayer2D {
        constructor(name) {
            this._referenceCount = 0;
            this._playStateInfo = new AnimatorPlayState2D();
            this._crossPlayStateInfo = new AnimatorPlayState2D();
            this._crossMark = 0;
            this._crossNodesOwnersCount = 0;
            this._crossNodesOwnersIndicesMap = {};
            this._srcCrossClipNodeIndices = [];
            this._destCrossClipNodeIndices = [];
            this.playOnWake = true;
            this.defaultWeight = 1.0;
            this.blendingMode = AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
            this.enable = true;
            this._states = [];
            this._playType = -1;
            this.name = name;
        }
        get states() {
            return this._states;
        }
        set states(states) {
            if (this._states === states)
                return;
            for (let i = this.states.length - 1; i >= 0; i--) {
                this.removeState(this.states[i]);
            }
            for (let i = states.length - 1; i >= 0; i--) {
                this.addState(states[i]);
            }
        }
        get defaultStateName() {
            if (!this._defaultState) {
                return null;
            }
            return this._defaultState.name;
        }
        set defaultStateName(str) {
            this._defaultState = this.getStateByName(str);
            if (null == this._defaultState) {
                if (0 == this._states.length) {
                    this._defaultStateNameCatch = str;
                }
                else {
                    for (var i = this._states.length - 1; i >= 0; i--) {
                        if (this._states[i].name == str) {
                            this._defaultState = this._states[i];
                            break;
                        }
                    }
                }
            }
        }
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(value) {
            this._defaultState = value;
        }
        _removeClip(clipStateInfos, index, state) {
            clipStateInfos.splice(index, 1);
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._addReference(count);
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._removeReference(count);
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getStateByName(str) {
            for (let i = this._states.length - 1; i >= 0; i--) {
                if (this._states[i].name == str) {
                    return this._states[i];
                }
            }
            return null;
        }
        addState(state) {
            var stateName = state.name;
            if (this.getStateByName(stateName)) {
                throw new Error("AnimatorControllerLayer:this stat's name has exist.");
            }
            else {
                this._states.push(state);
                if (stateName == this._defaultStateNameCatch) {
                    this._defaultState = state;
                    this._defaultStateNameCatch = null;
                }
            }
        }
        removeState(state) {
            var states = this._states;
            var index = -1;
            for (var i = 0, n = states.length; i < n; i++) {
                if (states[i] === state) {
                    index = i;
                    break;
                }
            }
            if (-1 != index)
                this._removeClip(states, index, state);
        }
        clone() {
            var dest = new AnimatorControllerLayer2D(this.name);
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
        }
        destroy() {
            this._removeReference();
            for (var i = 0, n = this._states.length; i < n; i++) {
                this._states[i].destroy();
            }
            this._states.length = 0;
        }
    }
    AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE = 0;
    AnimatorControllerLayer2D.BLENDINGMODE_ADDTIVE = 1;

    exports.AniParmType = void 0;
    (function (AniParmType) {
        AniParmType[AniParmType["Float"] = 0] = "Float";
        AniParmType[AniParmType["Bool"] = 1] = "Bool";
        AniParmType[AniParmType["Trigger"] = 2] = "Trigger";
    })(exports.AniParmType || (exports.AniParmType = {}));
    exports.AniStateConditionType = void 0;
    (function (AniStateConditionType) {
        AniStateConditionType[AniStateConditionType["Number"] = 0] = "Number";
        AniStateConditionType[AniStateConditionType["Bool"] = 1] = "Bool";
        AniStateConditionType[AniStateConditionType["Trigger"] = 2] = "Trigger";
    })(exports.AniStateConditionType || (exports.AniStateConditionType = {}));
    exports.AniStateConditionNumberCompressType = void 0;
    (function (AniStateConditionNumberCompressType) {
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Less"] = 0] = "Less";
        AniStateConditionNumberCompressType[AniStateConditionNumberCompressType["Greater"] = 1] = "Greater";
    })(exports.AniStateConditionNumberCompressType || (exports.AniStateConditionNumberCompressType = {}));
    class AnimatorControllerParse {
        static parse(data) {
            let ret = data;
            let layers = ret.controllerLayers;
            if (null == layers) {
                layers = [];
            }
            let clipsID = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let states = l.states;
                if (!states) {
                    states = [];
                    l.states = states;
                }
                l.defaultStateName = null;
                let retobj = this.checkStates(states, clipsID, ret);
                if (retobj) {
                    l.defaultStateName = retobj.enterName;
                }
                else {
                    layers.splice(i, 1);
                }
            }
            return { ret: ret, clipsID: clipsID };
        }
        static checkStates(states, clipsID, data) {
            let clipState = null;
            let enterState = null;
            for (let j = states.length - 1; j >= 0; j--) {
                let state = states[j];
                if (state.states) {
                    if (null == this.checkStates(state.states, clipsID, data)) {
                        states.splice(j, 1);
                    }
                    else {
                        if (null == clipState) {
                            clipState = [];
                        }
                        clipState.push(state);
                    }
                }
                else if ("-1" == state.id) {
                    enterState = state;
                }
                else if ("-2" == state.id) ;
                else if ("-3" == state.id) ;
                else if (null == state.clip || null == state.clip._$uuid || "" == state.clip._$uuid) {
                    states.splice(j, 1);
                }
                else {
                    if (0 > clipsID.indexOf(state.clip._$uuid)) {
                        clipsID.push(state.clip._$uuid);
                    }
                    this.checkNext(state, states, data);
                    if (null == clipState) {
                        clipState = [];
                    }
                    clipState.push(state);
                }
            }
            let ret = null;
            if (clipState && enterState) {
                let defName = this.checkDefault(enterState, clipState);
                if (null != defName) {
                    ret = { states: clipState, enterName: defName };
                }
            }
            return ret;
        }
        static checkNext(state, states, data) {
            let nexts = state.soloTransitions;
            if (nexts) {
                for (let i = nexts.length - 1; i >= 0; i--) {
                    let next = nexts[i];
                    let nState = this.getStateByID(states, next.id);
                    if (!nState || (null == nState.clip && "-3" != nState.id && null == nState.states)) {
                        nexts.splice(i, 1);
                    }
                    else {
                        next.name = nState.name;
                        next.conditions = this.checkConditions(next.conditions, data);
                    }
                }
            }
        }
        static checkConditions(conditions, data) {
            if (!conditions || 0 == conditions.length || null == data.animatorParams || 0 == data.animatorParams.length) {
                return [];
            }
            let parms = data.animatorParams;
            for (let i = conditions.length - 1; i >= 0; i--) {
                let o = conditions[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    conditions.splice(i, 1);
                }
                else {
                    o.name = parm.name;
                    if (parm.type == exports.AniParmType.Float) {
                        let num = Number(o.checkValue);
                        if (isNaN(num)) {
                            o.checkValue = 0;
                        }
                        num = Number(o.type);
                        if (isNaN(num)) {
                            o.type = 0;
                        }
                    }
                }
            }
            return conditions;
        }
        static checkDefault(state, states) {
            let nexts = state.soloTransitions;
            let id = null;
            if (nexts && 0 < nexts.length) {
                id = nexts[0].id;
            }
            let defState = null;
            if (null != id) {
                defState = this.getStateByID(states, id);
            }
            if (null != defState && (null != defState.clip || null != defState.states)) {
                return defState.name;
            }
            for (let i = states.length - 1; i >= 0; i--) {
                if (states[i].clip) {
                    return states[i].name;
                }
            }
            return null;
        }
        static getStateByID(states, id) {
            if (states) {
                for (let i = states.length - 1; i >= 0; i--) {
                    if (states[i].id == id) {
                        return states[i];
                    }
                }
            }
            return null;
        }
    }

    exports.AnimatorUpdateMode = void 0;
    (function (AnimatorUpdateMode) {
        AnimatorUpdateMode[AnimatorUpdateMode["Normal"] = 0] = "Normal";
        AnimatorUpdateMode[AnimatorUpdateMode["LowFrame"] = 1] = "LowFrame";
        AnimatorUpdateMode[AnimatorUpdateMode["UnScaleTime"] = 2] = "UnScaleTime";
    })(exports.AnimatorUpdateMode || (exports.AnimatorUpdateMode = {}));

    class Animator2D extends Component {
        constructor() {
            super();
            this._speed = 1;
            this._updateMode = exports.AnimatorUpdateMode.Normal;
            this._lowUpdateDelty = 20;
            this._isPlaying = true;
            this._controllerLayers = [];
            this._parameters = {};
        }
        get controller() {
            return this._controller;
        }
        set controller(val) {
            if (this._controller)
                this._controller._removeReference();
            this._controller = val;
            if (val) {
                val._addReference();
                val.updateTo(this);
            }
        }
        get parameters() {
            return this._parameters;
        }
        set parameters(val) {
            this._parameters = val;
        }
        get speed() {
            return this._speed;
        }
        set speed(num) {
            this._speed = num;
        }
        get isPlaying() {
            return this._isPlaying;
        }
        _updateStateFinish(animatorState, playState) {
            if (playState._finish) {
                animatorState._eventExit();
            }
        }
        _setClipDatasToNode(stateInfo, additive, weight, controllerLayer = null) {
            var realtimeDatas = stateInfo._realtimeDatas;
            var nodes = stateInfo._clip._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                if (null == realtimeDatas[i])
                    continue;
                var node = nodes.getNodeByIndex(i);
                var o = this.getOwner(node);
                o && this._applyFloat(o, additive, weight, realtimeDatas[i]);
            }
        }
        _applyFloat(o, additive, weight, data) {
            var pro = o.pro;
            if (pro && pro.ower) {
                if (additive && "number" == typeof data) {
                    pro.ower[pro.key] = pro.defVal + weight * data;
                }
                else if ("number" == typeof data) {
                    pro.ower[pro.key] = weight * data;
                }
                else {
                    pro.ower[pro.key] = data;
                }
            }
        }
        getOwner(node) {
            var ret;
            if (this._ownerMap) {
                ret = this._ownerMap.get(node);
                if (ret) {
                    return ret;
                }
            }
            var property = this.owner;
            for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                var ownPat = node.getOwnerPathByIndex(j);
                if ("" == ownPat) {
                    continue;
                }
                else {
                    property = property.getChild(ownPat);
                    if (!property)
                        break;
                }
            }
            ret = { ower: property };
            if (property) {
                var pobj = property;
                var propertyCount = node.propertyCount;
                if (1 == propertyCount) {
                    var pname = node.getPropertyByIndex(0);
                    ret.pro = { ower: property, key: pname, defVal: property[pname] };
                }
                else {
                    for (var i = 0; i < propertyCount; i++) {
                        var pname = node.getPropertyByIndex(i);
                        if (i == propertyCount - 1 || null == pobj) {
                            ret.pro = { ower: pobj, key: pname, defVal: pobj ? pobj[pname] : null };
                            break;
                        }
                        if ('_gcmds' === pname && null == pobj[pname] && pobj.graphics) {
                            pobj = pobj.graphics;
                            pname = "cmds";
                        }
                        if (null == pobj[pname] && property == pobj) {
                            pobj = null;
                            var classObj = ClassUtils.getClass(pname);
                            if (classObj) {
                                pobj = property.getComponent(classObj);
                            }
                        }
                        else {
                            pobj = pobj[pname];
                        }
                    }
                }
            }
            if (null == this._ownerMap) {
                this._ownerMap = new Map();
            }
            this._ownerMap.set(node, ret);
            return ret;
        }
        _updateClipDatas(animatorState, addtive, playStateInfo) {
            var clip = animatorState._clip;
            var clipDuration = clip._duration;
            var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            var currentFrameIndices = animatorState._currentFrameIndices;
            let frontPlay = true;
            clip._evaluateClipDatasRealTime(curPlayTime, currentFrameIndices, addtive, frontPlay, animatorState._realtimeDatas);
        }
        _updatePlayer(animatorState, playState, elapsedTime, loop, layerIndex) {
            let isReplay = false;
            var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
            var lastElapsedTime = playState._elapsedTime;
            let pAllTime = playState._playAllTime;
            playState._playAllTime += Math.abs(elapsedTime);
            elapsedTime = lastElapsedTime + elapsedTime;
            playState._lastElapsedTime = lastElapsedTime;
            playState._elapsedTime = elapsedTime;
            var normalizedTime = elapsedTime / clipDuration;
            let scale = 1;
            if (animatorState.yoyo) {
                scale = 2;
            }
            let pTime = playState._playAllTime / (clipDuration * scale);
            if (Math.floor(pAllTime / (clipDuration * scale)) < Math.floor(pTime)) {
                isReplay = true;
            }
            var playTime = normalizedTime % 1.0;
            let normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            playState._normalizedPlayTime = normalizedPlayTime;
            playState._duration = clipDuration;
            if (1 != scale) {
                normalizedTime = playState._playAllTime / (clipDuration * scale);
                playTime = normalizedTime % 1.0;
                normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
                if (animatorState.yoyo) {
                    if (0.5 > normalizedPlayTime) {
                        if (!playState._frontPlay) {
                            if (0 > animatorState.speed) {
                                playState._elapsedTime = animatorState.clipEnd * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipEnd;
                            }
                            else {
                                playState._elapsedTime = animatorState.clipStart * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipStart;
                            }
                            playState._frontPlay = true;
                        }
                    }
                    else {
                        if (playState._frontPlay) {
                            playState._frontPlay = false;
                            if (0 > animatorState.speed) {
                                playState._elapsedTime = animatorState.clipStart * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipStart;
                            }
                            else {
                                playState._elapsedTime = animatorState.clipEnd * pAllTime;
                                playState._normalizedPlayTime = animatorState.clipEnd;
                            }
                        }
                    }
                }
            }
            animatorState._eventStateUpdate(normalizedPlayTime);
            let ret = this._applyTransition(layerIndex, animatorState._eventtransition(normalizedPlayTime, this.parameters, isReplay));
            if (!ret && isReplay) {
                let absTime = playState._playAllTime / (clipDuration * scale);
                if (0 < loop && loop <= absTime) {
                    playState._finish = true;
                    if (0 > animatorState.speed) {
                        if (animatorState.yoyo) {
                            playState._elapsedTime = animatorState.clipEnd * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipEnd;
                        }
                        else {
                            playState._elapsedTime = animatorState.clipStart * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipStart;
                        }
                    }
                    else {
                        if (animatorState.yoyo) {
                            playState._elapsedTime = animatorState.clipStart * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipStart;
                        }
                        else {
                            playState._elapsedTime = animatorState.clipEnd * pAllTime;
                            playState._normalizedPlayTime = animatorState.clipEnd;
                        }
                    }
                    return;
                }
                else {
                    animatorState._eventLoop();
                }
            }
        }
        _updateEventScript(stateInfo, playStateInfo) {
            let clip = stateInfo._clip;
            let events = clip._animationEvents;
            if (!events || 0 == events.length)
                return;
            let clipDuration = clip._duration;
            let time = playStateInfo._normalizedPlayTime * clipDuration;
            let frontPlay = playStateInfo._frontPlay;
            const speed = playStateInfo._currentState.speed;
            if (0 > speed)
                frontPlay = !frontPlay;
            let pTime = playStateInfo._parentPlayTime;
            let parentPlayTime = playStateInfo._parentPlayTime;
            if (null == parentPlayTime) {
                if (frontPlay) {
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipStart;
                }
                else {
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipEnd;
                }
            }
            if (frontPlay) {
                if (time < parentPlayTime) {
                    this._eventScript(events, parentPlayTime, time, true);
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipStart;
                }
            }
            else {
                if (time > parentPlayTime) {
                    this._eventScript(events, parentPlayTime, time, false);
                    parentPlayTime = clipDuration * playStateInfo.animatorState.clipEnd;
                }
            }
            this._eventScript(events, parentPlayTime, time, frontPlay);
            if (pTime == playStateInfo._parentPlayTime) {
                playStateInfo._parentPlayTime = time;
            }
        }
        _eventScript(events, parentPlayTime, currPlayTime, frontPlay) {
            let scripts = this.owner.components;
            if (frontPlay) {
                for (let i = 0, len = events.length; i < len; i++) {
                    let e = events[i];
                    if (e.time > parentPlayTime && e.time <= currPlayTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[e.eventName];
                                (fun) && (fun.apply(script, e.params));
                            }
                        }
                    }
                    else if (e.time > currPlayTime) {
                        break;
                    }
                }
            }
            else {
                for (let i = events.length - 1; i >= 0; i--) {
                    let e = events[i];
                    if (e.time < parentPlayTime && e.time >= currPlayTime) {
                        for (let j = 0, m = scripts.length; j < m; j++) {
                            let script = scripts[j];
                            if (script._isScript()) {
                                let fun = script[e.eventName];
                                (fun) && (fun.apply(script, e.params));
                            }
                        }
                    }
                    else if (e.time < currPlayTime) {
                        break;
                    }
                }
            }
        }
        _applyTransition(layerindex, transition) {
            if (!transition)
                return false;
            return this.crossFade(transition.destState.name, layerindex, transition.transstartoffset, transition.transduration);
        }
        _applyUpdateMode(delta) {
            let ret;
            switch (this._updateMode) {
                case exports.AnimatorUpdateMode.Normal:
                    ret = delta;
                    break;
                case exports.AnimatorUpdateMode.LowFrame:
                    ret = (Stat.loopCount % this._lowUpdateDelty == 0) ? delta * this._lowUpdateDelty : 0;
                    break;
                case exports.AnimatorUpdateMode.UnScaleTime:
                    ret = 0;
                    break;
            }
            return ret;
        }
        gotoAndStopByFrame(name, layerIndex, frame) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var animatorState = controllerLayer.getStateByName(name);
                if (!animatorState || !animatorState._clip)
                    return;
                var allFrame = animatorState._clip._duration * animatorState._clip._frameRate;
                let normalizedTime = frame / allFrame;
                if (1 < normalizedTime)
                    normalizedTime = 1;
                this.gotoAndStop(name, layerIndex, normalizedTime);
            }
        }
        getControllerLayer(layerIndex = 0) {
            return this._controllerLayers[layerIndex];
        }
        gotoAndStop(name, layerIndex, normalizedTime) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var animatorState = controllerLayer.getStateByName(name);
                if (!animatorState || !animatorState._clip)
                    return;
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                playStateInfo._normalizedPlayTime = normalizedTime;
                controllerLayer._playType = 0;
                if (curPlayState !== animatorState) {
                    playStateInfo._currentState = animatorState;
                }
                animatorState._eventStart(this, layerIndex);
                let addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                this._updateClipDatas(animatorState, addtive, playStateInfo);
                this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, controllerLayer);
                this.stop();
            }
        }
        play(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            if (this._checkEnterIndex) {
                let i = this._checkEnterIndex.indexOf(layerIndex);
                if (0 <= i) {
                    this._checkEnterIndex.splice(i, 1);
                }
            }
            this._isPlaying = true;
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var defaultState = controllerLayer.defaultState;
                if (!name && !defaultState)
                    throw new Error("Animator:must have default clip value,please set clip property.");
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo._currentState;
                var animatorState = name ? controllerLayer.getStateByName(name) : defaultState;
                if (!animatorState._clip)
                    return;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                if (curPlayState !== animatorState) {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                    else
                        playStateInfo._resetPlayState(0.0, calclipduration);
                    controllerLayer._playType = 0;
                    playStateInfo._currentState = animatorState;
                }
                else {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                        controllerLayer._playType = 0;
                    }
                }
                animatorState._eventStart(this, layerIndex);
            }
        }
        stop() {
            this._isPlaying = false;
        }
        onUpdate() {
            if (!this._isPlaying)
                return;
            if (this._checkEnterIndex) {
                for (let i = this._checkEnterIndex.length - 1; i >= 0; i--) {
                    let index = this._checkEnterIndex[i];
                    let enterTransition = this._controllerLayers[index]._enterTransition;
                    if (enterTransition.check(0, this.parameters, true)) {
                        var defaultClip = this.getDefaultState(index);
                        this.play(null, index, defaultClip.cycleOffset);
                    }
                }
            }
            var delta = this.owner.timer.delta / 1000.0;
            delta = this._applyUpdateMode(delta);
            if (0 == this.speed || 0 == delta)
                return;
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllerLayer = this._controllerLayers[i];
                if (!controllerLayer.enable)
                    continue;
                var playStateInfo = controllerLayer._playStateInfo;
                var addtive = controllerLayer.blendingMode != AnimatorControllerLayer2D.BLENDINGMODE_OVERRIDE;
                switch (controllerLayer._playType) {
                    case 0:
                        var animatorState = playStateInfo._currentState;
                        var speed = this._speed * animatorState.speed;
                        var finish = playStateInfo._finish;
                        var loop = animatorState.loop;
                        if (-1 >= loop) {
                            var clip = animatorState._clip;
                            if (clip.islooping) {
                                loop = 0;
                            }
                            else {
                                loop = 1;
                            }
                        }
                        let dir = 1;
                        if (!playStateInfo._frontPlay) {
                            dir = -1;
                        }
                        finish || this._updatePlayer(animatorState, playStateInfo, delta * speed * dir, loop, i);
                        playStateInfo = controllerLayer._playStateInfo;
                        animatorState = playStateInfo._currentState;
                        {
                            this._updateClipDatas(animatorState, addtive, playStateInfo);
                            if (!finish) {
                                this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, controllerLayer);
                                this._updateEventScript(animatorState, playStateInfo);
                            }
                        }
                        finish || this._updateStateFinish(animatorState, playStateInfo);
                        break;
                }
            }
        }
        addControllerLayer(controllerLayer) {
            this._controllerLayers.push(controllerLayer);
        }
        crossFade(name, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY, transitionDuration) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var destAnimatorState = controllerLayer.getStateByName(name);
                if (destAnimatorState) {
                    this.play(name, layerIndex, normalizedTime);
                    return true;
                }
                else {
                    console.warn("Invalid layerIndex " + layerIndex + ".");
                }
            }
            return false;
        }
        onAfterDeserialize() {
            let arr = this.controllerLayers;
            if (!arr || null != this.controller)
                return;
            delete this.controllerLayers;
            this._controllerLayers.length = 0;
            for (let layer of arr) {
                this.addControllerLayer(layer);
            }
        }
        onEnable() {
            if (this._checkEnterIndex)
                this._checkEnterIndex.length = 0;
            else
                this._checkEnterIndex = [];
            if (this._isPlaying) {
                for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                    if (this._controllerLayers[i].playOnWake) {
                        var defaultClip = this.getDefaultState(i);
                        if (defaultClip) {
                            let enterTransition = this._controllerLayers[i]._enterTransition;
                            if (enterTransition) {
                                this._isPlaying = true;
                                if (enterTransition.check(0, this.parameters, true)) {
                                    this.play(null, i, defaultClip.cycleOffset);
                                }
                                else {
                                    this._checkEnterIndex.push(i);
                                }
                            }
                            else {
                                this.play(null, i, defaultClip.cycleOffset);
                            }
                        }
                    }
                }
            }
        }
        getDefaultState(layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            return controllerLayer.defaultState;
        }
        setParamsTrigger(name) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Trigger, value: true };
        }
        setParamsNumber(name, value) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
        }
        setParamsBool(name, value) {
            this._parameters[name] = { name: name, type: exports.AniParmType.Float, value: value };
        }
        getParamsvalue(name) {
            let parm = this._parameters[name];
            if (parm) {
                return parm.value;
            }
            return null;
        }
        onDestroy() {
            if (this._controller) {
                this._controller._removeReference();
                this._controller = null;
            }
            for (var i = 0, n = this._controllerLayers.length; i < n; i++)
                this._controllerLayers[i].destroy();
            this._controllerLayers.length = 0;
            this._isPlaying = false;
            this._parameters = null;
        }
    }

    class AnimatorState2D extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._referenceCount = 0;
            this._clip = null;
            this._currentFrameIndices = null;
            this.cycleOffset = 0;
            this.speed = 1.0;
            this.clipStart = 0.0;
            this.clipEnd = 1.0;
            this.loop = -1;
            this.yoyo = false;
            this.transitions = [];
            this.soloTransitions = [];
            this._scripts = null;
            this._realtimeDatas = [];
        }
        get clip() {
            return this._clip;
        }
        set clip(value) {
            if (this._clip != value) {
                if (this._clip)
                    (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                if (value) {
                    var clipNodes = value._nodes;
                    var count = clipNodes.count;
                    this._currentFrameIndices = new Int16Array(count);
                    this._resetFrameIndices();
                    (this._referenceCount > 0) && (value._addReference(this._referenceCount));
                    this._realtimeDatas.length = count;
                }
                this._clip = value;
            }
        }
        _eventStateUpdate(value) {
            this.event(AnimatorState2D.EVENT_OnStateUpdate, value);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateUpdate(value);
            }
        }
        _eventStart(animator, layerIndex) {
            this.event(AnimatorState2D.EVENT_OnStateEnter);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].setPlayScriptInfo(animator, layerIndex, this);
                    this._scripts[i].onStateEnter();
                }
            }
        }
        _eventExit() {
            this.event(AnimatorState2D.EVENT_OnStateExit);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateExit();
                }
            }
        }
        _eventLoop() {
            this.event(AnimatorState2D.EVENT_OnStateLoop);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    if (this._scripts[i].onStateLoop)
                        this._scripts[i].onStateLoop();
                }
            }
        }
        _eventtransition(normalizeTime, paramsMap, isReplay) {
            let soloNums = this.soloTransitions.length;
            if (soloNums > 0) {
                for (var i = 0; i < soloNums; i++) {
                    if (this.soloTransitions[i].check(normalizeTime, paramsMap, isReplay))
                        return this.soloTransitions[i];
                }
                return null;
            }
            let transNums = this.transitions.length;
            for (var i = 0; i < transNums; i++) {
                if (this.transitions[i].check(normalizeTime, paramsMap, isReplay))
                    return this.transitions[i];
            }
            return null;
        }
        _resetFrameIndices() {
            for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                this._currentFrameIndices[i] = -1;
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count) {
            (this._clip) && (this._clip._addReference(count));
            this._referenceCount += count;
        }
        _removeReference(count) {
            (this._clip) && (this._clip._removeReference(count));
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        addScript(type) {
            var script = new type();
            this._scripts = this._scripts || [];
            this._scripts.push(script);
            return script;
        }
        getScript(type) {
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type)
                        return script;
                }
            }
            return null;
        }
        getScripts(type) {
            var coms = null;
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) {
                        coms = coms || [];
                        coms.push(script);
                    }
                }
            }
            return coms;
        }
        clone() {
            var dest = new AnimatorState2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.speed = this.speed;
            destObject.clip = this._clip;
        }
        destroy() {
            this._clip = null;
            this._currentFrameIndices = null;
            this._scripts = null;
            this._realtimeDatas.length = 0;
        }
    }
    AnimatorState2D.EVENT_OnStateEnter = "OnStartEnter";
    AnimatorState2D.EVENT_OnStateUpdate = "OnStateUpdate";
    AnimatorState2D.EVENT_OnStateExit = "OnStateExit";
    AnimatorState2D.EVENT_OnStateLoop = 'OnStateLoop';

    class KeyframeNode2D {
        constructor() {
            this._ownerPath = [];
            this._propertys = [];
            this._keyFrames = [];
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(value) {
            this._ownerPath.length = value;
        }
        _setOwnerPathByIndex(index, value) {
            this._ownerPath[index] = value;
        }
        _setPropertyCount(value) {
            this._propertys.length = value;
        }
        _setPropertyByIndex(index, value) {
            this._propertys[index] = value;
        }
        _setKeyframeCount(value) {
            this._keyFrames.length = value;
        }
        _joinOwnerPath(sep) {
            return this._ownerPath.join(sep);
        }
        _joinProperty(sep) {
            return this._propertys.join(sep);
        }
        getKeyframeByIndex(index) {
            return this._keyFrames[index];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        getOwnerPathByIndex(index) {
            return this._ownerPath[index];
        }
        getPropertyByIndex(index) {
            return this._propertys[index];
        }
    }

    class Keyframe2D {
        clone() {
            var dest = new Keyframe2D();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            destObject.time = this.time;
        }
    }
    Keyframe2D.defaultWeight = 0.33333;

    class Animation2DEvent {
        constructor() {
        }
    }

    class AnimationClip2DParse01 {
        static READ_DATA() {
            this._DATA.offset = this._reader.getUint32();
            this._DATA.size = this._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = this._BLOCK.count = this._reader.getUint16();
            var blockStarts = this._BLOCK.blockStarts = [];
            var blockLengths = this._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(this._reader.getUint32());
                blockLengths.push(this._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = this._reader.getUint32();
            var count = this._reader.getUint16();
            var prePos = this._reader.pos;
            this._reader.pos = offset + this._DATA.offset;
            for (var i = 0; i < count; i++)
                this._strings[i] = this._reader.readUTFString();
            this._reader.pos = prePos;
        }
        static parse(clip, reader, version) {
            this._clip = clip;
            this._reader = reader;
            this._version = version;
            this.READ_DATA();
            this.READ_BLOCK();
            this.READ_STRINGS();
            for (var i = 0, n = this._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = this._strings[index];
                var fn = this["READ_" + blockName];
                if (!fn) {
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                }
                else
                    fn.call(this);
            }
            this._version = null;
            this._reader = null;
            this._clip = null;
            this._strings.length = 0;
        }
        static timeToFrame(second, fps) {
            return Math.round(second * fps);
        }
        static READ_ANIMATIONS2D() {
            var i, j;
            var reader = this._reader;
            var clip = this._clip;
            var node;
            var numList = [];
            var numCount = reader.getUint16();
            numList.length = numCount;
            for (i = 0; i < numCount; i++) {
                numList[i] = reader.getFloat32();
            }
            clip._duration = numList[reader.getInt16()];
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode2D();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++) {
                    node._setOwnerPathByIndex(j, this._strings[reader.getUint16()]);
                }
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++) {
                    node._setPropertyByIndex(j, this._strings[reader.getUint16()]);
                }
                var fullPath = nodePath + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                node.nodePath = nodePath;
                var keyframeCount = reader.getUint16();
                for (j = 0; j < keyframeCount; j++) {
                    var k = new Keyframe2D();
                    k.time = numList[reader.getUint16()];
                    k.data = { f: this.timeToFrame(k.time, clip._frameRate), val: 0 };
                    if (1 == reader.getByte()) {
                        k.data.tweenType = this._strings[reader.getUint16()];
                    }
                    if (1 == reader.getByte()) {
                        k.data.tweenInfo = {};
                        k.data.tweenInfo.inTangent = numList[reader.getUint16()];
                        k.data.tweenInfo.outTangent = numList[reader.getUint16()];
                        if (1 == reader.getByte()) {
                            k.data.tweenInfo.inWeight = numList[reader.getUint16()];
                        }
                        if (1 == reader.getByte()) {
                            k.data.tweenInfo.outWeight = numList[reader.getUint16()];
                        }
                    }
                    var num = reader.getByte();
                    if (0 == num) {
                        k.data.val = numList[reader.getUint16()];
                    }
                    else if (1 == num) {
                        k.data.val = this._strings[reader.getUint16()];
                    }
                    else if (2 == num) {
                        k.data.val = !!reader.getByte();
                    }
                    if (1 == reader.getByte()) {
                        try {
                            k.data.extend = JSON.parse(this._strings[reader.getUint16()]);
                        }
                        catch (err) { }
                    }
                    node._keyFrames.push(k);
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new Animation2DEvent();
                event.time = numList[reader.getUint16()];
                event.eventName = this._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(numList[reader.getUint16()]);
                            break;
                        case 3:
                            params.push(this._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClip2DParse01._strings = [];
    AnimationClip2DParse01._DATA = { offset: 0, size: 0 };
    AnimationClip2DParse01._BLOCK = { count: 0 };

    class KeyframeNodeList2D {
        constructor() {
            this._nodes = [];
        }
        get count() {
            return this._nodes.length;
        }
        set count(value) {
            this._nodes.length = value;
        }
        getNodeByIndex(index) {
            return this._nodes[index];
        }
        setNodeByIndex(index, node) {
            this._nodes[index] = node;
        }
    }

    class AnimationClip2D extends Resource {
        static _parse(data) {
            var clip = new AnimationClip2D();
            var reader = new Byte(data);
            var version = reader.readUTFString();
            switch (version) {
                case "LAYAANIMATION2D:01":
                    AnimationClip2DParse01.parse(clip, reader, version);
                    break;
                default:
                    throw "unknown animationClip version.";
            }
            return clip;
        }
        constructor() {
            super();
            this._nodes = new KeyframeNodeList2D();
            this._animationEvents = [];
        }
        duration() {
            return this._duration;
        }
        _evaluateClipDatasRealTime(playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay, outDatas) {
            var nodes = this._nodes;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var nextFrameIndex;
                var keyFrames = node._keyFrames;
                var keyFramesCount = keyFrames.length;
                if (0 == keyFramesCount)
                    continue;
                var frameIndex = realTimeCurrentFrameIndexes[i];
                if (frontPlay) {
                    if ((-1 != frameIndex) && (playCurTime < keyFrames[frameIndex].time)) {
                        frameIndex = -1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (nextFrameIndex < keyFramesCount) {
                        if (keyFrames[nextFrameIndex].time > playCurTime)
                            break;
                        frameIndex++;
                        nextFrameIndex++;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                else {
                    nextFrameIndex = frameIndex + 1;
                    if ((nextFrameIndex != keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) {
                        frameIndex = keyFramesCount - 1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (frameIndex > -1) {
                        if (keyFrames[frameIndex].time < playCurTime)
                            break;
                        frameIndex--;
                        nextFrameIndex--;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                var isEnd = nextFrameIndex == keyFramesCount;
                if (-1 != frameIndex) {
                    var frame = keyFrames[frameIndex];
                    if (isEnd) {
                        outDatas[i] = frame.data.val;
                    }
                    else {
                        var nextFarme = keyFrames[nextFrameIndex];
                        var d = nextFarme.time - frame.time;
                        var t;
                        if (d !== 0)
                            t = (playCurTime - frame.time) / d;
                        else
                            t = 0;
                        outDatas[i] = this._getTweenVal(frame, nextFarme, t, d);
                    }
                }
                else {
                    outDatas[i] = keyFrames[0].data.val;
                }
                if (addtive && "number" == typeof keyFrames[0].data.val) {
                    outDatas[i] = outDatas[i] - keyFrames[0].data.val;
                }
            }
        }
        _getTweenVal(frame, nextFrame, t, dur) {
            var start = frame.data;
            var end = nextFrame.data;
            if ("number" != typeof start.val || "number" != typeof end.val) {
                return start.val;
            }
            var tweenFun = getEase(start.tweenType);
            var poval = start.val;
            var oval = end.val;
            if (null != tweenFun) {
                return tweenFun(t, poval, oval - poval, 1);
            }
            var outTangent = 0;
            var inTangent = 0;
            var outWeight = NaN;
            var inWeight = NaN;
            if (null != start.tweenInfo) {
                outTangent = start.tweenInfo.outTangent;
                outWeight = start.tweenInfo.outWeight;
            }
            if (null != end.tweenInfo) {
                inTangent = end.tweenInfo.inTangent;
                inWeight = end.tweenInfo.inWeight;
            }
            if (isNaN(outWeight) || 0 >= outWeight)
                outWeight = Keyframe2D.defaultWeight;
            if (isNaN(inWeight) || 0 >= inWeight)
                inWeight = Keyframe2D.defaultWeight;
            if (isNaN(outTangent))
                outTangent = 0;
            if (isNaN(inTangent))
                inTangent = 0;
            if (Math.abs(outTangent) == Number.MAX_VALUE) {
                if (0 > outTangent) {
                    outTangent = -Infinity;
                }
                else {
                    outTangent = Infinity;
                }
            }
            if (Math.abs(inTangent) == Number.MAX_VALUE) {
                if (0 > inTangent) {
                    inTangent = -Infinity;
                }
                else {
                    inTangent = Infinity;
                }
            }
            var tnum;
            if ((!start.tweenInfo && !end.tweenInfo) || (Keyframe2D.defaultWeight == inWeight && Keyframe2D.defaultWeight == outWeight)) {
                tnum = hermiteInterpolate(outTangent, inTangent, poval, oval, t, dur);
            }
            else {
                tnum = this.hermiteCurveSplineWeight(poval, frame.time, outWeight, outTangent, oval, nextFrame.time, inWeight, inTangent, t);
            }
            return tnum;
        }
        _binarySearchEventIndex(time) {
            var start = 0;
            var end = this._animationEvents.length - 1;
            var mid;
            while (start <= end) {
                mid = (start + end) >> 1;
                var midValue = this._animationEvents[mid].time;
                if (midValue == time)
                    return mid;
                else if (midValue > time)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        hermiteCurveSplineWeight(frameValue, frametime, frameOutWeight, frameOutTangent, nextframeValue, nextframetime, nextframeInweight, nextframeIntangent, time) {
            let Eps = 2.22e-16;
            let x = time;
            let x1 = frametime;
            let y1 = frameValue;
            let wt1 = frameOutWeight;
            let x2 = nextframetime;
            let y2 = nextframeValue;
            let wt2 = nextframeInweight;
            let dx = x2 - x1;
            let dy = y2 - y1;
            dy = Math.max(Math.abs(dy), Eps) * (dy < 0 ? -1 : 1);
            let yp1 = frameOutTangent;
            let yp2 = nextframeIntangent;
            if (!Number.isFinite(yp1) || !Number.isFinite(yp2)) {
                return frameValue;
            }
            yp1 = yp1 * dx / dy;
            yp2 = yp2 * dx / dy;
            let wt2s = 1 - wt2;
            let t = 0.5;
            let t2 = 0;
            if (Math.abs(wt1 - 0.33333334) < 0.0001 && Math.abs(wt2 - 0.33333334) < 0.0001) {
                t = x;
                t2 = 1 - t;
            }
            else {
                while (true) {
                    t2 = (1 - t);
                    let fg = 3 * t2 * t2 * t * wt1 + 3 * t2 * t * t * wt2s + t * t * t - x;
                    if (Math.abs(fg) <= 2.5 * Eps)
                        break;
                    let fpg = 3 * t2 * t2 * wt1 + 6 * t2 * t * (wt2s - wt1) + 3 * t * t * (1 - wt2s);
                    let fppg = 6 * t2 * (wt2s - 2 * wt1) + 6 * t * (1 - 2 * wt2s + wt1);
                    let fpppg = 18 * wt1 - 18 * wt2s + 6;
                    t -= (6 * fg * fpg * fpg - 3 * fg * fg * fppg) / (6 * fpg * fpg * fpg - 6 * fg * fpg * fppg + fg * fg * fpppg);
                }
            }
            let y = 3 * t2 * t2 * t * wt1 * yp1 + 3 * t2 * t * t * (1 - wt2 * yp2) + t * t * t;
            return y * dy + y1;
        }
        addEvent(event) {
            var index = this._binarySearchEventIndex(event.time);
            this._animationEvents.splice(index, 0, event);
        }
    }
    const _map = {};
    function getEase(name) {
        if (!name)
            return null;
        let func = _map[name];
        if (!func) {
            name = name.replace("_Ease", "");
            name = name.charAt(0).toLowerCase() + name.substring(1);
            func = Ease[name];
            if (func != null)
                _map[name] = func;
        }
        return func;
    }
    function hermiteInterpolate(outTangent, inTangent, startValue, endValue, t, dur) {
        if (Math.abs(outTangent) == Infinity || Math.abs(inTangent) == Infinity) {
            if (0 > outTangent || 0 < inTangent)
                return startValue;
            return startValue;
        }
        var t2 = t * t;
        var t3 = t2 * t;
        var a = 2.0 * t3 - 3.0 * t2 + 1.0;
        var b = t3 - 2.0 * t2 + t;
        var c = t3 - t2;
        var d = -2.0 * t3 + 3.0 * t2;
        return a * startValue + b * outTangent * dur + c * inTangent * dur + d * endValue;
    }

    class Animation2DParm {
    }

    exports.AniConditionType = void 0;
    (function (AniConditionType) {
        AniConditionType[AniConditionType["Greater"] = 0] = "Greater";
        AniConditionType[AniConditionType["Less"] = 1] = "Less";
        AniConditionType[AniConditionType["Equals"] = 2] = "Equals";
        AniConditionType[AniConditionType["NotEqual"] = 3] = "NotEqual";
    })(exports.AniConditionType || (exports.AniConditionType = {}));
    class Animation2DCondition {
    }

    class Prefab extends Resource {
        constructor() {
            super(false);
            this.fromDCC = false;
            this._traceDeps = true;
        }
        onLoad() {
            Resource._idResourcesMap[this._id] = this;
            return this;
        }
        create(options, errors) {
            return null;
        }
    }
    var HierarchyResource = Prefab;

    class AnimatorStateCondition {
        static conditionNameToID(name) {
            if (AnimatorStateCondition._conditionNameMap[name] != null) {
                return AnimatorStateCondition._conditionNameMap[name];
            }
            else {
                var id = this._propertyNameCounter++;
                this._conditionNameMap[name] = id;
                this._conditionNameMap[id] = name;
                return id;
            }
        }
        static conditionIDToName(id) {
            return this._conditionNameMap[id];
        }
        constructor(name = null) {
            if (!name)
                return;
            this._id = AnimatorStateCondition.conditionNameToID(name);
            this._name = name;
        }
        get id() {
            return this._id;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._id = AnimatorStateCondition.conditionNameToID(value);
            this._name = value;
        }
        get type() {
            return this._type;
        }
        checkState(value) {
            return false;
        }
    }
    AnimatorStateCondition._conditionNameMap = {};
    AnimatorStateCondition._propertyNameCounter = 0;
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._numberValue = 0;
            this._numberCompareFlag = exports.AniStateConditionNumberCompressType.Greater;
            this._type = exports.AniStateConditionType.Number;
        }
        get numberValue() {
            return this._numberValue;
        }
        set numberValue(value) {
            this._numberValue = value;
        }
        get compareFlag() {
            return this._numberCompareFlag;
        }
        set compareFlag(value) {
            this._numberCompareFlag = value;
        }
        checkState(value) {
            if (exports.AniStateConditionNumberCompressType.Greater == this._numberCompareFlag)
                return value > this._numberValue;
            else
                return value < this._numberValue;
        }
    }
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._compareFlag = true;
            this._type = exports.AniStateConditionType.Bool;
        }
        get compareFlag() {
            return this._compareFlag;
        }
        set compareFlag(value) {
            this._compareFlag = value;
        }
        checkState(value) {
            return this._compareFlag == value;
        }
    }
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        constructor(name) {
            super(name);
            this._type = exports.AniStateConditionType.Trigger;
        }
        checkState(value) {
            return value;
        }
    }

    class AnimatorTransition2D {
        constructor() {
            this.conditions = [];
            this.exitByTime = true;
            this.exitTime = 1;
            this.transduration = 0;
            this.transstartoffset = 0;
            this.mute = false;
        }
        addCondition(condition) {
            if (this.conditions.indexOf(condition) == -1) {
                this.conditions.push(condition);
            }
        }
        removeCondition(condition) {
            let index = this.conditions.indexOf(condition);
            if (index != -1) {
                this.conditions.splice(index, 0);
            }
        }
        check(normalizeTime, paramsMap, isReplay) {
            if (this.mute)
                return false;
            if (this.exitByTime && (normalizeTime < this.exitTime && !isReplay))
                return false;
            if (!this.conditions || this.conditions.length === 0)
                return true;
            if (this.isAndOperEnabled) {
                for (let i = 0; i < this.conditions.length; i++) {
                    const con = this.conditions[i];
                    const out = con.checkState(paramsMap[con.name].value);
                    if (!out)
                        return false;
                    if (con.type === exports.AniStateConditionType.Trigger) {
                        paramsMap[con.name].value = false;
                    }
                }
                return true;
            }
            else {
                for (let i = 0; i < this.conditions.length; i++) {
                    const con = this.conditions[i];
                    const out = con.checkState(paramsMap[con.name].value);
                    if (out) {
                        if (con.type === exports.AniStateConditionType.Trigger) {
                            paramsMap[con.name].value = false;
                        }
                        return true;
                    }
                }
            }
            return false;
        }
    }

    class AnimatorController2D extends Resource {
        constructor(data) {
            super();
            let obj = AnimatorControllerParse.parse(data);
            this.data = obj.ret;
            this.clipsID = obj.clipsID;
        }
        getLayers() {
            let layers = this.data.controllerLayers;
            let lArr = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let acl = new AnimatorControllerLayer2D(l.name);
                lArr.unshift(acl);
                for (let k in l) {
                    if ("name" == k || "states" == k || null == l[k]) {
                        continue;
                    }
                    try {
                        acl[k] = l[k];
                    }
                    catch (err) {
                        console.error(err);
                    }
                }
                this.getState(l.states, acl, this.data);
            }
            return lArr;
        }
        createState(states, idCatch, acl) {
            if (!states)
                return null;
            let ret = {};
            let defID = null;
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                let childStates = obj.states;
                if (childStates) {
                    let groupRet = this.createState(childStates, idCatch, acl);
                    if (groupRet) {
                        idCatch[obj.id] = groupRet.states[groupRet.id];
                    }
                    continue;
                }
                if (0 > Number(obj.id)) {
                    if ("-1" == obj.id) {
                        let transitions = obj.soloTransitions;
                        if (transitions && 0 < transitions.length) {
                            defID = transitions[0].id;
                        }
                    }
                    continue;
                }
                let state = new AnimatorState2D();
                idCatch[obj.id] = state;
                ret[obj.id] = state;
                for (let k in obj) {
                    try {
                        if ("scripts" == k) {
                            let scripts = obj[k];
                            if (scripts && Array.isArray(scripts)) {
                                for (let k = scripts.length - 1; k >= 0; k--) {
                                    let uuid = scripts[k];
                                    if (uuid && 0 == uuid.indexOf("res://")) {
                                        uuid = uuid.substring(6);
                                    }
                                    let c = ClassUtils.getClass(uuid);
                                    if (c) {
                                        state.addScript(c);
                                    }
                                }
                            }
                            continue;
                        }
                        else if ("soloTransitions" == k) {
                            continue;
                        }
                        else if (null != obj[k]) {
                            state[k] = obj[k];
                        }
                    }
                    catch (err) { }
                }
                acl.addState(state);
            }
            return { id: defID, states: ret };
        }
        getState(states, acl, data) {
            if (states) {
                let idCatch = {};
                this.createState(states, idCatch, acl);
                this.setTransitions(states, idCatch, acl, data);
            }
        }
        setExitTransition(exitRet, transitions, idCatch, data, pExitRet) {
            for (let id in exitRet) {
                let state = idCatch[id];
                if (state) {
                    let ats = state.transitions;
                    let sts = state.soloTransitions;
                    let linArr = exitRet[id];
                    for (let i = transitions.length - 1; i >= 0; i--) {
                        let t = transitions[i];
                        if ("-3" == t.id) {
                            if (null == pExitRet[id]) {
                                pExitRet[id] = [];
                            }
                            pExitRet[id].push(t);
                            continue;
                        }
                        for (let j = linArr.length - 1; j >= 0; j--) {
                            let t2 = linArr[j];
                            let ato = new AnimatorTransition2D();
                            ato.destState = idCatch[t.id];
                            if (t.conditions) {
                                this.addConditions(t.conditions, ato, data);
                            }
                            if (t2.conditions) {
                                this.addConditions(t2.conditions, ato, data);
                            }
                            for (let k in t) {
                                if ("solo" == k || "id" == k || "conditions" == k) {
                                    continue;
                                }
                                else {
                                    ato[k] = t[k];
                                }
                            }
                            if (t.solo) {
                                sts.unshift(ato);
                            }
                            else {
                                ats.unshift(ato);
                            }
                        }
                    }
                }
            }
        }
        _getAnimatorTransition2D(o, idCatch, data) {
            let ato = new AnimatorTransition2D();
            if (idCatch[o.id]) {
                ato.destState = idCatch[o.id];
            }
            if (o.conditions) {
                this.addConditions(o.conditions, ato, data);
            }
            for (let k in o) {
                if ("solo" == k || "id" == k || "conditions" == k) {
                    continue;
                }
                else {
                    ato[k] = o[k];
                }
            }
            return ato;
        }
        setTransitions(states, idCatch, acl, data, pState) {
            if (!states)
                return null;
            let exitRet = {};
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    let exitTransition = this.setTransitions(obj.states, idCatch, acl, data, obj);
                    if (exitTransition) {
                        let transitions = obj.soloTransitions;
                        if (transitions) {
                            this.setExitTransition(exitTransition, transitions, idCatch, data, exitRet);
                        }
                    }
                }
            }
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    continue;
                }
                if ("-1" == obj.id) {
                    if (obj.soloTransitions && 0 < obj.soloTransitions.length) {
                        if (null == pState) {
                            acl.defaultState = idCatch[obj.soloTransitions[0].id];
                            acl._enterTransition = this._getAnimatorTransition2D(obj.soloTransitions[0], idCatch, data);
                        }
                        else {
                            idCatch[pState.id] = idCatch[obj.soloTransitions[0].id];
                        }
                        continue;
                    }
                }
                else if ("-2" == obj.id) {
                    let transitions = obj.soloTransitions;
                    if (transitions) {
                        for (let j = transitions.length - 1; j >= 0; j--) {
                            let o = transitions[j];
                            let destState = idCatch[o.id];
                            if (destState) {
                                for (let idk in idCatch) {
                                    let state = idCatch[idk];
                                    let ato = this._getAnimatorTransition2D(o, idCatch, data);
                                    if (o.solo) {
                                        state.soloTransitions.unshift(ato);
                                    }
                                    else {
                                        state.transitions.unshift(ato);
                                    }
                                }
                            }
                        }
                    }
                    continue;
                }
                else if ("-3" == obj.id) {
                    continue;
                }
                let soloTransitions = obj.soloTransitions;
                if (soloTransitions && idCatch[obj.id]) {
                    let ats = idCatch[obj.id].transitions;
                    let sts = idCatch[obj.id].soloTransitions;
                    for (let j = soloTransitions.length - 1; j >= 0; j--) {
                        let o = soloTransitions[j];
                        if ("-3" == o.id) {
                            if (null == exitRet[obj.id]) {
                                exitRet[obj.id] = [];
                            }
                            exitRet[obj.id].push(o);
                            continue;
                        }
                        let ato = this._getAnimatorTransition2D(o, idCatch, data);
                        if (o.solo) {
                            sts.unshift(ato);
                        }
                        else {
                            ats.unshift(ato);
                        }
                    }
                }
            }
            return exitRet;
        }
        addConditions(arr, ato, data) {
            let parms = data.animatorParams;
            if (null == parms || 0 == parms.length)
                return;
            for (let i = 0, len = arr.length; i < len; i++) {
                let o = arr[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    return;
                }
                let c;
                if (parm.type == exports.AniParmType.Bool) {
                    let b = new AnimatorStateBoolCondition(parm.name);
                    b.compareFlag = Boolean(o.checkValue);
                    c = b;
                }
                else if (parm.type == exports.AniParmType.Float) {
                    let n = new AnimatorStateNumberCondition(parm.name);
                    n.numberValue = Number(o.checkValue);
                    n.compareFlag = o.type;
                    c = n;
                }
                else if (parm.type == exports.AniParmType.Trigger) {
                    let t = new AnimatorStateTriggerCondition(parm.name);
                    c = t;
                }
                ato.addCondition(c);
            }
        }
        updateTo(a) {
            let currLayer = a._controllerLayers;
            for (let i = 0, len = currLayer.length; i < len; i++) {
                currLayer[i].destroy();
            }
            currLayer.length = 0;
            let layers = this.getLayers();
            for (let i = 0, len = layers.length; i < len; i++) {
                a.addControllerLayer(layers[i]);
            }
            let parms = this.data.animatorParams;
            if (parms) {
                let setParm = {};
                for (let i = parms.length - 1; i >= 0; i--) {
                    let p = parms[i];
                    let sp = new Animation2DParm();
                    sp.name = p.name;
                    sp.type = p.type;
                    sp.value = p.val;
                    setParm[p.name] = sp;
                }
                a.parameters = setParm;
            }
        }
    }

    class Script extends Component {
        _isScript() {
            return true;
        }
        setupScript() {
            let owner = this.owner;
            let func;
            if (func = this.onTriggerEnter)
                owner.on(Event.TRIGGER_ENTER, this, func);
            if (func = this.onTriggerStay)
                owner.on(Event.TRIGGER_STAY, this, func);
            if (func = this.onTriggerExit)
                owner.on(Event.TRIGGER_EXIT, this, func);
            if (func = this.onCollisionEnter)
                owner.on(Event.COLLISION_ENTER, this, func);
            if (func = this.onCollisionStay)
                owner.on(Event.COLLISION_STAY, this, func);
            if (func = this.onCollisionExit)
                owner.on(Event.COLLISION_EXIT, this, func);
            if (func = this.onJointBreak)
                owner.on(Event.JOINT_BREAK, this, func);
            if (func = this.onMouseDown)
                owner.on(Event.MOUSE_DOWN, this, func);
            if (func = this.onMouseUp)
                owner.on(Event.MOUSE_UP, this, func);
            if (func = this.onRightMouseDown)
                owner.on(Event.RIGHT_MOUSE_DOWN, this, func);
            if (func = this.onRightMouseUp)
                owner.on(Event.RIGHT_MOUSE_UP, this, func);
            if (func = this.onMouseMove)
                owner.on(Event.MOUSE_MOVE, this, func);
            if (func = this.onMouseDrag)
                owner.on(Event.MOUSE_DRAG, this, func);
            if (func = this.onMouseDragEnd)
                owner.on(Event.MOUSE_DRAG_END, this, func);
            if (func = this.onMouseOver)
                owner.on(Event.MOUSE_OVER, this, func);
            if (func = this.onMouseOut)
                owner.on(Event.MOUSE_OUT, this, func);
            if (func = this.onMouseClick)
                owner.on(Event.CLICK, this, func);
            if (func = this.onMouseDoubleClick)
                owner.on(Event.DOUBLE_CLICK, this, func);
            if (func = this.onMouseRightClick)
                owner.on(Event.RIGHT_CLICK, this, func);
            if (func = this.onKeyDown)
                ILaya.stage.on(Event.KEY_DOWN, this, func);
            if (func = this.onKeyPress)
                ILaya.stage.on(Event.KEY_PRESS, this, func);
            if (func = this.onKeyUp)
                ILaya.stage.on(Event.KEY_UP, this, func);
        }
    }

    class VertexMesh2D {
        static getVertexDeclaration(vertexFlags, compatible = true) {
            let verDecs = [];
            for (let i = 0, len = vertexFlags.length; i < len; i++) {
                let vertexFlag = vertexFlags[i];
                let verDec = VertexMesh2D._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")];
                if (!verDec) {
                    var subFlags = vertexFlag.split(",");
                    var offset = 0;
                    var elements = [];
                    for (let j = 0, n = subFlags.length; j < n; j++) {
                        var element;
                        switch (subFlags[j]) {
                            case "POSITION":
                                element = new VertexElement(offset, VertexElementFormat.Vector3, VertexMesh.MESH_POSITION0);
                                offset += 12;
                                break;
                            case "COLOR":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_COLOR0);
                                offset += 16;
                                break;
                            case "UV":
                                element = new VertexElement(offset, VertexElementFormat.Vector2, VertexMesh.MESH_TEXTURECOORDINATE0);
                                offset += 8;
                                break;
                            case "BLENDWEIGHT":
                                element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDWEIGHT0);
                                offset += 16;
                                break;
                            case "BLENDINDICES":
                                if (compatible) {
                                    element = new VertexElement(offset, VertexElementFormat.Vector4, VertexMesh.MESH_BLENDINDICES0);
                                    offset += 16;
                                }
                                else {
                                    element = new VertexElement(offset, VertexElementFormat.Byte4, VertexMesh.MESH_BLENDINDICES0);
                                    offset += 4;
                                }
                                break;
                            default:
                                throw "VertexMesh: unknown vertex flag.";
                        }
                        elements.push(element);
                    }
                    verDec = new VertexDeclaration(offset, elements);
                    VertexMesh2D._vertexDeclarationMap[vertexFlag + (compatible ? "_0" : "_1")] = verDec;
                }
                verDecs.push(verDec);
            }
            return verDecs;
        }
        static getMeshDefine(mesh, out) {
            out.length = 0;
            let vertexs = mesh._vertexBuffers;
            for (var i = 0, n = vertexs.length; i < n; i++) {
                let elements = vertexs[i].vertexDeclaration._vertexElements;
                for (const element of elements) {
                    switch (element.elementUsage) {
                        case VertexMesh.MESH_COLOR0:
                            out.push(Shader3D.getDefineByName("COLOR"));
                            break;
                        case VertexMesh.MESH_TEXTURECOORDINATE0:
                            out.push(Shader3D.getDefineByName("UV"));
                            break;
                    }
                }
            }
        }
    }
    VertexMesh2D._vertexDeclarationMap = {};
    class Mesh2D extends Resource {
        static createMesh2DByPrimitive(vbs, vbDeclaration, ib, ibFormat, submeshInfo, canRead = false) {
            let mesh2d = new Mesh2D();
            mesh2d.canRead = canRead;
            let vbArray = [];
            let vertices = [];
            for (var i = 0, n = vbs.length; i < n; i++) {
                let vbdata = vbs[i];
                let vertex = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
                vertex.vertexDeclaration = vbDeclaration[i];
                vertex.setDataLength(vbdata.buffer.byteLength);
                vertex.setData(vbdata.buffer, 0, 0, vbdata.buffer.byteLength);
                vbArray.push(vertex);
                vertices[i] = vbdata.buffer;
            }
            let indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Dynamic);
            indexBuffer._setIndexDataLength(ib.buffer.byteLength);
            indexBuffer._setIndexData(ib, 0);
            indexBuffer.indexType = ibFormat;
            mesh2d._setBuffers(vbArray, indexBuffer);
            let geometryArray = [];
            for (var i = 0; i < submeshInfo.length; i++) {
                let geometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
                geometry.bufferState = mesh2d._bufferState;
                geometry.setDrawElemenParams(submeshInfo[i].length, submeshInfo[i].start);
                geometry.indexFormat = ibFormat;
                geometryArray.push(geometry);
            }
            mesh2d._setSubMeshes(geometryArray);
            if (canRead) {
                mesh2d._vertices = vertices;
                mesh2d._indices = ib;
            }
            return mesh2d;
        }
        get vertexBuffers() {
            return this._vertexBuffers;
        }
        get indexBuffer() {
            return this._indexBuffer;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get indexFormat() {
            return this._indexFormat;
        }
        constructor() {
            super();
            this._instanceBufferStateType = 0;
            this._vertexBuffers = null;
            this._indexBuffer = null;
            this._vertexCount = 0;
            this._indexFormat = exports.IndexFormat.UInt16;
            this.canRead = false;
            this._vertices = null;
            this._indices = null;
            this._bufferState = LayaGL.renderDeviceFactory.createBufferState();
            this._subMeshes = [];
            this.destroyedImmediately = Config.destroyResourceImmediatelyDefault;
        }
        _disposeResource() {
            for (let i = 0, n = this._subMeshes.length; i < n; i++)
                this._subMeshes[i].destroy();
            for (let i = 0, n = this._vertexBuffers.length; i < n; i++)
                this._vertexBuffers[i].destroy();
            this._indexBuffer && this._indexBuffer.destroy();
            this._bufferState.destroy();
            this._instanceBufferState && this._instanceBufferState.destroy();
            this._instanceWorldVertexBuffer && this._instanceWorldVertexBuffer.destroy();
            this._instanceSimpleAniVertexBuffer && this._instanceSimpleAniVertexBuffer.destroy();
            this._setCPUMemory(0);
            this._setGPUMemory(0);
            this._bufferState = null;
            this._instanceBufferState = null;
            this._vertexBuffers = null;
            this._indexBuffer = null;
            this._subMeshes = null;
            this._indexBuffer = null;
        }
        _setSubMeshes(subMeshes) {
            this._subMeshes = subMeshes;
        }
        _setBuffers(vertexBuffers, indexBuffer) {
            var bufferState = this._bufferState;
            this._vertexBuffers = vertexBuffers;
            this._indexBuffer = indexBuffer;
            bufferState.applyState(vertexBuffers, indexBuffer);
        }
        getSubMesh(index) {
            return this._subMeshes[index];
        }
        setVertices(vertices) {
            for (let i = 0, len = vertices.length; i < len; i++) {
                if (vertices[i] && this._vertexBuffers[i]) {
                    this._vertexBuffers[i].setData(vertices[i], 0, 0, vertices[i].byteLength);
                }
            }
            if (this.canRead) {
                this._vertices = vertices;
            }
        }
        getVertices() {
            if (!this.canRead || !this._vertices) {
                throw new Error("Can't getVertices without the canRead flag, or if the canRead flag is false before setVertices!");
            }
            else {
                return this._vertices;
            }
        }
        setVertexByIndex(data, index, bufferOffset = 0) {
            this._vertexBuffers[index].setData(data, bufferOffset, 0, data.byteLength);
        }
        setIndices(indices) {
            var format;
            if (indices instanceof Uint32Array)
                format = exports.IndexFormat.UInt32;
            else if (indices instanceof Uint16Array)
                format = exports.IndexFormat.UInt16;
            else if (indices instanceof Uint8Array)
                format = exports.IndexFormat.UInt8;
            let indexBuffer = this._indexBuffer;
            if (indexBuffer.indexCount < indices.length) {
                console.error("Mesh2D:set indices buffer large than ori indices");
            }
            var iscreateBuffer = false;
            if (this._indexFormat !== format || indexBuffer.indexCount < indices.length) {
                indexBuffer.destroy();
                iscreateBuffer = true;
                this._indexBuffer = indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Static);
                this._indexBuffer._setIndexDataLength(indices.byteLength);
                indexBuffer.indexCount = indexBuffer.indexCount;
                indexBuffer.indexType = format;
            }
            indexBuffer._setIndexData(indices, 0);
            if (iscreateBuffer) {
                this._bufferState.applyState(this._bufferState._vertexBuffers, indexBuffer);
            }
            if (this.canRead) {
                this._indices = indices;
            }
        }
        getIndices() {
            if (!this.canRead || !this._indices) {
                throw new Error("Can't getIndices without the canRead flag, or if the canRead flag is false before setIndices!");
            }
            else {
                return this._indices;
            }
        }
    }

    class LoadModel2DV01 {
        static parse(readData, version, mesh, subMeshes) {
            LoadModel2DV01._mesh = mesh;
            LoadModel2DV01._subMeshes = subMeshes;
            LoadModel2DV01._version = version;
            LoadModel2DV01._readData = readData;
            LoadModel2DV01.READ_DATA();
            LoadModel2DV01.READ_BLOCK();
            LoadModel2DV01.READ_STRINGS();
            for (var i = 0, n = LoadModel2DV01._BLOCK.count; i < n; i++) {
                LoadModel2DV01._readData.pos = LoadModel2DV01._BLOCK.blockStarts[i];
                var index = LoadModel2DV01._readData.getUint16();
                var blockName = LoadModel2DV01._strings[index];
                var fn = LoadModel2DV01["READ_" + blockName];
                if (fn == null)
                    console.warn("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            LoadModel2DV01._strings.length = 0;
            LoadModel2DV01._readData = null;
            LoadModel2DV01._version = null;
            LoadModel2DV01._mesh = null;
            LoadModel2DV01._subMeshes = null;
        }
        static _readString() {
            return LoadModel2DV01._strings[LoadModel2DV01._readData.getUint16()];
        }
        static READ_DATA() {
            LoadModel2DV01._DATA.offset = LoadModel2DV01._readData.getUint32();
            LoadModel2DV01._DATA.size = LoadModel2DV01._readData.getUint32();
        }
        static READ_BLOCK() {
            var count = LoadModel2DV01._BLOCK.count = LoadModel2DV01._readData.getUint16();
            var blockStarts = LoadModel2DV01._BLOCK.blockStarts = [];
            var blockLengths = LoadModel2DV01._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(LoadModel2DV01._readData.getUint32());
                blockLengths.push(LoadModel2DV01._readData.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = LoadModel2DV01._readData.getUint32();
            var count = LoadModel2DV01._readData.getUint16();
            var prePos = LoadModel2DV01._readData.pos;
            LoadModel2DV01._readData.pos = offset + LoadModel2DV01._DATA.offset;
            for (var i = 0; i < count; i++)
                LoadModel2DV01._strings[i] = LoadModel2DV01._readData.readUTFString();
            LoadModel2DV01._readData.pos = prePos;
        }
        static READ_MESH() {
            var i;
            var memorySize = 0;
            var name = LoadModel2DV01._readString();
            var reader = LoadModel2DV01._readData;
            var arrayBuffer = reader.__getBuffer();
            var vertexBufferCount = reader.getInt16();
            var offset = LoadModel2DV01._DATA.offset;
            var mesh = LoadModel2DV01._mesh;
            let vertexBuffers = [];
            var vertexCount = 0;
            for (i = 0; i < vertexBufferCount; i++) {
                var vbStart = offset + reader.getUint32();
                var byteLength = reader.getUint32();
                var vertexFlag = LoadModel2DV01._readString();
                var vertexDeclaration = VertexMesh.getVertexDeclaration(vertexFlag, false);
                var vertexData = arrayBuffer.slice(vbStart, vbStart + byteLength);
                var vertexBuffer = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Static);
                vertexBuffer.vertexDeclaration = vertexDeclaration;
                vertexBuffer.setDataLength(byteLength);
                vertexBuffer.setData(vertexData, 0, 0, byteLength);
                vertexCount = byteLength / vertexDeclaration.vertexStride;
                memorySize += byteLength;
                vertexBuffers[i] = vertexBuffer;
            }
            if (vertexCount > 65535)
                mesh._indexFormat = exports.IndexFormat.UInt32;
            else
                mesh._indexFormat = exports.IndexFormat.UInt16;
            var ibStart = offset + reader.getUint32();
            var ibLength = reader.getUint32();
            var ibDatas, byteCount;
            if (mesh.indexFormat == exports.IndexFormat.UInt32) {
                ibDatas = new Uint32Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
                byteCount = 4;
            }
            else {
                ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
                byteCount = 2;
            }
            var indexBuffer = LayaGL.renderDeviceFactory.createIndexBuffer(exports.BufferUsage.Static);
            indexBuffer.indexType = mesh.indexFormat;
            indexBuffer.indexCount = ibLength / byteCount;
            indexBuffer._setIndexDataLength(ibLength);
            indexBuffer._setIndexData(ibDatas, 0);
            mesh._setBuffers(vertexBuffers, indexBuffer);
            memorySize += ibDatas.byteLength;
            mesh._setCPUMemory(memorySize);
            mesh._setGPUMemory(memorySize);
            mesh.name = name;
            return true;
        }
        static READ_SUBMESH() {
            var reader = LoadModel2DV01._readData;
            var subMesh = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.Triangles, exports.DrawType.DrawElement);
            reader.getInt16();
            let mesh = LoadModel2DV01._mesh;
            subMesh.bufferState = mesh._bufferState;
            subMesh.indexFormat = mesh.indexFormat;
            var drawCount = reader.getUint16();
            for (var i = 0; i < drawCount; i++) {
                let ibOffset = reader.readUint32();
                let ibCount = reader.readUint32();
                subMesh.setDrawElemenParams(ibCount, ibOffset);
            }
            LoadModel2DV01._subMeshes.push(subMesh);
            return true;
        }
    }
    LoadModel2DV01._BLOCK = { count: 0 };
    LoadModel2DV01._DATA = { offset: 0, size: 0 };
    LoadModel2DV01._strings = [];

    class MeshLoader {
        load(task) {
            let url = AssetDb.inst.getSubAssetURL(task.url, task.uuid, null, "lm");
            return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return this._parse(task, data);
            });
        }
        _parse(task, data) {
            var readData = new Byte(data);
            readData.pos = 0;
            var version = readData.readUTFString();
            if (!version || !version.startsWith("LAYAMODEL")) {
                console.warn(`Unknow version:${version} ! Model : ${task.url}`);
                return null;
            }
            let is2D = version.startsWith("LAYAMODEL2D");
            if (!is2D) {
                if (!MeshLoader.v3d) {
                    console.warn(`Loading ${task.url} , you need load the laya.d3 lib!`);
                    return null;
                }
                return MeshLoader.v3d.parse(readData, version);
            }
            else {
                return MeshLoader.v2d.parse(readData, version);
            }
        }
    }
    class Mesh2DReader {
        static parse(readData, version) {
            var mesh = new Mesh2D();
            let subMeshes = mesh._subMeshes;
            switch (version) {
                case "LAYAMODEL2D:01":
                    LoadModel2DV01.parse(readData, version, mesh, subMeshes);
                    break;
                default:
                    throw new Error("unknown mesh version: " + version);
            }
            mesh._setSubMeshes(subMeshes);
            return mesh;
        }
    }
    MeshLoader.v2d = Mesh2DReader;
    Loader.registerLoader(["lm"], MeshLoader, Loader.MESH);

    exports.TextResourceFormat = void 0;
    (function (TextResourceFormat) {
        TextResourceFormat[TextResourceFormat["Buffer"] = 0] = "Buffer";
        TextResourceFormat[TextResourceFormat["Plain"] = 1] = "Plain";
        TextResourceFormat[TextResourceFormat["JSON"] = 2] = "JSON";
        TextResourceFormat[TextResourceFormat["XML"] = 3] = "XML";
    })(exports.TextResourceFormat || (exports.TextResourceFormat = {}));
    class TextResource extends Resource {
        constructor(data, format) {
            super();
            this.data = data;
            this.format = format;
        }
    }

    class TextAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Plain);
            });
        }
    }
    class BytesAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.Buffer);
            });
        }
    }
    class JsonAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.JSON);
            });
        }
    }
    class XMLAssetLoader {
        load(task) {
            return task.loader.fetch(task.url, "xml", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new TextResource(data, exports.TextResourceFormat.XML);
            });
        }
    }
    Loader.registerLoader(["txt", "csv"], TextAssetLoader, Loader.TEXT);
    Loader.registerLoader(["bin", "bytes", "fui"], BytesAssetLoader, Loader.BUFFER);
    Loader.registerLoader(["json"], JsonAssetLoader, Loader.JSON);
    Loader.registerLoader(["xml"], XMLAssetLoader, Loader.XML);

    class AtlasLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                let toloadPics = [];
                if (data.meta && data.meta.image) {
                    let folderPath = "";
                    let i = task.url.lastIndexOf("/");
                    if (i != -1)
                        folderPath = task.url.substring(0, i + 1);
                    let query = "";
                    i = task.url.lastIndexOf("?");
                    if (i != -1)
                        query = task.url.substring(i);
                    let pics = data.meta.image.split(",");
                    for (let pic of pics)
                        toloadPics.push(task.loader.load(folderPath + pic + query, null, task.progress.createCallback()));
                }
                else {
                    toloadPics.push(task.loader.load(Utils.replaceFileExtension(task.url, "png"), null, task.progress.createCallback()));
                }
                return Promise.all(toloadPics).then(pics => {
                    pics = pics.filter(pic => pic != null);
                    let baseUrl = task.options.baseUrl || "";
                    let frames = data.frames;
                    let directory = (data.meta && data.meta.prefix != null) ? data.meta.prefix : task.url.substring(0, task.url.lastIndexOf(".")) + "/";
                    let subTextures = [];
                    let scaleRate = 1;
                    if (data.meta && data.meta.scale && data.meta.scale != 1)
                        scaleRate = parseFloat(data.meta.scale);
                    for (let tPic of pics)
                        tPic.scaleRate = scaleRate;
                    for (let name in frames) {
                        let obj = frames[name];
                        let tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
                        if (!tPic)
                            continue;
                        let url = baseUrl + directory + (obj.filename || name);
                        let tt = Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h);
                        tt._sizeGrid = obj.sizeGrid;
                        tt._stateNum = obj.stateNum;
                        task.loader.cacheRes(url, tt);
                        tt.url = url;
                        subTextures.push(tt);
                    }
                    let res = task.obsoluteInst;
                    if (res) {
                        res.update(pics, subTextures);
                        res.dir = directory;
                        res.animation = data.animation;
                        res.event("reload");
                        return res;
                    }
                    else {
                        res = new AtlasResource(directory, pics, subTextures);
                        res.animation = data.animation;
                        return res;
                    }
                });
            });
        }
    }
    Loader.registerLoader(["atlas"], AtlasLoader, Loader.ATLAS, true);

    const TypedArrayClasses = {
        "Int8Array": Int8Array,
        "Uint8Array": Uint8Array,
        "Int16Array": Int16Array,
        "Uint16Array": Uint16Array,
        "Int32Array": Int32Array,
        "Uint32Array": Uint32Array,
        "Float32Array": Float32Array,
        "Float64Array": Float64Array
    };
    class SerializeUtil {
        static hasProp(...keys) {
            for (let k of keys) {
                if (SerializeUtil._data[k] !== undefined)
                    return true;
            }
            return false;
        }
        static decodeObj(data, obj) {
            return ObjDecoder.decodeObj(data, obj);
        }
        static getLoadTypeByEngineType(type) {
            return Loader.assetTypeToLoadType[type];
        }
        static bakeOverrideData(overrideData) {
            let dataMap = null;
            for (let n = overrideData.length, i = n - 1; i >= 0; i--) {
                let arr = overrideData[i];
                if (arr && arr.length > 0) {
                    for (let d of arr) {
                        let od = d._$override || d._$parent;
                        let k;
                        if (Array.isArray(od))
                            k = od[n - i - 1];
                        else if (i == n - 1)
                            k = od;
                        if (k != null) {
                            if (!dataMap)
                                dataMap = {};
                            let arr2 = dataMap[k];
                            if (!arr2)
                                dataMap[k] = arr2 = [];
                            arr2.push(n - i, d);
                        }
                    }
                }
            }
            return dataMap;
        }
        static applyOverrideData(nodeData, overrideDataMap) {
            function test(obj) {
                if (overrideDataMap[obj._$id])
                    return true;
                let children = obj._$child;
                if (children && children.find(child => test(child)))
                    return true;
                return false;
            }
            function cloneTree(obj) {
                let ret = Object.assign({}, obj);
                let children = ret._$child;
                if (children)
                    ret._$child = children.map(c => cloneTree(c));
                let comps = ret._$comp;
                if (comps)
                    ret._$comp = comps.map(c => Object.assign({}, c));
                return ret;
            }
            function visit(data) {
                let children = data._$child;
                if (children) {
                    for (let child of children) {
                        if (child._$id)
                            visit(child);
                    }
                }
                let od = overrideDataMap[data._$id];
                if (od) {
                    for (let i = 0; i < od.length; i += 2) {
                        let j = od[i];
                        let e = od[i + 1];
                        let idPath;
                        if (idPath = e._$override) {
                            let toWrite;
                            if (Array.isArray(idPath)) {
                                if (j == idPath.length - 1) {
                                    let k = idPath[j];
                                    if (!children)
                                        data._$child = children = [];
                                    else
                                        toWrite = children.find(c => c._$override == k);
                                    if (!toWrite) {
                                        toWrite = { _$override: k };
                                        children.push(toWrite);
                                    }
                                }
                                else if (j < idPath.length - 1) {
                                    let k = idPath.slice(j);
                                    if (!children)
                                        data._$child = children = [];
                                    else {
                                        toWrite = children.find(c => {
                                            let o = c._$override;
                                            return Array.isArray(o) && arrayEquals(o, k);
                                        });
                                    }
                                    if (!toWrite) {
                                        toWrite = { _$override: k };
                                        children.push(toWrite);
                                    }
                                }
                                else
                                    toWrite = data;
                            }
                            else
                                toWrite = data;
                            mergeData(toWrite, e);
                            if (e._$comp) {
                                let comps = toWrite._$comp;
                                if (!comps)
                                    toWrite._$comp = comps = [];
                                for (let comp of e._$comp) {
                                    let typeOrId = comp._$type || comp._$override;
                                    let c = comps.find(c => c._$override == typeOrId || c._$type == typeOrId || c._$id == typeOrId);
                                    if (!c) {
                                        c = {};
                                        if (comp._$type)
                                            c._$type = typeOrId;
                                        else
                                            c._$override = typeOrId;
                                        comps.push(c);
                                    }
                                    mergeData(c, comp);
                                }
                            }
                        }
                        else if (idPath = e._$parent) {
                            if (!children)
                                data._$child = children = [];
                            let k;
                            if (j < idPath.length) {
                                if (j == idPath.length - 1)
                                    k = idPath[j];
                                else
                                    k = idPath.slice(j);
                                let toWrite = Object.assign({}, e);
                                toWrite._$parent = k;
                                children.push(toWrite);
                            }
                            else {
                                let toWrite = Object.assign({}, e);
                                delete toWrite._$parent;
                                if (data._$prefab) {
                                    children.push(toWrite);
                                }
                                else {
                                    delete toWrite._$index;
                                    if (e._$index < children.length)
                                        children.splice(e._$index, 0, toWrite);
                                    else
                                        children.push(toWrite);
                                }
                            }
                        }
                    }
                }
            }
            if (test(nodeData)) {
                nodeData = cloneTree(nodeData);
                visit(nodeData);
            }
            return nodeData;
        }
    }
    SerializeUtil.isDeserializing = false;
    function mergeData(target, overrided) {
        for (let k in overrided) {
            if (k.startsWith("_$"))
                continue;
            let v = overrided[k];
            if (v != null && typeof (v) === "object" && !Array.isArray(v) && !(v._$type || v._$uuid || v._$ref)) {
                let v2 = target[k];
                if (v2 != null && typeof (v2) === "object") {
                    target[k] = v2 = Object.assign({}, v2);
                    mergeData(v2, v);
                }
                else
                    target[k] = v;
            }
            else
                target[k] = v;
        }
    }
    function arrayEquals(a, b) {
        if (a.length === b.length) {
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        else {
            return false;
        }
    }

    class ObjDecoder {
        constructor() {
            this.getNodeByRef = dummy;
            this.getNodeData = dummy;
        }
        static decodeObj(data, obj) {
            decoder.errors = null;
            decoder.getNodeByRef = dummy;
            decoder.getNodeData = dummy;
            return decoder.decodeObj(data, obj);
        }
        decodeObj(data, obj, excludeKeys) {
            SerializeUtil.isDeserializing = true;
            try {
                return this._decode(data, obj, excludeKeys);
            }
            finally {
                SerializeUtil.isDeserializing = false;
            }
        }
        decodeObjBounds(data, obj) {
            SerializeUtil.isDeserializing = true;
            try {
                let v0 = data["x"];
                let v1 = data["y"];
                if (v0 !== undefined && v1 !== undefined)
                    obj.pos(v0, v1);
                else if (v0 !== undefined)
                    obj.x = v0;
                else if (v1 !== undefined)
                    obj.y = v1;
                v0 = data["width"];
                v1 = data["height"];
                if (v0 !== undefined && v1 !== undefined)
                    obj.size(v0, v1);
                else if (v0 !== undefined)
                    obj.width = v0;
                else if (v1 !== undefined)
                    obj.height = v1;
                v0 = data["controllers"];
                if (v0 !== undefined)
                    obj.controllers = this._decode(v0);
            }
            finally {
                SerializeUtil.isDeserializing = false;
            }
        }
        _decode(data, obj, excludeKeys) {
            if (data == null)
                return null;
            else if (Array.isArray(data)) {
                let arr = [];
                for (let i = 0; i < data.length; i++) {
                    let v = data[i];
                    if (v != null) {
                        try {
                            arr[i] = this._decode(v);
                        }
                        catch (error) {
                            if (this.errors)
                                this.errors.push(error);
                            else
                                console.error(error);
                            arr[i] = null;
                        }
                    }
                    else
                        arr[i] = null;
                }
                return arr;
            }
            else if (typeof (data) === "object") {
                if (data._$uuid != null) {
                    let url = URL.getResURLByUUID(data._$uuid);
                    return ILaya.loader.getRes(url, Loader.assetTypeToLoadType[data._$type]);
                }
                if (data._$ref != null) {
                    let node = this.getNodeByRef(data._$ref);
                    if (!node)
                        return null;
                    if (data._$type) {
                        let cls = ClassUtils.getClass(data._$type);
                        if (cls)
                            return node.getComponent(cls);
                        else
                            return null;
                    }
                    else if (data._$ctrl !== undefined) {
                        let cls = crefClass || (crefClass = ClassUtils.getClass("ControllerRef"));
                        if (cls)
                            return new cls(node, data._$ctrl);
                        else
                            return null;
                    }
                    else
                        return node;
                }
                let type = data._$type;
                if (type === "any") {
                    if (data._$type)
                        return data.value;
                    else
                        return data;
                }
                let typedArray = TypedArrayClasses[type];
                if (typedArray != null) {
                    if (data._$type)
                        return new typedArray(data.value);
                    else
                        return new typedArray(data);
                }
                if (!obj) {
                    let cls = ClassUtils.getClass(type);
                    if (!cls) {
                        return null;
                    }
                    obj = new cls();
                }
                for (let key in data) {
                    if (key.startsWith("_$") || excludeKeys && excludeKeys.has(key))
                        continue;
                    let v = data[key];
                    if (v == null || typeof (v) !== "object" || Array.isArray(v)
                        || v._$type || v._$uuid || v._$ref) {
                        try {
                            let v2 = this._decode(v);
                            obj[key] = v2;
                            if (v2 != null && v != null && v._$tmpl)
                                obj[v._$tmpl] = new PrefabImpl(null, this.getNodeData(v2));
                        }
                        catch (error) {
                            if (this.errors)
                                this.errors.push(error);
                            else
                                console.error(error);
                        }
                    }
                    else {
                        let childObj = obj[key];
                        if (childObj) {
                            try {
                                this._decode(v, childObj);
                            }
                            catch (error) {
                                if (this.errors)
                                    this.errors.push(error);
                                else
                                    console.error(error);
                            }
                        }
                    }
                }
                if (obj.onAfterDeserialize) {
                    try {
                        SerializeUtil._data = data;
                        obj.onAfterDeserialize();
                    }
                    catch (error) {
                        if (this.errors)
                            this.errors.push(error);
                        else
                            console.error(error);
                    }
                }
                return obj;
            }
            else
                return data;
        }
    }
    function dummy(...args) { return null; }
    var crefClass;
    const decoder = new ObjDecoder();

    const excludeKeys = new Set(["x", "y", "width", "height", "controllers", "relations", "gears"]);
    class HierarchyParser {
        static parse(data, options, errors) {
            let printErrors = errors == null;
            errors = errors || [];
            let nodeMap = {};
            let dataList = [];
            let allNodes = [];
            let outNodes = [];
            let scene;
            let inPrefab;
            let prefabNodeDict;
            let skinBaseUrl;
            let overrideData;
            let hasRuntime;
            let hasUI;
            if (options) {
                inPrefab = options.inPrefab;
                if (inPrefab)
                    prefabNodeDict = options.prefabNodeDict;
                skinBaseUrl = options.skinBaseUrl;
                overrideData = options.overrideData;
            }
            function createChildren(data, prefab) {
                for (let child of data._$child) {
                    if (child._$child) {
                        let node = createNode(child, prefab);
                        createChildren(child, child._$prefab ? node : prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                    else {
                        let node = createNode(child, prefab);
                        dataList.push(child);
                        allNodes.push(node);
                    }
                }
            }
            function createNode(nodeData, prefab) {
                let node;
                let pstr;
                if (pstr = nodeData._$override) {
                    if (prefab && prefabNodeDict) {
                        if (Array.isArray(pstr)) {
                            node = prefab;
                            for (let i = 0, n = pstr.length; i < n; i++) {
                                let map = prefabNodeDict.get(node);
                                node = map === null || map === void 0 ? void 0 : map[pstr[i]];
                                if (!node)
                                    break;
                            }
                        }
                        else {
                            let map = prefabNodeDict.get(prefab);
                            if (map)
                                node = map[nodeData._$override];
                        }
                    }
                }
                else {
                    if (pstr = nodeData._$prefab) {
                        let res = Loader.getRes(URL.getResURLByUUID(pstr), Loader.HIERARCHY);
                        if (res) {
                            if (!prefabNodeDict)
                                prefabNodeDict = new Map();
                            let overrideData2 = [];
                            let testId = nodeData._$id;
                            if (overrideData) {
                                for (let i = 0, n = overrideData.length; i < n; i++) {
                                    let arr = overrideData[i];
                                    if (arr && arr.length > 0) {
                                        overrideData2[i] = arr.filter(d => {
                                            let od = d._$override || d._$parent;
                                            return Array.isArray(od) && od.length > n - i && od[n - i - 1] == testId;
                                        });
                                    }
                                    else
                                        overrideData2[i] = arr;
                                }
                            }
                            overrideData2.push(nodeData._$child);
                            node = res.create({ inPrefab: true, prefabNodeDict: prefabNodeDict, overrideData: overrideData2 }, errors);
                        }
                    }
                    else if (pstr = nodeData._$type) {
                        let cls = ClassUtils.getClass(pstr);
                        if (cls) {
                            try {
                                node = new cls();
                            }
                            catch (err) {
                                errors.push(err);
                            }
                        }
                        else {
                            errors.push(new Error(`missing node type '${pstr}' (in ${nodeData.name || 'noname'})`));
                        }
                    }
                    if (node) {
                        nodeMap[nodeData._$id] = node;
                        if (node._nodeType === 2)
                            hasUI = true;
                    }
                }
                return node;
            }
            function getNodeByRef(idPath) {
                if (Array.isArray(idPath)) {
                    let prefab = nodeMap[idPath[0]];
                    if (prefab && idPath.length > 1)
                        return findNodeInPrefab(prefab, idPath, 1);
                    else
                        return prefab;
                }
                else
                    return nodeMap[idPath];
            }
            function findNodeInPrefab(prefab, idPath, startIndex = 0) {
                if (!idPath)
                    return prefab;
                let map = prefabNodeDict === null || prefabNodeDict === void 0 ? void 0 : prefabNodeDict.get(prefab);
                if (!map)
                    return null;
                if (Array.isArray(idPath)) {
                    let node;
                    for (let i = startIndex, n = idPath.length; i < n; i++) {
                        if (!map)
                            return null;
                        node = map[idPath[i]];
                        if (!node)
                            break;
                        map = prefabNodeDict.get(node);
                    }
                    return node;
                }
                else
                    return map[idPath];
            }
            let bakedOverrideData;
            function getNodeData(node) {
                let i = allNodes.indexOf(node);
                let nodeData = dataList[i];
                node.destroy();
                allNodes[i] = null;
                if (!overrideData)
                    return nodeData;
                if (bakedOverrideData === undefined)
                    bakedOverrideData = SerializeUtil.bakeOverrideData(overrideData);
                if (bakedOverrideData)
                    return SerializeUtil.applyOverrideData(nodeData, bakedOverrideData);
                else
                    return nodeData;
            }
            if (data._$type || data._$prefab) {
                let runtime = data._$runtime;
                if (runtime) {
                    hasRuntime = true;
                    if (runtime.startsWith("res://"))
                        runtime = runtime.substring(6);
                    runtime = ClassUtils.getClass(runtime);
                    if (!runtime)
                        errors.push(new Error(`missing runtime class '${data._$runtime}'`));
                }
                if (options && options.runtime)
                    runtime = options.runtime;
                let node;
                if (runtime) {
                    node = new runtime();
                    if (!(node instanceof Node)) {
                        errors.push(new Error(`runtime class invalid - '${runtime}', must derive from Node`));
                        node = null;
                    }
                    nodeMap[data._$id] = node;
                }
                else
                    node = createNode(data, null);
                if (node) {
                    if (data._$child)
                        createChildren(data, data._$prefab ? node : null);
                    dataList.push(data);
                    allNodes.push(node);
                    if (node instanceof Scene)
                        scene = node;
                }
            }
            else {
                if (data._$child)
                    createChildren(data, null);
            }
            let nodeCnt = dataList.length;
            let k = 0;
            let outNodeData = [];
            for (let i = 0; i < nodeCnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                let children = nodeData._$child;
                if (children) {
                    let num = children.length;
                    if (node) {
                        if (nodeData._$prefab) {
                            for (let j = 0; j < num; j++) {
                                let m = k - num + j;
                                let n = outNodes[m];
                                if (n && !n.parent) {
                                    let nodeData2 = outNodeData[m];
                                    let parentNode = findNodeInPrefab(node, nodeData2._$parent);
                                    if (parentNode) {
                                        let pos = nodeData2._$index;
                                        if (pos != null && pos < parentNode.numChildren)
                                            parentNode.addChildAt(n, pos);
                                        else
                                            parentNode.addChild(n);
                                    }
                                    else {
                                        node.addChildAt(n, 0);
                                    }
                                }
                            }
                        }
                        else {
                            for (let j = 0; j < num; j++) {
                                let n = outNodes[k - num + j];
                                if (n) {
                                    if (node === scene && n.is3D)
                                        scene._scene3D = n;
                                    else
                                        node.addChild(n);
                                }
                            }
                        }
                    }
                    k -= num;
                }
                outNodes[k] = node;
                outNodeData[k] = nodeData;
                k++;
            }
            outNodes.length = k;
            outNodes = outNodes.filter(n => n != null);
            let topNode = outNodes[0];
            let compInitList = [];
            for (let i = 0; i < nodeCnt; i++) {
                let components = dataList[i]._$comp;
                if (!components)
                    continue;
                let node = allNodes[i];
                if (!node)
                    continue;
                for (let compData of components) {
                    let comp;
                    let typeOrId = compData._$override;
                    if (compData._$override) {
                        let cls = ClassUtils.getClass(typeOrId);
                        if (cls)
                            comp = node.getComponent(cls);
                        else
                            comp = node.components.find(comp => comp._extra.storeId == typeOrId);
                    }
                    else {
                        let cls = ClassUtils.getClass(compData._$type);
                        if (cls) {
                            if (!compData._$id)
                                comp = node.getComponent(cls);
                            if (!comp) {
                                try {
                                    comp = node.addComponent(cls);
                                    comp._extra.storeId = compData._$id;
                                }
                                catch (err) {
                                    errors.push(err);
                                }
                            }
                        }
                        else
                            errors.push(new Error(`missing component type '${compData._$type}' (in ${dataList[i].name || 'noname'})`));
                    }
                    if (comp)
                        compInitList.push(compData, comp);
                }
            }
            const decoder = new ObjDecoder();
            decoder.errors = errors;
            decoder.getNodeByRef = getNodeByRef;
            decoder.getNodeData = getNodeData;
            for (let i = 0; i < nodeCnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                if (node && (node._nodeType === 2 || node === scene))
                    decoder.decodeObjBounds(nodeData, node);
            }
            if (hasUI) {
                if (topNode._nodeType === 2) {
                    topNode.sourceWidth = topNode.width;
                    topNode.sourceHeight = topNode.height;
                }
                for (let i = 0; i < nodeCnt; i++) {
                    let nodeData = dataList[i];
                    let node = allNodes[i];
                    if (node && node._nodeType === 2) {
                        let v = nodeData["relations"];
                        if (v != null) {
                            if (nodeData._$prefab != null)
                                node._addRelations(decoder.decodeObj(v));
                            else
                                node.relations = decoder.decodeObj(v);
                        }
                    }
                }
            }
            for (let i = 0; i < nodeCnt; i++) {
                let nodeData = dataList[i];
                let node = allNodes[i];
                if (node) {
                    if (skinBaseUrl != null && node._nodeType === 0)
                        node._skinBaseUrl = skinBaseUrl;
                    decoder.decodeObj(nodeData, node, (node._nodeType === 2 || node === scene) ? excludeKeys : null);
                    if (hasRuntime && nodeData._$var && node.name) {
                        try {
                            topNode[node.name] = node;
                        }
                        catch (err) {
                            errors.push(err);
                        }
                    }
                }
            }
            let compCnt = compInitList.length;
            for (let i = 0; i < compCnt; i += 2) {
                let compData = compInitList[i];
                let comp = compInitList[i + 1];
                decoder.decodeObj(compData, comp);
            }
            if (hasUI) {
                for (let i = 0; i < nodeCnt; i++) {
                    let nodeData = dataList[i];
                    let node = allNodes[i];
                    if (node && node._nodeType === 2) {
                        let v = nodeData["gears"];
                        if (v != null) {
                            if (nodeData._$prefab != null)
                                node._addGears(decoder.decodeObj(v));
                            else
                                node.gears = decoder.decodeObj(v);
                        }
                    }
                }
                if (topNode._nodeType === 2 && (!prefabNodeDict || !prefabNodeDict.has(topNode))) {
                    try {
                        topNode._onConstruct(inPrefab);
                    }
                    catch (error) {
                        errors.push(error);
                    }
                }
            }
            if (inPrefab && prefabNodeDict && topNode)
                prefabNodeDict.set(topNode, nodeMap);
            if (printErrors && errors.length > 0)
                errors.forEach(err => console.error(err));
            return outNodes;
        }
        static collectResourceLinks(data, basePath) {
            let test = {};
            let innerUrls = [];
            function addInnerUrl(url, type, absolutePath) {
                if (!url)
                    return "";
                let entry = test[url];
                if (entry === undefined) {
                    let url2;
                    if (Utils.isUUID(url))
                        url2 = "res://" + url;
                    else if (absolutePath)
                        url2 = url;
                    else
                        url2 = URL.join(basePath, url);
                    innerUrls.push({ url: url2, type: type });
                    test[url] = entry = [url2, type];
                }
                else if (entry.indexOf(type, 1) == -1) {
                    entry.push(type);
                    innerUrls.push({ url: entry[0], type: type });
                }
                return entry[0];
            }
            let type;
            function checkData(data) {
                if (data._$uuid != null) {
                    data._$uuid = addInnerUrl(data._$uuid, Loader.assetTypeToLoadType[data._$type]);
                    return;
                }
                if (data._$prefab != null)
                    data._$prefab = addInnerUrl(data._$prefab, Loader.HIERARCHY);
                else if ((type = data._$type) != null) {
                    if (type.endsWith(".bp"))
                        addInnerUrl(type, null, true);
                    else if (LayaEnv.isPreview && Utils.isUUID(type)) {
                        let cls = ClassUtils.getClass(type);
                        if (cls == null || cls._$loadable)
                            addInnerUrl("res://" + type, null);
                    }
                }
                check(data);
            }
            function check(data) {
                for (let key in data) {
                    let child = data[key];
                    if (child == null)
                        continue;
                    if (Array.isArray(child)) {
                        for (let item of child) {
                            if (item == null)
                                continue;
                            if (typeof (item) === "object") {
                                checkData(item);
                            }
                            else if (typeof (item) === "string" && item.startsWith("i18n:")) {
                                let i = item.indexOf(":", 5);
                                if (i != -1)
                                    addInnerUrl(AssetDb.inst.getI18nSettingsURL(item.substring(5, i)), null);
                            }
                        }
                    }
                    else if (typeof (child) === "object") {
                        checkData(child);
                    }
                    else if (typeof (child) === "string" && child.startsWith("i18n:")) {
                        let i = child.indexOf(":", 5);
                        if (i != -1)
                            addInnerUrl(AssetDb.inst.getI18nSettingsURL(child.substring(5, i)), null);
                    }
                }
            }
            check(data);
            if (data._$preloads) {
                let types = data._$preloadTypes;
                let pi = 0;
                for (let url of data._$preloads) {
                    if (types && types[pi])
                        addInnerUrl(url, Loader.assetTypeToLoadType[types[pi]]);
                    else
                        innerUrls.push(url);
                    pi++;
                }
            }
            return innerUrls;
        }
    }

    class PrefabImpl extends Prefab {
        constructor(api, data) {
            super();
            this.api = api || PrefabImpl.v3;
            this.data = data;
        }
        create(options, errors) {
            let runtime = ClassUtils.getRuntime(this.url);
            if (runtime) {
                if (!options)
                    options = { runtime };
                else if (!options.runtime)
                    options = Object.assign({ runtime }, options);
            }
            let ret = this.api.parse(this.data, options, errors);
            if (Array.isArray(ret)) {
                if (ret.length == 1) {
                    ret[0].url = this.url;
                }
                return ret[0];
            }
            else {
                ret.url = this.url;
                return ret;
            }
        }
    }
    PrefabImpl.v3 = HierarchyParser;
    PrefabImpl.v2 = null;

    class HierarchyLoader {
        load(task) {
            let url = task.url;
            let fromDCC = task.ext == "gltf" || task.ext == "fbx" || task.ext == "glb" || task.ext == "obj";
            if (fromDCC)
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "lh");
            return task.loader.fetch(url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                if (!data)
                    return null;
                if (data._$ver != null)
                    return this._load(PrefabImpl.v3, task, data, fromDCC);
                else if (task.ext == "ls" || task.ext == "lh")
                    return this._load(PrefabImpl.v2, task, data, fromDCC);
                else if (task.ext == "scene" || task.ext == "prefab")
                    return this._load(PrefabImpl.legacySceneOrPrefab, task, data, fromDCC);
                else
                    return null;
            });
        }
        _load(api, task, data, fromDCC) {
            let basePath = URL.getPath(task.url);
            let links = api.collectResourceLinks(data, basePath);
            let options = Object.assign({}, task.options);
            options.initiator = task;
            delete options.cache;
            delete options.ignoreCache;
            return task.loader.load(links, options, task.progress.createCallback()).then((resArray) => {
                let res = new PrefabImpl(api, data);
                res.fromDCC = fromDCC;
                res.onLoad();
                res.addDeps(resArray);
                return res;
            });
        }
    }
    Loader.registerLoader(["lh", "ls", "scene", "prefab"], HierarchyLoader, Loader.HIERARCHY);

    class HDRTextureInfo {
        static _parseHDRTexture(data, propertyParams = null, constructParams = null) {
            let hdrInfo = HDRTextureInfo.getHDRInfo(data);
            let texture = new Texture2D(hdrInfo.width, hdrInfo.height, hdrInfo.format, false, false, false);
            texture.setHDRData(hdrInfo);
            if (propertyParams) {
                if (propertyParams.wrapModeU != null)
                    texture.wrapModeU = propertyParams.wrapModeU;
                if (propertyParams.wrapModeV != null)
                    texture.wrapModeV = propertyParams.wrapModeV;
                if (propertyParams.filterMode != null)
                    texture.filterMode = propertyParams.filterMode;
                if (propertyParams.anisoLevel != null)
                    texture.anisoLevel = propertyParams.anisoLevel;
            }
            return texture;
        }
        static getHDRInfo(source) {
            let data = new Uint8Array(source);
            let readByteOffset = 0;
            const readLine = () => {
                let lineStr = HDRTextureInfo.getLineString(data, readByteOffset);
                readByteOffset += lineStr.length + 1;
                return lineStr;
            };
            let identifier = readLine();
            if (identifier != "#?RADIANCE") {
                throw "HDR image: identifier wrong.";
            }
            let commandsMap = new Map();
            let line = "";
            do {
                line = readLine();
                if (line[0] != "#") {
                    let commands = line.split("=");
                    commandsMap.set(commands[0], commands[1]);
                }
            } while (line != "");
            let hdrFormat = commandsMap.get("FORMAT");
            if (hdrFormat != "32-bit_rle_rgbe") {
                throw "HDR image: unsupported format.";
            }
            let resolutionStr = readLine();
            let resolutions = resolutionStr.split(" ");
            let decreaseY = resolutions[0] == "-Y";
            let decreaseX = resolutions[2] == "-X";
            let height = parseInt(resolutions[1]);
            let width = parseInt(resolutions[3]);
            let hdrInfo = new HDRTextureInfo(source, readByteOffset, decreaseX, decreaseY, width, height, exports.TextureFormat.R32G32B32A32);
            return hdrInfo;
        }
        static getLineString(data, readByteOffset) {
            let dataLength = data.length;
            let index = readByteOffset;
            let res = "";
            let char = "";
            while (index < dataLength && char != "\n") {
                res = `${res}${char}`;
                char = String.fromCharCode(data[index]);
                index++;
            }
            return res;
        }
        constructor(source, byteOffset, decreaseX, decreaseY, width, height, format) {
            this.source = source;
            this.byteOffset = byteOffset;
            this.decreaseX = decreaseX;
            this.decreaseY = decreaseY;
            this.width = width;
            this.height = height;
            this.format = format;
        }
        get_32_bit_rle_rgbe() {
            let width = this.width;
            let height = this.height;
            this.decreaseX;
            this.decreaseY;
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataIndex = 0;
            let rgbeBuffer = new ArrayBuffer(width * 4);
            let rgbeArray = new Uint8Array(rgbeBuffer);
            let pixelBuffer = new ArrayBuffer(width * height * 4 * 3);
            let pixelArray = new Float32Array(pixelBuffer);
            for (let y = height; y > 0; y--) {
                data[dataIndex++];
                data[dataIndex++];
                let c = data[dataIndex++];
                let d = data[dataIndex++];
                let scanlineLength = (c << 8) | d;
                if (scanlineLength != width) {
                    throw "HDR info: scanlineLength wrong.";
                }
                let index = 0;
                for (let i = 0; i < 4; i++) {
                    let endIndex = (i + 1) * scanlineLength;
                    while (index < endIndex) {
                        let a = data[dataIndex++];
                        let b = data[dataIndex++];
                        if (a > 128) {
                            let count = a - 128;
                            if (count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            while (count-- > 0) {
                                rgbeArray[index++] = b;
                            }
                        }
                        else {
                            let count = a;
                            if (count == 0 || count > endIndex - index) {
                                throw "HDR info: ??";
                            }
                            rgbeArray[index++] = b;
                            if (--count > 0) {
                                for (let j = 0; j < count; j++) {
                                    rgbeArray[index++] = data[dataIndex++];
                                }
                            }
                        }
                    }
                }
                for (let i = 0; i < scanlineLength; i++) {
                    let r = rgbeArray[i];
                    let g = rgbeArray[i + scanlineLength];
                    let b = rgbeArray[i + 2 * scanlineLength];
                    let e = rgbeArray[i + 3 * scanlineLength];
                    let index = (height - y) * scanlineLength * 3 + i * 3;
                    const Ldexp = (mantissa, exponent) => {
                        if (exponent > 1023) {
                            return mantissa * Math.pow(2, 1023) * Math.pow(2, exponent - 1023);
                        }
                        if (exponent < -1074) {
                            return mantissa * Math.pow(2, -1074) * Math.pow(2, exponent + 1074);
                        }
                        return mantissa * Math.pow(2, exponent);
                    };
                    if (e > 0) {
                        let exponent = Ldexp(1.0, e - (128 + 8));
                        pixelArray[index] = r * exponent;
                        pixelArray[index + 1] = g * exponent;
                        pixelArray[index + 2] = b * exponent;
                    }
                    else {
                        pixelArray[index] = 0;
                        pixelArray[index + 1] = 0;
                        pixelArray[index + 2] = 0;
                    }
                }
            }
            return pixelArray;
        }
        readScanLine() {
            let width = this.width;
            let height = this.height;
            let decreaseX = this.decreaseX;
            let decreaseY = this.decreaseY;
            let n = 3;
            if (this.format == exports.TextureFormat.R32G32B32A32) {
                n = 4;
            }
            let pixelArray = new Float32Array(width * height * n);
            let scanlineArray = new Uint8Array(width * 4);
            let data = new Uint8Array(this.source, this.byteOffset);
            let dataLength = data.length;
            let dataIndex = 0;
            const getc = () => {
                if (dataIndex >= dataLength) {
                    throw "HDR info: data wrong.";
                }
                return data[dataIndex++];
            };
            const wrong = () => {
                throw "HDR info: data wrong.";
            };
            for (let y = (height - 1); y >= 0; y--) {
                this.readcolors(scanlineArray, getc, wrong);
                for (let i = 0; i < width; i++) {
                    let index = 4 * i;
                    let byter = scanlineArray[index];
                    let byteg = scanlineArray[index + 1];
                    let byteb = scanlineArray[index + 2];
                    let bytee = scanlineArray[index + 3];
                    let offsetY = y;
                    let offsetX = i;
                    if (decreaseY) {
                        offsetY = height - 1 - y;
                    }
                    if (decreaseX) {
                        offsetX = width - 1 - i;
                    }
                    let pixelIndex = offsetY * width * n + offsetX * n;
                    if (bytee == 0) {
                        pixelArray[pixelIndex] = 0;
                        pixelArray[pixelIndex + 1] = 0;
                        pixelArray[pixelIndex + 2] = 0;
                        if (n == 4) {
                            pixelArray[pixelIndex + 3] = 1;
                        }
                    }
                    else {
                        let f = ldexp(1.0, bytee - (128 + 8));
                        pixelArray[pixelIndex] = (byter + 0.5) * f;
                        pixelArray[pixelIndex + 1] = (byteg + 0.5) * f;
                        pixelArray[pixelIndex + 2] = (byteb + 0.5) * f;
                        if (n == 4) {
                            pixelArray[pixelIndex + 3] = 1;
                        }
                    }
                }
            }
            return pixelArray;
        }
        readcolors(scanlineArray, getc, wrong) {
            const setScanLineData = (w, channel, value) => {
                scanlineArray[w * 4 + channel] = value;
            };
            let width = this.width;
            let unnormalizedr = getc();
            let unnormalizedg = getc();
            let unnormalizedb = getc();
            let unnormalizede = getc();
            if (width < 8 || width > 32767) {
                this.olddreadcolors(scanlineArray, getc, unnormalizedr, unnormalizedg, unnormalizedb, unnormalizede);
                return;
            }
            if (unnormalizedr != 2 || unnormalizedg != 2 || unnormalizedb & 128) {
                this.olddreadcolors(scanlineArray, getc, unnormalizedr, unnormalizedg, unnormalizedb, unnormalizede);
                return;
            }
            if ((unnormalizedb << 8 | unnormalizede) != width) {
                wrong();
            }
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < width;) {
                    let code = getc();
                    if (code > 128) {
                        code &= 127;
                        let val = getc();
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            setScanLineData(j++, i, val);
                        }
                    }
                    else {
                        if (j + code > width) {
                            wrong();
                        }
                        while (code--) {
                            let val = getc();
                            setScanLineData(j++, i, val);
                        }
                    }
                }
            }
        }
        olddreadcolors(scanlineArray, getc, r, g, b, e) {
            let rshift = 0;
            let len = this.width;
            scanlineArray[0] = r;
            scanlineArray[1] = g;
            scanlineArray[2] = b;
            scanlineArray[3] = e;
            for (let w = 1; w < len; w++) {
                let unnormalizedr = getc();
                let unnormalizedg = getc();
                let unnormalizedb = getc();
                let unnormalizede = getc();
                let scanIndex = w * 4;
                scanlineArray[scanIndex] = unnormalizedr;
                scanlineArray[scanIndex + 1] = unnormalizedg;
                scanlineArray[scanIndex + 2] = unnormalizedb;
                scanlineArray[scanIndex + 3] = unnormalizede;
                if (unnormalizedr == 1 && unnormalizedg == 1 && unnormalizedb == 1) {
                    let lastIndex = scanIndex - 4;
                    for (let i = unnormalizede << rshift; i > 0; i--) {
                        scanlineArray[scanIndex] = scanlineArray[lastIndex];
                        scanlineArray[scanIndex + 1] = scanlineArray[lastIndex + 1];
                        scanlineArray[scanIndex + 2] = scanlineArray[lastIndex + 2];
                        scanlineArray[scanIndex + 3] = scanlineArray[lastIndex + 3];
                    }
                    rshift += 8;
                }
                else {
                    rshift = 0;
                }
            }
        }
        color_color(col, clr) {
            let f = 0;
            if (clr.w == 0) {
                col.x = col.y = col.z = 0;
            }
            else {
                f = ldexp(1.0, clr.w - (128 + 8));
                col.x = (clr.x) * f;
                col.y = (clr.y) * f;
                col.z = (clr.z) * f;
            }
        }
    }
    HDRTextureInfo.HDRTEXTURE = "HDRTEXTURE";
    function ldexp(value, exponent) {
        return value * Math.pow(2, exponent);
    }

    class VideoTexture extends BaseTexture {
        static createInstance() {
            return PAL.media.createVideoTexture();
        }
        constructor() {
            super(1, 1, exports.RenderTargetFormat.R8G8B8);
            this.allowBackground = false;
            this._playing = false;
            this._loaded = false;
            this._frameRender = true;
            this._interval = 0;
            this._lastTimer = 0;
            this._frameRate = 0;
            this._useMediaFrameRate = true;
            this._loop = false;
            this._autoResume = false;
            this._dimension = exports.TextureDimension.Tex2D;
        }
        get frameRate() {
            return this._frameRate;
        }
        set frameRate(value) {
            if (value < 0.001)
                this._interval = 0;
            else
                this._interval = 1000 / value;
            this._frameRate = value;
        }
        get useMediaFrameRate() {
            return this._useMediaFrameRate;
        }
        set useMediaFrameRate(value) {
            this._useMediaFrameRate = value;
        }
        get frameRender() {
            return this._frameRender;
        }
        set frameRender(value) {
            if (this._loaded) {
                if (this._frameRender && !value)
                    ILaya.timer.clear(this, this.render);
                if (!this._frameRender && value && this._playing)
                    ILaya.timer.frameLoop(1, this, this.render);
            }
            this._frameRender = value;
        }
        get source() {
            return this._source;
        }
        set source(url) {
            this.load(url);
        }
        get currentTime() {
            return 0;
        }
        set currentTime(value) {
        }
        get volume() {
            return 0;
        }
        set volume(value) {
        }
        get muted() {
            return false;
        }
        set muted(value) {
        }
        get readyState() {
            return 0;
        }
        get videoWidth() {
            return this._width;
        }
        get videoHeight() {
            return this._height;
        }
        get duration() {
            return 0;
        }
        get ended() {
            return false;
        }
        get loop() {
            return this._loop;
        }
        set loop(value) {
            this._loop = value;
        }
        get playbackRate() {
            return 1;
        }
        set playbackRate(value) {
        }
        get paused() {
            return false;
        }
        canPlayType(type) {
            return PAL.media.canPlayType(type);
        }
        setLoaded(width, height, rgba) {
            this._width = width;
            this._height = height;
            this._loaded = true;
            if (this._texture)
                this._texture.dispose();
            this._texture = LayaGL.textureContext.createTextureInternal(this._dimension, width, height, rgba ? exports.TextureFormat.R8G8B8A8 : exports.TextureFormat.R8G8B8, false, false, false);
            this.wrapModeU = exports.WrapMode.Clamp;
            this.wrapModeV = exports.WrapMode.Clamp;
            this.filterMode = exports.FilterMode.Bilinear;
            LayaGL.textureContext.initVideoTextureData(this._texture);
            this._texture.gammaCorrection = 2.2;
            if (this._frameRender && this._playing)
                ILaya.timer.frameLoop(1, this, this.render);
            if (this._playing)
                this.onPlay();
            this.event(Event.READY, this);
        }
        render(force) {
            if (!this._loaded)
                return;
            if (!this._useMediaFrameRate && !force) {
                let timer = Browser.now();
                if (timer - this._lastTimer < this._interval)
                    return;
            }
            if (this.onRender())
                this.event("videoUpdate");
        }
        load(url) {
            this._source = url;
            if (url) {
                AssetDb.inst.resolveURL(url, url2 => {
                    if (this._source === url)
                        this.onLoad(url2);
                });
            }
            else
                this.pause();
        }
        play() {
            if (this._playing || !LayaEnv.isPlaying)
                return;
            this._playing = true;
            ILaya.stage.on(Event.BLUR, this, this.onBlur);
            if (this._loaded) {
                if (this._frameRender)
                    ILaya.timer.frameLoop(1, this, this.render);
                this.onPlay();
            }
        }
        pause() {
            this._autoResume = false;
            if (!this._playing)
                return;
            this._playing = false;
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
            ILaya.timer.clear(this, this.render);
            if (this._loaded)
                this.onPause();
        }
        resume() {
            this.play();
        }
        get gammaCorrection() {
            return 2.2;
        }
        _getSource() {
            return this._texture ? this._texture.resource : Texture2D.blackTexture._getSource();
        }
        get defaultTexture() {
            return Texture2D.blackTexture;
        }
        destroy() {
            this._playing = false;
            ILaya.timer.clear(this, this.render);
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
            this.onDestroy();
            super.destroy();
        }
        onBlur() {
            if (!this.allowBackground)
                PAL.media.resumeUntilGotFocus(this);
        }
        onLoad(url) {
        }
        onRender() {
            return false;
        }
        onPlay() {
        }
        onPause() {
        }
        onDestroy() {
        }
        get currentSrc() {
            return this._source;
        }
        get updateFrame() {
            return this.frameRate;
        }
        set updateFrame(value) {
            this.frameRate = value;
        }
        get useFrame() {
            return this.useMediaFrameRate;
        }
        set useFrame(value) {
            this.useMediaFrameRate = value;
        }
    }

    var internalResources;
    class Texture2DLoader {
        constructor() {
            if (!internalResources) {
                internalResources = {
                    "WhiteTexture.png": Texture2D.whiteTexture,
                    "BlackTexture.png": Texture2D.blackTexture,
                    "GrayTexture.png": Texture2D.grayTexture,
                    "NormalTexture.png": Texture2D.normalTexture,
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                let tex = internalResources[Utils.getBaseName(task.url)];
                if (tex)
                    return Promise.resolve(tex);
            }
            let meta;
            if (!task.url.startsWith("data:")) {
                meta = AssetDb.inst.metaMap[task.url];
                if (!meta && LayaEnv.isPreview) {
                    return AssetDb.inst.getMeta(task.url, task.uuid).then(meta => {
                        return this.load2(task, meta);
                    });
                }
            }
            return this.load2(task, meta);
        }
        load2(task, meta) {
            var _a, _b, _c;
            let constructParams;
            let propertyParams;
            let ext = task.ext;
            let url = task.url;
            if (meta) {
                let platform = Browser.platform;
                let fileIndex = ((_a = meta.platforms) === null || _a === void 0 ? void 0 : _a[platform]) || 0;
                let fileInfo = ((_b = meta.files) === null || _b === void 0 ? void 0 : _b[fileIndex]) || {};
                if (fileInfo.file) {
                    url = AssetDb.inst.getSubAssetURL(url, task.uuid, fileInfo.file, fileInfo.ext);
                    ext = fileInfo.ext;
                }
                constructParams = [0, 0, (_c = fileInfo.format) !== null && _c !== void 0 ? _c : 1, meta.mipmap, meta.readWrite, meta.sRGB];
                propertyParams = {
                    wrapModeU: meta.wrapMode,
                    wrapModeV: meta.wrapMode,
                    filterMode: meta.filterMode,
                    anisoLevel: meta.anisoLevel,
                    premultiplyAlpha: !!meta.pma,
                    hdrEncodeFormat: meta.hdrEncodeFormat,
                };
            }
            else {
                constructParams = task.options.constructParams;
                propertyParams = task.options.propertyParams;
            }
            let compress = compressedFormats.indexOf(ext) != -1 ? ext : null;
            if (compress != null) {
                return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let tex;
                    switch (compress) {
                        case "dds":
                            let ddsInfo = DDSTextureInfo.getDDSTextureInfo(data);
                            if (ddsInfo.isCube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let srgb = constructParams ? !!constructParams[5] : false;
                                    let tc = new cls(ddsInfo.width, ddsInfo.format, ddsInfo.mipmapCount > 1, srgb);
                                    tc.setDDSData(ddsInfo);
                                    tex = tc;
                                }
                                else {
                                    return null;
                                }
                            }
                            else {
                                tex = Texture2D._parseDDS(data, propertyParams, constructParams);
                            }
                            break;
                        case "ktx":
                            let ktxInfo = KTXTextureInfo.getKTXTextureInfo(data);
                            if (ktxInfo.dimension == exports.TextureDimension.Cube) {
                                let cls = ClassUtils.getClass("TextureCube");
                                if (cls) {
                                    let tc = new cls(ktxInfo.width, ktxInfo.format, ktxInfo.mipmapCount > 1, ktxInfo.sRGB);
                                    tc.setKTXData(ktxInfo);
                                    tex = tc;
                                }
                                else
                                    return null;
                            }
                            else if (ktxInfo.dimension == exports.TextureDimension.Tex2D) {
                                tex = Texture2D._parseKTX(data, propertyParams, constructParams);
                            }
                            break;
                        case "pvr":
                            tex = Texture2D._parsePVR(data, propertyParams, constructParams);
                            break;
                        case "hdr":
                            tex = HDRTextureInfo._parseHDRTexture(data, propertyParams, constructParams);
                            break;
                        case "lanit.ls":
                            tex = Texture2D._SimpleAnimatorTextureParse(data, propertyParams, constructParams);
                            break;
                    }
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (propertyParams && propertyParams.hdrEncodeFormat)
                        tex.hdrEncodeFormat = propertyParams.hdrEncodeFormat;
                    if (meta) {
                        tex._sizeGrid = meta.sizeGrid;
                        tex._stateNum = meta.stateNum;
                    }
                    return tex;
                });
            }
            else {
                let options = task.options;
                let premultiplyAlpha = (propertyParams && propertyParams.premultiplyAlpha) ? "premultiply" : "none";
                if (options.useWorkerLoader && premultiplyAlpha === "none")
                    options = Object.assign({ workerLoaderOptions: { premultiplyAlpha } }, options);
                return task.loader.fetch(url, "image", task.progress.createCallback(), options).then(img => {
                    if (LayaGL.textureContext.needBitmap) {
                        if (img instanceof ImageBitmap)
                            return img;
                        else
                            return createImageBitmap(img, options.workerLoaderOptions || { premultiplyAlpha });
                    }
                    else {
                        return img;
                    }
                }).then(bitmapimage => {
                    if (!bitmapimage)
                        return null;
                    let tex = Texture2D._parseImage(bitmapimage, propertyParams, constructParams);
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && Object.getPrototypeOf(obsoluteInst) == Object.getPrototypeOf(tex))
                        tex = this.move(obsoluteInst, tex);
                    if (meta) {
                        tex._sizeGrid = meta.sizeGrid;
                        tex._stateNum = meta.stateNum;
                    }
                    return tex;
                });
            }
        }
        move(obsoluteInst, tex) {
            obsoluteInst._texture = tex._texture;
            obsoluteInst._format = tex.format;
            obsoluteInst.width = tex.width;
            obsoluteInst.height = tex.height;
            obsoluteInst.obsolute = false;
            delete Resource._idResourcesMap[tex.id];
            return obsoluteInst;
        }
    }
    class RenderTextureLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let rt = task.obsoluteInst;
                if (rt)
                    rt.recreate(data.width, data.height, data.colorFormat, data.depthFormat, data.generateMipmap, data.multiSamples, data.generateDepthTexture, data.sRGB);
                else
                    rt = new RenderTexture(data.width, data.height, data.colorFormat, data.depthFormat, data.generateMipmap, data.multiSamples, data.generateDepthTexture, data.sRGB);
                if (null != data.anisoLevel)
                    rt.anisoLevel = data.anisoLevel;
                if (null != data.filterMode)
                    rt.filterMode = data.filterMode;
                if (null != data.wrapModeU)
                    rt.wrapModeU = data.wrapModeU;
                if (null != data.wrapModeV)
                    rt.wrapModeV = data.wrapModeV;
                return rt;
            });
        }
    }
    class VideoTextureLoader {
        load(task) {
            let inst = task.obsoluteInst || VideoTexture.createInstance();
            inst.source = task.url;
            return Promise.resolve(inst);
        }
    }
    const propertyParams2d = { premultiplyAlpha: true };
    const constructParams2d = [null, null, exports.TextureFormat.R8G8B8A8, false, false, true];
    class TextureLoader {
        wrapTex2D(task, tex2D) {
            if (!tex2D)
                return null;
            let tex = task.obsoluteInst;
            if (tex) {
                tex.setTo(tex2D);
                tex.obsolute = false;
                tex._sizeGrid = tex2D._sizeGrid;
                tex._stateNum = tex2D._stateNum;
                tex.event("reload");
                if (tex._clipCache) {
                    tex._clipCache.forEach(t => {
                        t.event("reload");
                        t._sizeGrid = tex._sizeGrid;
                        t._stateNum = tex._stateNum;
                    });
                }
            }
            else {
                tex = new Texture(tex2D);
                tex._sizeGrid = tex2D._sizeGrid;
                tex._stateNum = tex2D._stateNum;
            }
            return tex;
        }
        load(task) {
            let tex2D = task.loader.getRes(task.url, Loader.TEXTURE2D);
            if (!tex2D || tex2D.obsolute) {
                let url = { url: task.url, type: Loader.TEXTURE2D };
                if (!task.options.propertyParams)
                    url.propertyParams = propertyParams2d;
                else if (task.options.propertyParams.premultiplyAlpha == null)
                    url.propertyParams = Object.assign({}, propertyParams2d, task.options.propertyParams);
                if (!task.options.constructParams)
                    url.constructParams = constructParams2d;
                else if (task.options.constructParams[5] == null)
                    url.constructParams = Object.assign([], constructParams2d, task.options.constructParams);
                return task.loader.load(url, task.options, task.progress.createCallback()).then(tex2D => {
                    return this.wrapTex2D(task, tex2D);
                });
            }
            else
                return Promise.resolve(this.wrapTex2D(task, tex2D));
        }
    }
    const compressedFormats = ["ktx", "pvr", "dds", "hdr", "exr", "lanit.ls"];
    const videoFormats = ["mp4", "webm"];
    Loader.registerLoader(["tga", "tif", "tiff", "png", "jpg", "jpeg", "webp", "rendertexture", ...videoFormats, ...compressedFormats], TextureLoader, Loader.IMAGE, true);
    Loader.registerLoader([], Texture2DLoader, Loader.TEXTURE2D, true);
    Loader.registerLoader(["rendertexture"], RenderTextureLoader, Loader.TEXTURE2D, true);
    Loader.registerLoader(videoFormats, VideoTextureLoader, Loader.TEXTURE2D);

    class AnimationClip2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return AnimationClip2D._parse(data);
            });
        }
    }
    Loader.registerLoader(["mc"], AnimationClip2DLoader);

    class AnimationController2DLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                let ret = new AnimatorController2D(data);
                if (ret.data && ret.data.controllerLayers) {
                    let layers = ret.data.controllerLayers;
                    let promises = [];
                    for (let i = layers.length - 1; i >= 0; i--) {
                        let states = layers[i].states;
                        this.loadStates(states, promises, task);
                    }
                    return Promise.all(promises).then(deps => {
                        ret.addDeps(deps);
                        return ret;
                    });
                }
                else
                    return ret;
            });
        }
        loadStates(states, promises, task) {
            let basePath = URL.getPath(task.url);
            for (let j = states.length - 1; j >= 0; j--) {
                if (states[j].clip && states[j].clip._$uuid) {
                    let url = URL.getResURLByUUID(states[j].clip._$uuid);
                    if (!url.startsWith("res://"))
                        url = URL.join(basePath, url);
                    promises.push(task.loader.load(url).then(res => {
                        states[j].clip = res;
                        return res;
                    }));
                }
                if (states[j].states) {
                    this.loadStates(states[j].states, promises, task);
                }
            }
        }
    }
    Loader.registerLoader(["mcc"], AnimationController2DLoader);

    class NullLoader {
        load(task) {
            return Promise.resolve(null);
        }
    }
    Loader.registerLoader(["lighting"], NullLoader);

    class BitmapFontLoader {
        load(task) {
            let picUrl = Utils.replaceFileExtension(task.url, "png");
            return Promise.all([
                task.loader.fetch(task.url, "xml", task.progress.createCallback(0.2), task.options),
                task.loader.load(picUrl, task.options, task.progress.createCallback(0.8))
            ]).then(([xml, tex]) => {
                if (!xml || !tex)
                    return null;
                let font = new BitmapFont();
                font.parseFont(xml, tex);
                return font;
            });
        }
    }
    Loader.registerLoader(["fnt"], BitmapFontLoader, Loader.FONT);

    class TTFFontLoader {
        load(task) {
            return PAL.font.loadFont(task);
        }
    }
    Loader.registerLoader(["ttf", "woff", "woff2", "otf"], TTFFontLoader, Loader.TTF);

    class MaterialParser {
        static parse(data) {
            let props = data.props;
            switch (data.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                case "LAYAMATERIAL:03":
                    let mat = MaterialParser.parseLegacy(data);
                    mat.oldparseEndEvent();
                    return mat;
                case "LAYAMATERIAL:04":
                    break;
                default:
                    throw new Error(`unkonwn material version: ${data.version}`);
            }
            let mat = new Material();
            mat.setShaderName(props.type);
            let renderQueue;
            for (let key in props) {
                switch (key) {
                    case "type":
                    case "name":
                        break;
                    case "defines":
                        let defineNames = props[key];
                        for (let i = 0, n = defineNames.length; i < n; i++) {
                            let define = Shader3D.getDefineByName(defineNames[i]);
                            mat._shaderValues.addDefine(define);
                        }
                        break;
                    case "textures":
                        let textures = props[key];
                        for (let i = 0, n = textures.length; i < n; i++) {
                            let texture = textures[i];
                            let path = texture.path;
                            (path) && (mat._shaderValues.setTexture(Shader3D.propertyNameToID(texture.name), Loader.getBaseTexture(path)));
                        }
                        break;
                    case "renderQueue":
                        renderQueue = props[key];
                        break;
                    case "alphaTest":
                        mat.alphaTest = props[key];
                        break;
                    case "materialRenderMode":
                        mat.materialRenderMode = props[key];
                        break;
                    default:
                        let property = props[key];
                        let uniName = Shader3D.propertyNameToID(key);
                        switch (uniName) {
                            case Shader3D.CULL:
                                mat.cull = property;
                                break;
                            case Shader3D.BLEND:
                                mat.blend = property;
                                break;
                            case Shader3D.BLEND_SRC:
                                mat.blendSrc = property;
                                break;
                            case Shader3D.BLEND_DST:
                                mat.blendDst = property;
                                break;
                            case Shader3D.BLEND_DST_ALPHA:
                                mat.blendDstAlpha = property;
                                break;
                            case Shader3D.BLEND_SRC_ALPHA:
                                mat.blendSrcAlpha = property;
                                break;
                            case Shader3D.BLEND_SRC_RGB:
                                mat.blendSrcRGB = property;
                                break;
                            case Shader3D.BLEND_DST_RGB:
                                mat.blendDstRGB = property;
                                break;
                            case Shader3D.DEPTH_TEST:
                                mat.depthTest = property;
                                break;
                            case Shader3D.DEPTH_WRITE:
                                mat.depthWrite = !!props[key];
                                break;
                            case Shader3D.STENCIL_TEST:
                                mat.stencilTest = property;
                                break;
                            case Shader3D.STENCIL_Op:
                                mat.stencilOp = property;
                                break;
                            case Shader3D.STENCIL_Ref:
                                mat.stencilRef = property;
                                break;
                            case Shader3D.STENCIL_WRITE:
                                mat.stencilWrite = property;
                                break;
                            case Shader3D.BLEND_EQUATION:
                                mat.blendEquation = property;
                                break;
                            case Shader3D.BLEND_EQUATION_RGB:
                                mat.blendEquationRGB = property;
                                break;
                            case Shader3D.BLEND_EQUATION_ALPHA:
                                mat.blendEquationAlpha = property;
                                break;
                            default:
                                if (!property.length) {
                                    if (typeof property == 'boolean')
                                        mat._shaderValues.setBool(uniName, props[key]);
                                    else {
                                        mat._shaderValues.setNumber(uniName, props[key]);
                                    }
                                }
                                else {
                                    var vectorValue = property;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat._shaderValues.setVector2(uniName, new Vector2(vectorValue[0], vectorValue[1]));
                                            break;
                                        case 3:
                                            mat._shaderValues.setVector3(uniName, new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                            break;
                                        case 4:
                                            if (mat._shaderValues.getColor(uniName)) {
                                                mat._shaderValues.setColor(uniName, new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            }
                                            else
                                                mat._shaderValues.setVector(uniName, new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                            break;
                                        case 9:
                                            let matrix3 = new Matrix3x3();
                                            matrix3.elements = new Float32Array(vectorValue);
                                            mat._shaderValues.setMatrix3x3(uniName, matrix3);
                                            break;
                                        case 16:
                                            let matrix4 = new Matrix4x4();
                                            matrix4.elements = new Float32Array(vectorValue);
                                            mat._shaderValues.setMatrix4x4(uniName, matrix4);
                                            break;
                                        default:
                                            mat._shaderValues.setBuffer(uniName, vectorValue);
                                    }
                                }
                                break;
                        }
                }
            }
            if (null != renderQueue) {
                mat.renderQueue = renderQueue;
            }
            return mat;
        }
        static collectLinks(data, basePath) {
            var _a;
            let urls = [];
            let textures = (_a = data.props) === null || _a === void 0 ? void 0 : _a.textures;
            if (textures) {
                for (let i = 0, n = textures.length; i < n; i++) {
                    let tex2D = textures[i];
                    let tex2DPath = tex2D.path;
                    if (tex2DPath) {
                        tex2D.path = URL.join(basePath, tex2DPath);
                        urls.push({ url: tex2D.path, type: Loader.TEXTURE2D, constructParams: tex2D.constructParams, propertyParams: tex2D.propertyParams });
                    }
                }
            }
            return urls;
        }
        static parseLegacy(data) {
            let jsonData = data;
            let props = jsonData.props;
            let mat;
            let classType = props.type;
            let clas = ClassUtils.getClass(classType);
            if (!clas && classType && classType.startsWith("Laya."))
                clas = ClassUtils.getClass(classType.substring(5));
            if (clas)
                mat = new clas();
            else {
                mat = new Material();
                mat.setShaderName(classType);
            }
            switch (jsonData.version) {
                case "LAYAMATERIAL:01":
                case "LAYAMATERIAL:02":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                                break;
                            case "vectors":
                                let vectors = props[key];
                                for (let i = 0, n = vectors.length; i < n; i++) {
                                    let vector = vectors[i];
                                    let vectorValue = vector.value;
                                    switch (vectorValue.length) {
                                        case 2:
                                            mat[vector.name] = new Vector2(vectorValue[0], vectorValue[1]);
                                            break;
                                        case 3:
                                            if (mat[vector.name] instanceof Color) {
                                                mat[vector.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], 1.0);
                                            }
                                            else
                                                mat[vector.name] = new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]);
                                            break;
                                        case 4:
                                            if (mat[vector.name] instanceof Color) {
                                                mat[vector.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            }
                                            else
                                                mat[vector.name] = new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                            break;
                                        default:
                                            throw new Error("unknown material color length: " + vectorValue.length);
                                    }
                                }
                                break;
                            case "colors":
                                let colors = props[key];
                                for (let i = 0, n = colors.length; i < n; i++) {
                                    let color = colors[i];
                                    let vectorValue = color.value;
                                    mat[color.name] = new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat[texture.name] = Loader.getBaseTexture(path));
                                }
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "renderStates":
                                let renderStatesData = props[key];
                                let renderStateData = renderStatesData[0];
                                mat.blend = renderStateData.blend;
                                mat.cull = this._getRenderStateParams(renderStateData.cull);
                                mat.depthTest = this._getRenderStateParams(renderStateData.depthTest);
                                mat.depthWrite = renderStateData.depthWrite;
                                mat.blendSrc = this._getRenderStateParams(renderStateData.srcBlend);
                                mat.blendDst = this._getRenderStateParams(renderStateData.dstBlend);
                                break;
                            case "cull":
                                mat.cull = this._getRenderStateParams(props[key]);
                                break;
                            case "blend":
                                mat.blend = this._getRenderStateParams(props[key]);
                                break;
                            case "depthWrite":
                                mat.depthWrite = !!props[key];
                                break;
                            case "srcBlend":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            case "dstBlend":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "depthTest":
                                mat.depthTest = this._getRenderStateParams(props[key]);
                                break;
                            case "blendDst":
                                mat.blendDst = this._getRenderStateParams(props[key]);
                                break;
                            case "blendSrc":
                                mat.blendSrc = this._getRenderStateParams(props[key]);
                                break;
                            default:
                                mat[key] = props[key];
                        }
                    }
                    break;
                case "LAYAMATERIAL:03":
                    for (let key in props) {
                        switch (key) {
                            case "type":
                            case "name":
                                break;
                            case "defines":
                                let defineNames = props[key];
                                for (let i = 0, n = defineNames.length; i < n; i++) {
                                    let define = Shader3D.getDefineByName(defineNames[i]);
                                    mat._shaderValues.addDefine(define);
                                }
                                break;
                            case "textures":
                                let textures = props[key];
                                for (let i = 0, n = textures.length; i < n; i++) {
                                    let texture = textures[i];
                                    let path = texture.path;
                                    (path) && (mat._shaderValues.setTexture(Shader3D.propertyNameToID(texture.name), Loader.getBaseTexture(path)));
                                }
                                break;
                            case "renderQueue":
                                mat.renderQueue = props[key];
                                break;
                            default:
                                let property = props[key];
                                let uniName = Shader3D.propertyNameToID(key);
                                switch (uniName) {
                                    case Shader3D.CULL:
                                        mat.cull = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND:
                                        mat.blend = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND_SRC:
                                        mat.blendSrc = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.BLEND_DST:
                                        mat.blendDst = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.DEPTH_TEST:
                                        mat.depthTest = this._getRenderStateParams(property);
                                        break;
                                    case Shader3D.DEPTH_WRITE:
                                        mat.depthWrite = !!props[key];
                                        break;
                                    case Shader3D.BLEND_EQUATION:
                                        mat.blendEquation = props[key];
                                        break;
                                    case Shader3D.BLEND_EQUATION_ALPHA:
                                        mat.blendEquationAlpha = props[key];
                                        break;
                                    case Shader3D.BLEND_EQUATION_RGB:
                                        mat.blendEquationRGB = props[key];
                                        break;
                                    default:
                                        if (!property.length) {
                                            if (typeof property == 'boolean')
                                                mat._shaderValues.setBool(uniName, props[key]);
                                            else {
                                                mat._shaderValues.setNumber(uniName, props[key]);
                                            }
                                        }
                                        else {
                                            var vectorValue = property;
                                            switch (vectorValue.length) {
                                                case 2:
                                                    mat._shaderValues.setVector2(uniName, new Vector2(vectorValue[0], vectorValue[1]));
                                                    break;
                                                case 3:
                                                    mat._shaderValues.setVector3(uniName, new Vector3(vectorValue[0], vectorValue[1], vectorValue[2]));
                                                    break;
                                                case 4:
                                                    if (mat._shaderValues.getColor(uniName)) {
                                                        mat._shaderValues.setColor(uniName, new Color(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    }
                                                    else
                                                        mat._shaderValues.setVector(uniName, new Vector4(vectorValue[0], vectorValue[1], vectorValue[2], vectorValue[3]));
                                                    break;
                                                default:
                                                    throw new Error("unknown material color length: " + vectorValue.length);
                                            }
                                        }
                                        break;
                                }
                        }
                    }
                    break;
                default:
                    throw new Error("unknown material version: " + jsonData.version);
            }
            return mat;
        }
        static _getRenderStateParams(type) {
            switch (type) {
                case 0x0300:
                    return exports.BlendFactor.SourceColor;
                case 0x0301:
                    return exports.BlendFactor.OneMinusSourceColor;
                case 0x0306:
                    return exports.BlendFactor.DestinationColor;
                case 0x0307:
                    return exports.BlendFactor.OneMinusDestinationColor;
                case 0x0302:
                    return exports.BlendFactor.SourceAlpha;
                case 0x0303:
                    return exports.BlendFactor.OneMinusSourceAlpha;
                case 0x0304:
                    return exports.BlendFactor.DestinationAlpha;
                case 0x0305:
                    return exports.BlendFactor.OneMinusDestinationAlpha;
                case 0x0308:
                    return exports.BlendFactor.SourceAlphaSaturate;
                case 0x8006:
                    return exports.BlendEquationSeparate.ADD;
                case 0x800A:
                    return exports.BlendEquationSeparate.SUBTRACT;
                case 0x800B:
                    return exports.BlendEquationSeparate.REVERSE_SUBTRACT;
                case 0x0200:
                    return exports.CompareFunction.Never;
                case 0x0201:
                    return exports.CompareFunction.Less;
                case 0x0202:
                    return exports.CompareFunction.Equal;
                case 0x0203:
                    return exports.CompareFunction.LessEqual;
                case 0x0204:
                    return exports.CompareFunction.Greater;
                case 0x0205:
                    return exports.CompareFunction.NotEqual;
                case 0x0206:
                    return exports.CompareFunction.GreaterEqual;
                case 0x0207:
                    return exports.CompareFunction.Always;
                default:
                    return type;
            }
        }
    }

    class MaterialLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.3), task.options).then(data => {
                if (!data)
                    return null;
                let basePath = URL.getPath(task.url);
                let urls = MaterialParser.collectLinks(data, basePath);
                if (data.version === "LAYAMATERIAL:04") {
                    let shaderName = data.props.type;
                    if (!Shader3D.find(shaderName)) {
                        let url = AssetDb.inst.shaderName_to_URL(shaderName);
                        if (url)
                            urls.push(url);
                        else {
                            return AssetDb.inst.shaderName_to_URL_async(shaderName).then(url => {
                                if (url)
                                    urls.push(url);
                                else if (data.props.shaderPath)
                                    urls.push(URL.join(basePath, data.props.shaderPath));
                                else
                                    Loader.warn(`unknown shaderName: ${shaderName}`);
                                return this.load2(task, data, urls);
                            });
                        }
                    }
                }
                return this.load2(task, data, urls);
            });
        }
        load2(task, data, urls) {
            if (urls.length == 0) {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return Promise.resolve(mat);
            }
            let options = Object.assign({}, task.options);
            options.initiator = task;
            delete options.cache;
            delete options.ignoreCache;
            return task.loader.load(urls, options, task.progress.createCallback()).then(() => {
                let mat = MaterialParser.parse(data);
                let obsoluteInst = task.obsoluteInst;
                if (task.obsoluteInst)
                    mat = this.move(obsoluteInst, mat);
                return mat;
            });
        }
        move(obsoluteInst, mat) {
            obsoluteInst._shaderValues.clearData();
            obsoluteInst.setShaderName(mat._shader.name);
            mat._shaderValues.cloneTo(obsoluteInst._shaderValues);
            obsoluteInst.materialRenderMode = mat.materialRenderMode;
            obsoluteInst.renderQueue = mat.renderQueue;
            obsoluteInst.obsolute = false;
            mat.destroy();
            return obsoluteInst;
        }
    }
    Loader.registerLoader(["lmat"], MaterialLoader, Loader.MATERIAL, true);

    class ParseJSON {
        static parse(str) {
            return this.parseStart(str);
        }
        static findIndex(str, i, fstr, len) {
            var fi = str.indexOf(fstr, i + 1);
            if (0 > fi) {
                fi = len;
            }
            return { str: str.substring(i + 1, fi), i: fi };
        }
        static finCurrObj() {
            this.type = 1;
            if (null == this.cobj) {
                return null;
            }
            if (0 == this.currArr.length) {
                if (this.cobj.k) {
                    this.ret[this.cobj.k] = this.cobj.val;
                }
                return null;
            }
            else {
                var pobj = this.currArr.pop();
                if (this.cobj.k) {
                    if (Array.isArray(pobj.val)) {
                        if (null != this.cobj.k) {
                            var obj = {};
                            obj[this.cobj.k] = this.cobj.val;
                            pobj.val.push(obj);
                        }
                    }
                    else {
                        pobj.val[this.cobj.k] = this.cobj.val;
                    }
                }
                else if (Array.isArray(this.cobj.val)) {
                    if (Array.isArray(pobj.val)) {
                        pobj.val.push(this.cobj.val);
                    }
                    else {
                        pobj.val = this.cobj.val;
                    }
                }
                else ;
                return pobj;
            }
        }
        static formatVal(str) {
            if (null == str) {
                return null;
            }
            var numVal = Number(str);
            if (!isNaN(numVal)) {
                return numVal;
            }
            if ("false" == str.toLowerCase()) {
                return false;
            }
            else if ("true" == str.toLowerCase()) {
                return true;
            }
            else if ("null" == str) {
                return null;
            }
            return str;
        }
        static finCurrStr() {
            if (null != this.currStr) {
                this.currStr = this.currStr.trim();
                if ("" != this.currStr) {
                    if (null != this.cobj) {
                        if (Array.isArray(this.cobj.val)) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                        else {
                            this.cobj.val = this.formatVal(this.currStr);
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                }
            }
        }
        static parseStart(str) {
            this.len = str.length;
            var i = 0;
            this.ret = {};
            this.currStr = null;
            this.currArr = [];
            this.cobj = null;
            this.type = 0;
            while (i < this.len) {
                var c = str.charAt(i);
                if ("/" == c) {
                    if (i + 1 < this.len) {
                        i += 1;
                        var cNext = str.charAt(i);
                        var cstr = null;
                        if ("/" == cNext) {
                            cstr = "\n";
                        }
                        else if ("*" == cNext) {
                            cstr = "*/";
                        }
                        if (null != cstr) {
                            this.finCurrStr();
                            var fi = str.indexOf(cstr, i);
                            if (0 > fi) {
                                console.log("没有找到注释结尾，应该是一直注释到最后了");
                                i = this.len;
                            }
                            else {
                                i = fi + cstr.length - 1;
                            }
                        }
                    }
                }
                else if ("}" == c) {
                    if (null != this.cobj) {
                        this.finCurrStr();
                        if (null != this.cobj) {
                            this.cobj = this.finCurrObj();
                        }
                    }
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("{" == c) {
                    this.currStr = "";
                    this.type = 1;
                }
                else if ("'" == c || "\"" == c || "‘" == c || "“" == c) {
                    if ("‘" == c) {
                        c = "’";
                    }
                    else if ("“" == c) {
                        c = "”";
                    }
                    var obj = this.findIndex(str, i, c, this.len);
                    if (2 == this.type && null != this.cobj && Array.isArray(this.cobj.val)) {
                        if (null != this.currStr) {
                            this.currStr = this.currStr.trim();
                            if ("" != this.currStr) {
                                this.cobj.val.push(this.formatVal(this.currStr));
                            }
                        }
                        this.cobj.val.push(obj.str);
                        this.currStr = "";
                    }
                    else if (null != this.currStr) {
                        this.currStr += obj.str;
                    }
                    i = obj.i;
                }
                else if (";" == c || "," == c || "\n" == c) {
                    this.finCurrStr();
                }
                else if ("]" == c) {
                    if (null != this.currStr && null != this.cobj && Array.isArray(this.cobj.val)) {
                        this.currStr = this.currStr.trim();
                        if ("" != this.currStr) {
                            this.cobj.val.push(this.formatVal(this.currStr));
                        }
                    }
                    if (null != this.cobj) {
                        this.cobj = this.finCurrObj();
                        this.cobj = this.finCurrObj();
                    }
                    this.currStr = "";
                }
                else if ("[" == c) {
                    if (2 != this.type) {
                        console.warn("没有key值，忽略掉一个数组");
                    }
                    else {
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { val: [] };
                    }
                }
                else if (":" == c) {
                    if (null != this.currStr && 1 == this.type) {
                        this.type = 2;
                        if (null != this.cobj) {
                            this.currArr.push(this.cobj);
                        }
                        if (null != this.cobj && Array.isArray(this.cobj.val)) {
                            var pcobj = this.cobj;
                            this.cobj = { val: {} };
                            pcobj.val.push(this.cobj.val);
                            this.currArr.push(this.cobj);
                        }
                        this.cobj = { k: this.currStr.trim(), val: {} };
                        this.currStr = "";
                    }
                }
                else if (null != this.currStr) {
                    this.currStr += c;
                }
                i++;
            }
            return this.ret;
        }
    }

    const CGBlock = ["GLSL Start", "GLSL End"];
    const split = ["#defineGLSL", "#endGLSL"];
    const shaderBlock = ["Shader3D Start", "Shader3D End"];
    const shaderDataOBJ = {
        "Color": exports.ShaderDataType.Color,
        "Int": exports.ShaderDataType.Int,
        "Bool": exports.ShaderDataType.Bool,
        "Float": exports.ShaderDataType.Float,
        "Vector2": exports.ShaderDataType.Vector2,
        "Vector3": exports.ShaderDataType.Vector3,
        "Vector4": exports.ShaderDataType.Vector4,
        "Matrix4x4": exports.ShaderDataType.Matrix4x4,
        "Matrix3x3": exports.ShaderDataType.Matrix3x3,
        "Texture2D": exports.ShaderDataType.Texture2D,
        "TextureCube": exports.ShaderDataType.TextureCube,
        "Texture2DArray": exports.ShaderDataType.Texture2DArray,
        "Texture3D": exports.ShaderDataType.Texture3D,
    };
    class ShaderParser {
        static parse(data, basePath) {
            let obj = ShaderParser.getShaderBlock(data);
            let cgmap = ShaderParser.getCGBlock(data);
            ShaderParser.bindCG(obj, cgmap);
            let shader = Shader3D.parse(obj, basePath);
            return shader;
        }
        static compileToTree(sliceFlag, data, sliceIndex) {
            if (sliceIndex == sliceFlag.length)
                return [data];
            let slicedata = sliceFlag[sliceIndex];
            let splitmap = data.split(slicedata);
            if (splitmap.length == 1)
                return splitmap;
            let map = [];
            for (let i = 0, n = splitmap.length; i < n; i++) {
                map = map.concat(ShaderParser.compileToTree(sliceFlag, splitmap[i], sliceIndex + 1));
                (i != n - 1) && map.push(slicedata);
            }
            return map;
        }
        static getMapKey(value) {
            let index = value.indexOf("\n");
            value = value.slice(0, index).replace("\r", "");
            value = value.slice(0, index).replace(" ", "");
            value = value.trim();
            return value;
        }
        static getShaderBlock(source) {
            let shaderObj = null;
            try {
                let i1 = source.indexOf(shaderBlock[0]);
                if (i1 == -1)
                    throw new Error(`no '${shaderBlock[0]}' tag`);
                let i2 = source.indexOf(shaderBlock[1]);
                if (i2 == -1)
                    throw new Error(`no '${shaderBlock[1]}' tag`);
                let shaderData = source.substring(i1 + shaderBlock[0].length, i2);
                shaderObj = ParseJSON.parse(shaderData);
            }
            catch (err) {
                console.error("Shader parse error: " + err + "\n" + source.substring(0, 100) + "...");
            }
            return shaderObj;
        }
        static getCGBlock(source) {
            let cgmap = {};
            try {
                let i1 = source.indexOf(CGBlock[0]);
                if (i1 == -1)
                    throw new Error(`no '${shaderBlock[0]}' tag`);
                let i2 = source.indexOf(CGBlock[1]);
                if (i2 == -1)
                    throw new Error(`no '${shaderBlock[1]}' tag`);
                let cgdata = source.substring(i1, i2);
                let map = ShaderParser.compileToTree(split, cgdata, 0);
                for (let i = 0, n = map.length; i < n; i++) {
                    let value = map[i];
                    if (value == split[0]) {
                        i += 1;
                        let datavalue = map[i];
                        let key = ShaderParser.getMapKey(datavalue);
                        cgmap[key] = datavalue.slice(datavalue.indexOf("\n"), datavalue.length - 1);
                    }
                }
            }
            catch (err) {
                console.error("Shader parse error: " + err + "\n" + source.substring(0, 100) + "...");
            }
            return cgmap;
        }
        static bindCG(shaderObj, cgmap) {
            let passArray = shaderObj.shaderPass;
            if (passArray) {
                passArray.forEach(element => {
                    if (element.VS) {
                        element.VS = cgmap[element.VS];
                    }
                    if (element.FS) {
                        element.FS = cgmap[element.FS];
                    }
                });
            }
            let attributemap = shaderObj.attributeMap;
            if (attributemap) {
                let indexofAttribute = 0;
                for (let i in attributemap) {
                    if (attributemap[i] instanceof Array) {
                        let dataArray = attributemap[i];
                        let type = ShaderParser.getShaderDataType(dataArray[0]);
                        if (type == null) {
                            console.warn(`${shaderObj.name}: unkown attribute type '${dataArray[0]}'`);
                            continue;
                        }
                        attributemap[i] = [dataArray[1], type];
                    }
                    else {
                        let type = ShaderParser.getShaderDataType(attributemap[i]);
                        if (type == null) {
                            console.warn(`${shaderObj.name}: unkown attribute type '${attributemap[i]}'`);
                            continue;
                        }
                        attributemap[i] = [indexofAttribute, type];
                        indexofAttribute++;
                    }
                }
            }
            let uniformMap = shaderObj.uniformMap;
            if (uniformMap) {
                let defaultmap = {};
                shaderObj.defaultValue = defaultmap;
                let newUniformMap = {};
                shaderObj.uniformMap = newUniformMap;
                for (let k in uniformMap) {
                    let entry = uniformMap[k];
                    if (entry.serializable === false)
                        continue;
                    let dataType = ShaderParser.getShaderDataType(entry.type);
                    if (dataType == null) {
                        console.warn(`${shaderObj.name}: unkown uniform type '${entry.type}'`);
                        continue;
                    }
                    if (entry.default != null)
                        defaultmap[k] = ShaderParser.getDefaultData(dataType, entry.default);
                    if (entry.block) {
                        let block = newUniformMap[entry.block];
                        if (!block)
                            newUniformMap[entry.block] = block = {};
                        block[k] = dataType;
                    }
                    else
                        newUniformMap[k] = dataType;
                }
            }
        }
        static getShaderDataType(value) {
            return shaderDataOBJ[value];
        }
        static getDefaultData(type, data) {
            switch (type) {
                case exports.ShaderDataType.Int:
                case exports.ShaderDataType.Float:
                case exports.ShaderDataType.Bool:
                    return data;
                case exports.ShaderDataType.Vector2:
                    return new Vector2(data[0], data[1]);
                case exports.ShaderDataType.Vector3:
                    return new Vector3(data[0], data[1], data[2]);
                case exports.ShaderDataType.Vector4:
                    return new Vector4(data[0], data[1], data[2], data[3]);
                case exports.ShaderDataType.Color:
                    return new Color(data[0], data[1], data[2], data[3]);
                case exports.ShaderDataType.Matrix4x4:
                    let mat = new Matrix4x4();
                    mat.cloneByArray(data);
                    return mat;
                case exports.ShaderDataType.Matrix3x3:
                    let mat3 = new Matrix3x3();
                    mat3.cloneByArray(data);
                    return mat3;
                case exports.ShaderDataType.Texture2D:
                    let tex = null;
                    if (data == "white")
                        tex = Texture2D.whiteTexture;
                    else if (data == "black")
                        tex = Texture2D.blackTexture;
                    else if (data == "gray")
                        tex = Texture2D.grayTexture;
                    else if (data == "normal")
                        tex = Texture2D.normalTexture;
                    return tex;
                case exports.ShaderDataType.TextureCube:
                    let texcube = TextureCube.grayTexture;
                    if (data == "white")
                        texcube = TextureCube.whiteTexture;
                    else if (data == "black")
                        texcube = TextureCube.blackTexture;
                    else if (data == "gray")
                        texcube = TextureCube.grayTexture;
                    return texcube;
            }
        }
    }

    class ShaderLoader {
        load(task) {
            let url = task.url;
            if (task.ext === "bps")
                url = AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "shader");
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let obj = ShaderParser.getShaderBlock(data);
                let cgmap = ShaderParser.getCGBlock(data);
                ShaderParser.bindCG(obj, cgmap);
                if (!obj.name || !obj.uniformMap)
                    return null;
                let basePath = URL.getPath(task.url);
                let passArray = obj.shaderPass;
                return Promise.all(passArray.map(pass => ShaderCompile.compileAsync(pass.VS, pass.FS, basePath))).then(compiledObjs => {
                    var _a;
                    if (compiledObjs.findIndex(obj => obj == null) != -1) {
                        Loader.warn("some pass null " + task.url);
                        return null;
                    }
                    let shader = Shader3D.add(obj.name, obj.enableInstancing, obj.supportReflectionProbe);
                    shader._surportVolumetricGI = obj.surportVolumetricGI;
                    let subshader = new SubShader(obj.attributeMap ? obj.attributeMap : SubShader.DefaultAttributeMap, obj.uniformMap, obj.defaultValue);
                    shader.addSubShader(subshader);
                    for (let i in passArray) {
                        let pass = subshader._addShaderPass(compiledObjs[i], passArray[i].pipeline);
                        pass.statefirst = (_a = passArray[i].statefirst) !== null && _a !== void 0 ? _a : false;
                        ShaderCompile.getRenderState(passArray[i].renderState, pass.renderState);
                    }
                    return shader;
                });
            });
        }
    }
    Loader.registerLoader(["shader", "bps"], ShaderLoader);

    class GLSLLoader {
        load(task) {
            let url = task.url;
            return task.loader.fetch(url, "text", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return ShaderCompile.addInclude(task.url, data, true);
            });
        }
    }
    Loader.registerLoader(["glsl", "vs", "fs"], GLSLLoader);

    class WebAudioLoader {
        load(task) {
            return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let size = data.byteLength;
                return PAL.media.decodeAudioData(data).then(buffer => {
                    if (buffer)
                        buffer.__byteLength = size;
                    return buffer;
                });
            });
        }
    }
    Loader.registerLoader(["mp3", "wav", "ogg"], WebAudioLoader, Loader.SOUND);

    class Mesh2DRender extends BaseRenderNode2D {
        set sharedMesh(value) {
            if (this._sharedMesh == value)
                return;
            let meshArrayDefine = new Array();
            if (this._sharedMesh) {
                VertexMesh2D.getMeshDefine(this._sharedMesh, meshArrayDefine);
                for (var i = 0, n = meshArrayDefine.length; i < n; i++)
                    this._spriteShaderData.removeDefine(meshArrayDefine[i]);
                this._sharedMesh._removeReference();
            }
            meshArrayDefine.length = 0;
            if (value) {
                if (!value._vertexBuffers) {
                    value = null;
                    console.warn("not a 2D mesh");
                }
                else {
                    VertexMesh2D.getMeshDefine(value, meshArrayDefine);
                    for (var i = 0, n = meshArrayDefine.length; i < n; i++)
                        this._spriteShaderData.addDefine(meshArrayDefine[i]);
                    value._addReference();
                }
            }
            this._sharedMesh = value;
            this._changeMesh();
        }
        get sharedMesh() {
            return this._sharedMesh;
        }
        set color(value) {
            if (value != this._color && this._color.equal(value))
                return;
            value = value ? value : Color.BLACK;
            value.cloneTo(this._color);
            this._renderAlpha = -1;
        }
        get color() {
            return this._color;
        }
        set texture(value) {
            if (this._texture != null && value == this._texture)
                return;
            if (this._texture)
                this._texture._removeReference();
            this._texture = value;
            value = value ? value : Texture2D.whiteTexture;
            this._spriteShaderData.setTexture(BaseRenderNode2D.BASERENDER2DTEXTURE, value);
            if (value) {
                value._addReference();
                if (value.gammaCorrection != 1) {
                    this._spriteShaderData.addDefine(ShaderDefines2D.GAMMATEXTURE);
                }
                else {
                    this._spriteShaderData.removeDefine(ShaderDefines2D.GAMMATEXTURE);
                }
            }
        }
        get texture() {
            return this._texture;
        }
        set textureRange(value) {
            if (!value)
                return;
            this._spriteShaderData.setVector(BaseRenderNode2D.BASERENDER2DTEXTURERANGE, value);
            value ? value.cloneTo(this._textureRange) : null;
        }
        get textureRange() {
            return this._textureRange;
        }
        set textureRangeIsClip(value) {
            if (this._textureRangeIsClip != value) {
                this._textureRangeIsClip = value;
                if (value)
                    this._spriteShaderData.addDefine(BaseRenderNode2D.SHADERDEFINE_CLIPMODE);
                else
                    this._spriteShaderData.removeDefine(BaseRenderNode2D.SHADERDEFINE_CLIPMODE);
            }
        }
        get textureRangeIsClip() {
            return this._textureRangeIsClip;
        }
        set normalTexture(value) {
            if (value === this._normalTexture)
                return;
            if (this._normalTexture)
                this._normalTexture._removeReference(1);
            if (value)
                value._addReference();
            this._normalTexture = value;
            this._spriteShaderData.setTexture(BaseRenderNode2D.NORMAL2DTEXTURE, value);
            if (this._normal2DStrength > 0 && this._normalTexture)
                this._spriteShaderData.addDefine(BaseRenderNode2D.SHADERDEFINE_LIGHT2D_NORMAL_PARAM);
            else
                this._spriteShaderData.removeDefine(BaseRenderNode2D.SHADERDEFINE_LIGHT2D_NORMAL_PARAM);
        }
        get normalTexture() {
            return this._normalTexture;
        }
        set normalStrength(value) {
            value = Math.max(0, Math.min(1, value));
            if (this._normal2DStrength === value)
                return;
            this._normal2DStrength = value;
            this._spriteShaderData.setNumber(BaseRenderNode2D.NORMAL2DSTRENGTH, value);
            if (value > 0 && this._normalTexture)
                this._spriteShaderData.addDefine(BaseRenderNode2D.SHADERDEFINE_LIGHT2D_NORMAL_PARAM);
            else
                this._spriteShaderData.removeDefine(BaseRenderNode2D.SHADERDEFINE_LIGHT2D_NORMAL_PARAM);
        }
        get normalStrength() {
            return this._normal2DStrength;
        }
        set sharedMaterial(value) {
            super.sharedMaterial = value;
            this._changeMesh();
        }
        get sharedMaterial() {
            return this._materials[0];
        }
        _changeMesh() {
            let submeshNum = this._sharedMesh ? this._sharedMesh.subMeshCount : 0;
            if (submeshNum < this._renderElements.length) {
                for (var i = this._renderElements.length, n = submeshNum; n < i; i--) {
                    let element = this._renderElements[i - 1];
                    element.destroy();
                }
                this._renderElements.length = submeshNum;
            }
            for (var i = 0, n = submeshNum; i < n; i++) {
                let element = this._renderElements[i];
                if (!element)
                    element = this._renderElements[i] = LayaGL.render2DRenderPassFactory.createRenderElement2D();
                element.geometry = this._sharedMesh.getSubMesh(i);
                element.value2DShaderData = this._spriteShaderData;
                BaseRenderNode2D._setRenderElement2DMaterial(element, this._materials[i] ? this._materials[i] : Mesh2DRender.mesh2DDefaultMaterial);
                element.renderStateIsBySprite = false;
                element.nodeCommonMap = this._getcommonUniformMap();
            }
        }
        addCMDCall(context, px, py) {
            let mat = context._curMat;
            let vec3 = Vector3.TEMP;
            vec3.x = mat.a;
            vec3.y = mat.c;
            vec3.z = px * mat.a + py * mat.c + mat.tx;
            this._spriteShaderData.setVector3(BaseRenderNode2D.NMATRIX_0, vec3);
            vec3.x = mat.b;
            vec3.y = mat.d;
            vec3.z = px * mat.b + py * mat.d + mat.ty;
            this._spriteShaderData.setVector3(BaseRenderNode2D.NMATRIX_1, vec3);
            this._setRenderSize(context.width, context.height);
            context._copyClipInfoToShaderData(this._spriteShaderData);
            if (this._renderAlpha !== context.globalAlpha) {
                let a = context.globalAlpha * this._color.a;
                this._setRenderColor.setValue(this._color.r * a, this._color.g * a, this._color.b * a, a);
                this._spriteShaderData.setColor(BaseRenderNode2D.BASERENDER2DCOLOR, this._setRenderColor);
                this._renderAlpha = context.globalAlpha;
            }
            this._lightReceive && this._updateLight();
        }
        constructor() {
            super();
            this._texture = Texture2D.whiteTexture;
            this._normal2DStrength = 0;
            this._renderAlpha = -1;
            this._textureRangeIsClip = false;
            if (!Mesh2DRender.mesh2DDefaultMaterial) {
                Mesh2DRender.mesh2DDefaultMaterial = new Material();
                Mesh2DRender.mesh2DDefaultMaterial.setShaderName("baseRender2D");
                Mesh2DRender.mesh2DDefaultMaterial.setBoolByIndex(Shader3D.DEPTH_WRITE, false);
                Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.DEPTH_TEST, RenderState.DEPTHTEST_OFF);
                Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND, RenderState.BLEND_ENABLE_ALL);
                Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND_EQUATION, RenderState.BLENDEQUATION_ADD);
                Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND_SRC, RenderState.BLENDPARAM_ONE);
                Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.BLEND_DST, RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA);
                Mesh2DRender.mesh2DDefaultMaterial.setFloatByIndex(ShaderDefines2D.UNIFORM_VERTALPHA, 1.0);
                Mesh2DRender.mesh2DDefaultMaterial.setIntByIndex(Shader3D.CULL, RenderState.CULL_NONE);
            }
            this._renderElements = [];
            this._materials = [];
            this._color = new Color();
            this._setRenderColor = new Color();
            this._textureRange = new Vector4(0, 0, 1, 1);
            this.textureRange = this._textureRange;
            this.texture = null;
            this._spriteShaderData.addDefine(BaseRenderNode2D.SHADERDEFINE_BASERENDER2D);
            this._spriteShaderData.setColor(BaseRenderNode2D.BASERENDER2DCOLOR, this._color);
        }
    }

    class GradientMode {
    }
    GradientMode.Blend = 0;
    GradientMode.Fixed = 1;

    class Gradient {
        get maxColorRGBKeysCount() {
            return this._maxColorRGBKeysCount;
        }
        get colorRGBKeysCount() {
            return this._colorRGBKeysCount;
        }
        get _rgbElements() {
            return this._rgbElementDatas;
        }
        set _rgbElements(value) {
            this._rgbElementDatas = value;
            this._maxColorRGBKeysCount = value ? value.length / 4 : 0;
        }
        get maxColorAlphaKeysCount() {
            return this._maxColorAlphaKeysCount;
        }
        get colorAlphaKeysCount() {
            return this._colorAlphaKeysCount;
        }
        get _alphaElements() {
            return this._alphaElementDatas;
        }
        set _alphaElements(value) {
            this._alphaElementDatas = value;
            this._maxColorAlphaKeysCount = value ? value.length / 2 : 0;
        }
        get maxColorKeysCount() {
            return Math.max(this._maxColorAlphaKeysCount, this._maxColorRGBKeysCount);
        }
        ;
        get mode() {
            return this._mode;
        }
        set mode(value) {
            this._mode = value;
        }
        constructor() {
            this._mode = 0;
            this._maxColorRGBKeysCount = 0;
            this._colorRGBKeysCount = 0;
            this._maxColorAlphaKeysCount = 0;
            this._colorAlphaKeysCount = 0;
            this._keyRanges = new Vector4(1, 0, 1, 0);
        }
        addColorRGB(key, value) {
            if (this._colorRGBKeysCount >= this._maxColorRGBKeysCount) {
                let newRGBElementDatas = new Float32Array((this._maxColorRGBKeysCount + 4) * 4);
                this._rgbElementDatas && newRGBElementDatas.set(this._rgbElementDatas);
                this._rgbElements = newRGBElementDatas;
            }
            let offset = this._colorRGBKeysCount * 4;
            this._rgbElementDatas[offset] = key;
            this._rgbElementDatas[offset + 1] = value.r;
            this._rgbElementDatas[offset + 2] = value.g;
            this._rgbElementDatas[offset + 3] = value.b;
            this._colorRGBKeysCount++;
        }
        addColorAlpha(key, value) {
            if (this._colorAlphaKeysCount >= this._maxColorAlphaKeysCount) {
                let newAlphaElementDatas = new Float32Array((this._maxColorAlphaKeysCount + 4) * 2);
                this._alphaElementDatas && newAlphaElementDatas.set(this._alphaElementDatas);
                this._alphaElements = newAlphaElementDatas;
            }
            let offset = this._colorAlphaKeysCount * 2;
            this._alphaElementDatas[offset] = key;
            this._alphaElementDatas[offset + 1] = value;
            this._colorAlphaKeysCount++;
        }
        updateColorRGB(index, key, value) {
            if (index < this._colorRGBKeysCount) {
                var offset = index * 4;
                this._rgbElements[offset] = key;
                this._rgbElements[offset + 1] = value.r;
                this._rgbElements[offset + 2] = value.g;
                this._rgbElements[offset + 3] = value.b;
                if (this._gpuRGBData4 && index < 4) {
                    this._gpuRGBData4[offset] = key;
                    this._gpuRGBData4[offset + 1] = value.r;
                    this._gpuRGBData4[offset + 2] = value.g;
                    this._gpuRGBData4[offset + 3] = value.b;
                }
                if (this._gpuRGBData8 && index < 8) {
                    this._gpuRGBData8[offset] = key;
                    this._gpuRGBData8[offset + 1] = value.r;
                    this._gpuRGBData8[offset + 2] = value.g;
                    this._gpuRGBData8[offset + 3] = value.b;
                }
            }
            else {
                console.warn("Gradient:warning:index must lessEqual than colorRGBKeysCount:" + this._colorRGBKeysCount);
            }
        }
        updateColorAlpha(index, key, value) {
            if (index < this._colorAlphaKeysCount) {
                var offset = index * 2;
                this._alphaElements[offset] = key;
                this._alphaElements[offset + 1] = value;
                if (this._gpuAlphaData4 && index < 4) {
                    this._gpuAlphaData4[offset] = key;
                    this._gpuAlphaData4[offset + 1] = value;
                }
                if (this._gpuAlphaData8 && index < 8) {
                    this._gpuAlphaData8[offset] = key;
                    this._gpuAlphaData8[offset + 1] = value;
                }
            }
            else {
                console.warn("Gradient:warning:index must lessEqual than colorAlphaKeysCount:" + this._colorAlphaKeysCount);
            }
        }
        evaluateColorRGB(lerpFactor, out, startSearchIndex = 0, reverseSearch = false) {
            lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
            var rgbElements = this._rgbElements;
            var curIndex = startSearchIndex;
            if (reverseSearch) {
                for (var i = curIndex; i >= 0; i--) {
                    var offset = i * 4;
                    var left = rgbElements[offset];
                    if (lerpFactor === left) {
                        out.r = rgbElements[offset + 1];
                        out.g = rgbElements[offset + 2];
                        out.b = rgbElements[offset + 3];
                        return curIndex;
                    }
                    var right = rgbElements[offset + 4];
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left && right) {
                                if (lerpFactor > right)
                                    continue;
                                var diff = right - left;
                                var y1 = right - lerpFactor;
                                var y2 = lerpFactor - left;
                                out.r = (y1 * rgbElements[offset + 1] + y2 * rgbElements[offset + 5]) / diff;
                                out.g = (y1 * rgbElements[offset + 2] + y2 * rgbElements[offset + 6]) / diff;
                                out.b = (y1 * rgbElements[offset + 3] + y2 * rgbElements[offset + 7]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > rgbElements[offset + 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                out.r = rgbElements[offset + 5];
                                out.g = rgbElements[offset + 6];
                                out.b = rgbElements[offset + 7];
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            else {
                for (var i = 0, n = this._rgbElements.length; i < n; i++) {
                    offset = i * 4;
                    var right = rgbElements[offset];
                    if (lerpFactor === right) {
                        out.r = rgbElements[offset + 1];
                        out.g = rgbElements[offset + 2];
                        out.b = rgbElements[offset + 3];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor < right) {
                                var left = rgbElements[offset - 4];
                                if (lerpFactor < left)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var y1 = right - lerpFactor;
                                var y2 = lerpFactor - left;
                                out.r = (y1 * rgbElements[offset - 3] + y2 * rgbElements[offset + 1]) / diff;
                                out.g = (y1 * rgbElements[offset - 2] + y2 * rgbElements[offset + 2]) / diff;
                                out.b = (y1 * rgbElements[offset - 1] + y2 * rgbElements[offset + 3]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor < right) {
                                if (lerpFactor < rgbElements[offset - 4])
                                    throw "Gradient:wrong startSearchIndex.";
                                out.r = rgbElements[offset + 1];
                                out.g = rgbElements[offset + 2];
                                out.b = rgbElements[offset + 3];
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            return curIndex;
        }
        evaluateColorAlpha(lerpFactor, outColor, startSearchIndex = 0, reverseSearch = false) {
            lerpFactor = Math.min(Math.max(lerpFactor, 0.0), 1.0);
            var alphaElements = this._alphaElements;
            var curIndex = startSearchIndex;
            if (reverseSearch) {
                for (var i = curIndex; i >= 0; i--) {
                    var offset = i * 2;
                    var left = alphaElements[offset];
                    if (lerpFactor === left) {
                        outColor.a = alphaElements[offset + 1];
                        return curIndex;
                    }
                    var right = alphaElements[offset + 2];
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor > left && right) {
                                if (lerpFactor > right)
                                    continue;
                                var diff = right - left;
                                var x1 = right - lerpFactor;
                                var x2 = lerpFactor - left;
                                outColor.a = (x1 * alphaElements[offset + 1] + x2 * alphaElements[offset + 3]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor > left) {
                                if (lerpFactor > alphaElements[offset + 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                outColor.a = alphaElements[offset + 3];
                                return curIndex;
                            }
                            else {
                                curIndex--;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            else {
                for (var i = curIndex, n = this._alphaElements.length; i < n; i++) {
                    var offset = i * 2;
                    var right = alphaElements[offset];
                    if (lerpFactor === right) {
                        outColor.a = alphaElements[offset + 1];
                        return curIndex;
                    }
                    switch (this._mode) {
                        case GradientMode.Blend:
                            if (lerpFactor < right) {
                                var left = alphaElements[offset - 2];
                                if (lerpFactor < left)
                                    throw "Gradient:wrong startSearchIndex.";
                                var diff = right - left;
                                var x1 = right - lerpFactor;
                                var x2 = lerpFactor - left;
                                outColor.a = (x1 * alphaElements[offset - 1] + x2 * alphaElements[offset + 1]) / diff;
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        case GradientMode.Fixed:
                            if (lerpFactor < right) {
                                if (lerpFactor < alphaElements[offset - 2])
                                    throw "Gradient:wrong startSearchIndex.";
                                outColor.a = alphaElements[offset + 1];
                                return curIndex;
                            }
                            else {
                                curIndex++;
                                continue;
                            }
                        default:
                            throw "Gradient:unknown mode.";
                    }
                }
            }
            return curIndex;
        }
        _updateGpuData(data, elements) {
            let length = Math.min(data.length, elements.length);
            for (let index = 0; index < length; index++) {
                data[index] = elements[index];
            }
        }
        _fixGPUAlphaData(data) {
            if (this.colorAlphaKeysCount == 1) {
                let alpha = this._alphaElements[1];
                data[0] = 0;
                data[1] = alpha;
                data[2] = 1;
                data[3] = alpha;
            }
            else if (this.colorAlphaKeysCount == 2) {
                data[0] = 0;
                data[1] = this._alphaElements[1];
                data[2] = 1;
                data[3] = this._alphaElements[3];
            }
            else {
                this._updateGpuData(data, this._alphaElements);
            }
        }
        _fixGPURGBData(data) {
            if (this.colorRGBKeysCount == 1) {
                let r = this._rgbElements[1];
                let g = this._rgbElements[2];
                let b = this._rgbElements[3];
                data[0] = 0;
                data[1] = r;
                data[2] = g;
                data[3] = b;
                data[4] = 1;
                data[5] = r;
                data[6] = g;
                data[7] = b;
            }
            else if (this.colorRGBKeysCount == 2) {
                data[0] = 0;
                data[1] = this._rgbElements[1];
                data[2] = this._rgbElements[2];
                data[3] = this._rgbElements[3];
                data[4] = 1;
                data[5] = this._rgbElements[5];
                data[6] = this._rgbElements[6];
                data[7] = this._rgbElements[7];
            }
            else {
                this._updateGpuData(data, this._rgbElements);
            }
        }
        _getGPURGBData4() {
            if (!this._gpuRGBData4) {
                this._gpuRGBData4 = new Float32Array(16);
            }
            this._fixGPURGBData(this._gpuRGBData4);
            return this._gpuRGBData4;
        }
        _getGPURGBData8() {
            if (!this._gpuRGBData8) {
                this._gpuRGBData8 = new Float32Array(32);
            }
            this._fixGPURGBData(this._gpuRGBData8);
            return this._gpuRGBData8;
        }
        _getGPUAlphaData4() {
            if (!this._gpuAlphaData4) {
                this._gpuAlphaData4 = new Float32Array(8);
            }
            this._fixGPUAlphaData(this._gpuAlphaData4);
            return this._gpuAlphaData4;
        }
        _getGPUAlphaData8() {
            if (!this._gpuAlphaData8) {
                this._gpuAlphaData8 = new Float32Array(16);
            }
            this._fixGPUAlphaData(this._gpuAlphaData8);
            return this._gpuAlphaData8;
        }
        cloneTo(destObject) {
            destObject._colorAlphaKeysCount = this._colorAlphaKeysCount;
            let destAlphaElements = destObject._alphaElements = new Float32Array(this._alphaElements.length);
            for (let i = 0, n = this._alphaElements.length; i < n; i++)
                destAlphaElements[i] = this._alphaElements[i];
            destObject._colorRGBKeysCount = this._colorRGBKeysCount;
            var destRGBElements = destObject._rgbElements = new Float32Array(this._rgbElements.length);
            for (let i = 0, n = this._rgbElements.length; i < n; i++)
                destRGBElements[i] = this._rgbElements[i];
        }
        clone() {
            var destGradientDataColor = new Gradient();
            this.cloneTo(destGradientDataColor);
            return destGradientDataColor;
        }
    }

    exports.WeightedMode = void 0;
    (function (WeightedMode) {
        WeightedMode[WeightedMode["None"] = 0] = "None";
        WeightedMode[WeightedMode["In"] = 1] = "In";
        WeightedMode[WeightedMode["Out"] = 2] = "Out";
        WeightedMode[WeightedMode["Both"] = 3] = "Both";
    })(exports.WeightedMode || (exports.WeightedMode = {}));
    class Keyframe {
        constructor() {
        }
        cloneTo(destObject) {
            destObject.time = this.time;
        }
        clone() {
            var dest = new Keyframe();
            this.cloneTo(dest);
            return dest;
        }
    }
    Keyframe.defaultWeight = 0.33333;

    class FloatKeyframe extends Keyframe {
        constructor() {
            super();
            this.inWeight = Keyframe.defaultWeight;
            this.outWeight = Keyframe.defaultWeight;
            this.weightedMode = exports.WeightedMode.None;
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            destObject.inTangent = this.inTangent;
            destObject.outTangent = this.outTangent;
            destObject.value = this.value;
            destObject.inTangent = this.inTangent;
            destObject.outTangent = this.outTangent;
            destObject.value = this.value;
            destObject.inWeight = this.inWeight;
            destObject.outWeight = this.outWeight;
            destObject.weightedMode = this.weightedMode;
        }
        clone() {
            let f = new FloatKeyframe();
            this.cloneTo(f);
            return f;
        }
    }

    class OpenDataContextView extends Sprite {
        constructor() {
            super();
            this._fps = 30;
            this._width = this._height = 200;
            this._widget = Widget.EMPTY;
            let tex = new Texture(new Texture2D(this._width, this._height, exports.TextureFormat.R8G8B8A8, false, false, true));
            tex.bitmap.lock = true;
            this.texture = tex;
            this._canvas = PAL.browser.getOpenDataContextCanvas();
        }
        get fps() {
            return this._fps;
        }
        set fps(value) {
            if (this._fps != value) {
                this._fps = value;
                if (LayaEnv.isPlaying && this.activeInHierarchy && this._canvas) {
                    ILaya.timer.clear(this, this._onLoop);
                    ILaya.timer.loop(1000 / value, this, this._onLoop);
                }
            }
        }
        _onActive() {
            if (!LayaEnv.isPlaying)
                return;
            if (this._canvas)
                ILaya.timer.loop(1000 / this._fps, this, this._onLoop);
        }
        _onInActive() {
            if (!LayaEnv.isPlaying)
                return;
            this.postMsg({ type: "close" });
            ILaya.timer.clear(this, this._onLoop);
        }
        get top() {
            return this._widget.top;
        }
        set top(value) {
            if (value != this._widget.top) {
                this._getWidget().top = value;
            }
        }
        get bottom() {
            return this._widget.bottom;
        }
        set bottom(value) {
            if (value != this._widget.bottom) {
                this._getWidget().bottom = value;
            }
        }
        get left() {
            return this._widget.left;
        }
        set left(value) {
            if (value != this._widget.left) {
                this._getWidget().left = value;
            }
        }
        get right() {
            return this._widget.right;
        }
        set right(value) {
            if (value != this._widget.right) {
                this._getWidget().right = value;
            }
        }
        get centerX() {
            return this._widget.centerX;
        }
        set centerX(value) {
            if (value != this._widget.centerX) {
                this._getWidget().centerX = value;
            }
        }
        get centerY() {
            return this._widget.centerY;
        }
        set centerY(value) {
            if (value != this._widget.centerY) {
                this._getWidget().centerY = value;
            }
        }
        _getWidget() {
            this._widget === Widget.EMPTY && (this._widget = this.addComponent(Widget));
            return this._widget;
        }
        _onLoop() {
            let tex = this.texture;
            let canvas = this._canvas;
            if (tex.width != canvas.width || tex.height != canvas.height) {
                tex.bitmap.destroy();
                tex.bitmap = new Texture2D(canvas.width, canvas.height, exports.TextureFormat.R8G8B8A8, false, false, true, true);
                tex.bitmap.lock = true;
            }
            if (this._canvas)
                tex.bitmap.setImageData(canvas, true, false);
        }
        _transChanged(kind) {
            super._transChanged(kind);
            if ((kind & exports.TransformKind.Size) != 0) {
                if (this._canvas) {
                    this._canvas.width = this._width;
                    this._canvas.height = this._height;
                }
                if (this._widget !== Widget.EMPTY)
                    this._widget.resetLayout();
                this.callLater(this.updateViewPort);
            }
            if ((kind & exports.TransformKind.Pos) != 0)
                this.callLater(this.updateViewPort);
        }
        updateViewPort() {
            let stage = ILaya.stage;
            let sx = stage._canvasTransform.getScaleX() * this.globalScaleX * stage.transform.getScaleX();
            let sy = stage._canvasTransform.getScaleY() * this.globalScaleY * stage.transform.getScaleY();
            this.postMsg({
                type: "updateViewPort",
                box: {
                    x: this.x * sx,
                    y: this.y * sy,
                    width: this.width * sx,
                    height: this.height * sy,
                }
            });
        }
        postMsg(msg) {
            PAL.browser.postMessageToOpenDataContext(msg);
        }
    }

    let c = ClassUtils.regClass;
    c("Record", Object);
    c("Node", Node);
    c("Sprite", Sprite);
    c("Widget", Widget);
    c("Text", Text);
    c("TextRender", TextRender);
    c("Input", Input);
    c("Animation", Animation);
    c("SoundNode", SoundNode);
    c("VideoNode", VideoNode);
    c("Area2D", Area2D);
    c("OpenDataContextView", OpenDataContextView);
    c("Scene", Scene);
    c("Stage", Stage);
    c("Component", Component);
    c("Script", Script);
    c("BitmapFont", BitmapFont);
    c("BlurFilter", BlurFilter);
    c("ColorFilter", ColorFilter);
    c("GlowFilter", GlowFilter);
    c("Point", Point);
    c("Rectangle", Rectangle);
    c("Texture", Texture);
    c("Texture2D", Texture2D);
    c("Prefab", Prefab);
    c("Animator2D", Animator2D);
    c("AnimatorControllerLayer2D", AnimatorControllerLayer2D);
    c("AnimatorState2D", AnimatorState2D);
    c("AnimationClip2D", AnimationClip2D);
    c("AnimatorController2D", AnimatorController2D);
    c("Animation2DParm", Animation2DParm);
    c("Animation2DCondition", Animation2DCondition);
    c("FrameAnimation", FrameAnimation);
    c("Vector2", Vector2);
    c("Vector3", Vector3);
    c("Vector4", Vector4);
    c("Quaternion", Quaternion);
    c("Color", Color);
    c("Matrix", Matrix);
    c("Matrix3x3", Matrix3x3);
    c("Matrix4x4", Matrix4x4);
    c("Camera2D", Camera2D);
    c("Mesh2DRender", Mesh2DRender);
    c("BaseRenderNode2D", BaseRenderNode2D);
    c("Mesh2D", Mesh2D);
    c("Gradient", Gradient);
    c("FloatKeyframe", FloatKeyframe);

    class SetRendertarget2DCMD {
        get invertY() {
            return this._invertY;
        }
        set invertY(value) {
            this._invertY = value;
        }
        get clearColorValue() {
            return this._clearColorValue;
        }
        set clearColorValue(value) {
            this._clearColorValue = value;
        }
        get rt() {
            return this._rt;
        }
        set rt(value) {
            this._rt = value;
        }
        get clearColor() {
            return this._clearColor;
        }
        set clearColor(value) {
            this._clearColor = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class Draw2DElementCMD {
        setRenderelements(value) {
            throw new NotImplementedError();
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class Blit2DQuadCMD {
        get element() {
            return this._element;
        }
        set element(value) {
            this._element = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
        }
        get offsetScale() {
            return this._offsetScale;
        }
        set offsetScale(value) {
            this._offsetScale = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }

    class CommandUniformMap {
        constructor(stateName) {
        }
        addShaderUniform(propertyID, propertyKey, uniformtype) {
            throw "need override it";
        }
        addShaderUniformArray(propertyID, propertyName, uniformtype, arrayLength) {
            throw "need override it";
        }
    }

    exports.RenderCMDType = void 0;
    (function (RenderCMDType) {
        RenderCMDType[RenderCMDType["DrawNode"] = 0] = "DrawNode";
        RenderCMDType[RenderCMDType["DrawElement"] = 1] = "DrawElement";
        RenderCMDType[RenderCMDType["Blit"] = 2] = "Blit";
        RenderCMDType[RenderCMDType["ChangeData"] = 3] = "ChangeData";
        RenderCMDType[RenderCMDType["ChangeShaderDefine"] = 4] = "ChangeShaderDefine";
        RenderCMDType[RenderCMDType["ChangeViewPort"] = 5] = "ChangeViewPort";
        RenderCMDType[RenderCMDType["ChangeRenderTarget"] = 6] = "ChangeRenderTarget";
    })(exports.RenderCMDType || (exports.RenderCMDType = {}));
    class SetRenderDataCMD {
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
        }
        get dataType() {
            return this._dataType;
        }
        set dataType(value) {
            this._dataType = value;
        }
        get propertyID() {
            return this._propertyID;
        }
        set propertyID(value) {
            this._propertyID = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }
    class SetShaderDefineCMD {
        get define() {
            return this._define;
        }
        set define(value) {
            this._define = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        get add() {
            return this._add;
        }
        set add(value) {
            this._add = value;
        }
        apply(context) {
            throw new NotImplementedError();
        }
    }

    class UniformBufferBlock {
        constructor(cluster, index, size, alignedSize, user) {
            this._destroyed = false;
            this._id = UniformBufferBlock._idCounter++;
            this.cluster = cluster;
            this.index = index;
            this.size = size;
            this._alignedSize = alignedSize;
            this.offset = alignedSize * index;
            this.user = user;
            this.uploadNum = 0;
            this.moved = false;
        }
        needUpload() {
            this.cluster._addUploadBlock(this.index);
            if (!this.moved && this.uploadNum++ > this.cluster.manager.uploadThreshold)
                this.cluster.manager._addOptimizeBufferPos(this.cluster);
        }
        destroy() {
            if (!this._destroyed) {
                this._destroyed = true;
                this.cluster = null;
                this.user = null;
                return true;
            }
            console.warn('UniformBufferBlock: object alreay destroyed!');
            return false;
        }
    }
    UniformBufferBlock._idCounter = 0;

    class UniformBufferCluster {
        constructor(blockSize, blockNum, manager) {
            this._inManagerUpdateArray = false;
            this._sn = 0;
            this._id = 0;
            this._destroyed = false;
            this._blocks = [];
            this._holeNum = 0;
            this._expand = 16;
            this._id = UniformBufferCluster._idCounter++;
            this.manager = manager;
            this._blockSize = blockSize;
            this._blockNum = blockNum;
            this._totalSize = blockSize * blockNum;
            this._needUpload = new Array(blockNum).fill(false);
            this.data = new ArrayBuffer(this._totalSize);
            this._move = new Uint8Array(this._blockSize);
            this.buffer = this.manager.createGPUBuffer(this._totalSize);
            this.manager.statisGPUMemory(this._totalSize);
        }
        get usedNum() {
            return this._blocks.length;
        }
        _expandBuffer() {
            let expandNum = this._blockNum;
            this._blockNum += this._expand;
            if (this._blockNum > this.manager.clusterMaxBlock)
                this._blockNum = this.manager.clusterMaxBlock;
            expandNum = this._blockNum - expandNum;
            if (expandNum < 1)
                return false;
            this._totalSize = this._blockSize * this._blockNum;
            const expandSize = this._blockSize * this._expand;
            this._needUpload = this._needUpload.concat(new Array(expandNum).fill(false));
            const newArrayBuffer = new ArrayBuffer(this._totalSize);
            new Uint8Array(newArrayBuffer).set(new Uint8Array(this.data));
            this.data = newArrayBuffer;
            this.buffer = this.manager.createGPUBuffer(this._totalSize);
            this.manager.statisGPUMemory(expandSize);
            this._blocks.forEach(block => block && block.user.notifyGPUBufferChange('expand'));
            return true;
        }
        _moveBlock(index) {
            const len = this._blocks.length;
            if (index >= len)
                return false;
            const dataView = new Uint8Array(this.data);
            const size = this._blockSize;
            for (let i = index + 1; i < len; i++) {
                const start = i * size;
                const end = start + size;
                const target = start - size;
                dataView.copyWithin(target, start, end);
                this._needUpload[i - 1] = this._needUpload[i];
                this._blocks[i - 1] = this._blocks[i];
                if (this._blocks[i - 1]) {
                    this._blocks[i - 1].index--;
                    this._blocks[i - 1].offset -= size;
                    this._blocks[i - 1].user.notifyGPUBufferChange('moveBlock');
                }
            }
            this._blocks.length--;
            return true;
        }
        _createBufferBlock(index, size, alignedSize, user) {
            return new UniformBufferBlock(this, index, size, alignedSize, user);
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.manager.byteAlign);
            if (alignedSize !== this._blockSize) {
                console.warn('WebGPUBufferCluster: 获取内存块时, 长度错误!');
                return null;
            }
            const index = this._getBlockWithExpand();
            const bb = this._createBufferBlock(index, size, alignedSize, user);
            this._blocks[index] = bb;
            return bb;
        }
        freeBlock(bb) {
            const index = this._blocks.indexOf(bb);
            if (index !== -1) {
                if (index === this._blocks.length - 1)
                    this._blocks.length--;
                else {
                    this._blocks[index] = null;
                    this._holeNum++;
                }
                bb.destroy();
                if (this._holeNum > this.manager.removeHoleThreshold) {
                    this.manager._addRemoveHoleCluster(this);
                    this._holeNum = 0;
                }
                return true;
            }
            return false;
        }
        upload() {
            var _a;
            let count = 0;
            let bytes = 0;
            let next = false;
            let startIndex = -1;
            let endIndex = -1;
            let offset = 0;
            let size = 0;
            for (let i = 0, len = this._blocks.length; i < len; i++) {
                if (this._needUpload[i]) {
                    if (startIndex === -1)
                        startIndex = i;
                    endIndex = i;
                    next = true;
                    this._needUpload[i] = false;
                    (_a = this._blocks[i]) === null || _a === void 0 ? void 0 : _a.user.updateOver();
                }
                else {
                    if (next) {
                        offset = startIndex * this._blockSize;
                        size = (endIndex - startIndex + 1) * this._blockSize;
                        this.manager.writeBuffer(this.buffer, this.data, offset, size);
                        count++;
                        bytes += size;
                        startIndex = -1;
                        endIndex = -1;
                        next = false;
                    }
                }
            }
            if (next) {
                offset = startIndex * this._blockSize;
                size = (endIndex - startIndex + 1) * this._blockSize;
                this.manager.writeBuffer(this.buffer, this.data, offset, size);
                count++;
                bytes += size;
            }
            this.manager.statisUpload(count, bytes);
        }
        _addUploadBlock(index) {
            this._needUpload[index] = true;
            if (!this._inManagerUpdateArray)
                this.manager._addUpdateArray(this);
        }
        optimize() {
            let ret = false;
            for (let i = 0, len = this._blocks.length; i < len; i++) {
                const bb = this._blocks[i];
                if (bb && !bb.moved && bb.uploadNum > this.manager.uploadThreshold && i > 0) {
                    const size = this._blockSize;
                    const dataView = new Uint8Array(this.data);
                    this._move.set(new Uint8Array(this.data, size * i, size));
                    for (let j = i - 1; j >= 0; j--) {
                        const start = j * size;
                        const end = start + size;
                        const target = start + size;
                        dataView.copyWithin(target, start, end);
                        this._needUpload[j + 1] = this._needUpload[j];
                        this._blocks[j + 1] = this._blocks[j];
                        if (this._blocks[j + 1]) {
                            this._blocks[j + 1].index++;
                            this._blocks[j + 1].offset += size;
                            this._blocks[j + 1].user.notifyGPUBufferChange('optimize');
                        }
                    }
                    dataView.set(this._move);
                    bb.index = 0;
                    bb.offset = 0;
                    bb.moved = true;
                    this._blocks[0] = bb;
                    this._blocks[0].user.notifyGPUBufferChange('optimize');
                    ret = true;
                    if (this.manager._enableStat)
                        this.manager._stat.moveNum++;
                }
            }
            return ret;
        }
        removeHole() {
            let ret = false;
            for (let i = this._blocks.length - 1; i > -1; i--) {
                if (!this._blocks[i]) {
                    if (this._moveBlock(i)) {
                        ret = true;
                        if (this.manager._enableStat)
                            this.manager._stat.moveNum++;
                    }
                }
            }
            this._holeNum = 0;
            return ret;
        }
        clear(blockNum) {
            this._blocks.forEach(block => block && block.destroy());
            this._blocks.length = 0;
            if (blockNum != undefined && blockNum > 0 && blockNum !== this._blockNum) {
                this._blockNum = blockNum;
                this._totalSize = this._blockSize * this._blockNum;
                this.buffer = this.manager.createGPUBuffer(this._totalSize);
                this.data = new ArrayBuffer(this._totalSize);
            }
            else {
                this._blockNum = 0;
                this._totalSize = 0;
                this.buffer = null;
                this.data = null;
            }
            this._needUpload.length = this._blockNum;
            this._needUpload.fill(false);
        }
        _getBlockWithExpand() {
            for (let i = this._blocks.length - 1; i > -1; i--) {
                if (!this._blocks[i]) {
                    this._holeNum--;
                    return i;
                }
            }
            if (this._blocks.length < this._blockNum)
                return this._blocks.length;
            else {
                this._expandBuffer();
                return this._blocks.length;
            }
        }
        destroy() {
            var _a;
            if (!this._destroyed) {
                this.clear();
                (_a = this.buffer.destroy) !== null && _a !== void 0 ? _a : this.buffer.destroy();
                this.manager.statisGPUMemory(-this._totalSize);
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferCluster: object alreay destroyed!');
            return false;
        }
    }
    UniformBufferCluster._idCounter = 0;

    function roundUp(n, align) {
        return (((n + align - 1) / align) | 0) * align;
    }
    function roundDown(n, align) {
        const res = (((n + align - 1) / align) | 0) * align;
        return res > n ? res - align : res;
    }
    class UBOStat {
        constructor() {
            this.moveNum = 0;
            this.uploadNum = 0;
            this.uploadByte = 0;
            this.timeCostAvg = 0;
            this.timeCostSum = 0;
            this.timeCostCount = 0;
        }
    }
    class UniformBufferManager {
        constructor(useBigBuffer) {
            this._destroyed = false;
            this._needUpdateClusters = [];
            this._removeHoleArray = [];
            this._optimizeBufferPosArray = [];
            this._useBigBuffer = true;
            this.byteAlign = 256;
            this.clusterMaxBlock = 256;
            this.uploadThreshold = 200;
            this.removeHoleThreshold = 10;
            this._enableStat = true;
            this.aloneBuffers = [];
            this._useBigBuffer = useBigBuffer;
            this._clustersAll = new Map();
            this._clustersCur = new Map();
            this._stat = new UBOStat();
        }
        _createBufferCluster(size, blockNum) {
            return new UniformBufferCluster(size, blockNum, this);
        }
        _addCluster(size, blockNum = 16) {
            const alignedSize = roundUp(size, this.byteAlign);
            const cluster = this._createBufferCluster(alignedSize, blockNum);
            const clusters = this._clustersAll.get(alignedSize);
            if (clusters) {
                clusters.push(cluster);
                cluster._sn = clusters.length - 1;
            }
            else
                this._clustersAll.set(alignedSize, [cluster]);
            this._clustersCur.set(alignedSize, cluster);
            return cluster;
        }
        startFrame() { }
        endFrame() {
            if (this._enableStat) {
                this._stat.moveNum = 0;
                this._stat.uploadNum = 0;
                this._stat.uploadByte = 0;
                this._stat.timeCostCount++;
            }
            if (this._useBigBuffer) {
                if (this._removeHoleArray.length > 0) {
                    for (let i = this._removeHoleArray.length - 1; i > -1; i--)
                        this._removeHoleArray[i].removeHole();
                    this._removeHoleArray.length = 0;
                }
                if (this._optimizeBufferPosArray.length > 0) {
                    for (let i = this._optimizeBufferPosArray.length - 1; i > -1; i--)
                        this._optimizeBufferPosArray[i].optimize();
                    this._optimizeBufferPosArray.length = 0;
                }
            }
        }
        getBufferAlone(size, name) {
            const alignedSize = roundUp(size, this.byteAlign);
            this.statisGPUMemory(alignedSize);
            return this.createGPUBuffer(alignedSize, name);
        }
        removeCluster(size, sn) {
            var _a;
            const alignedSize = roundUp(size, this.byteAlign);
            if (sn < 0) {
                this._clustersAll.delete(alignedSize);
                this._clustersCur.delete(alignedSize);
                return;
            }
            const cluster_sn = (_a = this._clustersCur.get(alignedSize)) === null || _a === void 0 ? void 0 : _a._sn;
            const clusters = this._clustersAll.get(alignedSize);
            if (clusters.length > sn) {
                clusters.splice(sn, 1);
                if (clusters.length === 0) {
                    this._clustersAll.delete(alignedSize);
                    this._clustersCur.delete(alignedSize);
                    return;
                }
                else {
                    for (let i = sn; i < clusters.length; i++)
                        clusters[i]._sn--;
                }
            }
            else
                return;
            if (cluster_sn !== undefined
                && cluster_sn === sn) {
                let usedNumMax = -1, usedNum = -1, index = -1;
                for (let i = clusters.length - 1; i > -1; i--) {
                    usedNum = clusters[i].usedNum;
                    if (usedNum > usedNumMax
                        && usedNum < this.clusterMaxBlock) {
                        index = i;
                        usedNumMax = usedNum;
                    }
                }
                if (index >= 0)
                    this._clustersCur.set(alignedSize, clusters[index]);
                else
                    this._clustersCur.delete(alignedSize);
            }
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.byteAlign);
            let cluster = this._clustersCur.get(alignedSize);
            if (!cluster)
                return this._addCluster(alignedSize).getBlock(size, user);
            if (cluster.usedNum < this.clusterMaxBlock)
                return cluster.getBlock(size, user);
            cluster = null;
            const clusters = this._clustersAll.get(alignedSize);
            let usedNumMax = -1, usedNum = -1, index = -1;
            for (let i = clusters.length - 1; i > 0; i--) {
                usedNum = clusters[i].usedNum;
                if (usedNum > usedNumMax
                    && usedNum < this.clusterMaxBlock) {
                    index = i;
                    usedNumMax = usedNum;
                }
            }
            if (index >= 0) {
                cluster = clusters[index];
                this._clustersCur.set(alignedSize, cluster);
            }
            else
                this._clustersCur.delete(alignedSize);
            if (cluster)
                return cluster.getBlock(size, user);
            return this._addCluster(alignedSize).getBlock(size, user);
        }
        freeBlock(bb) {
            const cluster = bb.cluster;
            if (cluster) {
                if (cluster.freeBlock(bb)) {
                    if (cluster.usedNum === 0)
                        this.removeCluster(cluster._blockSize, cluster._sn);
                    return true;
                }
                return false;
            }
            return false;
        }
        upload() {
            if (this._useBigBuffer) {
                let t;
                if (this._enableStat)
                    t = performance.now();
                let cluster;
                for (let i = this._needUpdateClusters.length - 1; i > -1; i--) {
                    cluster = this._needUpdateClusters[i];
                    cluster.upload();
                    cluster._inManagerUpdateArray = false;
                }
                this._needUpdateClusters.length = 0;
                if (this._enableStat)
                    this.statisTimeCostAvg(performance.now() - t);
            }
        }
        _addUpdateArray(cluster) {
            if (!cluster._inManagerUpdateArray) {
                this._needUpdateClusters.push(cluster);
                cluster._inManagerUpdateArray = true;
            }
        }
        _addRemoveHoleCluster(cluster) {
            if (this._removeHoleArray.indexOf(cluster) === -1)
                this._removeHoleArray.push(cluster);
        }
        _addOptimizeBufferPos(cluster) {
            if (this._optimizeBufferPosArray.indexOf(cluster) === -1)
                this._optimizeBufferPosArray.push(cluster);
        }
        clear() {
            this._clustersAll.forEach(clusters => {
                for (let i = clusters.length - 1; i > -1; i--)
                    clusters[i].clear();
            });
        }
        destroy() {
            if (!this._destroyed) {
                this.clear();
                this._clustersAll.clear();
                this._clustersCur.clear();
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferManager: object alreay destroyed!');
            return false;
        }
        createGPUBuffer(size, name) {
        }
        writeBuffer(buffer, data, offset, size) {
        }
        statisGPUMemory(bytes) {
        }
        statisTimeCostAvg(time) {
            this._stat.timeCostSum += time;
            if (this._stat.timeCostCount > 100) {
                this._stat.timeCostAvg = ((this._stat.timeCostSum / this._stat.timeCostCount) * 10000 | 0) / 10;
                this._stat.timeCostSum = 0;
                this._stat.timeCostCount = 0;
            }
        }
        statisUpload(count, bytes) {
            this._stat.uploadNum += count;
            this._stat.uploadByte += bytes;
        }
    }

    class UniformBufferAlone {
        constructor(size, manager, user) {
            this._destroyed = false;
            this.uploadNum = 0;
            this.data = new ArrayBuffer(size);
            this.buffer = manager.getBufferAlone(size);
            this._manager = manager;
            this._size = size;
            this._alignedSize = roundUp(size, manager.byteAlign);
            this.user = user;
            manager.aloneBuffers.push(this);
        }
        upload() {
            let t;
            if (this._manager._enableStat)
                t = performance.now();
            this.uploadNum++;
            this._manager.writeBuffer(this.buffer, this.data, 0, this._size);
            if (this._manager._enableStat) {
                this._manager.statisUpload(1, this._size);
                this._manager.statisTimeCostAvg(performance.now() - t);
            }
        }
        destroy() {
            if (!this._destroyed) {
                this.data = null;
                if (this.buffer.destroy)
                    this.buffer.destroy();
                this._manager.statisGPUMemory(-this._size);
                this._manager.aloneBuffers.splice(this._manager.aloneBuffers.indexOf(this), 1);
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferAlone: object alreay destroyed!');
            return false;
        }
    }

    class UniformBufferUser {
        constructor(name, size, manager, data) {
            this.destroyed = false;
            this.name = name;
            this._strId = '';
            this._items = new Map();
            this._itemNum = 0;
            this.data = data;
            this._size = size;
            this.manager = manager;
            this.needUpload = false;
            if (manager._useBigBuffer) {
                this.bufferBlock = manager.getBlock(size, this);
                this.offset = this.bufferBlock.offset;
            }
            else
                this.bufferAlone = this._createBufferAlone(size, manager);
        }
        _createBufferAlone(size, manager) {
            return new UniformBufferAlone(size, manager, this);
        }
        updateOver() {
            this.needUpload = false;
        }
        notifyGPUBufferChange() {
            const offset = this.bufferBlock.offset - this.offset;
            this.offset = this.bufferBlock.offset;
            this._items.forEach(item => {
                const tac = UniformBufferUser._typeArray(item.type);
                item.view = new tac(this.bufferBlock.cluster.data, item.view.byteOffset + offset, item.size / tac.BYTES_PER_ELEMENT);
            });
            this.clearGPUBufferBind();
            this.needUpload = true;
        }
        clearGPUBufferBind() { }
        addUniform(id, name, type, offset, align, size, elements, count) {
            if (this._items.has(id))
                return;
            this._items.set(id, this._getUniformItem(name, UniformBufferUser._typeArray(type), type, offset, align, size, elements, count));
            if (this._strId.length > 0)
                this._strId += '|';
            this._strId += id;
            this._itemNum++;
        }
        setUniformData(id, data) {
            const item = this._items.get(id);
            if (item) {
                this.needUpload = true;
                if (item.count == 1) {
                    switch (item.type) {
                        case 'int':
                        case 'float':
                            item.view[0] = data;
                            break;
                        case 'vec2':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            break;
                        case 'vec3':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            break;
                        case 'vec4':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            item.view[3] = data.w;
                            break;
                        case 'mat3':
                            for (let i = 0; i < 3; i++) {
                                item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                                item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                                item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                            }
                            break;
                        case 'mat4':
                            item.view.set(data.elements);
                            break;
                    }
                }
                else {
                    const arraySize = item.count * item.elements;
                    const alignElements = item.size / item.count / item.view.BYTES_PER_ELEMENT;
                    for (let i = 0, j = 0; i < arraySize; i += item.elements, j += alignElements)
                        item.view.set(data.subarray(i, i + item.elements), j);
                }
            }
        }
        setBool(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data ? 1 : 0;
                this.needUpload = true;
            }
        }
        setBoolArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i] ? 1 : 0;
                this.needUpload = true;
            }
        }
        setInt(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setIntArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setFloat(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setFloatArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setVector2(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                this.needUpload = true;
            }
        }
        setVector2Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 2 + 0] = data[i].x;
                    item.view[i * 2 + 1] = data[i].y;
                }
                this.needUpload = true;
            }
        }
        setVector3(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                this.needUpload = true;
            }
        }
        setVector3Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                }
                this.needUpload = true;
            }
        }
        setVector4(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                item.view[3] = data.w;
                this.needUpload = true;
            }
        }
        setVector4Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                    item.view[i * 4 + 3] = data[i].w;
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0; i < 3; i++) {
                    item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                    item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                    item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let j = 0, len = Math.min(item.count, data.length); j < len; j++) {
                    for (let i = 0; i < 3; i++) {
                        item.view[j * 16 + i * 4 + 0] = data[j].elements[i * 3 + 0];
                        item.view[j * 16 + i * 4 + 1] = data[j].elements[i * 3 + 1];
                        item.view[j * 16 + i * 4 + 2] = data[j].elements[i * 3 + 2];
                    }
                }
                this.needUpload = true;
            }
        }
        setMatrix4x4(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view.set(data.elements);
                this.needUpload = true;
            }
        }
        setMatrix4x4Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view.set(data[i].elements, i * 16);
                this.needUpload = true;
            }
        }
        setBuffer(id, data) {
            this.setUniformData(id, data);
        }
        getUniform(id) {
            return this._items.get(id);
        }
        hasUniform(id) {
            return this._items.has(id);
        }
        isMe(strId) {
            return this._strId === strId;
        }
        upload() {
            if (this.needUpload) {
                if (this.manager._useBigBuffer)
                    this.bufferBlock.needUpload();
                else
                    this.bufferAlone.upload();
                this.needUpload = false;
            }
        }
        clear() {
            if (this.manager._useBigBuffer)
                new Uint8Array(this.bufferBlock.cluster.data).fill(0, this.bufferBlock.offset, this.bufferBlock.offset + this.bufferBlock.size);
            else
                new Uint8Array(this.bufferAlone.data).fill(0);
            this._strId = '';
            this._items.clear();
            this._itemNum = 0;
            this.needUpload = false;
        }
        destroy() {
            if (!this.destroyed) {
                if (this.manager._useBigBuffer)
                    this.manager.freeBlock(this.bufferBlock);
                else
                    this.bufferAlone.destroy();
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferUser: object alreay destroyed!');
            return false;
        }
        _getUniformItem(name, tac, type, offset, align, size, elements, count) {
            let view;
            if (this.manager._useBigBuffer)
                view = new tac(this.bufferBlock.cluster.data, this.bufferBlock.offset + offset, size / tac.BYTES_PER_ELEMENT);
            else
                view = new tac(this.bufferAlone.data, offset, size / tac.BYTES_PER_ELEMENT);
            return { name, view, type, align, size, elements, count };
        }
        static _typeArray(type) {
            switch (type) {
                case 'int':
                    return Int32Array;
                case 'float':
                case 'vec2':
                case 'vec3':
                case 'vec4':
                case 'mat3':
                case 'mat4':
                    return Float32Array;
                default:
                    return Float32Array;
            }
        }
    }

    class ShaderDefine {
        constructor(index, value) {
            this._index = index;
            this._value = value;
        }
    }

    class BlendState {
        static create(blendType, colorBlendhash, alphaBlendComponent) {
        }
        constructor(blendType) {
            this.blendType = 0;
        }
    }
    BlendState._blend_All_pool = {};
    BlendState._blend_seperate_pool = {};
    class BlendComponent {
        static getHash(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            return (blendOperationGLData) + (sourceBlendFactor << 3) + (destinationFactor << 7);
        }
        static getBlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor) {
            let index = BlendComponent.getHash(blendOperationGLData, sourceBlendFactor, destinationFactor);
            if (!BlendComponent._pool[index])
                BlendComponent._pool[index] = new BlendComponent(blendOperationGLData, sourceBlendFactor, destinationFactor, index);
            return BlendComponent._pool[index];
        }
        constructor(blendOperationGLData, sourceBlendFactor, destinationFactor, hashindex) {
            this._hashIndex = 0;
            this._hashIndex = hashindex;
            this._blendOperationGLData = blendOperationGLData;
            this._sourceBlendFactor = sourceBlendFactor;
            this._destinationFactor = destinationFactor;
        }
    }
    BlendComponent._pool = {};

    class Buffer {
        get bufferUsage() {
            return this._bufferUsage;
        }
        constructor(targetType, bufferUsageType) {
            this._byteLength = 0;
            this._bufferType = targetType;
            this._bufferUsage = bufferUsageType;
        }
        destroy() {
        }
    }

    class DepthState {
    }

    class IndexBuffer extends Buffer {
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._indexType = exports.IndexFormat.UInt16;
        }
    }

    exports.RenderClearFlag = void 0;
    (function (RenderClearFlag) {
        RenderClearFlag[RenderClearFlag["Nothing"] = 0] = "Nothing";
        RenderClearFlag[RenderClearFlag["Color"] = 1] = "Color";
        RenderClearFlag[RenderClearFlag["Depth"] = 2] = "Depth";
        RenderClearFlag[RenderClearFlag["Stencil"] = 4] = "Stencil";
    })(exports.RenderClearFlag || (exports.RenderClearFlag = {}));

    exports.RenderDrawMode = void 0;
    (function (RenderDrawMode) {
        RenderDrawMode[RenderDrawMode["TRIANGLES"] = 0] = "TRIANGLES";
        RenderDrawMode[RenderDrawMode["POINTS"] = 1] = "POINTS";
        RenderDrawMode[RenderDrawMode["LINES"] = 2] = "LINES";
    })(exports.RenderDrawMode || (exports.RenderDrawMode = {}));

    exports.RenderIndexMode = void 0;
    (function (RenderIndexMode) {
        RenderIndexMode[RenderIndexMode["UNSIGNED_BYTE"] = 0] = "UNSIGNED_BYTE";
        RenderIndexMode[RenderIndexMode["UNSIGNED_SHORT"] = 1] = "UNSIGNED_SHORT";
        RenderIndexMode[RenderIndexMode["UNSIGNED_INT"] = 2] = "UNSIGNED_INT";
    })(exports.RenderIndexMode || (exports.RenderIndexMode = {}));

    exports.RenderStateType = void 0;
    (function (RenderStateType) {
        RenderStateType[RenderStateType["DepthTest"] = 0] = "DepthTest";
        RenderStateType[RenderStateType["DepthMask"] = 1] = "DepthMask";
        RenderStateType[RenderStateType["DepthFunc"] = 2] = "DepthFunc";
        RenderStateType[RenderStateType["StencilTest"] = 3] = "StencilTest";
        RenderStateType[RenderStateType["StencilMask"] = 4] = "StencilMask";
        RenderStateType[RenderStateType["StencilFunc"] = 5] = "StencilFunc";
        RenderStateType[RenderStateType["StencilOp"] = 6] = "StencilOp";
        RenderStateType[RenderStateType["BlendType"] = 7] = "BlendType";
        RenderStateType[RenderStateType["BlendEquation"] = 8] = "BlendEquation";
        RenderStateType[RenderStateType["BlendEquationSeparate"] = 9] = "BlendEquationSeparate";
        RenderStateType[RenderStateType["BlendFunc"] = 10] = "BlendFunc";
        RenderStateType[RenderStateType["BlendFuncSeperate"] = 11] = "BlendFuncSeperate";
        RenderStateType[RenderStateType["CullFace"] = 12] = "CullFace";
        RenderStateType[RenderStateType["FrontFace"] = 13] = "FrontFace";
    })(exports.RenderStateType || (exports.RenderStateType = {}));

    exports.TextureCompareMode = void 0;
    (function (TextureCompareMode) {
        TextureCompareMode[TextureCompareMode["None"] = 0] = "None";
        TextureCompareMode[TextureCompareMode["LEQUAL"] = 1] = "LEQUAL";
        TextureCompareMode[TextureCompareMode["GEQUAL"] = 2] = "GEQUAL";
        TextureCompareMode[TextureCompareMode["LESS"] = 3] = "LESS";
        TextureCompareMode[TextureCompareMode["GREATER"] = 4] = "GREATER";
        TextureCompareMode[TextureCompareMode["EQUAL"] = 5] = "EQUAL";
        TextureCompareMode[TextureCompareMode["NOTEQUAL"] = 6] = "NOTEQUAL";
        TextureCompareMode[TextureCompareMode["ALWAYS"] = 7] = "ALWAYS";
        TextureCompareMode[TextureCompareMode["NEVER"] = 8] = "NEVER";
    })(exports.TextureCompareMode || (exports.TextureCompareMode = {}));

    exports.TextureDecodeFormat = void 0;
    (function (TextureDecodeFormat) {
        TextureDecodeFormat[TextureDecodeFormat["Normal"] = 0] = "Normal";
        TextureDecodeFormat[TextureDecodeFormat["RGBM"] = 1] = "RGBM";
    })(exports.TextureDecodeFormat || (exports.TextureDecodeFormat = {}));

    class GLSLCodeGenerator {
        static glslAttributeString(attributeMap) {
            let res = "";
            for (const key in attributeMap) {
                let type = getAttributeType(attributeMap[key][1]);
                if (type != "") {
                    res = `${res}attribute ${type} ${key};\n`;
                }
            }
            return res;
        }
        static glslUniformString(uniformsMap, useUniformBlock, blockName) {
            if (uniformsMap.size == 0) {
                return "";
            }
            if (useUniformBlock) {
                let uniformsStr = "";
                let blockStr = `uniform ${blockName}{\n`;
                let blockPropertyCount = 0;
                uniformsMap.forEach((uniform, key) => {
                    let dataType = uniform.uniformtype;
                    let uniformName = uniform.propertyName;
                    if (uniform.arrayLength > 0) ;
                    let typeStr = getAttributeType(dataType);
                    if (typeStr != "") {
                        if (supportUniformBlock(dataType)) {
                            blockStr += `${typeStr} ${uniformName};\n`;
                            blockPropertyCount++;
                        }
                        else {
                            uniformsStr += `uniform ${typeStr} ${uniformName};\n`;
                        }
                    }
                });
                blockStr += "};\n";
                if (blockPropertyCount > 0) {
                    return blockStr + uniformsStr;
                }
                else {
                    return uniformsStr;
                }
            }
            else {
                let uniformsStr = "";
                uniformsMap.forEach((uniform, id) => {
                    let dataType = uniform.uniformtype;
                    let uniformName = uniform.propertyName;
                    if (uniform.arrayLength > 0) ;
                    let typeStr = getAttributeType(dataType);
                    if (typeStr != "") {
                        uniformsStr += `uniform ${typeStr} ${uniformName};\n`;
                    }
                });
                return uniformsStr;
            }
        }
        static GLShaderLanguageProcess3D(defineString, attributeMap, uniformMap, VS, FS) {
            var clusterSlices = Config3D.lightClusterCount;
            var defMap = {};
            var vertexHead;
            var fragmentHead;
            var defineStr = "";
            let useUniformBlock = Config.matUseUBO;
            let attributeglsl = GLSLCodeGenerator.glslAttributeString(attributeMap);
            let materialUniformGlsl = GLSLCodeGenerator.glslUniformString(uniformMap, useUniformBlock, "Material");
            if (LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) > 30) {
                defineString.push("GRAPHICS_API_GLES3");
                vertexHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
    precision highp sampler2DArray;
    precision highp sampler3D;
#else
    precision mediump float;
    precision mediump int;
    precision mediump sampler2DArray;
    precision mediump sampler3D;
#endif
layout(std140, column_major) uniform;
#define attribute in
#define varying out
#define textureCube texture
#define texture2D texture
${attributeglsl}

${materialUniformGlsl}
`;
                fragmentHead =
                    `#version 300 es
#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
    precision highp sampler2DArray;
	precision highp sampler3D;
#else
    precision mediump float;
    precision mediump int;
    precision mediump sampler2DArray;
	precision mediump sampler3D;
#endif
layout(std140, column_major) uniform;
#define varying in
out highp vec4 pc_fragColor;
#define gl_FragColor pc_fragColor
#define gl_FragDepthEXT gl_FragDepth
#define texture2D texture
#define textureCube texture
#define texture2DProj textureProj
#define texture2DLodEXT textureLod
#define texture2DProjLodEXT textureProjLod
#define textureCubeLodEXT textureLod
#define texture2DGradEXT textureGrad
#define texture2DProjGradEXT textureProjGrad
#define textureCubeGradEXT textureGrad

${materialUniformGlsl}`;
            }
            else {
                vertexHead =
                    `#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif
${attributeglsl}
${materialUniformGlsl}`;
                fragmentHead =
                    `#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif

#ifdef GL_OES_standard_derivatives
	#extension GL_OES_standard_derivatives : enable 
#endif

#if defined(GL_FRAGMENT_PRECISION_HIGH)
    precision highp float;
    precision highp int;
#else
    precision mediump float;
    precision mediump int;
#endif

#if !defined(GL_EXT_shader_texture_lod)
    #define texture1DLodEXT texture1D
    #define texture2DLodEXT texture2D
    #define texture2DProjLodEXT texture2DProj
    #define texture3DLodEXT texture3D
    #define textureCubeLodEXT textureCube
#endif
${materialUniformGlsl}`;
            }
            defineStr += "#define MAX_LIGHT_COUNT " + Config3D.maxLightCount + "\n";
            defineStr += "#define MAX_LIGHT_COUNT_PER_CLUSTER " + Config3D._maxAreaLightCountPerClusterAverage + "\n";
            defineStr += "#define CLUSTER_X_COUNT " + clusterSlices.x + "\n";
            defineStr += "#define CLUSTER_Y_COUNT " + clusterSlices.y + "\n";
            defineStr += "#define CLUSTER_Z_COUNT " + clusterSlices.z + "\n";
            defineStr += "#define MORPH_MAX_COUNT " + Config3D.maxMorphTargetCount + "\n";
            defineStr += "#define SHADER_CAPAILITY_LEVEL " + LayaGL.renderEngine.getParams(exports.RenderParams.SHADER_CAPAILITY_LEVEL) + "\n";
            for (var i = 0, n = defineString.length; i < n; i++) {
                var def = defineString[i];
                defineStr += "#define " + def + "\n";
                defMap[def] = true;
            }
            var vs = VS.toscript(defMap, []);
            var vsVersion = '';
            if (vs[0].indexOf('#version') == 0) {
                vsVersion = vs[0] + '\n';
                vs.shift();
            }
            var ps = FS.toscript(defMap, []);
            var psVersion = '';
            if (ps[0].indexOf('#version') == 0) {
                psVersion = ps[0] + '\n';
                ps.shift();
            }
            let dstVS = vsVersion + vertexHead + defineStr + vs.join('\n');
            let detFS = psVersion + fragmentHead + defineStr + ps.join('\n');
            return { vs: dstVS, fs: detFS };
        }
    }
    function getAttributeType(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return "int";
            case exports.ShaderDataType.Bool:
                return "bool";
            case exports.ShaderDataType.Float:
                return "float";
            case exports.ShaderDataType.Vector2:
                return "vec2";
            case exports.ShaderDataType.Vector3:
                return "vec3";
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
                return "vec4";
            case exports.ShaderDataType.Matrix4x4:
                return "mat4";
            case exports.ShaderDataType.Matrix3x3:
                return "mat3";
            case exports.ShaderDataType.Texture2D:
                return "sampler2D";
            case exports.ShaderDataType.TextureCube:
                return "samplerCube";
            case exports.ShaderDataType.Texture2DArray:
                if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                    return "sampler2DArray";
                }
                else {
                    return "";
                }
            case exports.ShaderDataType.Texture3D:
                if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                    return "sampler3D";
                }
                else {
                    return "";
                }
            default:
                return "";
        }
    }
    function supportUniformBlock(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
            case exports.ShaderDataType.Float:
            case exports.ShaderDataType.Vector2:
            case exports.ShaderDataType.Vector3:
            case exports.ShaderDataType.Vector4:
            case exports.ShaderDataType.Color:
            case exports.ShaderDataType.Matrix4x4:
            case exports.ShaderDataType.Matrix3x3:
                return true;
            case exports.ShaderDataType.Bool:
            default:
                return false;
        }
    }

    class ShaderVariable {
        constructor() {
            this.onID = ShaderVariable.pointID++;
            this.textureID = -1;
        }
    }
    ShaderVariable.pointID = 0;

    class StencilState {
    }

    class VertexAttributeLayout {
        static getVertexLayoutByPool(vertexs) {
            let pool = VertexAttributeLayout._pool;
            for (var i in pool) {
                let layout = pool[i];
                if (layout.deepthEqaul(vertexs)) {
                    return layout;
                }
            }
            return new VertexAttributeLayout(vertexs);
        }
        constructor(vertexs) {
            this.VAElements = new Array();
            this.attributeByteSize = new Array();
            this.instanceMode = new Array();
            for (let i = 0; i < vertexs.length; i++) {
                let vaelements = [];
                let oneAttributeSize = vertexs[i].vertexDeclaration.vertexStride;
                let vdec = vertexs[i].vertexDeclaration._VAElements;
                for (let j = 0; j < vdec.length; j++) {
                    vaelements.push({ format: vdec[j].format, stride: vdec[j].stride, shaderLocation: vdec[j].shaderLocation });
                }
                this.attributeByteSize.push(oneAttributeSize);
                this.VAElements.push(vaelements);
                this.instanceMode.push(vertexs[i].instanceBuffer);
            }
            this.id = VertexAttributeLayout.IPoint;
            VertexAttributeLayout._pool[VertexAttributeLayout.IPoint++] = this;
        }
        deepthEqaul(vertexs) {
            if (vertexs.length != this.VAElements.length) {
                return false;
            }
            for (var i = 0; i < vertexs.length; i++) {
                let vaelemets = vertexs[i]._vertexDeclaration._VAElements;
                let thisVaeEs = this.VAElements[i];
                if (vaelemets.length != thisVaeEs.length) {
                    return false;
                }
                else {
                    for (var ii = 0, nn = vaelemets.length; ii < nn; ii++) {
                        let v0 = vaelemets[ii];
                        let v1 = thisVaeEs[ii];
                        if (v0.format != v1.format || v0.stride != v1.stride || v0.shaderLocation != v1.shaderLocation)
                            return false;
                    }
                }
            }
            return true;
        }
    }
    VertexAttributeLayout.IPoint = 0;
    VertexAttributeLayout._pool = {};

    class VertexBuffer extends Buffer {
        get vertexDeclaration() {
            return this._vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._vertexDeclaration = value;
        }
        get instanceBuffer() {
            return this._instanceBuffer;
        }
        set instanceBuffer(value) {
            this._instanceBuffer = value;
        }
        constructor(targetType, bufferUsageType) {
            super(targetType, bufferUsageType);
            this._instanceBuffer = false;
            this._vertexDeclaration = null;
        }
    }

    class AnimatorState2DScript {
        setPlayScriptInfo(animator, layerindex, playstate) {
            this.playStateInfo.animator = animator;
            this.playStateInfo.layerindex = layerindex;
            this.playStateInfo.playState = playstate;
        }
        constructor() {
            this.playStateInfo = { animator: null, layerindex: -1, playState: null };
        }
        onStateEnter() {
        }
        onStateUpdate(normalizeTime) {
        }
        onStateExit() {
        }
        onStateLoop() {
        }
    }

    class Command2D {
        constructor() {
            this._commandBuffer = null;
        }
        recover() {
            this._commandBuffer = null;
            this._context = null;
        }
        destroy() {
            this._commandBuffer = null;
            this._context = null;
        }
    }

    class Blit2DCMD extends Command2D {
        static __initBlitShader__() {
            let blitvs = `
        #define SHADER_NAME Blit2DVS

        varying vec2 v_Texcoord0;

        void main()
        {
            gl_Position = vec4(u_OffsetScale.x * 2.0 - 1.0 + (a_PositionTexcoord.x + 1.0) * u_OffsetScale.z, (1.0 - ((u_OffsetScale.y * 2.0 - 1.0 + (-a_PositionTexcoord.y + 1.0) * u_OffsetScale.w) + 1.0) / 2.0) * 2.0 - 1.0, 0.0, 1.0);

            v_Texcoord0 = a_PositionTexcoord.zw;

            #ifdef INVERTY
            gl_Position.y = -gl_Position.y;
            #endif
        }
        `;
            let blitfs = `
        #define SHADER_NAME Blit2DFS

        #include "Color.glsl";

        varying vec2 v_Texcoord0;

        void main()
        {
            vec4 mainColor = texture2D(u_MainTex, v_Texcoord0);
            #ifdef Gamma_u_MainTex
            mainColor = gammaToLinear(mainColor);
            #endif // Gamma_u_AlbedoTexture
            gl_FragColor = mainColor;
            gl_FragColor = outputTransform(gl_FragColor);
        }
        `;
            let attributeMap = {
                "a_PositionTexcoord": [0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_OffsetScale": exports.ShaderDataType.Vector4,
                "u_MainTex": exports.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": exports.ShaderDataType.Vector4,
            };
            let shader = Shader3D.add("Blit2DCMD");
            shader.shaderType = exports.ShaderFeatureType.PostProcess;
            let subShader = new SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(blitvs, blitfs);
            blitPass.statefirst = true;
            blitPass.renderState.depthWrite = false;
            blitPass.renderState.depthTest = RenderState.DEPTHTEST_OFF;
            blitPass.renderState.blend = RenderState.BLEND_ENABLE_ALL;
            blitPass.renderState.blendEquation = RenderState.BLENDEQUATION_ADD;
            blitPass.renderState.srcBlend = RenderState.BLENDPARAM_ONE;
            blitPass.renderState.dstBlend = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
            blitPass.renderState.cull = RenderState.CULL_NONE;
        }
        static __initGeometryElement__() {
            let _vertices = new Float32Array([
                1, 1, 1, 1,
                1, -1, 1, 0,
                -1, 1, 0, 1,
                -1, -1, 0, 0
            ]);
            let vertexDec = new VertexDeclaration(16, [new VertexElement(0, VertexElementFormat.Vector4, 0)]);
            let vertex = LayaGL.renderDeviceFactory.createVertexBuffer(exports.BufferUsage.Dynamic);
            vertex.vertexDeclaration = vertexDec;
            vertex.setDataLength(_vertices.buffer.byteLength);
            vertex.setData(_vertices.buffer, 0, 0, _vertices.buffer.byteLength);
            let bufferState = LayaGL.renderDeviceFactory.createBufferState();
            bufferState.applyState([vertex], null);
            let geometry = Blit2DCMD.QuadGeometry = LayaGL.renderDeviceFactory.createRenderGeometryElement(exports.MeshTopology.TriangleStrip, exports.DrawType.DrawArray);
            geometry.setDrawArrayParams(0, 4);
            geometry.bufferState = bufferState;
        }
        static __init__() {
            Blit2DCMD.__initBlitShader__();
            Blit2DCMD.__initGeometryElement__();
            Blit2DCMD._blitShaderData = LayaGL.renderDeviceFactory.createShaderData();
            Blit2DCMD._defaultShader = Shader3D.find("Blit2DCMD");
        }
        static create(source, dest, offsetScale = null, shader = null, shaderData = null) {
            if (!Blit2DCMD._blitShaderData)
                Blit2DCMD.__init__();
            var cmd;
            cmd = Blit2DCMD._pool.length > 0 ? Blit2DCMD._pool.pop() : new Blit2DCMD();
            cmd.source = source;
            cmd.dest = dest;
            cmd.offsetScale = offsetScale;
            cmd.setshader(shader, shaderData);
            return cmd;
        }
        constructor() {
            super();
            this._source = null;
            this._dest = null;
            this._offsetScale = new Vector4();
            this._shader = null;
            this._shaderData = null;
            this._renderElement = LayaGL.render2DRenderPassFactory.createRenderElement2D();
            this._blitQuadCMDData = LayaGL.render2DRenderPassFactory.createBlit2DQuadCMDData();
            this._blitQuadCMDData.element = this._renderElement;
            this._renderElement.geometry = Blit2DCMD.QuadGeometry;
            this._renderElement.nodeCommonMap = null;
            this._renderElement.renderStateIsBySprite = false;
        }
        get offsetScale() {
            return this._offsetScale;
        }
        set offsetScale(value) {
            value ? value.cloneTo(this._offsetScale) : Blit2DCMD._defaultOffsetScale.cloneTo(this._offsetScale);
            this._blitQuadCMDData.offsetScale = this._offsetScale;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
            this._blitQuadCMDData.source = value ? value._texture : Texture2D.blackTexture._texture;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
            this._blitQuadCMDData.dest = value ? value._renderTarget : null;
        }
        set shaderData(value) {
            this._shaderData = value || Blit2DCMD._blitShaderData;
            this._renderElement.materialShaderData = this._shaderData;
        }
        getRenderCMD() {
            return this._blitQuadCMDData;
        }
        setshader(shader, shaderData) {
            this._shader = shader || Blit2DCMD._defaultShader;
            this.shaderData = shaderData;
            this._renderElement.subShader = this._shader.getSubShaderAt(0);
        }
        destroy() {
            this._commandBuffer = null;
            this._context = null;
        }
    }
    Blit2DCMD._defaultOffsetScale = new Vector4(0, 0, 1, 1);
    Blit2DCMD._pool = [];

    class DrawMesh2DCMD extends Command2D {
        static create(mesh, mat, texture, color, material) {
            var cmd = DrawMesh2DCMD._pool.length > 0 ? DrawMesh2DCMD._pool.pop() : new DrawMesh2DCMD();
            cmd.mesh = mesh;
            cmd.material = material;
            cmd.texture = texture;
            cmd.color = color;
            cmd._setMatrix(mat);
            return cmd;
        }
        constructor() {
            super();
            this._drawElementData = LayaGL.render2DRenderPassFactory.createDraw2DElementCMDData();
            this._mesh2DRender = new Mesh2DRender();
            this._needUpdateElement = true;
            this._matrix = new Matrix();
        }
        _setMatrix(value) {
            value ? value.copyTo(this._matrix) : Matrix.EMPTY.copyTo(this._matrix);
            let mat = this._matrix;
            let vec3 = Vector3.TEMP;
            vec3.x = mat.a;
            vec3.y = mat.c;
            vec3.z = mat.tx;
            this._mesh2DRender._spriteShaderData.setVector3(BaseRenderNode2D.NMATRIX_0, vec3);
            vec3.x = mat.b;
            vec3.y = mat.d;
            vec3.z = mat.ty;
            this._mesh2DRender._spriteShaderData.setVector3(BaseRenderNode2D.NMATRIX_1, vec3);
        }
        set material(value) {
            if (value == this.material)
                return;
            if (!value)
                value = Mesh2DRender.mesh2DDefaultMaterial;
            this._mesh2DRender.sharedMaterial = value;
            this._needUpdateElement = true;
        }
        get material() {
            return this._mesh2DRender.sharedMaterial;
        }
        set mesh(value) {
            if (value == this.mesh)
                return;
            this._mesh2DRender.sharedMesh = value;
            this._needUpdateElement = true;
        }
        get mesh() {
            return this._mesh2DRender.sharedMesh;
        }
        set texture(value) {
            this._mesh2DRender.texture = value;
        }
        get texture() {
            return this._mesh2DRender.texture;
        }
        set color(value) {
            this._mesh2DRender.color = value;
            let a = value.a;
            let renderColor = this._mesh2DRender._setRenderColor;
            renderColor.setValue(value.r * a, value.g * a, value.b * a, a);
            this._mesh2DRender._spriteShaderData.setColor(BaseRenderNode2D.BASERENDER2DCOLOR, renderColor);
        }
        get color() {
            return this._mesh2DRender.color;
        }
        getRenderCMD() {
            return this._drawElementData;
        }
        run() {
            if (this._needUpdateElement) {
                this._drawElementData.setRenderelements(this._mesh2DRender._renderElements);
                this._needUpdateElement = false;
            }
            this._mesh2DRender._setRenderSize(this._commandBuffer._renderSize.x, this._commandBuffer._renderSize.y);
        }
        recover() {
            DrawMesh2DCMD._pool.push(this);
            super.recover();
            this.material = null;
            this.texture = null;
            this.mesh = null;
        }
        destroy() {
            super.destroy();
            this.material = null;
        }
    }
    DrawMesh2DCMD._pool = [];

    class DrawRenderElement2DCMD extends Command2D {
        static create(element, mat = null) {
            var cmd = DrawRenderElement2DCMD._pool.length > 0 ? DrawRenderElement2DCMD._pool.pop() : new DrawRenderElement2DCMD();
            cmd.renderElement = element;
            cmd._setMatrix(mat);
            return cmd;
        }
        get renderElement() {
            return this._renderElement;
        }
        set renderElement(value) {
            this._renderElement = value;
            this._drawElementCMDData.setRenderelements([this._renderElement]);
        }
        constructor() {
            super();
            this._drawElementCMDData = LayaGL.render2DRenderPassFactory.createDraw2DElementCMDData();
            this._renderSize = new Vector2();
        }
        _setMatrix(value) {
            value ? (this._matreix = value.clone()) : (this._matreix = null);
            if (this._matreix && this.renderElement.nodeCommonMap.indexOf("BaseRender2D") != -1) {
                let vec3 = Vector3.TEMP;
                vec3.x = this._matreix.a;
                vec3.y = this._matreix.c;
                vec3.z = this._matreix.tx;
                this._renderElement.value2DShaderData.setVector3(BaseRenderNode2D.NMATRIX_0, vec3);
                vec3.x = this._matreix.b;
                vec3.y = this._matreix.d;
                vec3.z = this._matreix.ty;
                this._renderElement.value2DShaderData.setVector3(BaseRenderNode2D.NMATRIX_1, vec3);
            }
        }
        run() {
            if (Vector2.equals(this._renderSize, this._commandBuffer._renderSize))
                return;
            this._renderSize.setValue(this._commandBuffer._renderSize.x, this._commandBuffer._renderSize.y);
            this._renderElement.value2DShaderData.setVector2(BaseRenderNode2D.BASERENDERSIZE, this._renderSize);
        }
        recover() {
            super.recover();
            DrawRenderElement2DCMD._pool.push(this);
        }
        getRenderCMD() {
            return this._drawElementCMDData;
        }
        destroy() {
            this._renderElement = null;
            this._drawElementCMDData = null;
        }
    }
    DrawRenderElement2DCMD._pool = [];

    class Set2DRTCMD extends Command2D {
        static create(renderTexture, clearColor, colorValue, renderInvertY = true) {
            var cmd;
            cmd = Set2DRTCMD._pool.length > 0 ? Set2DRTCMD._pool.pop() : new Set2DRTCMD();
            cmd.renderTexture = renderTexture;
            cmd._setRenderTargetCMD.clearColor = clearColor;
            cmd._setRenderTargetCMD.clearColorValue = colorValue;
            cmd._setRenderTargetCMD.invertY = renderInvertY;
            return cmd;
        }
        get renderTexture() {
            return this._renderTexture;
        }
        set renderTexture(value) {
            this._renderTexture = value;
            this._setRenderTargetCMD.rt = value ? value._renderTarget : null;
        }
        constructor() {
            super();
            this._renderTexture = null;
            this._setRenderTargetCMD = LayaGL.render2DRenderPassFactory.createSetRendertarget2DCMD();
        }
        run() {
            if (this._renderTexture)
                this._commandBuffer._renderSize.setValue(this._renderTexture._renderTarget._textures[0].width, this._renderTexture._renderTarget._textures[0].height);
            else {
                this._commandBuffer._renderSize.setValue(RenderState2D.width, RenderState2D.height);
            }
        }
        getRenderCMD() {
            return this._setRenderTargetCMD;
        }
        recover() {
            Set2DRTCMD._pool.push(this);
            this._renderTexture = null;
        }
    }
    Set2DRTCMD._pool = [];

    class Set2DShaderDataCMD extends Command2D {
        static create(shaderData, nameID, value, shaderDataType) {
            var cmd;
            cmd = Set2DShaderDataCMD._pool.length > 0 ? Set2DShaderDataCMD._pool.pop() : new Set2DShaderDataCMD();
            cmd.setDest(shaderData);
            cmd._setRenderDataCMD.propertyID = nameID;
            cmd._setRenderDataCMD.dataType = shaderDataType;
            cmd._setRenderDataCMD.value = value;
            return cmd;
        }
        constructor() {
            super();
            this._globalMode = false;
            this._setRenderDataCMD = LayaGL.render2DRenderPassFactory.createSetRenderDataCMD();
        }
        getRenderCMD() {
            return this._setRenderDataCMD;
        }
        setDest(value) {
            this._setRenderDataCMD.dest = value;
        }
        recover() {
            Set2DShaderDataCMD._pool.push(this);
            this._globalMode = false;
        }
    }
    Set2DShaderDataCMD._pool = [];
    class Set2DDefineCMD extends Command2D {
        static create(shaderData, define, addDefine) {
            var cmd;
            cmd = Set2DDefineCMD._pool.length > 0 ? Set2DDefineCMD._pool.pop() : new Set2DDefineCMD();
            cmd.setDest(shaderData);
            cmd._setRenderDefineCMD.add = addDefine;
            cmd._setRenderDefineCMD.define = define;
            return cmd;
        }
        constructor() {
            super();
            this._globalMode = false;
            this._setRenderDefineCMD = LayaGL.render2DRenderPassFactory.createSetShaderDefineCMD();
        }
        setDest(value) {
            this._setRenderDefineCMD.dest = value;
        }
        getRenderCMD() {
            return this._setRenderDefineCMD;
        }
        recover() {
            Set2DDefineCMD._pool.push(this);
            this._globalMode = false;
        }
    }
    Set2DDefineCMD._pool = [];

    class CommandBuffer2D {
        constructor(name) {
            this._scene = null;
            this._renderCMDs = [];
            this._renderSize = new Vector2();
            this.cacheData = {};
            this._name = name;
            this._context = Render2DSimple.rendercontext2D;
            this._commands = [];
        }
        getName() {
            return this._name;
        }
        _cacheContextState() {
            this.cacheData.rt = this._context.getRenderTarget();
            this.cacheData.pipeline = this._context.pipelineMode;
            this.cacheData.invertY = this._context.invertY;
        }
        _recoverContextState() {
            this._context.setRenderTarget(this.cacheData.rt, false, Color.BLACK);
            this._context.pipelineMode = this.cacheData.pipeline;
            this._context.invertY = this.cacheData.invertY;
        }
        apply(render = true, recoverContextStat = true) {
            recoverContextStat && this._cacheContextState();
            for (var i = 0, n = this._commands.length; i < n; i++) {
                let cmd = this._commands[i];
                cmd.run && cmd.run();
            }
            render && this._context.runCMDList(this._renderCMDs);
            Stat.cmdDrawCall += this._renderCMDs.length;
            recoverContextStat && this._recoverContextState();
        }
        applyOne(recoverContextStat = true) {
            recoverContextStat && this._cacheContextState();
            if (this._commands.length) {
                var cmd = this._commands.shift();
                cmd.run && cmd.run();
                cmd.getRenderCMD && this._context.runOneCMD(this._renderCMDs.shift());
                cmd.recover();
            }
            recoverContextStat && this._recoverContextState();
            return this._commands.length > 0;
        }
        clear(recover = true) {
            if (recover)
                for (var i = 0, n = this._commands.length; i < n; i++)
                    this._commands[i].recover();
            this._commands.length = 0;
            this._renderCMDs.length = 0;
        }
        getCommandsSize() {
            return this._commands.length;
        }
        setShaderDataValue(shaderData, nameID, dataType, value) {
            if (!checkShaderDataValueLegal(value, dataType))
                return;
            let cmd = Set2DShaderDataCMD.create(shaderData, nameID, value, dataType);
            cmd._globalMode = false;
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalShaderDataValue(nameID, dataType, value) {
            if (!checkShaderDataValueLegal(value, dataType))
                return;
            if (!this._scene || (!this._scene._specialManager)) {
                return;
            }
            let cmd = Set2DShaderDataCMD.create(this._scene._specialManager._shaderData, nameID, value, dataType);
            cmd._globalMode = true;
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDefine(shaderData, define, value) {
            let cmd = Set2DDefineCMD.create(shaderData, define, value);
            cmd._globalMode = false;
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitTextureQuad(source, dest, offsetScale, shader, shaderData) {
            let cmd = Blit2DCMD.create(source, dest, offsetScale, shader, shaderData);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitTextureBlur(source, dest, blurParams) {
        }
        setRenderTarget(renderTexture, clearColor, colorValue = Color.BLACK, invertY = true) {
            let cmd = Set2DRTCMD.create(renderTexture, clearColor, colorValue, invertY);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawRenderElement(renderelement, mat) {
            let cmd = DrawRenderElement2DCMD.create(renderelement, mat);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawMesh(mesh, mat, meshTexture, color, material) {
            let cmd = DrawMesh2DCMD.create(mesh, mat, meshTexture || Texture2D.whiteTexture, color || Color.WHITE, material || Mesh2DRender.mesh2DDefaultMaterial);
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawQuad() {
        }
        drawLine() {
        }
        addCacheCommand(cmd) {
            if (this._scene) {
                if (cmd instanceof Set2DShaderDataCMD) {
                    if (cmd._commandBuffer)
                        cmd.setDest(this._scene._specialManager._shaderData);
                }
                if (cmd instanceof Set2DDefineCMD) {
                    if (cmd._commandBuffer)
                        cmd.setDest(this._scene._specialManager._shaderData);
                }
            }
            this._commands.push(cmd);
            cmd._commandBuffer = this;
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
    }

    class ButtonEffect {
        constructor() {
            this._curState = 0;
            this.effectScale = 1.5;
            this.tweenTime = 300;
        }
        set target(tar) {
            this._tar = tar;
            tar.on(Event.MOUSE_DOWN, this, this.toChangedState);
            tar.on(Event.MOUSE_UP, this, this.toInitState);
            tar.on(Event.MOUSE_OUT, this, this.toInitState);
        }
        toChangedState() {
            this._curState = 1;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curTween = Tween.to(this._tar, { scaleX: this.effectScale, scaleY: this.effectScale }, this.tweenTime, Ease[this.effectEase], Handler.create(this, this.tweenComplete));
        }
        toInitState() {
            if (this._curState == 2)
                return;
            if (this._curTween)
                Tween.clear(this._curTween);
            this._curState = 2;
            this._curTween = Tween.to(this._tar, { scaleX: 1, scaleY: 1 }, this.tweenTime, Ease[this.backEase], Handler.create(this, this.tweenComplete));
        }
        tweenComplete() {
            this._curState = 0;
            this._curTween = null;
        }
    }

    class EffectBase extends Component {
        constructor() {
            super(...arguments);
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.autoDestroyAtComplete = true;
        }
        _onAwake() {
            this.target = this.target || this.owner;
            if (this.autoDestroyAtComplete)
                this._comlete = Handler.create(this.target, this.target.destroy, null, false);
            if (this.eventName)
                this.owner.on(this.eventName, this, this._exeTween);
            else
                this._exeTween();
        }
        _exeTween() {
            this._tween = this._doTween();
            this._tween.repeat(this.repeat);
        }
        _doTween() {
            return null;
        }
        onReset() {
            this.duration = 1000;
            this.delay = 0;
            this.repeat = 0;
            this.ease = null;
            this.target = null;
            if (this.eventName) {
                this.owner.off(this.eventName, this, this._exeTween);
                this.eventName = null;
            }
            if (this._comlete) {
                this._comlete.recover();
                this._comlete = null;
            }
            if (this._tween) {
                this._tween.clear();
                this._tween = null;
            }
        }
    }

    class FadeIn extends EffectBase {
        _doTween() {
            this.target.alpha = 0;
            return Tween.to(this.target, { alpha: 1 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class FadeOut extends EffectBase {
        _doTween() {
            this.target.alpha = 1;
            return Tween.to(this.target, { alpha: 0 }, this.duration, Ease[this.ease], this._comlete, this.delay);
        }
    }

    class KeyLocation {
    }
    KeyLocation.STANDARD = 0;
    KeyLocation.LEFT = 1;
    KeyLocation.RIGHT = 2;
    KeyLocation.NUM_PAD = 3;

    class Keyboard {
    }
    Keyboard.NUMBER_0 = 48;
    Keyboard.NUMBER_1 = 49;
    Keyboard.NUMBER_2 = 50;
    Keyboard.NUMBER_3 = 51;
    Keyboard.NUMBER_4 = 52;
    Keyboard.NUMBER_5 = 53;
    Keyboard.NUMBER_6 = 54;
    Keyboard.NUMBER_7 = 55;
    Keyboard.NUMBER_8 = 56;
    Keyboard.NUMBER_9 = 57;
    Keyboard.A = 65;
    Keyboard.B = 66;
    Keyboard.C = 67;
    Keyboard.D = 68;
    Keyboard.E = 69;
    Keyboard.F = 70;
    Keyboard.G = 71;
    Keyboard.H = 72;
    Keyboard.I = 73;
    Keyboard.J = 74;
    Keyboard.K = 75;
    Keyboard.L = 76;
    Keyboard.M = 77;
    Keyboard.N = 78;
    Keyboard.O = 79;
    Keyboard.P = 80;
    Keyboard.Q = 81;
    Keyboard.R = 82;
    Keyboard.S = 83;
    Keyboard.T = 84;
    Keyboard.U = 85;
    Keyboard.V = 86;
    Keyboard.W = 87;
    Keyboard.X = 88;
    Keyboard.Y = 89;
    Keyboard.Z = 90;
    Keyboard.F1 = 112;
    Keyboard.F2 = 113;
    Keyboard.F3 = 114;
    Keyboard.F4 = 115;
    Keyboard.F5 = 116;
    Keyboard.F6 = 117;
    Keyboard.F7 = 118;
    Keyboard.F8 = 119;
    Keyboard.F9 = 120;
    Keyboard.F10 = 121;
    Keyboard.F11 = 122;
    Keyboard.F12 = 123;
    Keyboard.F13 = 124;
    Keyboard.F14 = 125;
    Keyboard.F15 = 126;
    Keyboard.NUMPAD = 21;
    Keyboard.NUMPAD_0 = 96;
    Keyboard.NUMPAD_1 = 97;
    Keyboard.NUMPAD_2 = 98;
    Keyboard.NUMPAD_3 = 99;
    Keyboard.NUMPAD_4 = 100;
    Keyboard.NUMPAD_5 = 101;
    Keyboard.NUMPAD_6 = 102;
    Keyboard.NUMPAD_7 = 103;
    Keyboard.NUMPAD_8 = 104;
    Keyboard.NUMPAD_9 = 105;
    Keyboard.NUMPAD_ADD = 107;
    Keyboard.NUMPAD_DECIMAL = 110;
    Keyboard.NUMPAD_DIVIDE = 111;
    Keyboard.NUMPAD_ENTER = 108;
    Keyboard.NUMPAD_MULTIPLY = 106;
    Keyboard.NUMPAD_SUBTRACT = 109;
    Keyboard.SEMICOLON = 186;
    Keyboard.EQUAL = 187;
    Keyboard.COMMA = 188;
    Keyboard.MINUS = 189;
    Keyboard.PERIOD = 190;
    Keyboard.SLASH = 191;
    Keyboard.BACKQUOTE = 192;
    Keyboard.LEFTBRACKET = 219;
    Keyboard.BACKSLASH = 220;
    Keyboard.RIGHTBRACKET = 221;
    Keyboard.QUOTE = 222;
    Keyboard.ALTERNATE = 18;
    Keyboard.BACKSPACE = 8;
    Keyboard.CAPS_LOCK = 20;
    Keyboard.COMMAND = 15;
    Keyboard.CONTROL = 17;
    Keyboard.DELETE = 46;
    Keyboard.ENTER = 13;
    Keyboard.ESCAPE = 27;
    Keyboard.PAGE_UP = 33;
    Keyboard.PAGE_DOWN = 34;
    Keyboard.END = 35;
    Keyboard.HOME = 36;
    Keyboard.LEFT = 37;
    Keyboard.UP = 38;
    Keyboard.RIGHT = 39;
    Keyboard.DOWN = 40;
    Keyboard.SHIFT = 16;
    Keyboard.SPACE = 32;
    Keyboard.TAB = 9;
    Keyboard.INSERT = 45;

    class CommandEncoder {
        constructor() {
            this._idata = [];
        }
        getArrayData() {
            return this._idata;
        }
        getCount() {
            return this._idata.length;
        }
        addShaderUniform(variable) {
            this._idata.push(variable);
        }
    }

    class QuickTestTool {
        static getMCDName(type) {
            return QuickTestTool._typeToNameDic[type];
        }
        static showRenderTypeInfo(type, force = false) {
            if (!force && QuickTestTool.showedDic[type])
                return;
            QuickTestTool.showedDic[type] = true;
            if (!QuickTestTool._rendertypeToStrDic[type]) {
                var arr = [];
                var tType;
                tType = 1;
                while (tType <= type) {
                    if (tType & type) {
                        arr.push(QuickTestTool.getMCDName(tType & type));
                    }
                    tType = tType << 1;
                }
                QuickTestTool._rendertypeToStrDic[type] = arr.join(",");
            }
            console.log("cmd:", QuickTestTool._rendertypeToStrDic[type]);
        }
        static __init__() {
            QuickTestTool._typeToNameDic[SpriteConst.ALPHA] = "ALPHA";
            QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM] = "TRANSFORM";
            QuickTestTool._typeToNameDic[SpriteConst.TEXTURE] = "TEXTURE";
            QuickTestTool._typeToNameDic[SpriteConst.GRAPHICS] = "GRAPHICS";
            QuickTestTool._typeToNameDic[SpriteConst.CHILDS] = "CHILDS";
            QuickTestTool._typeToNameDic[SpriteConst.TRANSFORM | SpriteConst.ALPHA] = "TRANSFORM|ALPHA";
            QuickTestTool._typeToNameDic[SpriteConst.CANVAS] = "CANVAS";
            QuickTestTool._typeToNameDic[SpriteConst.BLEND] = "BLEND";
            QuickTestTool._typeToNameDic[SpriteConst.FILTERS] = "FILTERS";
            QuickTestTool._typeToNameDic[SpriteConst.MASK] = "MASK";
            QuickTestTool._typeToNameDic[SpriteConst.CLIP] = "CLIP";
        }
        constructor() {
        }
        render(context, x, y) {
            QuickTestTool._addType(this._renderType);
            QuickTestTool.showRenderTypeInfo(this._renderType);
            RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y);
            this._repaint = 0;
        }
        _stageRender(context, x, y) {
            QuickTestTool._countStart();
            QuickTestTool._PreStageRender.call(ILaya.stage, context, x, y);
            QuickTestTool._countEnd();
        }
        static _countStart() {
            var key;
            for (key in QuickTestTool._countDic) {
                QuickTestTool._countDic[key] = 0;
            }
        }
        static _countEnd() {
            QuickTestTool._i++;
            if (QuickTestTool._i > 60) {
                QuickTestTool.showCountInfo();
                QuickTestTool._i = 0;
            }
        }
        static _addType(type) {
            if (!QuickTestTool._countDic[type]) {
                QuickTestTool._countDic[type] = 1;
            }
            else {
                QuickTestTool._countDic[type] += 1;
            }
        }
        static showCountInfo() {
            console.log("===================");
            var key;
            for (key in QuickTestTool._countDic) {
                console.log("count:" + QuickTestTool._countDic[key]);
                QuickTestTool.showRenderTypeInfo(key, true);
            }
        }
        static enableQuickTest() {
            QuickTestTool.__init__();
            Sprite["prototype"]["render"] = QuickTestTool["prototype"]["render"];
            QuickTestTool._PreStageRender = Stage["prototype"]["render"];
            Stage["prototype"]["render"] = QuickTestTool["prototype"]["_stageRender"];
        }
    }
    QuickTestTool.showedDic = {};
    QuickTestTool._rendertypeToStrDic = {};
    QuickTestTool._typeToNameDic = {};
    QuickTestTool._countDic = {};
    QuickTestTool._i = 0;

    class BooleanKeyframe extends Keyframe {
        cloneTo(destObject) {
            super.cloneTo(destObject);
            destObject.value = this.value;
        }
        clone() {
            let f = new BooleanKeyframe();
            this.cloneTo(f);
            return f;
        }
    }

    class QuaternionKeyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector4();
            this.outTangent = new Vector4();
            this.value = new Quaternion();
            if (weightMode) {
                this.inWeight = new Vector4();
                this.outWeight = new Vector4();
                this.weightedMode = new Vector4();
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            var destKeyFarme = dest;
            this.inTangent.cloneTo(destKeyFarme.inTangent);
            this.outTangent.cloneTo(destKeyFarme.outTangent);
            this.value.cloneTo(destKeyFarme.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(destKeyFarme.inWeight);
                this.outWeight.cloneTo(destKeyFarme.outWeight);
                this.weightedMode.cloneTo(destKeyFarme.weightedMode);
            }
        }
    }

    class Vector2Keyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector2();
            this.outTangent = new Vector2();
            this.value = new Vector2();
            if (weightMode) {
                this.inWeight = new Vector2(Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.outWeight = new Vector2(Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.weightedMode = new Vector2(exports.WeightedMode.None, exports.WeightedMode.None);
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            this.inTangent.cloneTo(dest.inTangent);
            this.outTangent.cloneTo(dest.outTangent);
            this.value.cloneTo(dest.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(dest.inWeight);
                this.outWeight.cloneTo(dest.outWeight);
                this.weightedMode.cloneTo(dest.weightedMode);
            }
        }
    }

    class Vector3Keyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector3();
            this.outTangent = new Vector3();
            this.value = new Vector3();
            if (weightMode) {
                this.inWeight = new Vector3(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.outWeight = new Vector3(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.weightedMode = new Vector3(exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None);
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            this.inTangent.cloneTo(dest.inTangent);
            this.outTangent.cloneTo(dest.outTangent);
            this.value.cloneTo(dest.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(dest.inWeight);
                this.outWeight.cloneTo(dest.outWeight);
                this.weightedMode.cloneTo(dest.weightedMode);
            }
        }
    }

    class Vector4Keyframe extends Keyframe {
        constructor(weightMode = false) {
            super();
            this.inTangent = new Vector4();
            this.outTangent = new Vector4();
            this.value = new Vector4();
            if (weightMode) {
                this.inWeight = new Vector4(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.outWeight = new Vector4(Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight, Keyframe.defaultWeight);
                this.weightedMode = new Vector4(exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None, exports.WeightedMode.None);
            }
        }
        cloneTo(dest) {
            super.cloneTo(dest);
            this.inTangent.cloneTo(dest.inTangent);
            this.outTangent.cloneTo(dest.outTangent);
            this.value.cloneTo(dest.value);
            if (this.weightedMode) {
                this.inWeight.cloneTo(dest.inWeight);
                this.outWeight.cloneTo(dest.outWeight);
                this.weightedMode.cloneTo(dest.weightedMode);
            }
        }
    }

    class Viewport {
        constructor(x, y, width, height) {
            this.minDepth = 0.0;
            this.maxDepth = 1.0;
            this.x = x !== null && x !== void 0 ? x : 0;
            this.y = y !== null && y !== void 0 ? y : 0;
            this.width = width !== null && width !== void 0 ? width : 0;
            this.height = height !== null && height !== void 0 ? height : 0;
        }
        project(source, matrix, out) {
            Vector3.transformV3ToV4(source, matrix, out);
            var x = out.x, y = out.y, z = out.z;
            var w = out.w;
            if (w !== 1.0) {
                x = x / w;
                y = y / w;
                z = z / w;
            }
            out.x = (x + 1.0) * 0.5 * this.width + this.x;
            out.y = (-y + 1.0) * 0.5 * this.height + this.y;
            out.z = z * (this.maxDepth - this.minDepth) + this.minDepth;
        }
        unprojectFromMat(source, matrix, out) {
            var matrixEleme = matrix.elements;
            out.x = (((source.x - this.x) / this.width) * 2.0) - 1.0;
            out.y = -((((source.y - this.y) / this.height) * 2.0) - 1.0);
            out.z = (source.z - this.minDepth) / (this.maxDepth - this.minDepth);
            var a = (((out.x * matrixEleme[3]) + (out.y * matrixEleme[7])) + (out.z * matrixEleme[11])) + matrixEleme[15];
            Vector3.transformV3ToV3(out, matrix, out);
            if (a !== 1.0) {
                out.x = out.x / a;
                out.y = out.y / a;
                out.z = out.z / a;
            }
        }
        unprojectFromWVP(source, projection, view, world, out) {
            Matrix4x4.multiply(projection, view, _tempMatrix4x4);
            (world) && (Matrix4x4.multiply(_tempMatrix4x4, world, _tempMatrix4x4));
            _tempMatrix4x4.invert(_tempMatrix4x4);
            this.unprojectFromMat(source, _tempMatrix4x4, out);
        }
        set(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        cloneTo(out) {
            out.x = this.x;
            out.y = this.y;
            out.width = this.width;
            out.height = this.height;
            out.minDepth = this.minDepth;
            out.maxDepth = this.maxDepth;
        }
    }
    Viewport.TEMP = new Viewport(0, 0, 0, 0);
    const _tempMatrix4x4 = new Matrix4x4();

    const EXPIRE_TIME = 30000;
    const CHECK_INTERVAL = 10000;
    class AudioDataCache {
        constructor() {
            this._size = 0;
            this._lastCheck = 0;
            this._items = {};
        }
        add(url, obj, size) {
            if (this._items[url])
                this._size -= this._items[url].size;
            let time = Browser.now();
            this._items[url] = { obj, size: size, time };
            this._size += size;
            if (this._size > Config.audioBufferCacheMaxSize && time - this._lastCheck > CHECK_INTERVAL) {
                this._lastCheck = time;
                for (let key in this._items) {
                    let item2 = this._items[key];
                    if (time - item2.time > EXPIRE_TIME) {
                        this._size -= item2.size;
                        delete this._items[key];
                        console.debug("AudioDataCache: remove " + key);
                    }
                }
            }
        }
        get(url, callback, callbackThis) {
            let item = this._items[url];
            if (item != null) {
                item.time = Browser.now();
                callback.call(callbackThis, item.obj);
                return;
            }
            ILaya.loader.load(url, { type: Loader.SOUND, cache: false }).then(buffer => {
                if (buffer)
                    this.add(url, buffer, buffer.__byteLength);
                callback.call(callbackThis, buffer);
            });
        }
    }

    class SoundChannel extends EventDispatcher {
        constructor(url) {
            super();
            this.playbackRate = 1;
            this._started = false;
            this._paused = false;
            this._loaded = false;
            this._completed = false;
            this._repeated = 0;
            this._volumeSet = 1;
            this._volume = 1;
            this._muted = false;
            this._startTime = 0;
            this._pauseTime = 0;
            this._isMusic = false;
            this._autoResume = false;
            this.url = url;
        }
        get volume() {
            return this._volumeSet;
        }
        set volume(value) {
            this._volumeSet = value;
            let t = value * (this._isMusic ? SoundManager.musicVolume : SoundManager.soundVolume);
            if (t !== this._volume) {
                this._volume = t;
                if (this._loaded)
                    this.onVolumeChanged();
            }
        }
        get muted() {
            return this._muted;
        }
        set muted(value) {
            value = !!value;
            if (this._muted == value)
                return;
            this._muted = value;
            if (this._loaded)
                this.onMuted();
        }
        get position() {
            if (this._paused)
                return this._pauseTime;
            else if (this._startTime != 0)
                return (Browser.now() - this._startTime) / 1000 + this.startTime;
            else
                return this.startTime;
        }
        get duration() {
            return 0;
        }
        get paused() {
            return this._paused;
        }
        get isStopped() {
            return !this._started;
        }
        play() {
            if (this._started) {
                if (this._paused)
                    this.resume();
                return;
            }
            this._started = true;
            this._loaded = false;
            this._completed = false;
            this._repeated = 0;
            this._startTime = Browser.now();
            SoundManager.addChannel(this);
            AssetDb.inst.resolveURL(this.url, url => {
                if (!this._started)
                    return;
                if (!url) {
                    this.stop();
                    return;
                }
                this.onPlay(url);
            });
        }
        stop() {
            if (!this._started)
                return;
            this._started = false;
            this._loaded = false;
            SoundManager.removeChannel(this);
            this.onStop();
            this.callComplete(this._completed);
        }
        pause() {
            if (!this._started || this._paused)
                return;
            this._pauseTime = this.position;
            this._paused = true;
            this._autoResume = false;
            if (this._loaded)
                this.onPause();
        }
        resume() {
            if (!this._started || !this._paused)
                return;
            this._paused = false;
            if (this._loaded)
                this.onResume();
        }
        onPlay(url) {
        }
        onPlayAgain() {
        }
        onStop() {
        }
        onPause() {
        }
        onResume() {
        }
        onVolumeChanged() {
        }
        onMuted() {
        }
        onPlayEnd() {
            this._repeated++;
            if (this.loops > 0 && this._repeated >= this.loops) {
                this._completed = true;
                this.stop();
            }
            else
                this.onPlayAgain();
        }
        callComplete(success) {
            if (success)
                this.event(Event.COMPLETE);
            if (!this.completeHandler)
                return;
            let handler = this.completeHandler;
            this.completeHandler = null;
            if (handler instanceof Handler)
                handler.runWith(success !== null && success !== void 0 ? success : true);
            else
                handler(success !== null && success !== void 0 ? success : true);
        }
    }

    class HTMLAudioChannel extends SoundChannel {
        get position() {
            if (this._ele)
                return this._ele.currentTime;
            else
                return 0;
        }
        get duration() {
            if (this._ele)
                return this._ele.duration;
            else
                return 0;
        }
        onPlay(url) {
            this._ele = HTMLAudioChannel.elementPool.take();
            Browser.container.appendChild(this._ele);
            this._loaded = true;
            let ele = this._ele;
            ele.onerror = (event) => {
                console.error("HTMLAudioChannel: ", event);
                this.stop();
            };
            ele.onended = () => this.onPlayEnd();
            ele.src = URL.postFormatURL(URL.formatURL(url));
            ele.playbackRate = this.playbackRate;
            ele.currentTime = this.startTime;
            ele.loop = this.loops === 0;
            ele.volume = this._volume;
            ele.muted = this._muted;
            if (!this._paused) {
                this._ele.play().catch(e => {
                    if (e.name === "NotAllowedError" && this._isMusic)
                        PAL.media.resumeUntilGotFocus(this);
                    else
                        console.warn(e);
                });
            }
        }
        onPlayAgain() {
            this._ele.currentTime = this.startTime;
            this._ele.play().catch(e => { });
        }
        onStop() {
            this._ele.pause();
            HTMLAudioChannel.elementPool.recover(this._ele);
            this._ele = null;
        }
        onPause() {
            this._ele.pause();
        }
        onResume() {
            if (this._ele.readyState === 0)
                this._ele.load();
            this._ele.play().catch(e => { });
        }
        onVolumeChanged() {
            this._ele.volume = this._volume;
        }
        onMuted() {
            this._ele.muted = this._muted;
        }
    }
    HTMLAudioChannel.elementPool = Pool.createPool2(() => createAudioElement(), null, ele => resetAudioElement(ele));
    function createAudioElement() {
        return Browser.createElement("audio");
    }
    function resetAudioElement(ele) {
        ele.remove();
        ele.src = "";
        ele.onended = null;
        ele.onerror = null;
        ele.oncanplay = null;
        ele.oncanplaythrough = null;
    }

    class VideoPlayer {
        constructor() {
            this.options = {};
            this.allowBackground = false;
            this._playing = false;
            this._loaded = false;
            this._autoResume = false;
        }
        get currentTime() {
            return 0;
        }
        set currentTime(value) {
        }
        get volume() {
            return 0;
        }
        set volume(value) {
        }
        get muted() {
            return false;
        }
        set muted(value) {
        }
        get duration() {
            return 0;
        }
        get ended() {
            return false;
        }
        get loop() {
            return false;
        }
        set loop(value) {
        }
        get playbackRate() {
            return 1;
        }
        set playbackRate(value) {
        }
        get paused() {
            return false;
        }
        attachTo(owner) {
            if (this._owner) {
                this._owner.off(Event.TRANSFORM_CHANGED, this, this.onTransformChanged);
                ILaya.stage.off(Event.RESIZE, this, this.onTransformChanged);
            }
            this._owner = owner;
            if (this._owner) {
                this._owner.on(Event.TRANSFORM_CHANGED, this, this.onTransformChanged);
                ILaya.stage.on(Event.RESIZE, this, this.onTransformChanged);
            }
        }
        load(url) {
            if (!url)
                return;
            AssetDb.inst.resolveURL(url, url2 => this.onLoad(url2));
        }
        play() {
            if (this._playing || !LayaEnv.isPlaying)
                return;
            this._playing = true;
            ILaya.stage.on(Event.BLUR, this, this.onBlur);
            if (this._loaded)
                this.onPlay();
        }
        pause() {
            this._autoResume = false;
            if (!this._playing)
                return;
            this._playing = false;
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
            if (this._loaded)
                this.onPause();
        }
        resume() {
            this.play();
        }
        setLoaded() {
            this._loaded = true;
            this.onTransformChanged();
            if (this._playing)
                this.onPlay();
        }
        getNodeTransform() {
            let trans;
            if (Browser.onTTMiniGame) {
                trans = SpriteUtils.getGlobalPosAndScale(this._owner);
                trans.x *= ILaya.stage.clientScaleX;
                trans.y *= ILaya.stage.clientScaleY;
                trans.scaleX *= ILaya.stage.clientScaleX;
                trans.scaleY *= ILaya.stage.clientScaleY;
            }
            else
                trans = SpriteUtils.getTransformRelativeToWindow(this._owner, 0, 0);
            return { x: trans.x, y: trans.y, width: Math.round(this._owner.width * trans.scaleX), height: Math.round(this._owner.height * trans.scaleY) };
        }
        onTransformChanged() {
        }
        destroy() {
            this.onDestroy();
            this.attachTo(null);
            ILaya.stage.off(Event.BLUR, this, this.onBlur);
        }
        onBlur() {
            if (!this.allowBackground)
                PAL.media.resumeUntilGotFocus(this);
        }
        onLoad(url) {
        }
        onPlay() {
        }
        onPause() {
        }
        onDestroy() {
        }
    }

    class HTMLVideoPlayer extends VideoPlayer {
        constructor() {
            super();
            this.element = HTMLVideoPlayer.createElement();
        }
        get currentTime() {
            return this.element.currentTime;
        }
        set currentTime(value) {
            this.element.currentTime = value;
        }
        get volume() {
            return this.element.volume;
        }
        set volume(value) {
            this.element.volume = value;
        }
        get readyState() {
            return this.element.readyState;
        }
        get duration() {
            return this.element.duration;
        }
        get ended() {
            return this.element.ended;
        }
        get loop() {
            return this.element.loop;
        }
        set loop(value) {
            this.element.loop = value;
        }
        get playbackRate() {
            return this.element.playbackRate;
        }
        set playbackRate(value) {
            this.element.playbackRate = value;
        }
        get muted() {
            return this.element.muted;
        }
        set muted(value) {
            this.element.muted = value;
        }
        onLoad(url) {
            var _a;
            this.element.controls = (_a = this.options.controls) !== null && _a !== void 0 ? _a : false;
            HTMLVideoPlayer.setSrc(this.element, url);
            if (this.options.underGameView) {
                let c = Browser.container;
                if (c !== Browser.document.body)
                    Browser.document.body.insertBefore(this.element, c);
                else
                    Browser.document.body.appendChild(this.element);
            }
            else
                Browser.document.body.appendChild(this.element);
            this.onTransformChanged();
            this.setLoaded();
        }
        onPlay() {
            this.element.play().catch(e => {
                if (e.name === "NotAllowedError")
                    PAL.media.resumeUntilGotFocus(this);
                else
                    console.warn(e);
            });
        }
        onPause() {
            this.element.pause();
        }
        onTransformChanged() {
            let { x, y, width, height } = this.getNodeTransform();
            let style = this.element.style;
            style.left = x + "px";
            style.top = y + "px";
            style.width = width + "px";
            style.height = height + "px";
            PAL.browser.setStyleTransform(style, "rotate(" + (ILaya.stage.canvasDegree) + "deg)");
        }
        onDestroy() {
            HTMLVideoPlayer.setSrc(this.element, null);
            this.element.remove();
            if (LayaEnv.isConch)
                this.element._destroy();
        }
        static createElement() {
            let ele = Browser.createElement("video");
            let style = ele.style;
            style.position = 'absolute';
            style.top = '0px';
            style.left = '0px';
            PAL.browser.setStyleTransformOrigin(style, "0 0");
            ele.setAttribute('crossorigin', 'anonymous');
            if (Browser.onMobile) {
                ele["x5-playsInline"] = true;
                ele["x5-playsinline"] = true;
                ele.x5PlaysInline = true;
                ele.playsInline = true;
                ele["webkit-playsInline"] = true;
                ele["webkit-playsinline"] = true;
                ele.webkitPlaysInline = true;
                ele.playsinline = true;
                ele.style.playsInline = true;
                ele.crossOrigin = "anonymous";
                ele.setAttribute('playsinline', 'true');
                ele.setAttribute('x5-playsinline', 'true');
                ele.setAttribute('webkit-playsinline', 'true');
                ele.autoplay = true;
            }
            return ele;
        }
        static setSrc(ele, url) {
            while (ele.childElementCount)
                ele.firstChild.remove();
            if (url) {
                if (url.startsWith("blob:"))
                    ele.src = url;
                else {
                    let sourceElement = Browser.createElement("source");
                    sourceElement.src = URL.postFormatURL(URL.formatURL(url));
                    let extension = Utils.getFileExtension(url);
                    sourceElement.type = extension == "m3u8" ? "application/vnd.apple.mpegurl" : ("video/" + extension);
                    ele.appendChild(sourceElement);
                }
            }
            else {
                ele.pause();
                ele.src = "";
            }
        }
    }

    class HTMLVideoTexture extends VideoTexture {
        constructor() {
            super();
            this._needUpdate = true;
            this._hasRequestVideoFrame = false;
            let ele = this.element = HTMLVideoPlayer.createElement();
            ele.addEventListener("loadedmetadata", () => this.setLoaded(this.element.videoWidth, this.element.videoHeight, Browser.onLayaRuntime));
            ele.addEventListener("canplay", () => {
                if (!this._playing)
                    this.render(true);
            });
            if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
                const scope = this;
                function updateVideo() {
                    scope._needUpdate = true;
                    ele.requestVideoFrameCallback(updateVideo);
                }
                ele.requestVideoFrameCallback(updateVideo);
                this._hasRequestVideoFrame = true;
            }
        }
        get currentTime() {
            return this.element.currentTime;
        }
        set currentTime(value) {
            this.element.currentTime = value;
            if (!this._playing && this._loaded)
                this.render();
        }
        get volume() {
            return this.element.volume;
        }
        set volume(value) {
            this.element.volume = value;
        }
        get readyState() {
            return this.element.readyState;
        }
        get duration() {
            return this.element.duration;
        }
        get ended() {
            return this.element.ended;
        }
        get loop() {
            return this.element.loop;
        }
        set loop(value) {
            this.element.loop = value;
        }
        get playbackRate() {
            return this.element.playbackRate;
        }
        set playbackRate(value) {
            this.element.playbackRate = value;
        }
        get muted() {
            return this.element.muted;
        }
        set muted(value) {
            this.element.muted = value;
        }
        onLoad(url) {
            HTMLVideoPlayer.setSrc(this.element, url);
            this.element.load();
        }
        onPlay() {
            this.element.play().catch(e => {
                if (e.name === "NotAllowedError")
                    PAL.media.resumeUntilGotFocus(this);
                else
                    console.warn(e);
            });
        }
        onPause() {
            this.element.pause();
        }
        onRender() {
            if (!this._hasRequestVideoFrame || this._needUpdate) {
                LayaGL.textureContext.updateVideoTexture(this._texture, this.element, false, false);
                this._needUpdate = false;
                return true;
            }
            else
                return false;
        }
        onDestroy() {
            HTMLVideoPlayer.setSrc(this.element, null);
            this.element.remove();
            if (LayaEnv.isConch)
                this.element._destroy();
        }
    }

    class WebAudioChannel extends SoundChannel {
        get duration() {
            if (this._buffer)
                return this._buffer.duration;
            else
                return 0;
        }
        onPlay(url) {
            PAL.media.audioDataCache.get(url, this.onLoaded, this);
        }
        onPlayAgain() {
            this.reset();
            this.startPlay(false);
        }
        onStop() {
            this.reset();
            this._buffer = null;
        }
        onPause() {
            this.reset();
        }
        onResume() {
            this.startPlay(true);
        }
        onVolumeChanged() {
            if (!this._sourceNode)
                return;
            let volume = this._muted ? 0 : this._volume;
            if (this._gainNode.gain.setTargetAtTime)
                this._gainNode.gain.setTargetAtTime(volume, PAL.media.audioCtx.currentTime, 0.001);
            else
                this._gainNode.gain.value = volume;
        }
        onMuted() {
            this.onVolumeChanged();
        }
        onLoaded(buffer) {
            if (!this._started)
                return;
            this._buffer = buffer;
            if (!buffer || this.startTime >= this.duration) {
                this.stop();
                return;
            }
            this._loaded = true;
            if (this._paused)
                return;
            this.startPlay(false);
        }
        startPlay(isResuming) {
            let ctx = PAL.media.audioCtx;
            this._gainNode = WebAudioChannel.gainNodePool.take();
            let sourceNode = this._sourceNode = ctx.createBufferSource();
            sourceNode.buffer = this._buffer;
            sourceNode.connect(this._gainNode);
            sourceNode.onended = () => this.onPlayEnd();
            if (sourceNode.playbackRate) {
                if (sourceNode.playbackRate.setTargetAtTime)
                    sourceNode.playbackRate.setTargetAtTime(this.playbackRate, ctx.currentTime, 0.001);
                else
                    sourceNode.playbackRate.value = this.playbackRate;
            }
            sourceNode.loop = this.loops === 0;
            sourceNode.loopStart = this.startTime;
            sourceNode.loopEnd = this._buffer.duration;
            this._gainNode.gain.value = this._muted ? 0 : this._volume;
            sourceNode.start(0, isResuming ? this._pauseTime : this.startTime);
            if (ctx.state != null && ctx.state !== "running") {
                this._startTime = 0;
                PAL.media.resumeUntilGotFocus(this);
            }
            else
                this._startTime = Browser.now();
        }
        reset() {
            if (!this._sourceNode)
                return;
            let sourceNode = this._sourceNode;
            if (sourceNode.stop)
                sourceNode.stop(0);
            else
                sourceNode.noteOff(0);
            sourceNode.disconnect(0);
            sourceNode.onended = null;
            this._sourceNode = null;
            WebAudioChannel.gainNodePool.recover(this._gainNode);
            this._gainNode = null;
        }
    }
    WebAudioChannel.gainNodePool = Pool.createPool2(() => createGainNode(), node => initGainNode(node), node => resetGainNode(node));
    function createGainNode() {
        let node;
        if (PAL.media.audioCtx.createGain)
            node = PAL.media.audioCtx.createGain();
        else
            node = PAL.media.audioCtx.createGainNode();
        return node;
    }
    function initGainNode(node) {
        node.connect(PAL.media.audioCtx.destination);
    }
    function resetGainNode(node) {
        node.disconnect(0);
    }

    class LocalStorage {
        static setItem(key, value) {
            PAL.storage.setItem(key, value);
        }
        static getItem(key) {
            return PAL.storage.getItem(key);
        }
        static setJSON(key, value) {
            PAL.storage.setItem(key, JSON.stringify(value));
        }
        static getJSON(key) {
            return JSON.parse(PAL.storage.getItem(key));
        }
        static removeItem(key) {
            PAL.storage.removeItem(key);
        }
        static clear() {
            PAL.storage.clear();
        }
        static get count() {
            return PAL.storage.getCount();
        }
    }

    class Socket extends EventDispatcher {
        constructor(host, port, byteClass, protocols, isSecure) {
            super();
            this.disableInput = false;
            if (Array.isArray(byteClass))
                protocols = byteClass;
            if (typeof (protocols) === "boolean") {
                isSecure = protocols;
                protocols = null;
            }
            this.output = new Byte();
            this.input = new Byte();
            this.endian = Byte.BIG_ENDIAN;
            if (host && port > 0 && port < 65535)
                this.connect(host, port, isSecure, protocols);
        }
        get connected() {
            return this._connected;
        }
        get endian() {
            return this.output.endian;
        }
        set endian(value) {
            this.input.endian = value;
            this.output.endian = value;
        }
        connect(host, port, isSecure, options) {
            this.connectByUrl(`${isSecure ? "wss" : "ws"}://${host}:${port}`, options);
        }
        connectByUrl(url, options) {
            if (this._socket != null)
                this.close();
            this.output.length = 0;
            this.input.length = 0;
            this._inputPos = 0;
            if (Array.isArray(options)) {
                options = { protocols: options };
            }
            this._socket = PAL.browser.createWebSocket();
            this._socket.onOpen = () => {
                this._connected = true;
                this.event(Event.OPEN);
            };
            this._socket.onClose = () => {
                this._connected = false;
                this.event(Event.CLOSE);
            };
            this._socket.onError = (e) => {
                if (this.hasListener(Event.ERROR))
                    this.event(Event.ERROR, e);
                else
                    console.error("Socket Error: " + getErrorMsg(e));
            };
            this._socket.onMessage = (msg) => this._onMessage(msg);
            this._socket.open(url, options);
        }
        close() {
            if (this._socket != null) {
                try {
                    this._socket.close();
                }
                catch (e) {
                }
                this._socket = null;
            }
            this._connected = false;
        }
        cleanSocket() {
            this.close();
        }
        send(data) {
            return this._socket.send(data);
        }
        flush() {
            if (this.output.length === 0 || !this._socket || !this._connected)
                return;
            let err;
            try {
                this._socket.send(this.output.rawBuffer.slice(0, this.output.length));
            }
            catch (e) {
                err = e;
            }
            this.output.clear();
            if (err)
                this.event(Event.ERROR, err);
        }
        _onMessage(data) {
            if (this.disableInput) {
                this.event(Event.MESSAGE, data);
                return;
            }
            if (this.input.length > 0 && this.input.bytesAvailable < 1) {
                this.input.clear();
                this._inputPos = 0;
            }
            let pre = this.input.pos;
            !this._inputPos && (this._inputPos = 0);
            this.input.pos = this._inputPos;
            if (typeof (data) == 'string') {
                this.input.writeUTFBytes(data);
            }
            else {
                this.input.writeArrayBuffer(data);
            }
            this._inputPos = this.input.pos;
            this.input.pos = pre;
            this.event(Event.MESSAGE, data);
        }
    }

    class _WebSocket {
        open(url, options) {
            let protocols = options === null || options === void 0 ? void 0 : options.protocols;
            if (!protocols || protocols.length == 0)
                this.ws = new Browser.window.WebSocket(url);
            else
                this.ws = new Browser.window.WebSocket(url, protocols);
            this.ws.binaryType = "arraybuffer";
            this.ws.onopen = e => this.onOpen({});
            this.ws.onclose = e => this.onClose();
            this.ws.onerror = err => this.onError(err);
            this.ws.onmessage = msg => {
                if (msg.data)
                    this.onMessage(msg.data);
            };
        }
        close() {
            this.ws.close();
        }
        send(data) {
            this.ws.send(data);
            return Promise.resolve();
        }
    }

    class BinHashUtils {
        static getHash(buffer, start, len, magic = 9191891) {
            var i;
            var rst = 0;
            for (i = 0; i < len; i++) {
                rst = (rst * 2 + buffer[start + i]) % magic;
            }
            return rst;
        }
        static isSame(buffer1, start1, len1, buffer2, start2, len2) {
            if (len1 != len2)
                return false;
            var i, len;
            len = len1;
            for (i = 0; i < len; i++) {
                if (buffer1[start1 + i] != buffer2[start2 + i])
                    return false;
            }
            return true;
        }
    }

    class JsonBinRead {
        static get instance() {
            return JsonBinRead._instance || (JsonBinRead._instance = new JsonBinRead());
        }
        static IsJsonbin(data) {
            if (data.byteLength < 5)
                return false;
            const value = (new Uint32Array(data, 0, 4))[0];
            return value == JsonBinRead.ISJSONBIN || value == JsonBinRead.ISJSONBIN2 || value == JsonBinRead.ISJSONBIN3;
        }
        static parse(value) {
            var int32 = new Int32Array(value, 0, 4);
            if (int32[0] !== JsonBinRead.ISJSONBIN && int32[0] !== JsonBinRead.ISJSONBIN2) {
                var b = new Byte();
                b.writeArrayBuffer(value);
                b.pos = 0;
                var str = b.readUTFBytes();
                return JSON.parse(str);
            }
            var r = new JsonBinRead();
            return r.read(value);
        }
        static parsePack(value) {
            var r = new JsonBinRead();
            var o = r.read(value);
            for (var key in o)
                Loader.cacheRes(key, o[key]);
            return o;
        }
        constructor() {
        }
        _readArray(data, pos, n, type, keyMap) {
            var array = [];
            array.length = n;
            var endPos;
            if (pos >= 0) {
                endPos = data.pos;
                data.pos = pos;
            }
            for (var i = 0; i < n; i++) {
                array[i] = this._readOne({}, data, null, data.readUint8(), keyMap);
            }
            if (pos >= 0) {
                data.pos = endPos;
            }
            return array;
        }
        _getLen(data) {
            let n = data.readUint8();
            return (n & 0x80) == 0 ? n : (data.readUint8() | ((n & ~0x80) << 8));
        }
        static _toLargeNumber(n1, n2) {
            let n2str = n2.toString(16);
            if (n2str.length < 7) {
                for (let i = n2str.length; i < 7; i++)
                    n2str = "0" + n2str;
            }
            return parseInt(n1.toString(16) + "" + n2str, 16);
        }
        static readInt8Array(byte, start, len) {
            var end = start + len;
            end = (end > byte._length) ? byte._length : end;
            var v = new Int8Array(byte._d_.buffer.slice(start, end));
            byte._pos_ = end;
            return v;
        }
        _readOne(parent, data, key, type, keyMap) {
            let n, value;
            switch (type) {
                case JsonBinRead.NULL:
                    value = null;
                    break;
                case JsonBinRead.NUM8:
                    value = data.readByte();
                    break;
                case JsonBinRead.NUM16:
                    value = data.readInt16();
                    break;
                case JsonBinRead.NUM32:
                    value = data.readInt32();
                    break;
                case JsonBinRead.NUM64:
                    value = JsonBinRead._toLargeNumber(data.readInt32(), data.readInt32());
                    break;
                case JsonBinRead.BOOLEAN:
                    value = data.readByte() ? true : false;
                    break;
                case JsonBinRead.DOUBLE:
                    value = data.readFloat32();
                    break;
                case JsonBinRead.NUM16_1000:
                    value = data.readInt16() / 1000;
                    break;
                case JsonBinRead.NUM32_1000:
                    value = data.readInt32() / 1000;
                    break;
                case JsonBinRead.STRING:
                    value = keyMap.keyArray[data.readUint16()][0];
                    break;
                case JsonBinRead.WORDTEXT:
                    n = data.readUint16();
                    value = keyMap.keyArray[n][3];
                    if (!value) {
                        value = keyMap.keyArray[n][3] = new WordText$1();
                        value.setText(keyMap.keyArray[n][0]);
                    }
                    break;
                case JsonBinRead.ARRAYEMPTY:
                    data.readUint8();
                    value = [];
                    break;
                case JsonBinRead.ARRAYNUM8:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readByte();
                    break;
                case JsonBinRead.ARRAYNUM16:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readInt16();
                    break;
                case JsonBinRead.ARRAYNUM32:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readInt32();
                    break;
                case JsonBinRead.ARRAYDOUBLE:
                    value = [];
                    value.length = n = data.readUint8();
                    for (let i = 0; i < n; i++)
                        value[i] = data.readFloat32();
                    break;
                case JsonBinRead.ARRAYBUFFER:
                    value = data.readArrayBuffer(data.readUint16());
                    break;
                case JsonBinRead.ARRAYBUFFER32:
                    value = data.readArrayBuffer(data.readUint32());
                    break;
                case JsonBinRead.INT8ARRAY:
                    n = this._getLen(data);
                    value = JsonBinRead.readInt8Array(data, data.pos, n);
                    break;
                case JsonBinRead.UINT8ARRAY:
                    n = this._getLen(data);
                    value = data.readUint8Array(data.pos, n);
                    break;
                case JsonBinRead.INT16ARRAY:
                    n = this._getLen(data);
                    value = data.readInt16Array(data.pos, n);
                    break;
                case JsonBinRead.FLOAT32ARRAY:
                    n = this._getLen(data);
                    value = data.readFloat32Array(data.pos, n);
                    break;
                default:
                    return this._readOne_other(parent, data, key, type, keyMap);
            }
            parent && key && (parent[key] = value);
            return value;
        }
        _readOne_other(parent, data, key, type, keyMap) {
            let cur = parent;
            let value;
            let n, i;
            let pos;
            switch (type) {
                case JsonBinRead.ARRAY8:
                case JsonBinRead.ARRAY16:
                case JsonBinRead.ARRAY32:
                    switch (type) {
                        case JsonBinRead.ARRAY8:
                            n = data.readUint8();
                            break;
                        case JsonBinRead.ARRAY16:
                            n = data.readInt16();
                            break;
                        case JsonBinRead.ARRAY32:
                            n = data.readUint32();
                            break;
                    }
                    var array = value = [];
                    array.length = n;
                    for (i = 0; i < n; i++) {
                        type = data.readUint8();
                        array[i] = this._readOne(null, data, null, type, keyMap);
                    }
                    break;
                case JsonBinRead.ARRAYREFSOURCE8:
                case JsonBinRead.ARRAYREFSOURCE16:
                    n = type === JsonBinRead.ARRAYREFSOURCE8 ? data.readUint8() : data.readInt16();
                    pos = data.pos - this._dataStartOfs;
                    value = this._readArray(data, -1, n, type, keyMap);
                    this._objectRef[pos] = { array: value, pos: pos };
                    break;
                case JsonBinRead.ARRAYREF:
                case JsonBinRead.ARRAYREF32:
                    i = data.readByte();
                    pos = type == JsonBinRead.ARRAYREF ? data.readUint16() : data.readUint32();
                    let objectRef = this._objectRef[pos];
                    if (!objectRef) {
                        throw "load ref err";
                    }
                    if (i == JsonBinRead.COMPRESS_NEW) {
                        value = this._readArray(data, pos + this._dataStartOfs, objectRef.array.length, type, keyMap);
                    }
                    else
                        value = objectRef.array;
                    break;
                case JsonBinRead.OBJECT:
                case JsonBinRead.OBJECTTHISCLASS:
                    if (key != null || !parent) {
                        if (type == JsonBinRead.OBJECT) {
                            cur = {};
                        }
                        else {
                            n = data.readUint16();
                            cur = this._createObjWithClass(keyMap.keyArray[n][0]);
                            if (!cur)
                                throw "jsonbin read err,no this class:" + keyMap.keyArray[n][0];
                        }
                        key && parent && (parent[key] = cur);
                    }
                    let keyDef;
                    while (true) {
                        n = data.readUint16();
                        if (n == JsonBinRead.OBJECTEND)
                            break;
                        keyDef = keyMap.keyArray[n];
                        this._readOne(cur, data, keyDef[0], keyDef[1], keyMap);
                    }
                    value = cur;
                    cur = parent;
                    break;
            }
            (key != null) && (cur[key] = value);
            return value;
        }
        read(data, createObjWithClass = null) {
            this._createObjWithClass = createObjWithClass;
            let time = Browser.now();
            let bData = new Byte();
            let strMap;
            let binMark;
            bData.writeArrayBuffer(data);
            bData.pos = 0;
            this._objectRef = {};
            binMark = bData.readInt32();
            switch (binMark) {
                case JsonBinRead.ISJSONBIN:
                    strMap = bData.readUTFString();
                    break;
                case JsonBinRead.ISJSONBIN2:
                case JsonBinRead.ISJSONBIN3:
                    strMap = bData.readUTFString32();
                    break;
                default:
                    bData.pos = 0;
                    return null;
            }
            var keyMap = new ReadKeyMap();
            keyMap.strs = strMap.split(JsonBinRead.SPLITCHAR);
            keyMap.keyArray.length = keyMap.strs.length / 2;
            for (var i = 0, n = keyMap.strs.length; i < n; i += 2) {
                keyMap.keyArray[i / 2] = [keyMap.strs[i], parseInt(keyMap.strs[i + 1])];
            }
            let time2 = Browser.now();
            this._dataStartOfs = bData.pos;
            var r = {};
            this._readOne(r, bData, null, JsonBinRead.OBJECT, keyMap);
            if ((Browser.now() - time) > 10)
                console.debug("jsonbinread delay:", (Browser.now() - time) + "/" + (time2 - time), data.byteLength);
            return binMark == JsonBinRead.ISJSONBIN3 ? r.top : r;
        }
    }
    JsonBinRead.ISJSONBIN = 0xFFFFFF;
    JsonBinRead.ISJSONBIN2 = 0xFFFFFE;
    JsonBinRead.ISJSONBIN3 = 0xFFFFFD;
    JsonBinRead.SPLITCHAR = String.fromCharCode(3);
    JsonBinRead.COMPRESS_NEW = 1;
    JsonBinRead.COMPRESS_REF = 2;
    JsonBinRead.COMPRESS_REFMODIFY = 3;
    JsonBinRead.NUM8 = 0;
    JsonBinRead.NUM16 = 1;
    JsonBinRead.NUM32 = 2;
    JsonBinRead.BOOLEAN = 3;
    JsonBinRead.DOUBLE = 4;
    JsonBinRead.STRING = 5;
    JsonBinRead.ARRAY8 = 6;
    JsonBinRead.ARRAY16 = 7;
    JsonBinRead.ARRAYEMPTY = 8;
    JsonBinRead.ARRAYNUM8 = 9;
    JsonBinRead.ARRAYNUM16 = 10;
    JsonBinRead.ARRAYNUM32 = 11;
    JsonBinRead.ARRAYDOUBLE = 12;
    JsonBinRead.ARRAYSTRING = 13;
    JsonBinRead.NULL = 14;
    JsonBinRead.OBJECT = 15;
    JsonBinRead.NUM16_1000 = 16;
    JsonBinRead.NUM32_1000 = 17;
    JsonBinRead.WORDTEXT = 18;
    JsonBinRead.ARRAYBUFFER = 19;
    JsonBinRead.ARRAYREF = 20;
    JsonBinRead.ARRAYREFSOURCE8 = 21;
    JsonBinRead.ARRAYREFSOURCE16 = 22;
    JsonBinRead.ARRAYBUFFER32 = 23;
    JsonBinRead.ARRAYREF32 = 24;
    JsonBinRead.ARRAY32 = 25;
    JsonBinRead.OBJECTTHISCLASS = 26;
    JsonBinRead.NUM64 = 27;
    JsonBinRead.INT8ARRAY = 28;
    JsonBinRead.UINT8ARRAY = 29;
    JsonBinRead.INT16ARRAY = 30;
    JsonBinRead.FLOAT32ARRAY = 31;
    JsonBinRead.OBJECTEND = 0x7FFF;
    class ReadKeyMap {
        constructor() {
            this.keys = {};
            this.strs = ["BEGIN", 0];
            this.keyArray = [];
            this.keyIndex = 1;
        }
    }

    class JsonBinWrite {
        static get instance() {
            return JsonBinWrite._instance || (JsonBinWrite._instance = new JsonBinWrite());
        }
        constructor() {
            this.objectRef = {};
            this.deep = 0;
        }
        _saveKey(key, valueType, keyMap, out) {
            this.deep++;
            var keysv = key + "/&&__*?/" + valueType;
            var keyNum = keyMap.keys[keysv];
            if (!keyNum) {
                keyNum = keyMap.keys[keysv] = keyMap.keyIndex;
                keyMap.strs.push(key, valueType);
                keyMap.keyIndex++;
            }
            out.writeUint16(keyNum);
            this.deep--;
        }
        _getValueArrayType(value) {
            switch (typeof (value)) {
                case "number":
                    if (Math.floor(value) !== value)
                        return JsonBinRead.ARRAYDOUBLE;
                    var valueabs = Math.abs(value);
                    if (valueabs < 128)
                        return JsonBinRead.ARRAYNUM8;
                    if (valueabs < 0x7FFF)
                        return JsonBinRead.ARRAYNUM16;
                    return JsonBinRead.ARRAYNUM32;
                case "string":
                    return JsonBinRead.OBJECT;
                case "boolean":
                    return JsonBinRead.BOOLEAN;
            }
            return JsonBinRead.OBJECT;
        }
        _writeStrOrWordText(keyMap, key, value, out, isWordText) {
            var type = isWordText ? JsonBinRead.WORDTEXT : JsonBinRead.STRING;
            (key != null) ? (this._saveKey(key, type, keyMap, out)) : (out.writeUint8(type));
            var keyNum = keyMap.keys[value];
            if (!keyNum) {
                keyNum = keyMap.keys[value] = keyMap.keyIndex;
                keyMap.strs.push(value, 0);
                keyMap.keyIndex++;
            }
            out.writeUint16(keyNum);
        }
        _writeString(keyMap, value, out) {
            var keyNum = keyMap.keys[value];
            if (!keyNum) {
                keyNum = keyMap.keys[value] = keyMap.keyIndex;
                keyMap.strs.push(value, 0);
                keyMap.keyIndex++;
            }
            out.writeUint16(keyNum);
        }
        _getObjectTypeof(value) {
            if (value instanceof ArrayBuffer)
                return "ArrayBuffer";
            if (value instanceof Uint8Array)
                return "Uint8Array";
            if (value instanceof Int8Array)
                return "Int8Array";
            if (value instanceof Int16Array)
                return "Int16Array";
            if (value instanceof Float32Array)
                return "Float32Array";
            if ((value instanceof WordText) || JsonBinWrite.isWordText(value))
                return "WordText";
            return "object";
        }
        static isWordText(o) {
            return o && o._text && (o._$_$ISWORDTYEXT || o.lastGCCnt != null);
        }
        _writeLen(out, len) {
            if (len < 0x80)
                out.writeUint8(len);
            else if (len < 0x8000) {
                out.writeUint8((len >> 8) | 0x80);
                out.writeUint8(len & 0xFF);
            }
            else
                throw "jsonbin save len must<0x8000" + " " + len;
        }
        _writeBigNumber(out, value) {
            let numstr = value.toString(16);
            let n1 = parseInt(numstr.substring(0, numstr.length - 7), 16);
            let n2 = parseInt(numstr.substring(numstr.length - 7), 16);
            out.writeInt32(n1);
            out.writeInt32(n2);
            if (JsonBinRead._toLargeNumber(n1, n2) != value)
                throw "save big number err:" + value;
        }
        _writeOne(out, keyMap, key, value, parent) {
            if (value == undefined) {
                return false;
            }
            let type = typeof (value);
            if (type == "object" && value) {
                if (value.$__$disbaleJsonBinSv) {
                    if (value.$__$disbaleJsonBinSv == JsonBinWrite.NOSAVETHISOBJ_DELETE) ;
                    return false;
                }
                type = this._getObjectTypeof(value);
            }
            switch (type) {
                case "number":
                    if (Math.floor(value) !== value) {
                        var value1000 = value * 1000;
                        if ((value1000 | 0) === value1000) {
                            if (Math.abs(value) < 32) {
                                (key != null) ? this._saveKey(key, JsonBinRead.NUM16_1000, keyMap, out) : out.writeUint8(JsonBinRead.NUM16_1000);
                                out.writeInt16(value1000);
                                return true;
                            }
                            if (Math.abs(value) < 2147483) {
                                (key != null) ? this._saveKey(key, JsonBinRead.NUM32_1000, keyMap, out) : out.writeUint8(JsonBinRead.NUM32_1000);
                                out.writeInt32(value1000);
                                return true;
                            }
                        }
                        (key != null) ? this._saveKey(key, JsonBinRead.DOUBLE, keyMap, out) : out.writeUint8(JsonBinRead.DOUBLE);
                        out.writeFloat32(value);
                        return true;
                    }
                    var valueabs = Math.abs(value);
                    if (valueabs < 128) {
                        (key != null) ? this._saveKey(key, JsonBinRead.NUM8, keyMap, out) : out.writeUint8(JsonBinRead.NUM8);
                        out.writeByte(value);
                        return true;
                    }
                    if (valueabs < 0x7FFF) {
                        (key != null) ? this._saveKey(key, JsonBinRead.NUM16, keyMap, out) : out.writeUint8(JsonBinRead.NUM16);
                        out.writeInt16(value);
                        return true;
                    }
                    if (valueabs < 0x7FFFFFFF) {
                        (key != null) ? this._saveKey(key, JsonBinRead.NUM32, keyMap, out) : out.writeUint8(JsonBinRead.NUM32);
                        out.writeInt32(value);
                        return true;
                    }
                    (key != null) ? this._saveKey(key, JsonBinRead.NUM64, keyMap, out) : out.writeUint8(JsonBinRead.NUM64);
                    this._writeBigNumber(out, value);
                    return true;
                case "string":
                    this._writeStrOrWordText(keyMap, key, value, out, false);
                    return true;
                case "boolean":
                    (key != null) ? this._saveKey(key, JsonBinRead.BOOLEAN, keyMap, out) : out.writeUint8(JsonBinRead.BOOLEAN);
                    out.writeByte(value ? 1 : 0);
                    return true;
                case 'ArrayBuffer':
                    (key != null) ? this._saveKey(key, JsonBinRead.ARRAYBUFFER32, keyMap, out) : out.writeUint8(JsonBinRead.ARRAYBUFFER32);
                    out.writeUint32(value.byteLength);
                    out.writeArrayBuffer(value);
                    return true;
                case 'Uint8Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.UINT8ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.UINT8ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'Int8Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.INT8ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.INT8ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'Int16Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.INT16ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.INT16ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'Float32Array':
                    (key != null) ? this._saveKey(key, JsonBinRead.FLOAT32ARRAY, keyMap, out) : out.writeUint8(JsonBinRead.FLOAT32ARRAY);
                    this._writeLen(out, value.byteLength);
                    out.writeArrayBuffer(value.buffer);
                    return true;
                case 'WordText':
                    this._writeStrOrWordText(keyMap, key, value._text, out, true);
                    return true;
                case "object":
                    break;
                default:
                    throw "jsonbin no this type:" + type;
            }
            if (!value) {
                (key != null) ? this._saveKey(key, JsonBinRead.NULL, keyMap, out) : out.writeUint8(JsonBinRead.NULL);
                return true;
            }
            if (!(value instanceof Array)) {
                if (this._classEnable_ && value.__CLASS__) {
                    (key != null) ? this._saveKey(key, JsonBinRead.OBJECTTHISCLASS, keyMap, out) : out.writeUint8(JsonBinRead.OBJECTTHISCLASS);
                }
                else
                    (key != null) ? this._saveKey(key, JsonBinRead.OBJECT, keyMap, out) : out.writeUint8(JsonBinRead.OBJECT);
                this._writeObject(out, keyMap, value);
                out.writeUint16(JsonBinRead.OBJECTEND);
                return true;
            }
            return this._saveArray(parent, out, keyMap, key, value);
        }
        _saveArray(parent, out, keyMap, key, value) {
            var j, n = value.length;
            if (n === 0) {
                (key != null) ? this._saveKey(key, JsonBinRead.ARRAYEMPTY, keyMap, out) : out.writeUint8(JsonBinRead.ARRAYEMPTY);
                out.writeByte(0);
                return true;
            }
            var startType;
            if (n > 1 && n < 250 && ((startType = this._getValueArrayType(value[0])) != JsonBinRead.OBJECT)) {
                for (j = 1; j < n; j++) {
                    if (startType !== this._getValueArrayType(value[j])) {
                        startType = JsonBinRead.OBJECT;
                        break;
                    }
                }
                if (startType != JsonBinRead.OBJECT && startType != JsonBinRead.BOOLEAN) {
                    (key != null) ? this._saveKey(key, startType, keyMap, out) : out.writeUint8(startType);
                    out.writeUint8(value.length);
                    switch (startType) {
                        case JsonBinRead.ARRAYNUM8:
                            for (j = 0; j < n; j++)
                                out.writeByte(value[j]);
                            break;
                        case JsonBinRead.ARRAYNUM16:
                            for (j = 0; j < n; j++)
                                out.writeInt16(value[j]);
                            break;
                        case JsonBinRead.ARRAYNUM32:
                            for (j = 0; j < n; j++)
                                out.writeInt32(value[j]);
                            break;
                        case JsonBinRead.ARRAYDOUBLE:
                            for (j = 0; j < n; j++)
                                out.writeFloat32(value[j]);
                            break;
                    }
                    return true;
                }
            }
            var typeArray;
            if (n < 250) {
                typeArray = JsonBinRead.ARRAY8;
            }
            else if (n < 32700) {
                typeArray = JsonBinRead.ARRAY16;
            }
            else {
                typeArray = JsonBinRead.ARRAY32;
            }
            var posHead = out.pos;
            (key != null) ? this._saveKey(key, typeArray, keyMap, out) : out.writeUint8(typeArray);
            var pos = out.pos, s = 0;
            switch (typeArray) {
                case JsonBinRead.ARRAY8:
                    out.writeUint8(n);
                    break;
                case JsonBinRead.ARRAY16:
                    out.writeInt16(n);
                    break;
                case JsonBinRead.ARRAY32:
                    out.writeUint32(n);
                    break;
            }
            var posData = out.pos;
            for (j = 0; j < n; j++) {
                if (this._writeOne(out, keyMap, null, value[j], parent))
                    s++;
            }
            if (s != n) {
                var tmp = out.pos;
                out.pos = pos;
                typeArray == JsonBinRead.ARRAY8 ? out.writeUint8(s) : out.writeInt16(s);
                out.pos = tmp;
            }
            var compress;
            if (key && parent && (compress = parent[JsonBinWrite.COMPRESS + key])) {
                this._useCompress(out, keyMap, key, value, posHead, posData, compress, typeArray);
            }
            return true;
        }
        _useCompress(out, keyMap, key, value, posHead, dataPos, compress, typeArray) {
            var dLen = out.pos - dataPos;
            var hashCode = BinHashUtils.getHash(out._u8d_, dataPos, dLen);
            var same;
            var src;
            var i, n;
            if (this.objectRef[hashCode]) {
                var datas = this.objectRef[hashCode];
                n = datas.length;
                for (i = 0; i < n; i++) {
                    src = datas[i];
                    if (src.value == value) {
                        same = src;
                        break;
                    }
                }
                if (!same) {
                    for (i = 0; i < n; i++) {
                        src = datas[i];
                        if (BinHashUtils.isSame(out._u8d_, src.pos, src.len, out._u8d_, dataPos, dLen)) {
                            same = src;
                            break;
                        }
                    }
                }
            }
            else
                this.objectRef[hashCode] = [];
            if (!same) {
                this.objectRef[hashCode].push({ hashCode: hashCode, pos: dataPos, len: dLen, value: value });
                out.pos = posHead;
                this._saveKey(key, typeArray == JsonBinRead.ARRAY8 ? JsonBinRead.ARRAYREFSOURCE8 : JsonBinRead.ARRAYREFSOURCE16, keyMap, out);
                out.pos = dataPos + dLen;
            }
            else {
                out.pos = posHead;
                this._saveKey(key, JsonBinRead.ARRAYREF32, keyMap, out);
                out.writeByte(compress);
                out.writeUint32(same.pos);
            }
        }
        _writeObject(out, keyMap, o) {
            this._classEnable_ && o.__CLASS__ && this._writeString(keyMap, o.__CLASS__, out);
            for (var key in o) {
                if (key && key.length > JsonBinWrite.NOSAVE_KEY_LEN && key.substr(0, JsonBinWrite.NOSAVE_KEY_LEN) == JsonBinWrite.NOSAVEKEY) {
                    continue;
                }
                (this._classEnable_ && key == "__CLASS__") || this._writeOne(out, keyMap, key, o[key], o);
            }
        }
        write(o, __CLASS__ = false) {
            this.deep = 0;
            this._classEnable_ = __CLASS__;
            var keyMap = new SaveKeyMap();
            this.objectRef = {};
            var out = new Byte();
            this._writeObject(out, keyMap, { top: o });
            out.writeUint16(JsonBinRead.OBJECTEND);
            var r = new Byte();
            r.writeInt32(JsonBinRead.ISJSONBIN3);
            r.writeUTFString32(keyMap.strs.join(JsonBinRead.SPLITCHAR));
            r.writeArrayBuffer(out.buffer);
            return r.buffer;
        }
    }
    JsonBinWrite.COMPRESS = "_$TeMpkEy$_CoMpReSs";
    JsonBinWrite.NOSAVEKEY = "_$TeMpkEyNoSv$_";
    JsonBinWrite.NOSAVETHISOBJ = "$__$disbaleJsonBinSv";
    JsonBinWrite.NOSAVE_KEY_LEN = 15;
    JsonBinWrite.NOSAVETHISOBJ_DELETE = 2;
    JsonBinWrite.NOSAVETHISOBJ_TRUE = 1;
    class SaveKeyMap {
        constructor() {
            this.keys = {};
            this.strs = ["BEGIN", 0];
            this.keyArray = [];
            this.keyIndex = 1;
        }
    }

    class BrowserAdapter extends EventDispatcher {
        constructor() {
            super();
            this._pixelRatio = 1;
            this.init();
            this.initRequestFrameFunction();
        }
        init() {
            var _a;
            let doc = Browser.document;
            let win = Browser.window;
            this._pixelRatio = Math.max(1, (win.devicePixelRatio || 1));
            this.setPlatform(win.navigator.userAgent || "", win.navigator.platform || "");
            let state = "visibilityState", visibilityChange = "visibilitychange";
            let fullscreenchange = "fullscreenchange";
            if (typeof doc.hidden !== "undefined") {
                visibilityChange = "visibilitychange";
                state = "visibilityState";
                fullscreenchange = "fullscreenchange";
            }
            else if (typeof doc.mozHidden !== "undefined") {
                visibilityChange = "mozvisibilitychange";
                state = "mozVisibilityState";
                fullscreenchange = "mozfullscreenchange";
            }
            else if (typeof doc.msHidden !== "undefined") {
                visibilityChange = "msvisibilitychange";
                state = "msVisibilityState";
                fullscreenchange = "msfullscreenchange";
            }
            else if (typeof doc.webkitHidden !== "undefined") {
                visibilityChange = "webkitvisibilitychange";
                state = "webkitVisibilityState";
                fullscreenchange = "webkitfullscreenchange";
            }
            this._visibilityStateKey = state;
            doc.addEventListener(visibilityChange, () => this.event(Event.VISIBILITY_CHANGE, this.getVisibility()));
            doc.addEventListener(fullscreenchange, () => this.event(Event.FULL_SCREEN_CHANGE));
            win.addEventListener("resize", () => this.event(Event.RESIZE));
            win.addEventListener("orientationchange", (e) => this.event(Event.ORIENTATION_CHANGE, e));
            win.addEventListener("focus", () => this.event(Event.FOCUS));
            win.addEventListener("blur", () => this.event(Event.BLUR));
            win.addEventListener("unhandledrejection", e => this.event("unhandledrejection", e));
            let bodyStyle = doc.body.style;
            bodyStyle.margin = 0;
            bodyStyle.overflow = 'hidden';
            bodyStyle['-webkit-user-select'] = 'none';
            bodyStyle['-webkit-tap-highlight-color'] = 'rgba(200,200,200,0)';
            let metas = doc.getElementsByTagName('meta');
            let viewportContent = {
                "width": "device-width",
                "initial-scale": "1.0",
                "minimum-scale": "1.0",
                "maximum-scale": "1.0",
                "user-scalable": "no"
            };
            let viewport;
            for (let i = 0; i < metas.length; i++) {
                let meta = metas[i];
                if (meta.name === "viewport") {
                    viewport = meta;
                    break;
                }
            }
            if (!viewport) {
                viewport = doc.createElement('meta');
                viewport.name = 'viewport';
                (_a = doc.getElementsByTagName('head')[0]) === null || _a === void 0 ? void 0 : _a.appendChild(viewport);
            }
            else {
                let arr = (viewport.content || "").split(",");
                for (let ele of arr) {
                    let arr2 = ele.split("=");
                    if (!viewportContent[arr2[0].trim()])
                        viewportContent[arr2[0]] = arr2[1];
                }
            }
            viewport.content = Object.keys(viewportContent).map(k => k + "=" + viewportContent[k]);
        }
        setPlatform(u, platform) {
            platform = platform.toLowerCase();
            Browser.userAgent = u;
            Browser.onMobile = u.indexOf("Mobile") > -1;
            Browser.onIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
            Browser.onIPhone = u.indexOf("iPhone") > -1;
            Browser.onMac = u.indexOf("Mac OS X") > -1;
            Browser.onIPad = u.indexOf("iPad") > -1;
            Browser.onAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
            Browser.onOpenHarmonyOS = u.indexOf('OpenHarmony') > -1;
            Browser.onWP = u.indexOf("Windows Phone") > -1;
            Browser.onQQBrowser = u.indexOf("QQBrowser") > -1;
            Browser.onMQQBrowser = u.indexOf("MQQBrowser") > -1 || (u.indexOf("Mobile") > -1 && u.indexOf("QQ") > -1);
            Browser.onIE = !!window.ActiveXObject || "ActiveXObject" in window;
            Browser.onWeiXin = u.indexOf('MicroMessenger') > -1;
            Browser.onSafari = u.indexOf("Safari") > -1 && u.indexOf("Chrome") === -1;
            Browser.onChrome = u.indexOf("Chrome") > -1;
            Browser.onFirefox = u.indexOf('Firefox') > -1;
            Browser.onEdge = u.indexOf('Edge') > -1 || u.indexOf('Edg') > -1;
            if (platform.indexOf("ios") !== -1) {
                Browser.onIOS = true;
                Browser.onMobile = true;
                if (!u) {
                    Browser.onIPhone = true;
                    Browser.onIPad = true;
                }
                Browser.platform = Browser.PLATFORM_IOS;
                Browser.platformName = "ios";
            }
            else if (platform.indexOf("android") !== -1) {
                Browser.onAndroid = true;
                Browser.onMobile = true;
                Browser.platform = Browser.PLATFORM_ANDROID;
                Browser.platformName = "android";
            }
            else if (platform.indexOf("ohos") !== -1) {
                Browser.onOpenHarmonyOS = true;
                Browser.onMobile = true;
                Browser.platform = Browser.PLATFORM_ANDROID;
                Browser.platformName = "ohos";
            }
            else if (platform.indexOf("mac") !== -1) {
                Browser.onMac = true;
                Browser.platform = Browser.PLATFORM_PC;
                Browser.platformName = "mac";
            }
            else if (platform.indexOf("win") !== -1) {
                Browser.platform = Browser.PLATFORM_PC;
                Browser.platformName = "windows";
            }
            else if (Browser.onAndroid) {
                Browser.platform = Browser.PLATFORM_ANDROID;
                Browser.platformName = "android";
            }
            else if (Browser.onIOS) {
                Browser.platform = Browser.PLATFORM_IOS;
                Browser.platformName = "ios";
            }
            else {
                Browser.platform = Browser.PLATFORM_PC;
                Browser.platformName = platform;
            }
            Browser.onPC = !Browser.onMobile;
            Browser.onDevTools = Browser.platformName === "devtools";
            Browser.isTouchDevice = true;
            if (u.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") != -1)
                this._pixelRatio = 2;
        }
        initRequestFrameFunction() {
            this.requestFrame = window.requestAnimationFrame
                || window.webkitRequestAnimationFrame
                || window.mozRequestAnimationFrame
                || window.oRequestAnimationFrame
                || window.msRequestAnimationFrame;
            if (!this.requestFrame)
                this.requestFrame = function (fun) {
                    return setTimeout(fun, 1000 / 60);
                };
        }
        start() {
            return Promise.resolve();
        }
        onInitRender() {
        }
        getScreenOrientation() {
            let ret = window.screen.orientation.type;
            if (ret == null) {
                let o = window.orientation;
                switch (o) {
                    case 0:
                        ret = "portrait-primary";
                        break;
                    case 180:
                        ret = "portrait-secondary";
                        break;
                    case 90:
                        ret = "landscape-primary";
                        break;
                    case -90:
                        ret = "landscape-secondary";
                        break;
                }
            }
            return ret;
        }
        getPixelRatio() {
            return this._pixelRatio;
        }
        getClientWidth() {
            return Browser.window.innerWidth || Browser.document.body.clientWidth || Browser.document.documentElement.clientWidth;
        }
        getClientHeight() {
            return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
        }
        getVisibility() {
            return Browser.document[this._visibilityStateKey] !== "hidden";
        }
        requestFullscreen() {
            let ele = Browser.document.documentElement;
            if (!ele)
                return;
            if (ele.requestFullscreen)
                ele.requestFullscreen();
            else if (ele.mozRequestFullScreen)
                ele.mozRequestFullScreen();
            else if (ele.webkitRequestFullscreen)
                ele.webkitRequestFullscreen();
            else if (ele.msRequestFullscreen)
                ele.msRequestFullscreen();
        }
        exitFullscreen() {
            let doc = document;
            if (doc.exitFullscreen)
                doc.exitFullscreen();
            else if (doc.mozCancelFullScreen)
                doc.mozCancelFullScreen();
            else if (doc.webkitExitFullscreen)
                doc.webkitExitFullscreen();
        }
        createElement(tagName) {
            return Browser.document.createElement(tagName);
        }
        createMainCanvas() {
            let canvas = this.createElement("canvas");
            canvas.id = "layaCanvas";
            canvas.width = 0;
            canvas.height = 0;
            let style = canvas.style;
            style.position = 'absolute';
            style.top = style.left = "0px";
            style.background = "#000000";
            let container = Browser.document.createElement("div");
            container.id = "layaContainer";
            Browser.document.body.appendChild(container);
            container.appendChild(canvas);
            return canvas;
        }
        setCursor(cursor) {
            Browser.document.body.style.cursor = cursor;
        }
        get supportArrayBufferURL() {
            return !!window.Blob;
        }
        createBufferURL(data) {
            if (window.Blob) {
                let blob = new Blob([data], { type: 'application/octet-binary' });
                return window.URL.createObjectURL(blob);
            }
            else
                return null;
        }
        revokeBufferURL(url) {
            window.URL.revokeObjectURL(url);
        }
        getOpenDataContextCanvas() {
            return null;
        }
        postMessageToOpenDataContext(msg) {
        }
        captureGlobalError(callback) {
            this._globalErrorCallback = callback;
            this.onCaptureGlobalError(callback != null, onError);
        }
        onCaptureGlobalError(enabled, func) {
            if (enabled) {
                Browser.window.addEventListener("error", func);
                Browser.window.addEventListener("unhandledrejection", func);
            }
            else {
                Browser.window.removeEventListener("error", func);
                Browser.window.removeEventListener("unhandledrejection", func);
            }
        }
        alert(msg) {
            Browser.window.alert(msg);
        }
        setStyleTransformOrigin(style, value) {
            style.transformOrigin = style.webkitTransformOrigin
                = style.msTransformOrigin = style.mozTransformOrigin
                    = style.oTransformOrigin = value;
        }
        setStyleTransform(style, value) {
            style.transform = style.webkitTransform
                = style.msTransform = style.mozTransform
                    = style.oTransform = value;
        }
        createWebSocket() {
            return new (this.webSocketClass || _WebSocket)();
        }
    }
    function onError(e) {
        PAL.browser._globalErrorCallback(e);
    }
    PAL.register("browser", BrowserAdapter);

    class DeviceAdapter extends EventDispatcher {
        get supportedLocation() {
            return false;
        }
        get supportedGetUserMedia() {
            return false;
        }
        getCurrentPosition(successCallback, errorCallback, options) {
        }
        watchPosition(successCallback, errorCallback, options) {
            return -1;
        }
        clearWatchPosition(id) {
        }
        getUserMedia(constraints, successCallback, errorCallback) {
        }
        onStartListeningToType(type) {
            if (type === "devicemotion")
                this.startListeningDeviceMotion();
            else if (type === "deviceorientation")
                this.startListeningDeviceOrientation();
            return this;
        }
        startListeningDeviceMotion() {
        }
        startListeningDeviceOrientation() {
        }
    }
    PAL.register("device", DeviceAdapter);

    class FileSystemAdapter {
        readFile(path, encoding) {
            throw new NotImplementedError();
        }
        writeFile(path, data, encoding) {
            throw new NotImplementedError();
        }
        unlink(path) {
            throw new NotImplementedError();
        }
        copyFile(srcPath, destPath) {
            throw new NotImplementedError();
        }
        exists(path) {
            throw new NotImplementedError();
        }
        getFileSize(path) {
            throw new NotImplementedError();
        }
        mkdir(path, options) {
            throw new NotImplementedError();
        }
        rmdir(path, options) {
            throw new NotImplementedError();
        }
        readdir(path) {
            throw new NotImplementedError();
        }
        unzip(zipFilePath, targetPath) {
            throw new NotImplementedError();
        }
    }
    PAL.register("fs", FileSystemAdapter);

    class FontAdapter {
        loadFont(task) {
            let fontName = Utils.replaceFileExtension(Utils.getBaseName(task.url), "");
            let url = URL.postFormatURL(URL.formatURL(task.url));
            if (Browser.window.FontFace)
                return this.loadByFontFace(task, url, fontName);
            else
                return this.loadByCSS(task, url, fontName);
        }
        loadByFontFace(task, url, fontName) {
            let fontFace = new Browser.window.FontFace(fontName, "url('" + url + "')");
            Browser.document.fonts.add(fontFace);
            return fontFace.load().then(() => {
                return fontFace;
            });
        }
        loadByCSS(task, url, fontName) {
            let fontTxt = "40px " + fontName;
            Browser.context.font = fontTxt;
            let oldWidth = Browser.context.measureText(testString).width;
            let fontStyle = Browser.createElement("style");
            fontStyle.type = "text/css";
            Browser.document.body.appendChild(fontStyle);
            fontStyle.textContent = "@font-face { font-family:'" + fontName + "'; src:url('" + url + "');}";
            return new Promise((resolve) => {
                let checkComplete = () => {
                    Browser.context.font = fontTxt;
                    let newWidth = Browser.context.measureText(testString).width;
                    if (newWidth != oldWidth)
                        complete();
                };
                let complete = () => {
                    ILaya.systemTimer.clear(this, checkComplete);
                    ILaya.systemTimer.clear(this, complete);
                    resolve({ family: fontName });
                };
                ILaya.systemTimer.once(10000, this, complete);
                ILaya.systemTimer.loop(20, this, checkComplete);
            });
        }
    }
    const testString = "LayaTTFFont";
    PAL.register("font", FontAdapter);

    class MediaAdapter {
        constructor() {
            this.touchToStart = true;
            this._firstTouch = true;
            this.audioDataCache = new AudioDataCache();
            this.suspendedMedias = new Set();
            this.touchToStart = PAL.g == null;
            this.init();
        }
        init() {
            let ctxClass = window.AudioContext || window["webkitAudioContext"] || window["mozAudioContext"];
            if (ctxClass != null)
                this.audioCtx = new ctxClass();
            this.shortAudioClass = this.audioCtx ? WebAudioChannel : HTMLAudioChannel;
            this.longAudioClass = HTMLAudioChannel;
            this.videoTextureClass = HTMLVideoTexture;
            this.videoPlayerClass = HTMLVideoPlayer;
        }
        createSoundChannel(url, longAudioUsage) {
            return longAudioUsage ? new this.longAudioClass(url) : new this.shortAudioClass(url);
        }
        createVideoTexture() {
            if (this.videoTextureClass == null) {
                PAL.warnIncompatibility("VideoTexture");
                return new VideoTexture();
            }
            else
                return new this.videoTextureClass();
        }
        createVideoPlayer() {
            if (this.videoPlayerClass == null) {
                PAL.warnIncompatibility("VideoPlayer");
                return new VideoPlayer();
            }
            else
                return new this.videoPlayerClass();
        }
        decodeAudioData(data) {
            if (this.audioCtx)
                return this.audioCtx.decodeAudioData(data);
            else
                return Promise.resolve(null);
        }
        resumeUntilGotFocus(media) {
            if (this.suspendedMedias.size === 0) {
                ILaya.stage.on(Event.MOUSE_UP, this, this.onGotFocus);
                if (!this._firstTouch || !this.touchToStart)
                    ILaya.stage.on(Event.FOCUS, this, this.onGotFocus);
            }
            this.suspendedMedias.add(media);
            media.pause();
            media._autoResume = true;
        }
        canPlayType(type) {
            if (typeof (HTMLAudioElement) !== undefined && typeof (HTMLAudioElement.prototype.canPlayType) === "function") {
                if (!this._testElement)
                    this._testElement = Browser.createElement("audio");
                return this._testElement.canPlayType(type);
            }
            else
                return "";
        }
        onGotFocus() {
            this._firstTouch = false;
            ILaya.stage.off(Event.MOUSE_UP, this, this.onGotFocus);
            ILaya.stage.off(Event.FOCUS, this, this.onGotFocus);
            if (this.suspendedMedias.size === 0)
                return;
            let arr = Array.from(this.suspendedMedias).filter(c => c._autoResume);
            this.suspendedMedias.clear();
            this.beforeResumeMedias(arr).then(() => {
                for (let medias of arr) {
                    medias._autoResume = false;
                    medias.resume();
                }
            });
        }
        beforeResumeMedias(medias) {
            let checkCtx = false;
            for (let channel of medias) {
                if (channel instanceof WebAudioChannel && !checkCtx) {
                    checkCtx = true;
                    if (this.audioCtx.state === "suspended") {
                        return this.audioCtx.resume().catch(e => { });
                    }
                }
            }
            return Promise.resolve();
        }
    }
    PAL.register("media", MediaAdapter);

    class StorageAdapter {
        constructor() {
            this._supported = this.checkSupport();
        }
        checkSupport() {
            try {
                this._storage = Browser.window.localStorage;
                this._storage.setItem('laya', '1');
                this._storage.removeItem('laya');
                return true;
            }
            catch (e) {
                console.log('LocalStorage is not supprot or browser is private mode.');
                return false;
            }
        }
        getItem(key) {
            if (this._supported)
                return this._storage.getItem(key);
            else
                return null;
        }
        setItem(key, value) {
            this._supported && this._storage.setItem(key, value);
        }
        removeItem(key) {
            this._supported && this._storage.removeItem(key);
        }
        clear() {
            this._supported && this._storage.clear();
        }
        getCount() {
            if (this._supported)
                return this._storage.length || 0;
            else
                return 0;
        }
    }
    PAL.register("storage", StorageAdapter);

    class TextInputAdapter {
        constructor() {
            this._beginFlag = 0;
            this._editInline = true;
            this._enterEvent = new Event();
            this._lastTransform = {};
            Laya.addAfterInitCallback(() => {
                ILaya.stage.on(Event.MOUSE_UP, this, this.onTouchEnd);
                InputManager.onMouseDownCapture.add(this.onTouchBegin, this);
            });
        }
        begin(target, fromTouchBegin) {
            if (this.target === target || this._beginFlag !== 0)
                return Promise.resolve();
            this._beginFlag = 1;
            return (this.target ? this.end(false, this.target.editable) : Promise.resolve()).then(() => {
                this.target = target;
                ILaya.stage.focus = target;
                this.updateRestrictPattern();
                this._lastTransform.x = null;
                target.on(Event.UNDISPLAY, this, this.end);
                return this.onBegin().catch(e => {
                    console.error("TextInputAdapter begin error:", e);
                });
            }).then(() => {
                if (this._editInline) {
                    this.target.hideText(true);
                    ILaya.stage.on(Event.KEY_DOWN, this, this.onKeyDown);
                }
                target.event(Event.FOCUS);
            }).then(() => {
                if (!fromTouchBegin) {
                    this._beginFlag = 0;
                    return this.onCanShowKeyboard().catch(e => {
                        console.error("TextInputAdapter begin error:", e);
                    });
                }
                else {
                    this._beginFlag = 2;
                    return Promise.resolve();
                }
            });
        }
        end(complete, switching) {
            let target = this.target;
            if (!target)
                return Promise.resolve();
            this.target = null;
            ILaya.stage.focus = null;
            target.off(Event.UNDISPLAY, this, this.end);
            if (this._editInline)
                ILaya.stage.off(Event.KEY_DOWN, this, this.onKeyDown);
            return this.onEnd(target, !!complete, !!switching).then(() => {
                if (this._editInline)
                    target.hideText(false);
                if (target.editable)
                    target.event(Event.CHANGE);
                target.event(Event.BLUR);
            }).catch(e => {
                console.error("TextInputAdapter end error:", e);
            });
        }
        onBegin() {
            this.showInputElement();
            let ele = this._visEle;
            let target = this.target;
            if (ele instanceof HTMLInputElement)
                ele.type = this.target.type;
            ele.readOnly = !target.editable;
            ele.maxLength = target.maxChars <= 0 ? 1E5 : target.maxChars;
            ele.value = this.target.text;
            ele.placeholder = target.prompt;
            let style = ele.style;
            style.fontFamily = target.realFont;
            style.color = target.color;
            style.fontSize = target.fontSize + 'px';
            style.whiteSpace = (target.wordWrap ? "pre-wrap" : "nowrap");
            style.lineHeight = (target.leading + target.fontSize) + "px";
            style.fontStyle = (target.italic ? "italic" : "normal");
            style.fontWeight = (target.bold ? "bold" : "normal");
            style.textAlign = target.align;
            style.padding = "0 0";
            style.direction = Text.RightToLeft ? "rtl" : "";
            this.setPromptColor();
            this.syncTransform();
            if (this._editInline)
                ILaya.systemTimer.frameLoop(1, this, this.syncTransform);
            return Promise.resolve();
        }
        onCanShowKeyboard() {
            if (this._visEle)
                this._visEle.focus();
            return Promise.resolve();
        }
        onEnd(target, complete, switching) {
            Browser.document.body.scrollTop = 0;
            target.text = this._visEle.value;
            this._visEle.blur();
            this.hideInputElement();
            this._visEle = null;
            if (this._editInline)
                ILaya.systemTimer.clear(this, this.syncTransform);
            return Promise.resolve();
        }
        syncText() {
            if (this._visEle && this._beginFlag === 0)
                this.updateTargetText(this._visEle.value);
        }
        setText(value) {
            if (this._visEle)
                this._visEle.value = value;
        }
        setSelection(startIndex, endIndex) {
            if (this._visEle) {
                this._visEle.selectionStart = startIndex;
                this._visEle.selectionEnd = endIndex;
            }
        }
        onTouchBegin() {
            let lastFocus = ILaya.stage.focus;
            let touchTarget = InputManager.touchTarget;
            if (lastFocus != touchTarget) {
                if (touchTarget instanceof Input)
                    this.begin(touchTarget, true);
                else if (lastFocus instanceof Input)
                    this.end();
            }
        }
        onTouchEnd() {
            if (this._beginFlag !== 0) {
                if (this._beginFlag === 1) {
                    ILaya.systemTimer.frameOnce(1, this, this.onTouchEnd);
                }
                else {
                    this._beginFlag = 0;
                    this.onCanShowKeyboard().catch(e => {
                        console.error("TextInputAdapter begin error:", e);
                    });
                }
            }
        }
        setPromptColor() {
            this._promptStyleDOM = Browser.document.getElementById("promptStyle");
            if (!this._promptStyleDOM) {
                this._promptStyleDOM = Browser.document.createElement("style");
                this._promptStyleDOM.setAttribute("id", "promptStyle");
                Browser.document.head.appendChild(this._promptStyleDOM);
            }
            let color = this.target.promptColor;
            this._promptStyleDOM.innerText = `input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {
                color: ${color}
            }
            input:-moz-placeholder, textarea:-moz-placeholder {
                color: ${color}
            }
            input::-moz-placeholder, textarea::-moz-placeholder {
                color: ${color}
            }
            input:-ms-input-placeholder, textarea:-ms-input-placeholder {
                color: ${color}
            }
        `;
        }
        updateRestrictPattern() {
            let value = this.target.restrict;
            if (value) {
                value = "[^" + value + "]";
                if (value.indexOf("^^") > -1)
                    value = value.replace("^^", "");
                this._restrictPattern = new RegExp(value, "g");
            }
            else
                this._restrictPattern = null;
        }
        validateText(str) {
            if (str == null)
                str = "";
            if (!this.target.multiline)
                str = str.replace(/\r?\n/g, '');
            if (this._restrictPattern) {
                str = str.replace(/\u2006|\x27/g, "");
                if (this._restrictPattern.test(str)) {
                    str = str.replace(this._restrictPattern, "");
                }
            }
            return str;
        }
        showInputElement() {
            if (!this._eInput)
                this.createElements();
            let password = this.target.type === "password";
            let multiline = this.target.multiline && !password;
            let inputElement = (multiline ? this._eTextArea : password ? this._ePassword : this._eInput);
            this._visEle = inputElement;
            this._container.appendChild(inputElement);
        }
        hideInputElement() {
            if (this._visEle && this._visEle.parentElement)
                this._visEle.remove();
        }
        updateTargetText(value) {
            let target = this.target;
            this.target = null;
            let ret = target.text != value;
            target.text = value;
            this.target = target;
            return ret;
        }
        getTargetTransform() {
            let padding = this.target.padding;
            let { x, y, scaleX, scaleY } = SpriteUtils.getTransformRelativeToWindow(this.target, padding[3], padding[0]);
            let w = this.target.width - padding[1] - padding[3];
            let h = this.target.height - padding[0] - padding[2];
            let t = this._lastTransform;
            if (x !== t.x || y !== t.y || w !== t.width || h !== t.height || scaleX !== t.scaleX || scaleY !== t.scaleY) {
                t.x = x;
                t.y = y;
                t.width = w;
                t.height = h;
                t.scaleX = scaleX;
                t.scaleY = scaleY;
                return t;
            }
            else
                return null;
        }
        syncTransform() {
            let t = this.getTargetTransform();
            if (t != null) {
                let style = this._visEle.style;
                style.width = t.width + 'px';
                style.height = t.height + 'px';
                PAL.browser.setStyleTransform(style, "scale(" + t.scaleX + "," + t.scaleY + ") rotate(" + (ILaya.stage.canvasDegree) + "deg)");
                this._container.style.left = t.x + 'px';
                this._container.style.top = t.y + 'px';
            }
        }
        createElements() {
            this._container = Browser.document.createElement("div");
            Browser.container.appendChild(this._container);
            let style = this._container.style;
            style.position = "absolute";
            style.zIndex = '1E5';
            this.initElement(this._eTextArea = Browser.document.createElement("textarea"));
            this.initElement(this._eInput = Browser.document.createElement("input"));
            this.initElement(this._ePassword = Browser.document.createElement("input"));
        }
        initElement(input) {
            let style = input.style;
            style.cssText = "position:absolute;overflow:hidden;resize:none;";
            style.resize = 'none';
            style.backgroundColor = 'transparent';
            style.border = 'none';
            style.outline = 'none';
            style.zIndex = '1';
            PAL.browser.setStyleTransformOrigin(style, "0 0");
            input.addEventListener('input', ev => !ev.isComposing && this.processInputting(ev));
            input.addEventListener("compositionend", ev => this.processInputting(ev));
            input.addEventListener('mousemove', ev => this.stopEvent(ev), { passive: false });
            input.addEventListener('mousedown', ev => this.stopEvent(ev), { passive: false });
            input.addEventListener('touchmove', ev => this.stopEvent(ev), { passive: false });
        }
        processInputting(ev) {
            if (!this.target)
                return;
            let ele = ev.target;
            let value = this.validateText(ele.value);
            ele.value = value;
            if (this.updateTargetText(value))
                this.target.event(Event.INPUT);
        }
        stopEvent(e) {
            if (e.type == 'touchmove')
                e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }
        onKeyDown(e) {
            if (e.key === "Enter" || e.key === "NumpadEnter") {
                let target = this.target;
                if (!target.multiline) {
                    e.preventDefault();
                    this._enterEvent.setTo(Event.ENTER, this.target, this.target);
                    target.event(Event.ENTER, this._enterEvent);
                    if (!this._enterEvent._defaultPrevented && this.target === target)
                        this.end();
                }
            }
        }
    }
    PAL.register("textInput", TextInputAdapter);

    class RenderTextureCube extends RenderTexture {
        constructor(size, colorFormat, depthFormat, generateMipmap, multiSamples) {
            super(size, size, colorFormat, depthFormat, generateMipmap, multiSamples);
            this.faceIndex = 0;
        }
        _createRenderTarget() {
            this._dimension = exports.TextureDimension.Cube;
            this._renderTarget = LayaGL.textureContext.createRenderTargetCubeInternal(this.width, this._format, this._depthStencilFormat, this._generateMipmap, this._gammaSpace, this._multiSamples);
            this._texture = this._renderTarget._textures[0];
        }
    }

    class Texture3D extends BaseTexture {
        static get defaultTexture() {
            return this._defaultTexture;
        }
        static __init__() {
            if (LayaGL.renderEngine.getCapable(exports.RenderCapable.Texture3D)) {
                this._defaultTexture = new Texture3D(1, 1, 1, exports.TextureFormat.R8G8B8A8, false, false);
                this._defaultTexture.lock = true;
                this._defaultTexture.setPixelsData(new Uint8Array([255, 255, 255, 255]));
            }
        }
        constructor(width, height, depth, format, mipmap = true, sRGB = false) {
            super(width, height, format);
            this._dimension = exports.TextureDimension.Tex3D;
            this.depth = depth;
            this._gammaSpace = sRGB;
            let context = LayaGL.textureContext;
            this._texture = context.createTexture3DInternal(this._dimension, width, height, depth, format, mipmap, sRGB, false);
        }
        setPixelsData(source) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DPixelsData(texture, source, this.depth, false, false);
        }
        setSubPixelsData(xOffset, yOffset, zOffset, width, height, depth, pixels, mipmapLevel, generateMipmap) {
            let texture = this._texture;
            let context = LayaGL.textureContext;
            context.setTexture3DSubPixelsData(texture, pixels, mipmapLevel, generateMipmap, xOffset, yOffset, zOffset, width, height, depth, false, false);
        }
    }

    class WebGLRTMgr {
        static getRT(w, h) {
            w = w | 0;
            h = h | 0;
            if (w >= 10000) {
                console.error('getRT error! w too big');
            }
            var ret;
            ret = new RenderTexture2D(w, h, exports.RenderTargetFormat.R8G8B8A8, exports.RenderTargetFormat.None);
            return ret;
        }
        static releaseRT(rt) {
            rt.destroy();
            return;
        }
    }
    WebGLRTMgr.dict = {};

    class PerfTools {
        static begin(block) {
        }
        static end(block) {
        }
    }
    class PerformanceDefine {
    }
    window.PerformanceDefine = PerformanceDefine;
    function PERF_BEGIN(block) {
        PerfTools.begin(block);
    }
    window.PERF_BEGIN = PERF_BEGIN;
    function PERF_END(block) {
        PerfTools.end(block);
    }
    window.PERF_BEGIN = PERF_END;
    function PERF_FRAMECLEAR() {
    }
    window.PERF_FRAMECLEAR = PERF_FRAMECLEAR;

    exports.CurveType = void 0;
    (function (CurveType) {
        CurveType[CurveType["CRSpline"] = 0] = "CRSpline";
        CurveType[CurveType["Bezier"] = 1] = "Bezier";
        CurveType[CurveType["CubicBezier"] = 2] = "CubicBezier";
        CurveType[CurveType["Straight"] = 3] = "Straight";
    })(exports.CurveType || (exports.CurveType = {}));
    class PathPoint {
        constructor() {
            this.pos = new Vector3();
            this.c1 = new Vector3();
            this.c2 = new Vector3();
            this.curve = 0;
        }
        static create(x, y, z, curve) {
            let pt = pool$1.take();
            pt.pos.set(x, y, z);
            pt.curve = curve || 0;
            return pt;
        }
        recover() {
            pool$1.recover(this);
        }
        clone() {
            let pt = pool$1.take();
            this.pos.cloneTo(pt.pos);
            this.c1.cloneTo(pt.c1);
            this.c2.cloneTo(pt.c2);
            pt.curve = this.curve;
            return pt;
        }
        _reset() {
            this.pos.set(0, 0, 0);
            this.c1.set(0, 0, 0);
            this.c2.set(0, 0, 0);
            this.curve = 0;
        }
    }
    const pool$1 = Pool.createPool(PathPoint, null, e => e._reset());

    class CurvePath {
        constructor() {
            this._segments = [];
            this._points = [];
            this._curPt = new Vector3();
        }
        get length() {
            return this._fullLength;
        }
        create(...points) {
            this._segments.length = 0;
            let pts = this._points;
            pool.recover(this._points);
            this._fullLength = 0;
            this._cacheT = null;
            let cnt = points.length;
            if (cnt == 0)
                return;
            let splinePoints = [];
            let prev = points[0];
            if (prev.curve == exports.CurveType.CRSpline)
                splinePoints.push(prev.pos.cloneTo(pool.take()));
            for (let i = 1; i < cnt; i++) {
                let current = points[i];
                if (prev.curve != exports.CurveType.CRSpline) {
                    let seg = {};
                    seg.type = prev.curve;
                    seg.ptStart = pts.length;
                    if (prev.curve == exports.CurveType.Straight) {
                        seg.ptCount = 2;
                        pts.push(prev.pos.cloneTo(pool.take()));
                        pts.push(current.pos.cloneTo(pool.take()));
                    }
                    else if (prev.curve == exports.CurveType.Bezier) {
                        seg.ptCount = 3;
                        pts.push(prev.pos.cloneTo(pool.take()));
                        pts.push(current.pos.cloneTo(pool.take()));
                        pts.push(prev.c1.cloneTo(pool.take()));
                    }
                    else if (prev.curve == exports.CurveType.CubicBezier) {
                        seg.ptCount = 4;
                        pts.push(prev.pos.cloneTo(pool.take()));
                        pts.push(current.pos.cloneTo(pool.take()));
                        pts.push(prev.c1.cloneTo(pool.take()));
                        pts.push(prev.c2.cloneTo(pool.take()));
                    }
                    seg.length = Vector3.distance(prev.pos, current.pos);
                    this._fullLength += seg.length;
                    this._segments.push(seg);
                }
                if (current.curve != exports.CurveType.CRSpline) {
                    if (splinePoints.length > 0) {
                        splinePoints.push(current.pos.cloneTo(pool.take()));
                        this.createSplineSegment(splinePoints);
                    }
                }
                else
                    splinePoints.push(current.pos.cloneTo(pool.take()));
                prev = current;
            }
            if (splinePoints.length > 1)
                this.createSplineSegment(splinePoints);
        }
        createSplineSegment(splinePoints) {
            let cnt = splinePoints.length;
            splinePoints.splice(0, 0, splinePoints[0]);
            splinePoints.push(splinePoints[cnt]);
            splinePoints.push(splinePoints[cnt]);
            cnt += 3;
            let seg = {};
            seg.type = exports.CurveType.CRSpline;
            seg.ptStart = this._points.length;
            seg.ptCount = cnt;
            this._points = this._points.concat(splinePoints);
            seg.length = 0;
            for (let i = 1; i < cnt; i++) {
                seg.length += Vector3.distance(splinePoints[i - 1], splinePoints[i]);
            }
            this._fullLength += seg.length;
            this._segments.push(seg);
            splinePoints.length = 0;
        }
        clear() {
            this._segments.length = 0;
            this._points.length = 0;
        }
        getPointAt(t) {
            let out = this._curPt;
            t = MathUtil.clamp01(t);
            if (t === this._cacheT)
                return out;
            out.set(0, 0, 0);
            this._cacheT = t;
            let cnt = this._segments.length;
            if (cnt == 0) {
                return out;
            }
            let pts = this._points;
            if (t == 1) {
                let seg = this._segments[cnt - 1];
                if (seg.type == exports.CurveType.Straight)
                    Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t, out);
                else if (seg.type == exports.CurveType.Bezier || seg.type == exports.CurveType.CubicBezier)
                    this.onBezierCurve(seg.ptStart, seg.ptCount, t, out);
                else
                    this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, out);
                return out;
            }
            for (let i = 0, len = t * this._fullLength; i < cnt; i++) {
                let seg = this._segments[i];
                len -= seg.length;
                if (len < 0) {
                    t = 1 + len / seg.length;
                    if (seg.type == exports.CurveType.Straight)
                        Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t, out);
                    else if (seg.type == exports.CurveType.Bezier || seg.type == exports.CurveType.CubicBezier)
                        this.onBezierCurve(seg.ptStart, seg.ptCount, t, out);
                    else
                        this.onCRSplineCurve(seg.ptStart, seg.ptCount, t, out);
                    break;
                }
            }
            return out;
        }
        get segmentCount() {
            return this._segments.length;
        }
        getAnchorsInSegment(segmentIndex, out) {
            if (out == null)
                out = [];
            let pts = this._points;
            let seg = this._segments[segmentIndex];
            for (let i = 0; i < seg.ptCount; i++)
                out.push(pts[seg.ptStart + i]);
            return out;
        }
        getPointsInSegment(segmentIndex, t0, t1, outPoints, outTs, pointDensity) {
            if (outPoints == null)
                outPoints = [];
            if (!pointDensity || isNaN(pointDensity))
                pointDensity = 0.1;
            let pts = this._points;
            if (outTs)
                outTs.push(t0);
            let seg = this._segments[segmentIndex];
            if (seg.type == exports.CurveType.Straight) {
                let v = new Vector3();
                Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t0, v);
                outPoints.push(v);
                v = new Vector3();
                Vector3.lerp(pts[seg.ptStart], pts[seg.ptStart + 1], t1, v);
                outPoints.push(v);
            }
            else {
                let func;
                if (seg.type == exports.CurveType.Bezier || seg.type == exports.CurveType.CubicBezier)
                    func = this.onBezierCurve;
                else
                    func = this.onCRSplineCurve;
                outPoints.push(func.call(this, seg.ptStart, seg.ptCount, t0, new Vector3()));
                let SmoothAmount = Math.min(seg.length * pointDensity, 50);
                for (let j = 0; j <= SmoothAmount; j++) {
                    let t = j / SmoothAmount;
                    if (t > t0 && t < t1) {
                        outPoints.push(func.call(this, seg.ptStart, seg.ptCount, t, new Vector3()));
                        if (outTs)
                            outTs.push(t);
                    }
                }
                outPoints.push(func.call(this, seg.ptStart, seg.ptCount, t1, new Vector3()));
            }
            if (outTs)
                outTs.push(t1);
            return outPoints;
        }
        getAllPoints(out, outTs, pointDensity) {
            if (out == null)
                out = [];
            if (!pointDensity || isNaN(pointDensity))
                pointDensity = 0.1;
            for (let i = 0, cnt = this._segments.length; i < cnt; i++)
                this.getPointsInSegment(i, 0, 1, out, outTs, pointDensity);
            return out;
        }
        onCRSplineCurve(ptStart, ptCount, t, out) {
            let adjustedIndex = Math.floor(t * (ptCount - 4)) + ptStart;
            let pts = this._points;
            let p0 = pts[adjustedIndex];
            let p1 = pts[adjustedIndex + 1];
            let p2 = pts[adjustedIndex + 2];
            let p3 = pts[adjustedIndex + 3];
            let adjustedT = (t == 1) ? 1 : MathUtil.repeat(t * (ptCount - 4), 1);
            let t0 = ((-adjustedT + 2) * adjustedT - 1) * adjustedT * 0.5;
            let t1 = (((3 * adjustedT - 5) * adjustedT) * adjustedT + 2) * 0.5;
            let t2 = ((-3 * adjustedT + 4) * adjustedT + 1) * adjustedT * 0.5;
            let t3 = ((adjustedT - 1) * adjustedT * adjustedT) * 0.5;
            out.x = p0.x * t0 + p1.x * t1 + p2.x * t2 + p3.x * t3;
            out.y = p0.y * t0 + p1.y * t1 + p2.y * t2 + p3.y * t3;
            out.z = p0.z * t0 + p1.z * t1 + p2.z * t2 + p3.z * t3;
            return out;
        }
        onBezierCurve(ptStart, ptCount, t, out) {
            let t2 = 1 - t;
            let pts = this._points;
            let p0 = pts[ptStart];
            let p1 = pts[ptStart + 1];
            let cp0 = pts[ptStart + 2];
            if (ptCount == 4) {
                let cp1 = pts[ptStart + 3];
                Vector3.add(p0.scale(t2 * t2 * t2, tmpVec3), cp0.scale(3 * t2 * t2 * t, tmpVec31), tmpVec3);
                Vector3.add(cp1.scale(3 * t2 * t * t, tmpVec3), p1.scale(t * t * t, tmpVec31), tmpVec31);
                Vector3.add(tmpVec3, tmpVec31, out);
            }
            else {
                Vector3.add(p0.scale(t2 * t2, tmpVec3), cp0.scale(2 * t2 * t, tmpVec31), tmpVec3);
                Vector3.add(tmpVec3, p1.scale(t * t, tmpVec31), out);
            }
            return out;
        }
    }
    const tmpVec3 = new Vector3();
    const tmpVec31 = new Vector3();
    const pool = Pool.createPool(Vector3, null, e => e.set(0, 0, 0));

    class TimeLine extends EventDispatcher {
        constructor() {
            super(...arguments);
            this._tweenDic = [];
            this._tweenDataList = [];
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this._firstTweenDic = {};
            this._startTimeSort = false;
            this._endTimeSort = false;
            this._loopKey = false;
            this.scale = 1;
            this._frameRate = 60;
            this._frameIndex = 0;
            this._total = 0;
        }
        static to(target, props, duration, ease = null, offset = 0) {
            return new TimeLine().to(target, props, duration, ease, offset);
        }
        static from(target, props, duration, ease = null, offset = 0) {
            return new TimeLine().from(target, props, duration, ease, offset);
        }
        to(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, true);
        }
        from(target, props, duration, ease = null, offset = 0) {
            return this._create(target, props, duration, ease, offset, false);
        }
        _create(target, props, duration, ease, offset, isTo) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.isTo = isTo;
            tTweenData.type = 0;
            tTweenData.target = target;
            tTweenData.duration = duration;
            tTweenData.data = props;
            tTweenData.startTime = this._startTime + offset;
            tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
            tTweenData.ease = ease;
            this._startTime = Math.max(tTweenData.endTime, this._startTime);
            this._tweenDataList.push(tTweenData);
            this._startTimeSort = true;
            this._endTimeSort = true;
            return this;
        }
        addLabel(label, offset) {
            var tTweenData = Pool.getItemByClass("tweenData", tweenData);
            tTweenData.type = 1;
            tTweenData.data = label;
            tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
            this._labelDic || (this._labelDic = {});
            this._labelDic[label] = tTweenData;
            this._tweenDataList.push(tTweenData);
            return this;
        }
        removeLabel(label) {
            if (this._labelDic && this._labelDic[label]) {
                var tTweenData = this._labelDic[label];
                if (tTweenData) {
                    var tIndex = this._tweenDataList.indexOf(tTweenData);
                    if (tIndex > -1) {
                        this._tweenDataList.splice(tIndex, 1);
                    }
                }
                delete this._labelDic[label];
            }
        }
        gotoTime(time) {
            if (this._tweenDataList == null || this._tweenDataList.length == 0)
                return;
            for (let p in this._firstTweenDic) {
                let tObject = this._firstTweenDic[p];
                if (tObject) {
                    for (let tDataP in tObject) {
                        if (tDataP in tObject.diyTarget) {
                            tObject.diyTarget[tDataP] = tObject[tDataP];
                        }
                    }
                }
            }
            for (let p of this._tweenDic)
                Tween.kill(p);
            this._tweenDic.length = 0;
            this._index = 0;
            this._currTime = time;
            this._lastTime = Browser.now();
            var tTweenDataCopyList;
            if (this._endTweenDataList == null || this._endTimeSort) {
                this._endTimeSort = false;
                this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
                function Compare(paraA, paraB) {
                    if (paraA.endTime > paraB.endTime) {
                        return 1;
                    }
                    else if (paraA.endTime < paraB.endTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                tTweenDataCopyList.sort(Compare);
            }
            else {
                tTweenDataCopyList = this._endTweenDataList;
            }
            var tTweenData;
            for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
                tTweenData = tTweenDataCopyList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        var props = tTweenData.data;
                        if (tTweenData.isTo) {
                            for (var tP in props) {
                                tTweenData.target[tP] = props[tP];
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            for (i = 0, n = this._tweenDataList.length; i < n; i++) {
                tTweenData = this._tweenDataList[i];
                if (tTweenData.type == 0) {
                    if (time >= tTweenData.startTime && time < tTweenData.endTime) {
                        this._index = Math.max(this._index, i + 1);
                        let tTween;
                        if (tTweenData.isTo)
                            tTween = Tween.to(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        else
                            tTween = Tween.from(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        this._tweenDic.push(tTween);
                    }
                }
            }
        }
        gotoLabel(Label) {
            if (this._labelDic == null)
                return;
            var tLabelData = this._labelDic[Label];
            if (tLabelData)
                this.gotoTime(tLabelData.startTime);
        }
        pause() {
            ILaya.timer.clear(this, this._update);
        }
        resume() {
            this.play(this._currTime, this._loopKey);
        }
        play(timeOrLabel = 0, loop = false) {
            if (!this._tweenDataList)
                return;
            if (this._startTimeSort) {
                this._startTimeSort = false;
                function Compare(paraA, paraB) {
                    if (paraA.startTime > paraB.startTime) {
                        return 1;
                    }
                    else if (paraA.startTime < paraB.startTime) {
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                this._tweenDataList.sort(Compare);
                for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
                    var tTweenData = this._tweenDataList[i];
                    if (tTweenData != null && tTweenData.type == 0) {
                        var tTarget = tTweenData.target;
                        var gid = Utils.getGID(tTarget);
                        var tSrcData = null;
                        if (this._firstTweenDic[gid] == null) {
                            tSrcData = {};
                            tSrcData.diyTarget = tTarget;
                            this._firstTweenDic[gid] = tSrcData;
                        }
                        else {
                            tSrcData = this._firstTweenDic[gid];
                        }
                        for (var p in tTweenData.data) {
                            if (tSrcData[p] == null) {
                                tSrcData[p] = tTarget[p];
                            }
                        }
                    }
                }
            }
            if (typeof (timeOrLabel) == 'string') {
                this.gotoLabel(timeOrLabel);
            }
            else {
                this.gotoTime(timeOrLabel);
            }
            this._loopKey = loop;
            this._lastTime = Browser.now();
            ILaya.timer.frameLoop(1, this, this._update);
        }
        _update() {
            if (this._currTime >= this._startTime) {
                if (this._loopKey) {
                    this._complete();
                    if (!this._tweenDataList)
                        return;
                    this.gotoTime(0);
                }
                else {
                    for (let p of this._tweenDic)
                        p.complete();
                    this.pause();
                    this._complete();
                    return;
                }
            }
            var tNow = Browser.now();
            var tFrameTime = tNow - this._lastTime;
            var tCurrTime = this._currTime += tFrameTime * this.scale;
            this._lastTime = tNow;
            if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
                var tTweenData = this._tweenDataList[this._index];
                if (tCurrTime >= tTweenData.startTime) {
                    this._index++;
                    if (tTweenData.type == 0) {
                        let tTween;
                        if (tTweenData.isTo)
                            tTween = Tween.to(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        else
                            tTween = Tween.from(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete));
                        this._tweenDic.push(tTween);
                    }
                    else {
                        this.event(Event.LABEL, tTweenData.data);
                    }
                }
            }
        }
        _animComplete(tweener) {
            let i = this._tweenDic.indexOf(tweener.owner);
            if (i > -1)
                this._tweenDic.splice(i, 1);
        }
        _complete() {
            this.event(Event.COMPLETE);
        }
        get index() {
            return this._frameIndex;
        }
        set index(value) {
            this._frameIndex = value;
            this.gotoTime(this._frameIndex / this._frameRate * 1000);
        }
        get total() {
            this._total = Math.floor(this._startTime / 1000 * this._frameRate);
            return this._total;
        }
        reset() {
            var p;
            if (this._labelDic) {
                for (p in this._labelDic) {
                    delete this._labelDic[p];
                }
            }
            for (let p of this._tweenDic)
                Tween.kill(p);
            this._tweenDic.length = 0;
            for (p in this._firstTweenDic) {
                delete this._firstTweenDic[p];
            }
            this._endTweenDataList = null;
            if (this._tweenDataList && this._tweenDataList.length) {
                var i, len;
                len = this._tweenDataList.length;
                for (i = 0; i < len; i++) {
                    if (this._tweenDataList[i])
                        this._tweenDataList[i].destroy();
                }
            }
            this._tweenDataList.length = 0;
            this._currTime = 0;
            this._lastTime = 0;
            this._startTime = 0;
            this._index = 0;
            this.scale = 1;
            ILaya.timer.clear(this, this._update);
        }
        destroy() {
            this.reset();
            this._labelDic = null;
            this._tweenDic = null;
            this._tweenDataList = null;
            this._firstTweenDic = null;
        }
    }
    class tweenData {
        constructor() {
            this.type = 0;
            this.isTo = true;
        }
        destroy() {
            this.target = null;
            this.ease = null;
            this.data = null;
            this.isTo = true;
            this.type = 0;
            Pool.recover("tweenData", this);
        }
    }

    class Base64Tool {
        static init() {
            if (Base64Tool.lookup)
                return;
            Base64Tool.lookup = new Uint8Array(256);
            for (var i = 0; i < Base64Tool.chars.length; i++) {
                Base64Tool.lookup[Base64Tool.chars.charCodeAt(i)] = i;
            }
        }
        static isBase64String(str) {
            return Base64Tool.reg.test(str);
        }
        static encode(arraybuffer) {
            var bytes = new Uint8Array(arraybuffer), i, len = bytes["length"], base64 = "";
            for (i = 0; i < len; i += 3) {
                base64 += Base64Tool.chars[bytes[i] >> 2];
                base64 += Base64Tool.chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += Base64Tool.chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += Base64Tool.chars[bytes[i + 2] & 63];
            }
            if ((len % 3) === 2) {
                base64 = base64.substring(0, base64.length - 1) + "=";
            }
            else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + "==";
            }
            return base64;
        }
        static decode(base64) {
            Base64Tool.init();
            var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
            if (base64[base64.length - 1] === "=") {
                bufferLength--;
                if (base64[base64.length - 2] === "=") {
                    bufferLength--;
                }
            }
            var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
            for (i = 0; i < len; i += 4) {
                encoded1 = Base64Tool.lookup[base64.charCodeAt(i)];
                encoded2 = Base64Tool.lookup[base64.charCodeAt(i + 1)];
                encoded3 = Base64Tool.lookup[base64.charCodeAt(i + 2)];
                encoded4 = Base64Tool.lookup[base64.charCodeAt(i + 3)];
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
                if (p + 1 > bufferLength)
                    continue;
                bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
            }
            return arraybuffer;
        }
    }
    Base64Tool.chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    Base64Tool.reg = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*?)\s*$/i;
    Base64Tool.reghead = /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,/i;
    Base64Tool.lookup = null;

    const _rect = new Rectangle();
    const _ptPoint = new Point();
    class HitArea {
        contains(x, y, sp) {
            if (!HitArea._isHitGraphic(x, y, sp, this._hit))
                return false;
            return !HitArea._isHitGraphic(x, y, sp, this._unHit);
        }
        static _isHitGraphic(x, y, sp, graphic) {
            if (!graphic)
                return false;
            let cmds = graphic.cmds;
            if (cmds.length == 0)
                return false;
            let len = cmds.length;
            for (let i = 0; i < len; i++) {
                let cmd = cmds[i];
                if (!cmd)
                    continue;
                switch (cmd.cmdID) {
                    case TranslateCmd.ID:
                        x -= cmd.tx;
                        y -= cmd.ty;
                }
                if (HitArea._isHitCmd(x, y, sp, cmd))
                    return true;
            }
            return false;
        }
        static _isHitCmd(x, y, sp, cmd) {
            if (!cmd)
                return false;
            var rst = false;
            switch (cmd.cmdID) {
                case "DrawRect":
                    if (cmd.percent)
                        _rect.setTo(cmd.x * sp.width, cmd.y * sp.height, cmd.width * sp.width, cmd.height * sp.height);
                    else
                        _rect.setTo(cmd.x, cmd.y, cmd.width, cmd.height);
                    rst = _rect.contains(x, y);
                    break;
                case "DrawCircle":
                    let r = cmd.radius;
                    var d;
                    if (cmd.percent) {
                        x -= cmd.x * sp.width;
                        y -= cmd.y * sp.height;
                        r *= sp.width;
                    }
                    else {
                        x -= cmd.x;
                        y -= cmd.y;
                    }
                    d = x * x + y * y;
                    rst = d < r * r;
                    break;
                case "DrawPoly":
                    x -= cmd.x;
                    y -= cmd.y;
                    rst = HitArea._ptInPolygon(x, y, cmd.points);
                    break;
            }
            return rst;
        }
        static _ptInPolygon(x, y, areaPoints) {
            var p = _ptPoint;
            p.setTo(x, y);
            var nCross = 0;
            var p1x, p1y, p2x, p2y;
            var len;
            len = areaPoints.length;
            for (var i = 0; i < len; i += 2) {
                p1x = areaPoints[i];
                p1y = areaPoints[i + 1];
                p2x = areaPoints[(i + 2) % len];
                p2y = areaPoints[(i + 3) % len];
                if (p1y == p2y)
                    continue;
                if (p.y < Math.min(p1y, p2y))
                    continue;
                if (p.y >= Math.max(p1y, p2y))
                    continue;
                var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
                if (tx > p.x)
                    nCross++;
            }
            return (nCross % 2 == 1);
        }
        get hit() {
            if (!this._hit)
                this._hit = new Graphics();
            return this._hit;
        }
        set hit(value) {
            this._hit = value;
        }
        get unHit() {
            if (!this._unHit)
                this._unHit = new Graphics();
            return this._unHit;
        }
        set unHit(value) {
            this._unHit = value;
        }
        onAfterDeserialize() {
            if (LayaEnv.isPlaying) {
                if (this._hitCmds) {
                    this.hit.cmds = this._hitCmds;
                    delete this._hitCmds;
                }
                if (this._unHitCmds) {
                    this.unHit.cmds = this._unHitCmds;
                    delete this._unHitCmds;
                }
            }
        }
    }
    ClassUtils.regClass("HitArea", HitArea);

    class Mouse {
        static set cursor(value) {
            this._cursor = value;
            if (this._hidden)
                return;
            PAL.browser.setCursor(value);
        }
        static get cursor() {
            return this._cursor;
        }
        static hide() {
            this._hidden = true;
            PAL.browser.setCursor("none");
        }
        static show() {
            this._hidden = false;
            PAL.browser.setCursor(this._cursor);
        }
    }
    Mouse._cursor = "auto";
    Mouse._hidden = false;

    class StatUI {
        constructor() {
            this._show = false;
        }
        createUI() {
            let sp = this._sp = new Sprite();
            sp.scale(Math.max(Laya.stage.clientScaleX, 1), Math.max(Laya.stage.clientScaleY, 1));
            Laya.stage.on(Event.RESIZE, this, () => {
                this._sp.scale(Math.max(Laya.stage.clientScaleX, 1), Math.max(Laya.stage.clientScaleY, 1));
            });
            let leftText = new Text();
            leftText.singleCharRender = true;
            leftText.pos(5, 5);
            leftText.color = "#ffffff";
            leftText.fontSize = fontSize;
            sp.addChild(leftText);
            strArray.length = 0;
            for (let one of this._view)
                strArray.push(one.title);
            leftText.text = strArray.join("\n");
            this._txt = new Text();
            this._txt.singleCharRender = true;
            this._txt.pos(leftText.textWidth + 10, 5);
            this._txt.color = "#ffffff";
            this._txt.fontSize = fontSize;
            sp.addChild(this._txt);
            sp.size(leftText.textWidth + 100, leftText.textHeight + 10);
            sp.graphics.clear();
            sp.graphics.alpha(0.5);
            sp.graphics.drawRect(0, 0, sp.width, sp.height, "#999999");
            sp.graphics.alpha(2);
        }
        show(x, y, views) {
            x = x || 0;
            y = y || 0;
            views = views || Stat.AllShow;
            this._view = views;
            this._show = true;
            if (!this._sp)
                this.createUI();
            this._sp.pos(x, y);
        }
        hide() {
            this._show = false;
        }
        update() {
            if (this._show) {
                strArray.length = 0;
                for (let i = 0; i < this._view.length; i++) {
                    let item = this._view[i];
                    let isAverage = item.mode == "average";
                    let value = Stat[item.value];
                    (item.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100);
                    (item.units == "K") && (value = Math.floor(value / (1024) * 100) / 100);
                    if (isAverage) {
                        value /= Stat._count;
                        value = Math.floor(value);
                    }
                    (item.units == "M") && (value += "M");
                    (item.units == "K") && (value += "K");
                    strArray.push(value);
                }
                this._txt.text = strArray.join("\n");
            }
        }
        render(ctx, x, y) {
            this._show && this._sp && this._sp.render(ctx, 0, 0);
        }
    }
    const fontSize = 16;
    const strArray = [];
    Stat._statUIClass = StatUI;

    class VertexStream {
        constructor() {
            this._vp = 0;
            this._ip = 0;
            this._epv = 0;
            this.contentRect = new Rectangle();
            this.uvRect = new Rectangle();
            this.color = new Color();
            this._epv = 9;
            this._vbuf = new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT * this._epv * 10);
            this._vertices = new Float32Array(this._vbuf);
            this._ibuf = new ArrayBuffer(Uint16Array.BYTES_PER_ELEMENT * 3 * 10);
            this._indices = new Uint16Array(this._ibuf);
            this._vec = new Vector3();
        }
        init(mainTex, hasColor) {
            this.mainTex = mainTex;
            if (mainTex) {
                let uv = mainTex.uvrect;
                if (mainTex.width === mainTex.sourceWidth && mainTex.height === mainTex.sourceHeight)
                    this.uvRect.setTo(uv[0], uv[1], uv[2], uv[3]);
                else {
                    let sx = uv[2] / mainTex.width;
                    let sy = uv[3] / mainTex.height;
                    this.uvRect.setTo(uv[0] - mainTex.offsetX * sx, uv[1] - mainTex.offsetY * sy, mainTex.sourceWidth * sx, mainTex.sourceHeight * sy);
                }
            }
            else
                this.uvRect.setTo(0, 0, 1, 1);
            this._epv = hasColor ? 9 : 5;
            this.color.setValue(1, 1, 1, 1);
            this._vp = 0;
            this._ip = 0;
        }
        addVert(x, y, z, color, u, v) {
            this.checkVBuf(this._epv);
            let arr = this._vertices;
            let idx = this._vp;
            this._vp += this._epv;
            arr[idx] = x;
            arr[idx + 1] = y;
            arr[idx + 2] = z;
            if (u != null)
                arr[idx + 3] = u;
            else
                arr[idx + 3] = MathUtil.lerp(this.uvRect.x, this.uvRect.right, (x - this.contentRect.x) / (this.contentRect.width || 1));
            if (v != null)
                arr[idx + 4] = v;
            else
                arr[idx + 4] = MathUtil.lerp(this.uvRect.y, this.uvRect.bottom, (y - this.contentRect.y) / (this.contentRect.height || 1));
            if (this._epv === 9)
                (color || this.color).writeTo(arr, idx + 5);
        }
        addQuad(rect, color, uvRect) {
            if (uvRect) {
                this.addVert(rect.x, rect.y, 0, color, uvRect.x, uvRect.y);
                this.addVert(rect.right, rect.y, 0, color, uvRect.right, uvRect.y);
                this.addVert(rect.right, rect.bottom, 0, color, uvRect.right, uvRect.bottom);
                this.addVert(rect.x, rect.bottom, 0, color, uvRect.x, uvRect.bottom);
            }
            else {
                this.addVert(rect.x, rect.y, 0, color);
                this.addVert(rect.right, rect.y, 0, color);
                this.addVert(rect.right, rect.bottom, 0, color);
                this.addVert(rect.x, rect.bottom, 0, color);
            }
        }
        addTriangle(idx0, idx1, idx2) {
            this.checkIBuf(3);
            this._indices[this._ip++] = idx0;
            this._indices[this._ip++] = idx1;
            this._indices[this._ip++] = idx2;
        }
        addTriangles(indices) {
            this.checkIBuf(indices.length);
            let arr = this._indices;
            let idx = this._ip;
            let n = indices.length;
            this._ip += n;
            for (let i = 0; i < n; i++)
                arr[idx + i] = indices[i];
        }
        triangulateQuad(baseIndex) {
            let cnt = this._vp / this._epv;
            if (baseIndex < 0)
                baseIndex = cnt + baseIndex;
            let icnt = (cnt - baseIndex) / 4 * 6;
            this.checkIBuf(icnt);
            let arr = this._indices;
            for (let i = baseIndex, j = this._ip; i < cnt; i += 4, j += 6) {
                arr[j] = i;
                arr[j + 1] = i + 1;
                arr[j + 2] = i + 2;
                arr[j + 3] = i + 2;
                arr[j + 4] = i + 3;
                arr[j + 5] = i;
            }
            this._ip += icnt;
        }
        getPos(index) {
            if (index < 0)
                index = this._vp / this._epv + index;
            index *= this._epv;
            this._vec.set(this._vertices[index], this._vertices[index + 1], this._vertices[index + 2]);
            return this._vec;
        }
        get vertCount() {
            return this._vp / this._epv;
        }
        get vertexStride() {
            return this._epv;
        }
        getVertices() {
            return new Float32Array(this._vbuf, 0, this._vp);
        }
        getIndices() {
            return new Uint16Array(this._ibuf, 0, this._ip);
        }
        checkVBuf(addCount) {
            if (this._vp + addCount >= this._vertices.length) {
                this._vbuf = new ArrayBuffer(this._vbuf.byteLength + Float32Array.BYTES_PER_ELEMENT * this._epv * Math.max(10, addCount));
                let tmp = this._vertices;
                this._vertices = new Float32Array(this._vbuf);
                this._vertices.set(tmp);
            }
        }
        checkIBuf(addCount) {
            if (this._ip + addCount >= this._indices.length) {
                this._ibuf = new ArrayBuffer(this._ibuf.byteLength + Uint16Array.BYTES_PER_ELEMENT * 3 * Math.max(10, addCount));
                let tmp = this._indices;
                this._indices = new Uint16Array(this._ibuf);
                this._indices.set(tmp);
            }
        }
    }
    VertexStream.pool = Pool.createPool(VertexStream, (e, mainTex, hasColor) => e.init(mainTex, hasColor));

    class WasmAdapter {
        static create(module, wasmFile) {
            var _a;
            let webDir;
            if (typeof document != 'undefined') {
                webDir = (_a = Browser.document.currentScript) === null || _a === void 0 ? void 0 : _a.src;
                if (webDir)
                    webDir = webDir.substring(0, webDir.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            }
            return () => {
                let moduleArg = {};
                if (WasmAdapter.instantiateWasm != null) {
                    moduleArg["instantiateWasm"] = function (imports, receiveInstance) {
                        return WasmAdapter.instantiateWasm(wasmFile, imports).then(exports => {
                            receiveInstance(exports["instance"]);
                            return exports;
                        });
                    };
                }
                moduleArg["locateFile"] = function (path, scriptDirectory) {
                    if (WasmAdapter.locateFile != null)
                        wasmFile = WasmAdapter.locateFile(path, scriptDirectory, webDir);
                    else if (PlayerConfig.wasmSubpackage)
                        wasmFile = PlayerConfig.wasmSubpackage + "/" + path;
                    else
                        wasmFile = scriptDirectory + path;
                    return wasmFile;
                };
                return module(moduleArg);
            };
        }
    }
    WasmAdapter.Memory = typeof (window.WebAssembly) !== "undefined" ? window.WebAssembly.Memory : null;

    class WeakObject {
        static get I() {
            return this._i || (this._i = new WeakObject());
        }
        static clearCache() {
            for (let i = 0, n = WeakObject._maps.length; i < n; i++) {
                let obj = WeakObject._maps[i];
                obj._obj = {};
            }
        }
        constructor() {
            this._obj = {};
            if (!WeakObject._maps) {
                WeakObject._maps = [this];
                ILaya.systemTimer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
            }
            else
                WeakObject._maps.push(this);
        }
        set(key, value) {
            if (key == null)
                return;
            if (typeof (key) == 'string' || typeof (key) == 'number') {
                this._obj[key] = value;
            }
            else {
                this._obj[Utils.getGID(key)] = value;
            }
        }
        get(key) {
            if (key == null)
                return null;
            if (typeof (key) == 'string' || typeof (key) == 'number')
                return this._obj[key];
            else
                return this._obj[Utils.getGID(key)];
        }
        del(key) {
            if (key == null)
                return;
            if (typeof (key) == 'string' || typeof (key) == 'number')
                delete this._obj[key];
            else
                delete this._obj[Utils.getGID(key)];
        }
        has(key) {
            if (key == null)
                return false;
            if (typeof (key) == 'string' || typeof (key) == 'number')
                return this._obj[key] != null;
            else
                return this._obj[Utils.getGID(key)] != null;
        }
    }
    WeakObject.delInterval = 10 * 60 * 1000;

    class WebGLCacheAsNormalCanvas {
        constructor(ctx, sp) {
            this.submitStartPos = 0;
            this.submitEndPos = 0;
            this.touches = [];
            this.submits = [];
            this.sprite = null;
            this.meshlist = [];
            this.cachedClipInfo = new Matrix();
            this.oldTx = 0;
            this.oldTy = 0;
            this.invMat = new Matrix();
            this.context = ctx;
            this.sprite = sp;
            ctx._globalClipMatrix.copyTo(this.cachedClipInfo);
        }
        startRec() {
        }
        endRec() {
        }
        isTextNeedRestore() {
            var textNeedRestore = false;
            var charRIs = this.touches;
            if (charRIs) {
                for (var ci = 0; ci < charRIs.length; ci++) {
                    if (charRIs[ci].deleted) {
                        textNeedRestore = true;
                        break;
                    }
                }
            }
            return textNeedRestore;
        }
        flushsubmit() {
            SubmitBase.RENDERBASE;
            this.submits.forEach((subm) => {
                if (subm == SubmitBase.RENDERBASE)
                    return;
            });
        }
        releaseMem() {
        }
    }
    WebGLCacheAsNormalCanvas.matI = new Matrix();

    class ArabicReshaper {
        characterMapContains(c) {
            for (var i = 0; i < charsMap.length; ++i) {
                if (charsMap[i][0] === c) {
                    return true;
                }
            }
            return false;
        }
        getCharRep(c) {
            for (var i = 0; i < charsMap.length; ++i) {
                if (charsMap[i][0] === c) {
                    return charsMap[i];
                }
            }
            return false;
        }
        getCombCharRep(c1, c2) {
            for (var i = 0; i < combCharsMap.length; ++i) {
                if (combCharsMap[i][0][0] === c1 && combCharsMap[i][0][1] === c2) {
                    return combCharsMap[i];
                }
            }
            return false;
        }
        isTransparent(c) {
            for (var i = 0; i < transChars.length; ++i) {
                if (transChars[i] === c) {
                    return true;
                }
            }
            return false;
        }
        getOriginalCharsFromCode(code) {
            var j;
            for (j = 0; j < charsMap.length; ++j) {
                if (charsMap[j].indexOf(code) > -1) {
                    return String.fromCharCode(charsMap[j][0]);
                }
            }
            for (j = 0; j < combCharsMap.length; ++j) {
                if (combCharsMap[j].indexOf(code) > -1) {
                    return String.fromCharCode(combCharsMap[j][0][0]) +
                        String.fromCharCode(combCharsMap[j][0][1]);
                }
            }
            return String.fromCharCode(code);
        }
        convertArabic(normal) {
            var crep, combcrep, shaped = '';
            for (var i = 0; i < normal.length; ++i) {
                var current = normal.charCodeAt(i);
                if (this.characterMapContains(current)) {
                    var prev = null, next = null, prevID = i - 1, nextID = i + 1;
                    for (; prevID >= 0; --prevID) {
                        if (!this.isTransparent(normal.charCodeAt(prevID))) {
                            break;
                        }
                    }
                    prev = (prevID >= 0) ? normal.charCodeAt(prevID) : null;
                    crep = prev ? this.getCharRep(prev) : false;
                    if (!crep || crep[2] == null && crep[3] == null) {
                        prev = null;
                    }
                    for (; nextID < normal.length; ++nextID) {
                        if (!this.isTransparent(normal.charCodeAt(nextID))) {
                            break;
                        }
                    }
                    next = (nextID < normal.length) ? normal.charCodeAt(nextID) : null;
                    crep = next ? this.getCharRep(next) : false;
                    if (!crep || crep[3] == null && crep[4] == null) {
                        next = null;
                    }
                    if (current === 0x0644 && next != null &&
                        (next === 0x0622 || next === 0x0623 || next === 0x0625 || next === 0x0627)) {
                        combcrep = this.getCombCharRep(current, next);
                        if (prev != null) {
                            shaped += String.fromCharCode(combcrep[4]);
                        }
                        else {
                            shaped += String.fromCharCode(combcrep[1]);
                        }
                        ++i;
                        continue;
                    }
                    crep = this.getCharRep(current);
                    if (prev != null && next != null && crep[3] != null) {
                        shaped += String.fromCharCode(crep[3]);
                        continue;
                    }
                    else if (prev != null && crep[4] != null) {
                        shaped += String.fromCharCode(crep[4]);
                        continue;
                    }
                    else if (next != null && crep[2] != null) {
                        shaped += String.fromCharCode(crep[2]);
                        continue;
                    }
                    else {
                        shaped += String.fromCharCode(crep[1]);
                    }
                }
                else {
                    shaped += String.fromCharCode(current);
                }
            }
            return shaped;
        }
        convertArabicBack(apfb) {
            var toReturn = '', selectedChar;
            var i;
            for (i = 0; i < apfb.length; ++i) {
                selectedChar = apfb.charCodeAt(i);
                toReturn += this.getOriginalCharsFromCode(selectedChar);
            }
            return toReturn;
        }
    }
    const charsMap = [[0x0621, 0xFE80, null, null, null],
        [0x0622, 0xFE81, null, null, 0xFE82],
        [0x0623, 0xFE83, null, null, 0xFE84],
        [0x0624, 0xFE85, null, null, 0xFE86],
        [0x0625, 0xFE87, null, null, 0xFE88],
        [0x0626, 0xFE89, 0xFE8B, 0xFE8C, 0xFE8A],
        [0x0627, 0xFE8D, null, null, 0xFE8E],
        [0x0628, 0xFE8F, 0xFE91, 0xFE92, 0xFE90],
        [0x0629, 0xFE93, null, null, 0xFE94],
        [0x062A, 0xFE95, 0xFE97, 0xFE98, 0xFE96],
        [0x062B, 0xFE99, 0xFE9B, 0xFE9C, 0xFE9A],
        [0x062C, 0xFE9D, 0xFE9F, 0xFEA0, 0xFE9E],
        [0x062D, 0xFEA1, 0xFEA3, 0xFEA4, 0xFEA2],
        [0x062E, 0xFEA5, 0xFEA7, 0xFEA8, 0xFEA6],
        [0x062F, 0xFEA9, null, null, 0xFEAA],
        [0x0630, 0xFEAB, null, null, 0xFEAC],
        [0x0631, 0xFEAD, null, null, 0xFEAE],
        [0x0632, 0xFEAF, null, null, 0xFEB0],
        [0x0633, 0xFEB1, 0xFEB3, 0xFEB4, 0xFEB2],
        [0x0634, 0xFEB5, 0xFEB7, 0xFEB8, 0xFEB6],
        [0x0635, 0xFEB9, 0xFEBB, 0xFEBC, 0xFEBA],
        [0x0636, 0xFEBD, 0xFEBF, 0xFEC0, 0xFEBE],
        [0x0637, 0xFEC1, 0xFEC3, 0xFEC4, 0xFEC2],
        [0x0638, 0xFEC5, 0xFEC7, 0xFEC8, 0xFEC6],
        [0x0639, 0xFEC9, 0xFECB, 0xFECC, 0xFECA],
        [0x063A, 0xFECD, 0xFECF, 0xFED0, 0xFECE],
        [0x0640, 0x0640, 0x0640, 0x0640, 0x0640],
        [0x0641, 0xFED1, 0xFED3, 0xFED4, 0xFED2],
        [0x0642, 0xFED5, 0xFED7, 0xFED8, 0xFED6],
        [0x0643, 0xFED9, 0xFEDB, 0xFEDC, 0xFEDA],
        [0x0644, 0xFEDD, 0xFEDF, 0xFEE0, 0xFEDE],
        [0x0645, 0xFEE1, 0xFEE3, 0xFEE4, 0xFEE2],
        [0x0646, 0xFEE5, 0xFEE7, 0xFEE8, 0xFEE6],
        [0x0647, 0xFEE9, 0xFEEB, 0xFEEC, 0xFEEA],
        [0x0648, 0xFEED, null, null, 0xFEEE],
        [0x0649, 0xFEEF, null, null, 0xFEF0],
        [0x064A, 0xFEF1, 0xFEF3, 0xFEF4, 0xFEF2],
        [0x067E, 0xFB56, 0xFB58, 0xFB59, 0xFB57],
        [0x06CC, 0xFBFC, 0xFBFE, 0xFBFF, 0xFBFD],
        [0x0686, 0xFB7A, 0xFB7C, 0xFB7D, 0xFB7B],
        [0x06A9, 0xFB8E, 0xFB90, 0xFB91, 0xFB8F],
        [0x06AF, 0xFB92, 0xFB94, 0xFB95, 0xFB93],
        [0x0698, 0xFB8A, null, null, 0xFB8B]];
    const combCharsMap = [[[0x0644, 0x0622], 0xFEF5, null, null, 0xFEF6],
        [[0x0644, 0x0623], 0xFEF7, null, null, 0xFEF8],
        [[0x0644, 0x0625], 0xFEF9, null, null, 0xFEFA],
        [[0x0644, 0x0627], 0xFEFB, null, null, 0xFEFC]];
    const transChars = [0x0610,
        0x0612,
        0x0613,
        0x0614,
        0x0615,
        0x064B,
        0x064C,
        0x064D,
        0x064E,
        0x064F,
        0x0650,
        0x0651,
        0x0652,
        0x0653,
        0x0654,
        0x0655,
        0x0656,
        0x0657,
        0x0658,
        0x0670,
        0x06D6,
        0x06D7,
        0x06D8,
        0x06D9,
        0x06DA,
        0x06DB,
        0x06DC,
        0x06DF,
        0x06E0,
        0x06E1,
        0x06E2,
        0x06E3,
        0x06E4,
        0x06E7,
        0x06E8,
        0x06EA,
        0x06EB,
        0x06EC,
        0x06ED];

    class TextDebug {
        static showTextAtlas(texttex, n, bgcolor, x, y, w, h) {
            var sp = new Sprite();
            var texture = {
                width: TextRenderConfig.atlasWidth,
                height: TextRenderConfig.atlasWidth,
                sourceWidth: TextRenderConfig.atlasWidth,
                sourceHeight: TextRenderConfig.atlasWidth,
                offsetX: 0,
                offsetY: 0,
                getIsReady: function () { return true; },
                _addReference: function () { },
                _removeReference: function () { },
                _getSource: function () { return texttex._getSource(); },
                bitmap: { id: texttex.id },
                _uv: Texture.DEF_UV
            };
            sp.graphics.drawRect(0, 0, 1, 1, bgcolor, null, null, true);
            sp.graphics.fillTexture(texture, 0, 0, 1, 1, "no-repeat", null, null, true);
            sp.pos(x, y);
            ILaya.stage.addChild(sp);
            return sp;
        }
        static printRenderInfo(render) {
            console.log('图集个数:' + render.textAtlases.length + ',每个图集大小:' + TextRenderConfig.atlasWidth + 'x' + TextRenderConfig.atlasWidth, ' 用canvas:', !TextRenderConfig.useImageData);
            console.log('图集占用空间:' + (TextRenderConfig.atlasWidth * TextRenderConfig.atlasWidth * 4 / 1024 / 1024 * render.textAtlases.length) + 'M');
            console.log('缓存用到的字体:');
            for (var f in render.mapFont) {
                var fontsz = render.getFontSizeInfo(f);
                var offx = fontsz >> 24;
                var offy = (fontsz >> 16) & 0xff;
                var fw = (fontsz >> 8) & 0xff;
                var fh = fontsz & 0xff;
                console.log('    ' + f, ' off:', offx, offy, ' size:', fw, fh);
            }
            var num = 0;
            console.log('缓存数据:');
            var totalUsedRate = 0;
            var totalUsedRateAtlas = 0;
            render.textAtlases.forEach(function (a) {
                var id = a.texture.id;
                var dt = RenderInfo.loopCount - a.texture.lastTouchTm;
                var dtstr = dt > 0 ? ('' + dt + '帧以前') : '当前帧';
                totalUsedRate += a.texture.curUsedCovRate;
                totalUsedRateAtlas += a.texture.curUsedCovRateAtlas;
                console.log('--图集(id:' + id + ',当前使用率:' + (a.texture.curUsedCovRate * 1000 | 0) + '‰', '当前图集使用率:', (a.texture.curUsedCovRateAtlas * 100 | 0) + '%', '图集使用率:', (a.usedRate * 100 | 0), '%, 使用于:' + dtstr + ')--:');
                for (var k in a.charMaps) {
                    var ri = a.charMaps[k];
                    console.log('     off:', ri.orix, ri.oriy, ' bmp宽高:', ri.bmpWidth, ri.bmpHeight, '无效:', ri.deleted, 'touchdt:', (RenderInfo.loopCount - ri.touchTick), '位置:', ri.uv[0] * TextRenderConfig.atlasWidth | 0, ri.uv[1] * TextRenderConfig.atlasWidth | 0, '字符:', ri.char, 'key:', k);
                    num++;
                }
            });
            console.log('独立贴图文字(' + render.isoTextures.length + '个):');
            render.isoTextures.forEach(function (tex) {
                console.log('    size:', tex.width, tex.height, 'touch间隔:', (RenderInfo.loopCount - tex.lastTouchTm), 'char:', tex.ri.char);
            });
            console.log('总缓存:', num, '总使用率:', totalUsedRate, '总当前图集使用率:', totalUsedRateAtlas);
        }
    }

    class BufferState {
        constructor() {
            this._deviceBufferState = LayaGL.renderDeviceFactory.createBufferState();
        }
        applyState(vertexBuffers, indexBuffer) {
            this._vertexBuffers = vertexBuffers;
            this._bindedIndexBuffer = indexBuffer;
            if (!this._deviceBufferState)
                return;
            if (vertexBuffers.length == 1) {
                BufferState.vertexBufferArray.length = 1;
                BufferState.vertexBufferArray[0] = vertexBuffers[0]._deviceBuffer;
            }
            else {
                BufferState.vertexBufferArray.length = 0;
                vertexBuffers.forEach(element => {
                    BufferState.vertexBufferArray.push(element._deviceBuffer);
                });
            }
            this._deviceBufferState.applyState(BufferState.vertexBufferArray, indexBuffer ? indexBuffer._deviceBuffer : null);
        }
        destroy() {
            if (!this._deviceBufferState)
                return;
            this._deviceBufferState.destroy();
            this._deviceBufferState = null;
        }
    }
    BufferState.vertexBufferArray = [];

    exports.AlphaCmd = AlphaCmd;
    exports.Animation = Animation;
    exports.Animation2DCondition = Animation2DCondition;
    exports.Animation2DEvent = Animation2DEvent;
    exports.Animation2DParm = Animation2DParm;
    exports.AnimationClip2D = AnimationClip2D;
    exports.AnimationClip2DParse01 = AnimationClip2DParse01;
    exports.Animator2D = Animator2D;
    exports.AnimatorController2D = AnimatorController2D;
    exports.AnimatorControllerLayer2D = AnimatorControllerLayer2D;
    exports.AnimatorControllerParse = AnimatorControllerParse;
    exports.AnimatorPlayState2D = AnimatorPlayState2D;
    exports.AnimatorState2D = AnimatorState2D;
    exports.AnimatorState2DScript = AnimatorState2DScript;
    exports.AnimatorStateBoolCondition = AnimatorStateBoolCondition;
    exports.AnimatorStateCondition = AnimatorStateCondition;
    exports.AnimatorStateNumberCondition = AnimatorStateNumberCondition;
    exports.AnimatorStateTriggerCondition = AnimatorStateTriggerCondition;
    exports.AnimatorTransition2D = AnimatorTransition2D;
    exports.ArabicReshaper = ArabicReshaper;
    exports.Area2D = Area2D;
    exports.AssetDb = AssetDb;
    exports.AtlasGrid = AtlasGrid;
    exports.AtlasInfoManager = AtlasInfoManager;
    exports.AtlasResource = AtlasResource;
    exports.AudioDataCache = AudioDataCache;
    exports.Base64Tool = Base64Tool;
    exports.BasePoly = BasePoly;
    exports.BaseRenderNode2D = BaseRenderNode2D;
    exports.BaseTexture = BaseTexture;
    exports.Batch2DInfo = Batch2DInfo;
    exports.BatchProgress = BatchProgress;
    exports.Bezier = Bezier;
    exports.BinHashUtils = BinHashUtils;
    exports.BitmapFont = BitmapFont;
    exports.BlendComponent = BlendComponent;
    exports.BlendMode = BlendMode;
    exports.BlendState = BlendState;
    exports.Blit2DCMD = Blit2DCMD;
    exports.Blit2DQuadCMD = Blit2DQuadCMD;
    exports.BlurFilter = BlurFilter;
    exports.BooleanKeyframe = BooleanKeyframe;
    exports.Browser = Browser;
    exports.BrowserAdapter = BrowserAdapter;
    exports.Buffer = Buffer;
    exports.BufferState = BufferState;
    exports.ButtonEffect = ButtonEffect;
    exports.Byte = Byte;
    exports.CachePage = CachePage;
    exports.CacheStyle = CacheStyle;
    exports.Cache_Info = Cache_Info;
    exports.Camera2D = Camera2D;
    exports.CharRenderInfo = CharRenderInfo;
    exports.CharRender_Canvas = CharRender_Canvas;
    exports.CharSubmitCache = CharSubmitCache;
    exports.ClassUtils = ClassUtils;
    exports.ClipRectCmd = ClipRectCmd;
    exports.Color = Color;
    exports.ColorFilter = ColorFilter;
    exports.ColorUtils = ColorUtils;
    exports.Command2D = Command2D;
    exports.CommandBuffer2D = CommandBuffer2D;
    exports.CommandEncoder = CommandEncoder;
    exports.CommandUniformMap = CommandUniformMap;
    exports.Component = Component;
    exports.ComponentDriver = ComponentDriver;
    exports.Config = Config;
    exports.Config3D = Config3D;
    exports.Const = Const;
    exports.Context = Context;
    exports.CurvePath = CurvePath;
    exports.DDSTextureInfo = DDSTextureInfo;
    exports.DefferTouchResContext = DefferTouchResContext;
    exports.Delegate = Delegate;
    exports.DepthState = DepthState;
    exports.DeviceAdapter = DeviceAdapter;
    exports.Downloader = Downloader;
    exports.DragSupport = DragSupport;
    exports.Draw2DElementCMD = Draw2DElementCMD;
    exports.Draw9GridTextureCmd = Draw9GridTextureCmd;
    exports.DrawCircleCmd = DrawCircleCmd;
    exports.DrawCurvesCmd = DrawCurvesCmd;
    exports.DrawEllipseCmd = DrawEllipseCmd;
    exports.DrawImageCmd = DrawImageCmd;
    exports.DrawLineCmd = DrawLineCmd;
    exports.DrawLinesCmd = DrawLinesCmd;
    exports.DrawMesh2DCMD = DrawMesh2DCMD;
    exports.DrawPathCmd = DrawPathCmd;
    exports.DrawPieCmd = DrawPieCmd;
    exports.DrawPolyCmd = DrawPolyCmd;
    exports.DrawRectCmd = DrawRectCmd;
    exports.DrawRenderElement2DCMD = DrawRenderElement2DCMD;
    exports.DrawRoundRectCmd = DrawRoundRectCmd;
    exports.DrawStyle = DrawStyle;
    exports.DrawTextureCmd = DrawTextureCmd;
    exports.DrawTexturesCmd = DrawTexturesCmd;
    exports.DrawTrianglesCmd = DrawTrianglesCmd;
    exports.Earcut = Earcut;
    exports.EarcutNode = EarcutNode;
    exports.Ease = Ease;
    exports.EffectBase = EffectBase;
    exports.Event = Event;
    exports.EventDispatcher = EventDispatcher;
    exports.FadeIn = FadeIn;
    exports.FadeOut = FadeOut;
    exports.FastSinglelist = FastSinglelist;
    exports.FileSystemAdapter = FileSystemAdapter;
    exports.FillTextCmd = FillTextCmd;
    exports.FillTextureCmd = FillTextureCmd;
    exports.Filter = Filter;
    exports.FloatKeyframe = FloatKeyframe;
    exports.FontAdapter = FontAdapter;
    exports.FontInfo = FontInfo;
    exports.FrameAnimation = FrameAnimation;
    exports.GLSLCodeGenerator = GLSLCodeGenerator;
    exports.GlowFilter = GlowFilter;
    exports.Gradient = Gradient;
    exports.GradientMode = GradientMode;
    exports.GrahamScan = GrahamScan;
    exports.Graphics = Graphics;
    exports.GraphicsBounds = GraphicsBounds;
    exports.HDRTextureInfo = HDRTextureInfo;
    exports.HTMLAudioChannel = HTMLAudioChannel;
    exports.HTMLCanvas = HTMLCanvas;
    exports.HTMLVideoPlayer = HTMLVideoPlayer;
    exports.HTMLVideoTexture = HTMLVideoTexture;
    exports.HalfFloatUtils = HalfFloatUtils;
    exports.Handler = Handler;
    exports.HideFlags = HideFlags;
    exports.HierarchyLoader = HierarchyLoader;
    exports.HierarchyParser = HierarchyParser;
    exports.HierarchyResource = HierarchyResource;
    exports.HitArea = HitArea;
    exports.HtmlElement = HtmlElement;
    exports.HtmlImage = HtmlImage;
    exports.HtmlLink = HtmlLink;
    exports.HtmlParseOptions = HtmlParseOptions;
    exports.HtmlParser = HtmlParser;
    exports.HttpRequest = HttpRequest;
    exports.ILaya = ILaya;
    exports.IncludeFile = IncludeFile;
    exports.IndexBuffer = IndexBuffer;
    exports.Input = Input;
    exports.InputManager = InputManager;
    exports.JsonBinRead = JsonBinRead;
    exports.JsonBinWrite = JsonBinWrite;
    exports.KTXTextureInfo = KTXTextureInfo;
    exports.KeyLocation = KeyLocation;
    exports.Keyboard = Keyboard;
    exports.Keyframe = Keyframe;
    exports.Keyframe2D = Keyframe2D;
    exports.KeyframeNode2D = KeyframeNode2D;
    exports.KeyframeNodeList2D = KeyframeNodeList2D;
    exports.Laya = Laya;
    exports.LayaEnv = LayaEnv;
    exports.LayaGL = LayaGL;
    exports.LayaGLQuickRunner = LayaGLQuickRunner;
    exports.LoadModel2DV01 = LoadModel2DV01;
    exports.Loader = Loader;
    exports.LocalStorage = LocalStorage;
    exports.Material = Material;
    exports.MaterialLoader = MaterialLoader;
    exports.MaterialParser = MaterialParser;
    exports.MathUtil = MathUtil;
    exports.MathUtils3D = MathUtils3D;
    exports.Matrix = Matrix;
    exports.Matrix3x3 = Matrix3x3;
    exports.Matrix4x4 = Matrix4x4;
    exports.MeasureFont = MeasureFont;
    exports.MediaAdapter = MediaAdapter;
    exports.Mesh2D = Mesh2D;
    exports.Mesh2DReader = Mesh2DReader;
    exports.Mesh2DRender = Mesh2DRender;
    exports.MeshLoader = MeshLoader;
    exports.MeshQuadTexture = MeshQuadTexture;
    exports.MeshTexture = MeshTexture;
    exports.MeshVG = MeshVG;
    exports.Mouse = Mouse;
    exports.Node = Node;
    exports.NodeFlags = NodeFlags;
    exports.NotImplementedError = NotImplementedError;
    exports.NotReadableError = NotReadableError;
    exports.NullLoader = NullLoader;
    exports.ObjDecoder = ObjDecoder;
    exports.OpenDataContextView = OpenDataContextView;
    exports.OutOfRangeError = OutOfRangeError;
    exports.PAL = PAL;
    exports.PERF_BEGIN = PERF_BEGIN;
    exports.PERF_END = PERF_END;
    exports.PERF_FRAMECLEAR = PERF_FRAMECLEAR;
    exports.ParseJSON = ParseJSON;
    exports.Path = Path;
    exports.PathPoint = PathPoint;
    exports.PerfTools = PerfTools;
    exports.PerformanceDefine = PerformanceDefine;
    exports.PlayerConfig = PlayerConfig;
    exports.Point = Point;
    exports.Pool = Pool;
    exports.Prefab = Prefab;
    exports.PrefabImpl = PrefabImpl;
    exports.PrimitiveSV = PrimitiveSV;
    exports.Quaternion = Quaternion;
    exports.QuaternionKeyframe = QuaternionKeyframe;
    exports.QuickTestTool = QuickTestTool;
    exports.Rectangle = Rectangle;
    exports.Render = Render;
    exports.Render2D = Render2D;
    exports.Render2DSimple = Render2DSimple;
    exports.RenderInfo = RenderInfo;
    exports.RenderManager2D = RenderManager2D;
    exports.RenderObject2D = RenderObject2D;
    exports.RenderSprite = RenderSprite;
    exports.RenderState = RenderState;
    exports.RenderState2D = RenderState2D;
    exports.RenderStateContext = RenderStateContext;
    exports.RenderTexture = RenderTexture;
    exports.RenderTexture2D = RenderTexture2D;
    exports.RenderTextureCube = RenderTextureCube;
    exports.RenderTextureLoader = RenderTextureLoader;
    exports.RenderToCache = RenderToCache;
    exports.Resource = Resource;
    exports.RestoreCmd = RestoreCmd;
    exports.RotateCmd = RotateCmd;
    exports.SaveBase = SaveBase;
    exports.SaveClipRect = SaveClipRect;
    exports.SaveCmd = SaveCmd;
    exports.SaveMark = SaveMark;
    exports.SaveTransform = SaveTransform;
    exports.SaveTranslate = SaveTranslate;
    exports.ScaleCmd = ScaleCmd;
    exports.Scene = Scene;
    exports.Scene2DSpecialManager = Scene2DSpecialManager;
    exports.Script = Script;
    exports.SerializeUtil = SerializeUtil;
    exports.Set2DDefineCMD = Set2DDefineCMD;
    exports.Set2DRTCMD = Set2DRTCMD;
    exports.Set2DShaderDataCMD = Set2DShaderDataCMD;
    exports.SetRenderDataCMD = SetRenderDataCMD;
    exports.SetRendertarget2DCMD = SetRendertarget2DCMD;
    exports.SetShaderDefineCMD = SetShaderDefineCMD;
    exports.Shader2D = Shader2D;
    exports.Shader3D = Shader3D;
    exports.ShaderCompile = ShaderCompile;
    exports.ShaderCompileDefineBase = ShaderCompileDefineBase;
    exports.ShaderData = ShaderData;
    exports.ShaderDataDefaultValue = ShaderDataDefaultValue;
    exports.ShaderDefine = ShaderDefine;
    exports.ShaderDefines2D = ShaderDefines2D;
    exports.ShaderNode = ShaderNode;
    exports.ShaderParser = ShaderParser;
    exports.ShaderPass = ShaderPass;
    exports.ShaderVariable = ShaderVariable;
    exports.ShaderVariant = ShaderVariant;
    exports.ShaderVariantCollection = ShaderVariantCollection;
    exports.SingletonList = SingletonList;
    exports.Socket = Socket;
    exports.SoundChannel = SoundChannel;
    exports.SoundManager = SoundManager;
    exports.SoundNode = SoundNode;
    exports.Sprite = Sprite;
    exports.Sprite2DGeometry = Sprite2DGeometry;
    exports.SpriteCache = SpriteCache;
    exports.SpriteConst = SpriteConst;
    exports.SpriteGlobalTransform = SpriteGlobalTransform;
    exports.SpriteUtils = SpriteUtils;
    exports.Stage = Stage;
    exports.Stat = Stat;
    exports.StatUI = StatUI;
    exports.StencilState = StencilState;
    exports.StorageAdapter = StorageAdapter;
    exports.SubShader = SubShader;
    exports.SubmitBase = SubmitBase;
    exports.SubmitKey = SubmitKey;
    exports.Text = Text;
    exports.TextAtlas = TextAtlas;
    exports.TextDebug = TextDebug;
    exports.TextInputAdapter = TextInputAdapter;
    exports.TextRender = TextRender;
    exports.TextRenderConfig = TextRenderConfig;
    exports.TextResource = TextResource;
    exports.TextStyle = TextStyle;
    exports.TextTexture = TextTexture;
    exports.Texture = Texture;
    exports.Texture2D = Texture2D;
    exports.Texture2DArray = Texture2DArray;
    exports.Texture2DLoader = Texture2DLoader;
    exports.Texture3D = Texture3D;
    exports.TextureCube = TextureCube;
    exports.TextureLoader = TextureLoader;
    exports.TextureSV = TextureSV;
    exports.TimeLine = TimeLine;
    exports.Timer = Timer;
    exports.TransformCmd = TransformCmd;
    exports.TranslateCmd = TranslateCmd;
    exports.Tween = Tween;
    exports.TweenValue = TweenValue;
    exports.TweenValueAdapterKey = TweenValueAdapterKey;
    exports.Tweener = Tweener;
    exports.TypedArrayClasses = TypedArrayClasses;
    exports.UBBParser = UBBParser;
    exports.UBOStat = UBOStat;
    exports.URL = URL;
    exports.UniformBufferAlone = UniformBufferAlone;
    exports.UniformBufferBlock = UniformBufferBlock;
    exports.UniformBufferCluster = UniformBufferCluster;
    exports.UniformBufferManager = UniformBufferManager;
    exports.UniformBufferUser = UniformBufferUser;
    exports.Utils = Utils;
    exports.Value2D = Value2D;
    exports.Value2DManager = Value2DManager;
    exports.Vector2 = Vector2;
    exports.Vector2Keyframe = Vector2Keyframe;
    exports.Vector3 = Vector3;
    exports.Vector3Keyframe = Vector3Keyframe;
    exports.Vector4 = Vector4;
    exports.Vector4Keyframe = Vector4Keyframe;
    exports.VertexAttributeLayout = VertexAttributeLayout;
    exports.VertexBuffer = VertexBuffer;
    exports.VertexDeclaration = VertexDeclaration;
    exports.VertexElement = VertexElement;
    exports.VertexElementFormat = VertexElementFormat;
    exports.VertexMesh = VertexMesh;
    exports.VertexMesh2D = VertexMesh2D;
    exports.VertexStateContext = VertexStateContext;
    exports.VertexStream = VertexStream;
    exports.VideoNode = VideoNode;
    exports.VideoPlayer = VideoPlayer;
    exports.VideoTexture = VideoTexture;
    exports.VideoTextureLoader = VideoTextureLoader;
    exports.Viewport = Viewport;
    exports.WasmAdapter = WasmAdapter;
    exports.WeakObject = WeakObject;
    exports.WebAudioChannel = WebAudioChannel;
    exports.WebGLCacheAsNormalCanvas = WebGLCacheAsNormalCanvas;
    exports.WebGLRTMgr = WebGLRTMgr;
    exports.Widget = Widget;
    exports.WordText = WordText$1;
    exports.WorkerLoader = WorkerLoader;
    exports.XML = XML;
    exports.XMLIterator = XMLIterator;
    exports.XMLUtils = XMLUtils;
    exports._WebSocket = _WebSocket;
    exports.addAfterInitCallback = addAfterInitCallback;
    exports.addBeforeInitCallback = addBeforeInitCallback;
    exports.addInitCallback = addInitCallback;
    exports.alertGlobalError = alertGlobalError;
    exports.allowMultiple = allowMultiple;
    exports.checkShaderDataValueLegal = checkShaderDataValueLegal;
    exports.classInfo = classInfo;
    exports.getErrorMsg = getErrorMsg;
    exports.importNative = importNative;
    exports.init = init;
    exports.property = property;
    exports.regClass = regClass;
    exports.regLoader = regLoader;
    exports.roundDown = roundDown;
    exports.roundUp = roundUp;
    exports.runInEditor = runInEditor;

    return exports;

})({});
