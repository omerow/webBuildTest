(function (exports, Laya) {
    'use strict';

    class RenderState {
        ;
        get cull() {
            return this._cull;
        }
        set cull(value) {
            this._cull = value;
        }
        get blend() {
            return this._blend;
        }
        set blend(value) {
            this._blend = value;
        }
        get srcBlend() {
            return this._srcBlend;
        }
        set srcBlend(value) {
            this._srcBlend = value;
        }
        get dstBlend() {
            return this._dstBlend;
        }
        set dstBlend(value) {
            this._dstBlend = value;
        }
        get srcBlendRGB() {
            return this._srcBlendRGB;
        }
        set srcBlendRGB(value) {
            this._srcBlendRGB = value;
        }
        get dstBlendRGB() {
            return this._dstBlendRGB;
        }
        set dstBlendRGB(value) {
            this._dstBlendRGB = value;
        }
        get srcBlendAlpha() {
            return this._srcBlendAlpha;
        }
        set srcBlendAlpha(value) {
            this._srcBlendAlpha = value;
        }
        get dstBlendAlpha() {
            return this._dstBlendAlpha;
        }
        set dstBlendAlpha(value) {
            this._dstBlendAlpha = value;
        }
        get blendEquation() {
            return this._blendEquation;
        }
        set blendEquation(value) {
            this._blendEquation = value;
        }
        get blendEquationRGB() {
            return this._blendEquationRGB;
        }
        set blendEquationRGB(value) {
            this._blendEquationRGB = value;
        }
        get blendEquationAlpha() {
            return this._blendEquationAlpha;
        }
        set blendEquationAlpha(value) {
            this._blendEquationAlpha = value;
        }
        get depthTest() {
            return this._depthTest;
        }
        set depthTest(value) {
            this._depthTest = value;
        }
        get depthWrite() {
            return this._depthWrite;
        }
        set depthWrite(value) {
            this._depthWrite = value;
        }
        get stencilWrite() {
            return this._stencilWrite;
        }
        set stencilWrite(value) {
            this._stencilWrite = value;
        }
        get stencilTest() {
            return this._stencilTest;
        }
        set stencilTest(value) {
            this._stencilTest = value;
        }
        get stencilRef() {
            return this._stencilRef;
        }
        set stencilRef(value) {
            this._stencilRef = value;
        }
        get stencilOp() {
            return this._stencilOp;
        }
        set stencilOp(value) {
            this._stencilOp = value;
        }
        createObj() {
        }
        constructor() {
            this._stencilOp = new Laya.Vector3();
            this.createObj();
            this.cull = RenderState.CULL_BACK;
            this.blend = RenderState.BLEND_DISABLE;
            this.srcBlend = RenderState.BLENDPARAM_ONE;
            this.dstBlend = RenderState.BLENDPARAM_ZERO;
            this.srcBlendRGB = RenderState.BLENDPARAM_ONE;
            this.dstBlendRGB = RenderState.BLENDPARAM_ZERO;
            this.srcBlendAlpha = RenderState.BLENDPARAM_ONE;
            this.dstBlendAlpha = RenderState.BLENDPARAM_ZERO;
            this.blendEquation = RenderState.BLENDEQUATION_ADD;
            this.blendEquationRGB = RenderState.BLENDEQUATION_ADD;
            this.blendEquationAlpha = RenderState.BLENDEQUATION_ADD;
            this.depthTest = RenderState.DEPTHTEST_LEQUAL;
            this.depthWrite = true;
            this.stencilRef = 1;
            this.stencilTest = RenderState.STENCILTEST_OFF;
            this.stencilWrite = false;
            this.stencilOp = new Laya.Vector3(RenderState.STENCILOP_KEEP, RenderState.STENCILOP_KEEP, RenderState.STENCILOP_REPLACE);
        }
        setNull() {
            this.cull = null;
            this.blend = null;
            this.srcBlend = null;
            this.dstBlend = null;
            this.srcBlendRGB = null;
            this.dstBlendRGB = null;
            this.srcBlendAlpha = null;
            this.dstBlendAlpha = null;
            this.blendEquation = null;
            this.blendEquationRGB = null;
            this.blendEquationAlpha = null;
            this.depthTest = null;
            this.depthWrite = null;
            this.stencilRef = null;
            this.stencilTest = null;
            this.stencilWrite = null;
            this.stencilOp.set(null, null, null);
        }
        cloneTo(dest) {
            dest.cull = this.cull;
            dest.blend = this.blend;
            dest.srcBlend = this.srcBlend;
            dest.dstBlend = this.dstBlend;
            dest.srcBlendRGB = this.srcBlendRGB;
            dest.dstBlendRGB = this.dstBlendRGB;
            dest.srcBlendAlpha = this.srcBlendAlpha;
            dest.dstBlendAlpha = this.dstBlendAlpha;
            dest.blendEquation = this.blendEquation;
            dest.blendEquationRGB = this.blendEquationRGB;
            dest.blendEquationAlpha = this.blendEquationAlpha;
            dest.depthTest = this.depthTest;
            dest.depthWrite = this.depthWrite;
            dest.stencilRef = this.stencilRef;
            dest.stencilTest = this.stencilTest;
            dest.stencilWrite = this.stencilWrite;
            this.stencilOp.cloneTo(dest.stencilOp);
        }
        clone() {
            var dest = new RenderState();
            this.cloneTo(dest);
            return dest;
        }
    }
    RenderState.CULL_NONE = Laya.CullMode.Off;
    RenderState.CULL_FRONT = Laya.CullMode.Front;
    RenderState.CULL_BACK = Laya.CullMode.Back;
    RenderState.BLEND_DISABLE = Laya.BlendType.BLEND_DISABLE;
    RenderState.BLEND_ENABLE_ALL = Laya.BlendType.BLEND_ENABLE_ALL;
    RenderState.BLEND_ENABLE_SEPERATE = Laya.BlendType.BLEND_ENABLE_SEPERATE;
    RenderState.BLENDPARAM_ZERO = Laya.BlendFactor.Zero;
    RenderState.BLENDPARAM_ONE = Laya.BlendFactor.One;
    RenderState.BLENDPARAM_SRC_COLOR = Laya.BlendFactor.SourceColor;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_COLOR = Laya.BlendFactor.OneMinusSourceColor;
    RenderState.BLENDPARAM_DST_COLOR = Laya.BlendFactor.DestinationColor;
    RenderState.BLENDPARAM_ONE_MINUS_DST_COLOR = Laya.BlendFactor.OneMinusDestinationColor;
    RenderState.BLENDPARAM_SRC_ALPHA = Laya.BlendFactor.SourceAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA = Laya.BlendFactor.OneMinusSourceAlpha;
    RenderState.BLENDPARAM_DST_ALPHA = Laya.BlendFactor.DestinationAlpha;
    RenderState.BLENDPARAM_ONE_MINUS_DST_ALPHA = Laya.BlendFactor.OneMinusDestinationAlpha;
    RenderState.BLENDPARAM_SRC_ALPHA_SATURATE = Laya.BlendFactor.SourceAlphaSaturate;
    RenderState.BLENDPARAM_BLENDCOLOR = Laya.BlendFactor.BlendColor;
    RenderState.BLENDPARAM_BLEND_ONEMINUS_COLOR = Laya.BlendFactor.OneMinusBlendColor;
    RenderState.BLENDEQUATION_ADD = Laya.BlendEquationSeparate.ADD;
    RenderState.BLENDEQUATION_SUBTRACT = Laya.BlendEquationSeparate.SUBTRACT;
    RenderState.BLENDEQUATION_REVERSE_SUBTRACT = Laya.BlendEquationSeparate.REVERSE_SUBTRACT;
    RenderState.BLENDEQUATION_MIN = Laya.BlendEquationSeparate.MIN;
    RenderState.BLENDEQUATION_MAX = Laya.BlendEquationSeparate.MAX;
    RenderState.DEPTHTEST_OFF = Laya.CompareFunction.Off;
    RenderState.DEPTHTEST_NEVER = Laya.CompareFunction.Never;
    RenderState.DEPTHTEST_LESS = Laya.CompareFunction.Less;
    RenderState.DEPTHTEST_EQUAL = Laya.CompareFunction.Equal;
    RenderState.DEPTHTEST_LEQUAL = Laya.CompareFunction.LessEqual;
    RenderState.DEPTHTEST_GREATER = Laya.CompareFunction.Greater;
    RenderState.DEPTHTEST_NOTEQUAL = Laya.CompareFunction.NotEqual;
    RenderState.DEPTHTEST_GEQUAL = Laya.CompareFunction.GreaterEqual;
    RenderState.DEPTHTEST_ALWAYS = Laya.CompareFunction.Always;
    RenderState.STENCILTEST_OFF = Laya.CompareFunction.Off;
    RenderState.STENCILTEST_NEVER = Laya.CompareFunction.Never;
    RenderState.STENCILTEST_LESS = Laya.CompareFunction.Less;
    RenderState.STENCILTEST_EQUAL = Laya.CompareFunction.Equal;
    RenderState.STENCILTEST_LEQUAL = Laya.CompareFunction.LessEqual;
    RenderState.STENCILTEST_GREATER = Laya.CompareFunction.Greater;
    RenderState.STENCILTEST_NOTEQUAL = Laya.CompareFunction.NotEqual;
    RenderState.STENCILTEST_GEQUAL = Laya.CompareFunction.GreaterEqual;
    RenderState.STENCILTEST_ALWAYS = Laya.CompareFunction.Always;
    RenderState.STENCILOP_KEEP = Laya.StencilOperation.Keep;
    RenderState.STENCILOP_ZERO = Laya.StencilOperation.Zero;
    RenderState.STENCILOP_REPLACE = Laya.StencilOperation.Replace;
    RenderState.STENCILOP_INCR = Laya.StencilOperation.IncrementSaturate;
    RenderState.STENCILOP_INCR_WRAP = Laya.StencilOperation.IncrementWrap;
    RenderState.STENCILOP_DECR = Laya.StencilOperation.DecrementSaturate;
    RenderState.STENCILOP_DECR_WRAP = Laya.StencilOperation.DecrementWrap;
    RenderState.STENCILOP_INVERT = Laya.StencilOperation.Invert;
    RenderState.Default = new RenderState();

    class BlinnPhongMaterial extends Laya.Material {
        static __initDefine__() {
            BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP = Laya.Shader3D.getDefineByName("DIFFUSEMAP");
            BlinnPhongMaterial.SHADERDEFINE_NORMALMAP = Laya.Shader3D.getDefineByName("NORMALMAP");
            BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP = Laya.Shader3D.getDefineByName("SPECULARMAP");
            BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
            BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION = Laya.Shader3D.getDefineByName("ENABLETRANSMISSION");
            BlinnPhongMaterial.SHADERDEFINE_THICKNESSMAP = Laya.Shader3D.getDefineByName("THICKNESSMAP");
            BlinnPhongMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_DiffuseTexture");
            BlinnPhongMaterial.NORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_NormalTexture");
            BlinnPhongMaterial.SPECULARTEXTURE = Laya.Shader3D.propertyNameToID("u_SpecularTexture");
            BlinnPhongMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_DiffuseColor");
            BlinnPhongMaterial.MATERIALSPECULAR = Laya.Shader3D.propertyNameToID("u_MaterialSpecular");
            BlinnPhongMaterial.SHININESS = Laya.Shader3D.propertyNameToID("u_Shininess");
            BlinnPhongMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
            BlinnPhongMaterial.TRANSMISSIONRATE = Laya.Shader3D.propertyNameToID("u_TransmissionRate");
            BlinnPhongMaterial.IBACKDIFFUSE = Laya.Shader3D.propertyNameToID("u_BackDiffuse");
            BlinnPhongMaterial.IBACKSCALE = Laya.Shader3D.propertyNameToID("u_BackScale");
            BlinnPhongMaterial.THINKNESSTEXTURE = Laya.Shader3D.propertyNameToID("u_ThinknessTexture");
            BlinnPhongMaterial.TRANSMISSIONCOLOR = Laya.Shader3D.propertyNameToID("u_TransmissionColor");
            BlinnPhongMaterial.AlbedoIntensity = Laya.Shader3D.propertyNameToID("u_AlbedoIntensity");
        }
        set renderMode(value) {
            switch (value) {
                case BlinnPhongMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Laya.Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case BlinnPhongMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = Laya.Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case BlinnPhongMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                default:
                    throw new Error("unknown renderMode: " + value);
            }
        }
        get enableVertexColor() {
            return this.hasDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set enableVertexColor(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        get tilingOffset() {
            return this.getVector4ByIndex(BlinnPhongMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this.setVector4ByIndex(BlinnPhongMaterial.TILINGOFFSET, value);
            }
            else {
                this.getVector4ByIndex(BlinnPhongMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get albedoColor() {
            return this.getColorByIndex(BlinnPhongMaterial.ALBEDOCOLOR);
        }
        set albedoColor(value) {
            this.setColorByIndex(BlinnPhongMaterial.ALBEDOCOLOR, value);
        }
        get albedoIntensity() {
            return this.getFloatByIndex(BlinnPhongMaterial.AlbedoIntensity);
        }
        set albedoIntensity(value) {
            this.setFloatByIndex(BlinnPhongMaterial.AlbedoIntensity, value);
        }
        get specularColor() {
            return this.getColorByIndex(BlinnPhongMaterial.MATERIALSPECULAR);
        }
        set specularColor(value) {
            this.setColorByIndex(BlinnPhongMaterial.MATERIALSPECULAR, value);
        }
        get shininess() {
            return this.getFloatByIndex(BlinnPhongMaterial.SHININESS);
        }
        set shininess(value) {
            value = Math.max(0.0, Math.min(1.0, value));
            this.setFloatByIndex(BlinnPhongMaterial.SHININESS, value);
        }
        get albedoTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.ALBEDOTEXTURE);
        }
        set albedoTexture(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_DIFFUSEMAP);
            this.setTextureByIndex(BlinnPhongMaterial.ALBEDOTEXTURE, value);
        }
        get normalTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.NORMALTEXTURE);
        }
        set normalTexture(value) {
            if (value) {
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
            }
            else {
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_NORMALMAP);
            }
            this.setTextureByIndex(BlinnPhongMaterial.NORMALTEXTURE, value);
        }
        get specularTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.SPECULARTEXTURE);
        }
        set specularTexture(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_SPECULARMAP);
            this.setTextureByIndex(BlinnPhongMaterial.SPECULARTEXTURE, value);
        }
        get enableTransmission() {
            return this.hasDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION);
        }
        set enableTransmission(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_ENABLETRANSMISSION);
        }
        get transmissionRata() {
            return this.getFloatByIndex(BlinnPhongMaterial.TRANSMISSIONRATE);
        }
        set transmissionRata(value) {
            this.setFloatByIndex(BlinnPhongMaterial.TRANSMISSIONRATE, value);
        }
        get backDiffuse() {
            return this.getFloatByIndex(BlinnPhongMaterial.IBACKDIFFUSE);
        }
        set backDiffuse(value) {
            this.setFloatByIndex(BlinnPhongMaterial.IBACKDIFFUSE, Math.max(value, 1.0));
        }
        get backScale() {
            return this.getFloatByIndex(BlinnPhongMaterial.IBACKSCALE);
        }
        set backScale(value) {
            this.setFloatByIndex(BlinnPhongMaterial.IBACKSCALE, value);
        }
        get thinknessTexture() {
            return this.getTextureByIndex(BlinnPhongMaterial.THINKNESSTEXTURE);
        }
        set thinknessTexture(value) {
            if (value)
                this.addDefine(BlinnPhongMaterial.SHADERDEFINE_THICKNESSMAP);
            else
                this.removeDefine(BlinnPhongMaterial.SHADERDEFINE_THICKNESSMAP);
            this.setTextureByIndex(BlinnPhongMaterial.THINKNESSTEXTURE, value);
        }
        get transmissionColor() {
            return this.getColorByIndex(BlinnPhongMaterial.TRANSMISSIONCOLOR);
        }
        set transmissionColor(value) {
            this.setColorByIndex(BlinnPhongMaterial.TRANSMISSIONCOLOR, value);
        }
        get transmissionRate() {
            return this.getFloatByIndex(BlinnPhongMaterial.TRANSMISSIONRATE);
        }
        constructor() {
            super();
            this.setShaderName("BLINNPHONG");
            this.renderMode = BlinnPhongMaterial.RENDERMODE_OPAQUE;
        }
        clone() {
            var dest = new BlinnPhongMaterial();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            super.cloneTo(destObject);
            destObject.albedoIntensity = this.albedoIntensity;
            destObject.enableVertexColor = this.enableVertexColor;
            this.albedoColor.cloneTo(destObject.albedoColor);
        }
    }
    BlinnPhongMaterial.RENDERMODE_OPAQUE = 0;
    BlinnPhongMaterial.RENDERMODE_CUTOUT = 1;
    BlinnPhongMaterial.RENDERMODE_TRANSPARENT = 2;

    exports.PBRRenderQuality = void 0;
    (function (PBRRenderQuality) {
        PBRRenderQuality[PBRRenderQuality["High"] = 0] = "High";
        PBRRenderQuality[PBRRenderQuality["Low"] = 1] = "Low";
    })(exports.PBRRenderQuality || (exports.PBRRenderQuality = {}));

    var BRDFGLSL = "#if !defined(BRDF)\n#define BRDF\nfloat D_GGX(float roughness,float NoH,vec3 h,vec3 n){\n#if !defined(GL_FRAGMENT_PRECISION_HIGH)\nvec3 NxH=cross(n,h);float oneMinusNoHSquared=dot(NxH,NxH);\n#else\nfloat oneMinusNoHSquared=1.0-NoH*NoH;\n#endif\nfloat a=NoH*roughness;float k=roughness/(oneMinusNoHSquared+a*a);float d=k*k*INVERT_PI;return saturateMediump(d);}float D_GGX_Anisotropic(float NoH,const vec3 h,const vec3 t,const vec3 b,float at,float ab){float ToH=dot(t,h);float BoH=dot(b,h);float a2=at*ab;highp vec3 v=vec3(ab*ToH,at*BoH,a2*NoH);highp float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*INVERT_PI;}float D_Charlie(float roughness,float NoH){float invR=1.0/roughness;float cos2h=NoH*NoH;float sin2h=max(1.0-cos2h,0.0078125);return(2.0+invR)*pow(sin2h,invR*0.5)*0.5*INVERT_PI;}float V_SmithGGXCorrelated(float roughness,float NoV,float NoL){float a2=roughness*roughness;float lambdaV=NoL*sqrt((NoV-a2*NoV)*NoV+a2);float lambdaL=NoV*sqrt((NoL-a2*NoL)*NoL+a2);float v=0.5/(lambdaV+lambdaL);return saturateMediump(v);}float V_SmithGGXCorrelated_Fast(float roughness,float NoV,float NoL){float v=0.5/mix(2.0*NoL*NoV,NoL+NoV,roughness);return saturateMediump(v);}float V_kelemen(float LoH){return saturateMediump(0.25/(LoH*LoH));}float lCharlieNumericHelper(float x,float alphaG){float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}float lCharlie(float cosTheta,float alphaG){if(abs(cosTheta)<0.5){return exp(lCharlieNumericHelper(cosTheta,alphaG));}else{return exp(2.0*lCharlieNumericHelper(0.5,alphaG)-lCharlieNumericHelper(1.0-cosTheta,alphaG));}}float V_Charlie(float NoL,float NoV,float roughness){float alphaG=roughness*roughness;return clamp(1.0/((1.0+lCharlie(NoV,alphaG)+lCharlie(NoL,alphaG))*(4.0*NoV*NoL)),0.0,1.0);}float V_Neubelt(float NoV,float NoL){return saturateMediump(1.0/(4.0*(NoL+NoV-NoL*NoV)));}float V_SmithGGXCorrelated_Anisotropic(float at,float ab,float ToV,float BoV,float ToL,float BoL,float NoV,float NoL){float lambdaV=NoL*length(vec3(at*ToV,ab*BoV,NoV));float lambdaL=NoV*length(vec3(at*ToL,ab*BoL,NoL));float v=0.5/(lambdaV+lambdaL);return saturateMediump(v);}vec3 F_Schlick(vec3 f0,float f90,float VoH){return f0+(f90-f0)*pow5(1.0-VoH);}vec3 F_Schlick(vec3 f0,float VoH){return f0+(1.0-f0)*pow5(1.0-VoH);}float F_Schlick(float f0,float f90,float VoH){return f0+(f90-f0)*pow5(1.0-VoH);}float F_Schlick(float f0,float VoH){return f0+(1.0-f0)*pow5(1.0-VoH);}vec3 F_Schlick(vec3 f0,vec3 f90,float VoH){return f0+(f90-f0)*pow5(1.0-VoH);}\n#ifdef IRIDESCENCE\nconst mat3 XYZ_to_REC709_MAT=mat3(vec3(3.2409699419,-0.9692436363,0.0556300797),vec3(-1.5373831776,1.8759675015,-0.2039769589),vec3(-0.498610760,0.0415550574,1.0569715142));float IorToFresnel0(float iorT,float iorI){return pow2((iorT-iorI)/(iorT+iorI));}vec3 IorToFresnel0(vec3 iorT,float iorI){return pow2((iorT-vec3(iorI))/(iorT+vec3(iorI)));}vec3 Fresnel0ToIor(vec3 f0){vec3 sqrtF0=sqrt(f0);return(1.0+sqrtF0)/(1.0-sqrtF0);}vec3 evalSensitivity(float OPD,vec3 shift){float phase=2.0*PI*OPD*1.0e-9;vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-pow2(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*pow2(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_to_REC709_MAT*xyz;return srgb;}vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0){vec3 I;float iridescenceIor=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=pow2(outsideIOR/iridescenceIor)*(1.0-pow2(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if(cosTheta2Sq<0.0){return vec3(1.0);}float cosTheta2=sqrt(cosTheta2Sq);float R0=IorToFresnel0(iridescenceIor,outsideIOR);float R12=F_Schlick(R0,cosTheta1);float R21=R12;float T121=1.0-R12;float phi12=0.0;if(iridescenceIor<outsideIOR)phi12=PI;float phi21=PI-phi12;vec3 baseIOR=Fresnel0ToIor(clamp(baseF0,0.0,0.9999));vec3 R1=IorToFresnel0(baseIOR,iridescenceIor);vec3 R23=F_Schlick(R1,cosTheta2);vec3 phi23=vec3(0.0);if(baseIOR[0]<iridescenceIor)phi23[0]=PI;if(baseIOR[1]<iridescenceIor)phi23[1]=PI;if(baseIOR[2]<iridescenceIor)phi23[2]=PI;float OPD=2.0*iridescenceIor*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=pow2(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for(int m=1;m<=2;++m){Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*OPD,float(m)*phi);I+=Cm*Sm;}return max(I,vec3(0.0));}\n#endif\nfloat distribution(float roughness,float NoH,vec3 h,vec3 n){return D_GGX(roughness,NoH,h,n);}float visibility(float roughness,float NoV,float NoL){return V_SmithGGXCorrelated(roughness,NoV,NoL);}vec3 fresnel(vec3 f0,float LoH){float f90=saturate(dot(f0,vec3(50.0*0.33)));return F_Schlick(f0,f90,LoH);}vec3 fresnel(vec3 f0,vec3 f90,float LoH){return F_Schlick(f0,f90,LoH);}float Fd_Lambert(){return 1.0;}float Fd_Burley(float roughness,float NoV,float NoL,float LoH){float f90=0.5+2.0*roughness*LoH*LoH;float lightScatter=F_Schlick(1.0,f90,NoL);float veiwScatter=F_Schlick(1.0,f90,NoV);return lightScatter*veiwScatter*INVERT_PI;}\n#ifdef IRIDESCENCE\nvec3 Fd_IridescenceLambert(vec3 f0,vec3 f90,vec3 iridescenceFresnel,float iridescenceFactor,float VoH){vec3 iridescenceFresnelMax=vec3(vecmax(iridescenceFresnel));vec3 schlickFresnel=F_Schlick(f0,f90,VoH);vec3 F=mix(schlickFresnel,iridescenceFresnelMax,iridescenceFactor);return(1.0-F)*Fd_Lambert();}\n#endif\n#endif\n";

    var PBRGIGLSL = "#if !defined(pbrGI_lib)\n#define pbrGI_lib\n#include \"globalIllumination.glsl\";\n#ifdef ANISOTROPIC\nvec3 anisotropyBentNormal(const in Surface surface,const in PixelInfo info){float anisotropy=surface.anisotropy;vec3 anisotropyDirection=info.anisotropicB;vec3 n=info.normalWS;vec3 v=info.viewDir;float roughness=surface.perceptualRoughness;vec3 anisotropicTangent=cross(anisotropyDirection,v);vec3 anisotropicNormal=cross(anisotropicTangent,anisotropyDirection);float bendFactor=1.0-anisotropy*(1.0-roughness);float bendFactorPow4=pow2(bendFactor)*pow2(bendFactor);vec3 bentNormal=normalize(mix(anisotropicNormal,n,bendFactorPow4));return bentNormal;}\n#endif\nvec3 getReflectedVector(const in vec3 n,const in vec3 v,const in vec3 positionWS){vec3 r;r=reflect(-v,n);\n#ifdef SPECCUBE_BOX_PROJECTION\nr=getBoxProjectionReflectedVector(r,positionWS);\n#endif\nreturn r;}\n#ifdef IRIDESCENCE\nvoid iridescenceIBL(const in Surface surface,const in PixelInfo info,in vec3 E,inout vec3 Fd,inout vec3 Fr){vec3 dfg=info.dfg;float NoV=info.NoV;vec3 n=info.normalWS;vec3 v=info.viewDir;vec3 positionWS=info.positionWS;vec3 iridescenceFresnel=info.iridescenceFresnel;vec3 diffuseColor=surface.diffuseColor;float roughness=surface.perceptualRoughness;float occlusion=surface.occlusion;float iridescenceFactor=surface.iridescence;vec3 irradiance=diffuseIrradiance(n,positionWS,info.viewDir);Fd+=diffuseColor*irradiance*(1.0-E)*occlusion;vec3 iridescenceF0=mix(surface.f0,iridescenceFresnel,vec3(iridescenceFactor));vec3 Er=mix(dfg.xxx,dfg.yyy,iridescenceF0);\n#ifdef ANISOTROPIC\nvec3 bentNormal=anisotropyBentNormal(surface,info);vec3 r=getReflectedVector(bentNormal,v,positionWS);\n#else\nvec3 r=getReflectedVector(n,v,positionWS);\n#endif\nvec3 indirectSpecular=specularRadiance(r,roughness);Fr+=Er*indirectSpecular*occlusion*(1.0+Er*(1.0/dfg.y-1.0));}\n#endif\n#ifdef SHEEN\nvoid sheenIBL(const in Surface surface,const in PixelInfo info,inout vec3 Fd,inout vec3 Fr){vec3 v=info.viewDir;vec3 n=info.normalWS;vec3 positionWS=info.positionWS;float occlusion=surface.occlusion;float roughness=surface.sheenPerceptualRoughness;Fd*=info.sheenScaling;Fr*=info.sheenScaling;vec3 r=getReflectedVector(n,v,positionWS);vec3 indirectSpecular=specularRadiance(r,roughness);Fr+=indirectSpecular*info.sheenDfg*surface.sheenColor*occlusion;}\n#endif\n#ifdef CLEARCOAT\nvoid clearCoatIBL(const in Surface surface,const in PixelInfo info,inout vec3 Fd,inout vec3 Fr){vec3 v=info.viewDir;vec3 n=info.clearCoatNormal;float NoV=info.clearCoatNoV;vec3 positionWS=info.positionWS;float clearCoat=surface.clearCoat;float roughness=surface.clearCoatPerceptualRoughness;float occlusion=surface.occlusion;float Fc=F_Schlick(0.04,1.0,NoV)*clearCoat;float attenuation=1.0-Fc;Fd*=attenuation;Fr*=attenuation;vec3 r=getReflectedVector(n,v,positionWS);vec3 indirectSpecular=specularRadiance(r,roughness);Fr+=indirectSpecular*Fc*occlusion;}\n#endif\n#ifdef TRANSMISSION\nvec3 getRefraction(const in Surface surface,const in PixelInfo info){vec3 position=info.positionWS;\n#ifdef THICKNESS\nvec3 n=info.normalWS;vec3 r=-info.viewDir;float airIOR=1.0;float etaIR=airIOR/surface.ior;vec3 refractionV=normalize(refract(r,n,etaIR))*surface.thickness*info.worldScale.xyz;position+=refractionV;\n#endif\nvec4 p=u_ViewProjection*vec4(position,1.0);vec2 refractionUV=(p.xy/p.w)*0.5+0.5;float refractionLOD=u_OpaqueTextureParams.z*surface.perceptualRoughness*saturate(surface.ior*2.0-2.0);vec3 refraction=texture2DLodEXT(u_CameraOpaqueTexture,refractionUV,refractionLOD).xyz;return refraction;}vec3 transmissionIBL(const in Surface surface,const in PixelInfo info,in vec3 E){vec3 refraction=getRefraction(surface,info);\n#ifndef THICKNESS\nE*=1.0+surface.transmission*(1.0-E.g)/(1.0+E.g);\n#endif\n#ifdef THICKNESS\nvec3 attenuationColor=surface.attenuationColor;float attenuationDistance=surface.attenuationDistance;vec3 absorption=-log(attenuationColor)/(attenuationDistance);vec3 T=exp(-absorption*info.worldScale.xyz*surface.thickness);\n#endif\nvec3 Ft=refraction;Ft*=surface.diffuseColor;Ft*=1.0-E;\n#ifdef THICKNESS\nFt*=T;\n#endif\nreturn Ft*surface.transmission;}\n#endif\nvoid baseIBL(const in Surface surface,const in PixelInfo info,in vec3 E,inout vec3 Fd,inout vec3 Fr){vec3 dfg=info.dfg;float NoV=info.NoV;vec3 n=info.normalWS;vec3 v=info.viewDir;vec3 positionWS=info.positionWS;vec3 diffuseColor=surface.diffuseColor;float roughness=surface.perceptualRoughness;float occlusion=surface.occlusion;\n#ifdef ANISOTROPIC\nvec3 bentNormal=anisotropyBentNormal(surface,info);vec3 r=getReflectedVector(bentNormal,v,positionWS);\n#else\nvec3 r=getReflectedVector(n,v,positionWS);\n#endif\nvec3 indirectSpecular=specularRadiance(r,roughness);float specularAO=occlusion;Fr+=E*indirectSpecular*specularAO*info.energyCompensation;\n#if defined(USELIGHTMAP)\nvec2 lightmapUV=info.lightmapUV;vec3 bakedlight=getBakedLightmapColor(lightmapUV,n);Fd+=bakedlight*diffuseColor;\n#else\nvec3 irradiance=diffuseIrradiance(n,positionWS,info.viewDir);Fd+=diffuseColor*irradiance*(1.0-E)*occlusion;\n#endif\n}vec3 getE(const in Surface surface,const in PixelInfo info){\n#ifdef IRIDESCENCE\nvec3 dfg=info.dfg;float NoV=info.NoV;vec3 iridescenceFresnel=info.iridescenceFresnel;vec3 f0=surface.f0;float iridescenceFactor=surface.iridescence;vec3 iridescenceFresnelMax=vec3(vecmax(iridescenceFresnel));vec3 schlickFresnel=F_Schlick(f0,vec3(1.0),NoV);vec3 F=mix(schlickFresnel,iridescenceFresnelMax,iridescenceFactor);vec3 E=mix(dfg.xxx,dfg.yyy,F);\n#else\nvec3 dfg=info.dfg;vec3 f0=surface.f0;vec3 f90=surface.f90;vec3 E=(f90-f0)*dfg.x+f0*dfg.y;\n#endif\nreturn E;}vec3 PBRGI(const in Surface surface,const in PixelInfo info){vec3 Fd=vec3(0.0);vec3 Fr=vec3(0.0);vec3 E=getE(surface,info);\n#ifdef IRIDESCENCE\niridescenceIBL(surface,info,E,Fd,Fr);\n#else\nbaseIBL(surface,info,E,Fd,Fr);\n#endif\n#ifdef SHEEN\nsheenIBL(surface,info,Fd,Fr);\n#endif\n#ifdef CLEARCOAT\nclearCoatIBL(surface,info,Fd,Fr);\n#endif\n#ifdef TRANSMISSION\nFd*=(1.0-surface.transmission);vec3 Ft=transmissionIBL(surface,info,E);\n#endif\nvec3 gi=Fd+Fr;\n#ifdef TRANSMISSION\ngi+=Ft;\n#endif\nreturn gi;}\n#endif\n";

    var PBRCommonGLSL = "#if !defined(pbrCommon_lib)\n#define pbrCommon_lib\nvarying vec3 v_PositionWS;varying vec3 v_NormalWS;varying vec3 v_TangentWS;varying vec3 v_BiNormalWS;\n#ifdef UV\nvarying vec2 v_Texcoord0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nvarying vec2 v_Texcoord1;\n#endif\n#endif\n#ifdef COLOR\nvarying vec4 v_VertexColor;\n#endif\nstruct PixelParams{vec3 positionWS;vec3 normalWS;vec3 tangentWS;vec3 biNormalWS;mat3 TBN;\n#ifdef UV\nvec2 uv0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nvec2 uv1;\n#endif\n#endif\n#ifdef COLOR\nvec4 vertexColor;\n#endif\n};\n#endif\n";

    var PBRVertexGLSL = "#if !defined(pbrVertex_lib)\n#define pbrVertex_lib\n#include \"ShadingVertex.glsl\";\n#ifdef THICKNESS\nvarying vec4 v_WorldScale;\n#endif\nvoid initPixelParams(inout PixelParams params,in Vertex vertex){shadingPixelParams(params,vertex);sharePixelParams(params);\n#ifdef THICKNESS\nmat4 worldMat=getWorldMatrix();v_WorldScale.x=length(vec3(worldMat[0].xyz));v_WorldScale.y=length(vec3(worldMat[1].xyz));v_WorldScale.z=length(vec3(worldMat[2].xyz));v_WorldScale.w=length(v_WorldScale.xyz);\n#endif\n}\n#endif\n";

    var PBRFragGLSL = "\n#if !defined(pbrFrag_lib)\n#define pbrFrag_lib\n#include \"PBRLighting.glsl\";\n#ifdef THICKNESS\nvarying vec4 v_WorldScale;\n#endif\nvoid getPixelInfo(inout PixelInfo info,const in PixelParams pixel,const in Surface surface){info.positionWS=pixel.positionWS;info.vertexNormalWS=pixel.normalWS;\n#ifdef TANGENT\ninfo.normalWS=normalize(pixel.TBN*surface.normalTS);\n#else\ninfo.normalWS=pixel.normalWS;\n#endif\ninfo.tangentWS=pixel.tangentWS;info.biNormalWS=pixel.biNormalWS;info.viewDir=normalize(u_CameraPos-info.positionWS);info.NoV=min(max(dot(info.normalWS,info.viewDir),MIN_N_DOT_V),1.0);info.dfg=prefilteredDFG_LUT(surface.perceptualRoughness,info.NoV);\n#ifdef SHEEN\ninfo.energyCompensation=vec3(1.0);\n#else\ninfo.energyCompensation=(1.0+surface.f0*(1.0/info.dfg.y-1.0));\n#endif\n#ifdef IRIDESCENCE\ninfo.iridescenceFresnel=evalIridescence(1.0,surface.iridescenceIor,info.NoV,surface.iridescenceThickness,surface.f0);\n#endif\n#ifdef SHEEN\ninfo.sheenDfg=prefilteredDFG_LUT(surface.sheenPerceptualRoughness,info.NoV).z;info.sheenScaling=1.0-vecmax(surface.sheenColor)*info.sheenDfg;\n#endif\n#ifdef CLEARCOAT\n#ifdef CLEARCOAT_NORMAL\ninfo.clearCoatNormal=normalize(pixel.TBN*surface.clearCoatNormalTS);\n#else\ninfo.clearCoatNormal=info.vertexNormalWS;\n#endif\ninfo.clearCoatNoV=min(max(dot(info.clearCoatNormal,info.viewDir),MIN_N_DOT_V),1.0);\n#endif\n#ifdef ANISOTROPIC\nmat3 anisotropyTBN=mat3(info.tangentWS,info.biNormalWS*-1.0,info.normalWS);info.anisotropicT=anisotropyTBN*normalize(vec3(surface.anisotropyDirection,0.0));info.anisotropicB=cross(info.vertexNormalWS,info.anisotropicT);info.ToV=dot(info.anisotropicT,info.viewDir);info.BoV=dot(info.anisotropicB,info.viewDir);info.at=mix(surface.roughness,1.0,pow2(surface.anisotropy));info.ab=surface.roughness;\n#endif\n#ifdef THICKNESS\ninfo.worldScale=v_WorldScale;\n#endif\n#ifdef LIGHTMAP\n#ifdef UV1\ninfo.lightmapUV=pixel.uv1;\n#endif\n#endif\n}vec3 PBRLighting(const in Surface surface,const in PixelInfo info){vec3 lightColor=vec3(0.0);\n#ifdef DIRECTIONLIGHT\nfor(int i=0;i<CalculateLightCount;i++){if(i>=DirectionCount)break;DirectionLight directionLight=getDirectionLight(i,info.positionWS);if(directionLight.lightMode!=LightMode_Mix){Light light=getLight(directionLight);lightColor+=PBRLighting(surface,info,light)*light.attenuation;}}\n#endif\n#if defined(POINTLIGHT) || defined(SPOTLIGHT)\nivec4 clusterInfo=getClusterInfo(u_View,u_Viewport,info.positionWS,gl_FragCoord,u_ProjectionParams);\n#endif\n#ifdef POINTLIGHT\nfor(int i=0;i<CalculateLightCount;i++){\n#ifdef BREAK_TEXTURE_SAMPLE\nif(i>=clusterInfo.x)break;\n#endif\nPointLight pointLight=getPointLight(i,clusterInfo,info.positionWS);if(pointLight.lightMode!=LightMode_Mix){Light light=getLight(pointLight,info.normalWS,info.positionWS);\n#ifndef BREAK_TEXTURE_SAMPLE\nif(i<clusterInfo.x)\n#endif\nlightColor+=PBRLighting(surface,info,light)*light.attenuation;}}\n#endif\n#ifdef SPOTLIGHT\nfor(int i=0;i<CalculateLightCount;i++){\n#ifdef BREAK_TEXTURE_SAMPLE\nif(i>=clusterInfo.y)break;\n#endif\nSpotLight spotLight=getSpotLight(i,clusterInfo,info.positionWS);if(spotLight.lightMode!=LightMode_Mix){Light light=getLight(spotLight,info.normalWS,info.positionWS);\n#ifndef BREAK_TEXTURE_SAMPLE\nif(i<clusterInfo.y)\n#endif\nlightColor+=PBRLighting(surface,info,light)*light.attenuation;}}\n#endif\nvec3 giColor=PBRGI(surface,info);vec3 color=lightColor+giColor;\n#ifdef EMISSION\ncolor+=surface.emissionColor;\n#endif\nreturn color;}\n#endif\n";

    var PBRMetallicGLSL = "#if !defined(PBRMetallic_lib)\n#define PBRMetallic_lib\n#include \"ShadingFrag.glsl\";\n#include \"PBRFrag.glsl\";\nstruct SurfaceInputs{vec3 diffuseColor;float alpha;float alphaTest;float metallic;float smoothness;float occlusion;vec3 emissionColor;vec3 normalTS;\n#ifdef CLEARCOAT\nfloat clearCoat;float clearCoatRoughness;\n#ifdef CLEARCOAT_NORMAL\nvec3 clearCoatNormalTS;\n#endif\n#endif\n#ifdef ANISOTROPIC\nfloat anisotropy;vec2 anisotropyDirection;\n#endif\n};void initSurface(inout Surface surface,const in SurfaceInputs inputs,const in PixelParams pixel){surface.alpha=inputs.alpha;surface.normalTS=inputs.normalTS;vec3 baseColor=inputs.diffuseColor;float metallic=inputs.metallic;float perceptualRoughness=1.0-inputs.smoothness;float ior=1.5;surface.ior=1.5;vec3 f0=vec3(0.04,0.04,0.04);surface.perceptualRoughness=clamp(perceptualRoughness,MIN_PERCEPTUAL_ROUGHNESS,1.0);surface.roughness=surface.perceptualRoughness*surface.perceptualRoughness;surface.diffuseColor=computeDiffuse(baseColor,metallic);surface.f0=computeF0(f0,baseColor,metallic);surface.f90=computeF90(surface.f0);surface.occlusion=inputs.occlusion;\n#ifdef EMISSION\nsurface.emissionColor=inputs.emissionColor;\n#endif\n#ifdef CLEARCOAT\nsurface.clearCoat=inputs.clearCoat;surface.clearCoatPerceptualRoughness=clamp(inputs.clearCoatRoughness,MIN_PERCEPTUAL_ROUGHNESS,1.0);surface.clearCoatRoughness=surface.clearCoatPerceptualRoughness*surface.clearCoatPerceptualRoughness;\n#ifdef CLEARCOAT_NORMAL\nsurface.clearCoatNormalTS=inputs.clearCoatNormalTS;\n#endif\n#endif\n#ifdef ANISOTROPIC\nsurface.anisotropy=inputs.anisotropy;surface.anisotropyDirection=inputs.anisotropyDirection;\n#endif\n}vec4 PBR_Metallic_Flow(const in SurfaceInputs inputs,in PixelParams pixel){\n#ifdef ALPHATEST\nif(inputs.alpha<inputs.alphaTest){discard;}\n#endif\nSurface surface;initSurface(surface,inputs,pixel);PixelInfo info;getPixelInfo(info,pixel,surface);vec3 surfaceColor=vec3(0.0);surfaceColor+=PBRLighting(surface,info);return vec4(surfaceColor,surface.alpha);}\n#endif\n";

    const dfg_128 = "Iz9SQURJQU5DRQojIGNtZ2VuCkZPUk1BVD0zMi1iaXRfcmxlX3JnYmUKR0FNTUE9MQpFWFBPU1VSRT0wCgotWSAxMjggK1ggMTI4CgICAIAJCwoKCQkICAcHAwcGBgMGBQUEBQUEBIQEhwOKAosBhwKQAbYAgPnz7ujj3djTzsvIxcK/vLq3tbOwrqyqqKakoqCenZuZl5aVk5KQj42Mi4mIh4aEg4KBgP78+vj29fPx7+3r6efl4+Lg393c2tnX1tTT0dDPzczKycjHxcTDwsG/vr28u7q5t7a1tLOysbCvrq2srKuqqainpqWkpKOioaCgn56dgJ+alpOQjYuIhoSCgH59e3l4dnV0cnFvbm1samloZ2ZlZGNiYWBfXl1cW1pZWFdXVlVUU6WkoqGfnpybmZiWlZOSkI+OjIuKiIeGhIOCgH9+fXt6eXh3dXRzcnFvbm1sa2ppZ2ZlZGNiYWBfXVxbWllYV1ZVVFNSUVBPTk1LSklIs4DNfwICAIAJCwoKCQkICAcHAwcGBgMGBQWDBYUEiAOKAosBhgKQAbYAgPnz7unj3tjTz8vIxcK/vbq4tbOxr6yqqKalo6GfnZuamJeVlJKRkI6Ni4qJh4aFhIOCgYD+/Pr49vTy8O7s6unn5ePi4N/d3NrZ19bU09LQz87My8rIx8bFxMLBwL++vby6ubi3trW0s7KxsK+ura2sq6qpqKempqWko6KioaCfgJ+al5OQjYuJhoSCgH99e3p4dnV0cnFwbm1sa2loZ2ZlZGNiYWBfXl1cW1pZWFdXVlVUU1KkoqGfnpybmZiWlZOSkI+OjIuKiIeGhIOCgH9+fXt6eXh2dXRzcnBvbm1sa2loZ2ZlZGNiYF9eXVxbWllYV1ZVVFJRUE9OTUxLSklItIDMfwICAIAHCwoKCQkICAUIBwcGBgQGBgUFBAUFBASEBIcDigKMAYYCkAG1AID59O7p5N7Z1M/MycbDwL67uba0srCuq6mopqSioJ6dm5mYlpWUkpGQjo2MiomIh4WEg4KBgP/9+/n39fTy8O7s6unn5eTi4d/e3NvZ2NfV1NPR0M/NzMvKyMfGxcTDwsC/vr28u7q5uLe2tbSzsrGxsK+urayrqqqpqKempqWko4Cgm5eUkY6LiYeFg4F/fXt6eHd1dHJxcG5tbGtqaGdmZWRjYmFgX15dXFtaWVhXV1ZVVFNSUqKhn52cmpmXlpWTkpCPjYyLiYiHhYSDgYB/fnx7enl3dnV0cnFwb25sa2ppaGdmZGNiYWBfXl1cWllYV1ZVVFNSUVBPTk1MS0pJR7WAy38CAgCACgsLCgoJCQgIBwcDBwYGBAYGBQUEBQUEBIMEiAOKAo0BhQKQAbQAgPn07unk39rU0M3JxsTBvry6t7Wzsa+sq6mnpaOhoJ6cm5mYlpWUkpGQjo2MiomIh4aFhIOCgYD+/Pv59/Xz8e/u7Orp5+Xk4+Hg3t3c2tnX1tXU0tHQzs3My8rJyMfFxMPCwcC/vr28u7q5uLe2trW0s7KxsK+vrq2sq6uqqaiogKCbl5SRjoyJh4WDgX99fHp5d3V0c3Fwb21sa2ppZ2ZlZGNiYWBfXl1cW1pZWFdXVlVUU1JSUVCfnZyamZeWlJORkI+NjIqJiIaFhIKBgH59fHt5eHd2dHNycXBubWxramlnZmVkY2JhX15dXFtaWVhXVlVTUlFQT05NTEtKSUhHt4DJfwICAIAKCwsKCgkJCAgHBwMHBgYEBgYFBYMFhQSIA4oCjQGEApABtACA+fTv6uTf2tXQzcrHxMK/vbq4trSysK6sqqimpKOhn56cmpmYlpWUkpGQjo2Mi4qIh4aFhIOCgYD//vz6+Pf18/Hv7uzr6efm5ePi4d/e3Nva2dfW1dTS0dDPzs3LysnIx8bFxMPCwcC/vr28u7q6ubi3trW0tLOysbCwr66trayAoZyYlJGPjIqHhYOBf358enl3dnRzcXBvbWxramlnZmVkY2JhYF9eXVxbWllYV1dWVVRTUlJRUE+dnJqZl5aUk5GQjo2MiomHhoWDgoF/fn18enl4d3V0c3Jwb25tbGppaGdmZWRiYWBfXl1cW1lYV1ZVVFNSUVBPTkxLSklIR0a4gMh/AgIAgAgMCwoKCQkICAMIBwcDBwYGBAYGBQUEBQUEBIQEhwOLAo4BgwKQAbMAgPn07+rl4NvW0c7LyMXCwL67ube1s7Gvraupp6akoqCfnZyamZeWlZSSkZCPjYyLiomIh4aFhIOCgYD//fz6+Pb18/Hw7u3r6ujn5eTj4eDf3tzb2tnX1tXU0tHQz87NzMvKycjHxsXEw8LBwMC/vr28u7q5ubi3trW1tLOysrGwgKGcmJWSj4yKiIaEgoB+fHt5d3Z0c3Jwb25sa2ppaGZlZGNiYWBfXl1cW1pZWFhXVlVUU1JSUVBPTk6amZeWlJORkI6Ni4qJh4aEg4KAf359e3p5d3Z1dHJxcG9ubGtqaWhmZWRjYmFgXl1cW1pZWFdWVFNSUVBPTk1MS0pJSEdGuoDGfwICAIALDAsLCgoJCQgIBwcDBwYGBAYGBQWDBYYEhwOLAo8BBAICAQGOAbIAgPn07+rl4NvX0s7LycbDwb68uri2tLKwrqyqqKelo6Kgnp2bmpmYlpWUk5GQj46Ni4qJiIeGhYSDgoKBgP/9/Pr49vXz8vDv7ezq6ejm5eTi4eDf3tzb2tnY1tXU09LR0M/OzczLysnIx8bFxMTDwsHAv76+vby7urq5uLe3trW0gKKdmZWSj42KiIaEgoB+fXt5eHZ1c3Jwb25ta2ppaGdlZGNiYWBfXl1cW1pZWFhXVlVUU1JSUVBPTk1NTJeVlJKRj46Ni4qIh4aEg4KAf358e3p4d3Z1c3JxcG5tbGtqaGdmZWRjYWBfXl1cW1lYV1ZVVFNSUVBOTUxLSklIR0ZFvIDEfwICAIAJDAsLCgoJCQgIAwgHBwMHBgYEBgYFBYMFhQSIA4oCkQEDAgEBjQGyAID59O/r5uHc19PPzMnGxMG/vbu5t7Wzsa+tq6qopqWjoaCenZuamZiWlZSTkpCPjo2Mi4qJiIeGhYSDgoKBgP/9/Pr49/X08vHv7u3r6unn5uXk4+Hg397d29rZ2NfW1dTT0tHQz87NzMvKycnIx8bFxMTDwsHAwL++vb28u7q6uYCinZmWk5CNi4mGhIKAf317enh2dXNycW9ubWtqaWhnZmRjYmFgX15dXFtaWVhYV1ZVVFNSUVFQT05NTUxLSpSSkY+OjIuKiIeFhIOBgH99fHt5eHd1dHNycG9ubWxqaWhnZmRjYmFgX11cW1pZWFdWVFNSUVBPTk1MS0pIR0ZFRL6Awn8CAgCABwwMCwoKCQkFCQgIBwcEBwcGBgMGBQWDBYYEiAOKApEBAwABAY0BsQCA+fTw6+bh3djT0M3Kx8XCwL68uri2tLKwrqyrqaempKOhoJ6dm5qZmJeVlJOSkZCPjYyLiomIiIeGhYSDgoKBgP/+/Pr59/b08/Lw7+7s6+rp5+bl5OPi4d/e3dzb2tnY19bV1NPS0dDQz87NzMvKysnIx8bGxcTDwsLBwMC/vr6Ao56alpOQjouJh4WDgX99e3p4d3V0cnFwbm1samloZ2ZlY2JhYF9eXVxbWllYWFdWVVRTUlFRUE9OTU1MS0pKSZGPjoyLiYiGhYSCgYB+fXx6eXh2dXRzcXBvbmxramlnZmVkY2JgX15dXFtZWFdWVVRTUlFPTk1MS0pJSEdGRUTAgMB/AgIAgAoMDAsLCgoJCQgIAwgHBwMHBgYEBgYFBYMFhgSHA4sCkQGDAI0BsACA+fXw6+fi3dnU0M3LyMXDwb+9urm3tbOxr62sqqmnpaSioZ+enZuamZiXlpWTkpGQj46NjIuKiYiHhoaFhIODgoGAgP78+/n49/X08/Hw7+7s6+rp6Ofm5OPi4eDf3t3c29rZ2NfX1tXU09LR0M/Pzs3MzMvKycjIx8bGxcTEw8KAo56al5SRjoyJh4WDgX99fHp4d3V0cnFwbm1sa2loZ2ZlZGJhYF9eXVxbWllYWFdWVVRTUlFRUE9OTU1MS0pJSUhHRoyKiYiGhYOCgX9+fXt6eXd2dXNycXBubWxraWhnZmVjYmFgX15cW1pZWFdVVFNSUVBPTk1LSklIR0ZFREPDgL1/AgIAgAgNDAsLCgoJCQUJCAgHBwQHBwYGBAYGBQWDBYYEhwOLApEBhACLAbAAgPn18Ozn4t7Z1dHOy8nGxMLAvbu5uLa0srCurauqqKelpKKhn56dm5qZmJeWlZSTkpGPjo2MjIuKiYiHhoaFhIODgoGBgP79/Pr5+Pb19PPx8O/u7ezr6ejn5uXk4+Lh4N/e3d3c29rZ2NfW1tXU09LS0dDPz87NzMzLysrJyMjHgKSfm5eUkY+MioeFg4GAfnx6eXd2dHNxcG9tbGtqaGdmZWRjYmBfXl1cW1pZWVhXVlVUU1JRUVBPTk1MTEtKSUlIR0ZGRYmHhoSDgoB/fnx7enh3dnRzcnBvbm1ramloZmVkY2JgX15dXFtZWFdWVVRTUlBPTk1MS0pJSEZFRENCxYC7fwICAIALDQwMCwsKCgkJCAgDCAcHAwcGBgQGBgUFgwWGBIgDiwKRAYUAigGvAID59fDs5+Pe2tbRz8zJx8XCwL68uri3tbOxsK6sq6mopqWjoqGfnp2cm5qYl5aVlJOSkZCPjo2Mi4uKiYiHhoaFhISDgoKBgP/+/fv6+ff29fTz8vHv7u3s6+rp6Ofm5eTj4uLh4N/e3dzc29rZ2NfX1tXV1NPS0tHQ0M/Ozs3MzICkn5uYlZKPjIqIhoSCgH58e3l3dnRzcXBvbWxramhnZmVkY2JhX15dXFtaWVlYV1ZVVFNSUVFQT05NTExLSklISEdGRUVEQ4aEg4GAf318enl4dnV0c3Fwb21sa2poZ2ZlZGJhYF9eXFtaWVhXVVRTUlFQT05MS0pJSEdGRURDQceAuX8CAgCACQ0MDAsLCgoJCQMJCAgDCAcHAwcGBgQGBgUFgwWGBIgDigKSAYcAiAGuAID59fHs6OPf29bSz83KyMXDwb+9u7m4trSysa+urKupqKalo6Khn56dnJuamZiXlpWUk5KRkI+OjYyLi4qJiIeHhoWFhIODgoGAgP/+/Pv6+fj39vTz8vHw7+7t7Ovq6ejn5+bl5OPi4uHg397e3dzb29rZ2NjX1tbV1NTT0tLR0YCloJyYlZKPjYqIhoSCgH59e3l4dnVzcnBvbmxramlnZmVkY2JhYF9dXFtaWllYV1ZVVFNSUVBQT05NTEtLSklISEdGRUVEQ0JCQYGAfn17enl3dnVzcnFwbm1samloZ2VkY2JhX15dXFtZWFdWVVRTUVBPTk1MS0pIR0ZFRENCQcqAtn8CAgCADA0NDAwLCwoKCQkICAMIBwcEBwcGBgQGBgUFgwWGBIgDigKRAYoAhQGuAID59fHs6OTg29fT0M3LyMbEwsC+vLq5t7WzsrCvrayqqaempaOioZ+enZybmpmYl5aVlJOSkZCPj46NjIuLiomIiIeGhoWEhIOCgoGAgP/+/fz6+fj39vX08/Lx8fDv7u3s6+rp6Ojn5uXk5OPi4uHg397e3dzc29va2dnY19fW1oCmoJyZlpOQjYuJhoSCgH99e3p4dnVzcnFvbm1ramloZmVkY2JhYF9eXVxbWllYV1ZVVFNSUVBQT05NTEtLSklIR0dGRUREQ0JCQUA/P3x7enh3dnRzcnBvbm1ramlnZmVkYmFgX15cW1pZWFdVVFNSUVBOTUxLSklIR0VEQ0JBQM2As38CAgCACg4NDAwLCwoKCQkDCQgIAwgHBwMHBgaDBoUFhgSHA4sCkQGMAIMBrQCA+fXx7enk4NzY1NDOzMnHxcPBv727uri2tbOxsK6tq6qpp6alo6KhoJ+enZybmpmYl5aVlJOSkZCPj46NjIyLiomJiIeHhoaFhISDgoKBgYD//v38+/r5+Pf39vX08/Lx8O/u7u3s6+rq6ejn5+bl5eTj4uLh4eDf397d3dzc29uApqGdmZaTkI6LiYeFg4F/fXt6eHd1dHJxb25ta2ppaGZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQUE9OTUxLS0pJSEdHRkVERENCQUFAPz8+PTx4d3V0c3Fwb21sa2loZ2ZkY2JhX15dXFtZWFdWVVRSUVBPTk1MSklIR0ZFRENBQD/QgLB/AgIAgA0ODQ0MDAsLCgoJCQgIBAgIBwcDBwYGBAYGBQWDBYYEiAOLApEBuwCA+fXx7enl4d3Z1NHPzMrIxcPCwL68urm3trSysa+urauqqaempaOioaCfnp2cm5qZmJeWlZSUk5KRkI+Pjo2NjIuKiomJiIeHhoaFhISDg4KBgYCA//79/fz7+vn49/b19fTz8vHw8O/u7e3s6+vq6eno5+fm5eXk5OPi4uHh4OCAp6KdmpeUkY6MiYeFg4F/fnx6eHd1dHJxcG5tbGppaGdlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT09OTUxLSkpJSEdGRkVEQ0NCQUBAPz4+PTw8Ozo5cnFvbm1samloZmVkY2FgX15cW1pZWFZVVFNSUU9OTUxLSklHRkVEQ0JBQD/UgKx/AgIAgAsODQ0MDAsLCgoJCQMJCAgDCAcHBAcHBgYEBgYFBYMFhgSIA4sCkAG7AFj59fHt6eXh3dnV0s/Ny8jGxMLBv727uri3tbOysK+urKuqqaempaSioaCfnp2cnJuamZiXlpWUk5OSkZCQj46OjYyLi4qKiYmIh4eGhoWEhIODgoKBgYCAKID//v38+/v6+fj39vb19PPz8vHx8O/v7u3t7Ozr6urp6Ojn5+bm5eWAqKKempeUkY+MioiGg4KAfnx6eXd2dHNxcG5tbGppaGdmZGNiYWBfXl1cW1pZWFdWVVRTUlFQT09OTUxLSkpJSEdGRkVEQ0NCQUBAPz49PTw7Ozo5OTg3NzZramhnZmVjYmFgXl1cW1lYV1ZVU1JRUE9OTEtKSUhHRkRDQkFAPz7ZgKd/AgIAgAwODg0NDAwLCwoKCQkDCQgIAwgHBwQHBwYGBAYGBQWDBYYEiAOLApABugBW+vby7urm4t7a1tLQzsvJx8XDwcC+vLu5uLa1s7Kwr66sq6qpp6alpKOioaCfnp2cm5qZmZiXlpWUk5OSkZGQj4+OjY2Mi4uKiomJiIiHhoaFhYSEg4MHg4KCgYGAgCOA//79/fz7+vn5+Pf39vX19PPz8vLx8PDv7+7u7e3s7Ovr6oCoo5+bmJWSj42KiIaEgoB+fHt5d3Z0c3Fwb21sa2loZ2ZkY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk5NTEtKSUlIR0ZFRURDQkJBQD8/Pj09PDs6Ojk4ODc2NjU0NDMyZGNhYF9eXVtaWVhWVVRTUlBPTk1MS0lIR0ZFRENBQD8+Pd6Aon8CAgCACg8ODQ0MDAsLCgoFCgkJCAgECAgHBwMHBgaDBoUFhgSIA4oCkQG5AFb69vLu6ubi3tvX09DOzMrIxsTCwb+9vLq5t7a0s7Gwr62sq6qpp6alpKOioaCfnp2dnJuamZiYl5aVlJSTkpKRkJCPjo6NjYyMi4uKiYmIiIeHhoaFhQeFhISDg4KCA4KBgSCBgID///79/fz7+/r5+fj49/f29fX09PPz8vLx8fDw74CppJ+bmJWSkI2LiIaEgoB/fXt5eHZ1c3Jwb21sa2poZ2ZlY2JhYF9eXVxbWllYV1ZVVFNSUVBPTk5NTEtKSUhIR0ZFRURDQkFBQD8+Pj08PDs6Ojk4Nzc2NTU0MzMyMTEwMC9dXFtZWFdWVVNSUVBPTUxLSklIRkVEQ0JBQD49POOAnX8CAgCADQ8ODg0NDAwLCwoKCQkDCQgIAwgHBwQHBwYGBAYGBQWDBYcEiAOKApEBuABU+vby7urn49/b2NTRz83LycfFw8HAvry7uri3tbSysbCvrayrqqmopqWko6KhoKCfnp2cnJuamZiYl5aVlZSTk5KRkZCQj46OjY2MjIuLioqJiYiIB4iHh4aGhYUFhYSEg4MDg4KCA4KBgQOBgIASgP///v79/fz7+/r6+fn4+Pf3Bff29vX1gKqkoJyZlpOQjouJh4WDgX99e3p4dnVzcnBvbmxramhnZmVkYmFgX15dXFtaWVhXVlVUU1JRUE9OTU1MS0pJSEhHRkVERENCQUFAPz4+PTw7Ozo5OTg3NzY1NDQzMzIxMTAvLy4tLSwsKypUU1FQT05NTEpJSEdGRUNCQUA/Pj076oCWfwICAIALDw8ODQ0MDAsLCgoDCgkJAwkICAMIBwcEBwcGBgQGBgUFgwWHBIcDiwKQAbgAVPr28u/r5+Pg3NjV0tDNy8nHxcTCwb+9vLu5uLa1tLKxsK+trKuqqainpqWko6KhoJ+fnp2cnJuamZmYl5aWlZSUk5OSkZGQkI+Pjo6NjYyMi4uKigeKiYmIiIeHA4eGhgOGhYUDhYSEA4SDgwODgoIEgoKBgQOBgIAEgID//wn//v79/fz8+/sC+/qAqqWgnZmWk5GOjImHhYOBf318enh3dXRycW9ubGtqaWdmZWRiYWBfXl1cW1pZWFdWVVRTUlFQT05NTExLSklIR0dGRURDQ0JBQEA/Pj09PDs6Ojk4ODc2NjU0NDMyMjEwMC8uLi0sLCsrKikpKCgnJiYlJUhHRkVEQ0FAPz49PDvzgI1/AgIAgAwPDw4ODQ0MDAsLCgoFCgkJCAgECAgHBwQHBwYGBAYGBQWDBYYEiAOLApABtwBU+vby7+vo5ODd2dbS0M7MysjGxcPBwL69u7q5t7a1s7KxsK+urKuqqainpqWko6KioaCfn56dnJybmpmZmJeXlpWVlJSTk5KSkZGQkI+Pjo6NjYyMBYyLi4qKA4qJiQOJiIgDiIeHA4eGhgOGhYUEhYWEhAOEg4MEg4OCgoOChIGGgICrpqGdmpeUkY+MioiFg4GAfnx6eXd1dHJxb25ta2ppZ2ZlZGNhYF9eXVxbWllYV1ZVVFNSUVBPTk1MTEtKSUhHRkZFRENCQkFAPz8+PTw8Ozo6OTg3NzY1NTQzMzIxMTAvLy4tLSwrKyoqKSgoJycmJSUkJCMiIiEhICAfHh4dHf+AAYACAgCAChAPDw4NDQwMCwsFCwoKCQkDCQgIBAgIBwcDBwYGgwaFBYYEiAOLApABtgBL+vbz7+zo5OHd2tbT0c/Ny8nHxcTCwb++vLu6uLe2tLOysbCvrq2sqqmop6ampaSjoqKhoJ+fnp2dnJuampmYmJeXlpaVlJSTk5KSB5KRkZCQj48Fj46OjY0FjYyMi4sDi4qKA4qJiQSJiYiIBIiIh4cDh4aGBIaGhYWDhYWEhYMCgoKArKainpqXlJKPjYqIhoSCgH58e3l3dnRzcXBubWtqaWhmZWRjYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtLSklIR0ZGRURDQkJBQD8+Pj08Ozs6OTk4NzY2NTQ0MzIyMTAwLy4uLSwsKysqKSkoJycmJiUkJCMjIiEhICAfHx4dHRz/gAGAAgIAgA0QEA8ODg0NDAwLCwoKAwoJCQMJCAgDCAcHBAcHBgaDBoUFhgSIA4oCkQG1AE369vPv7Ojl4d7b19TRz83MysjGxcPCwL+9vLu5uLe2tLOysbCvrq2sq6qpqKempaSko6KioaCgn56dnZybm5qamZiYl5eWlpWVlJSTkwWTkpKRkQWRkJCPjwOPjo4Djo2NA42MjAOMi4sEi4uKigSKiomJBImJiIiDiIWHhoaDhYCtp6Kfm5iVkpCNi4iGhIKAfn17eXh2dHNxcG5tbGppaGZlZGNiYF9eXVxbWllYV1ZVVFNSUVBPTk1MS0pKSUhHRkVFRENCQUFAPz49PTw7Ojo5ODg3NjU1NDMzMjExMC8vLi0tLCsrKiopKCgnJiYlJSQjIyIiISAgHx8eHh0cHP+AAYACAgCADhAQDw8ODg0NDAwLCwoKAwoJCQMJCAgDCAcHBAcHBgaDBoUFhgSIA4oCkAG1AE369vPw7Onl4t/b2NXS0M7MysnHxcTCwcC+vby6ubi3tbSzsrGwr66trKuqqainp6alpKSjoqKhoKCfnp6dnZybm5qamZmYmJeXlpaVlQWVlJSTkwOTkpIFkpGRkJADkI+PBI+Pjo4Djo2Ng42EjISLhoqGiYWIgK2oo5+cmJWTkI6LiYeFg4F/fXt6eHZ1c3Jwb21sa2loZ2VkY2JhX15dXFtaWVhXVlVUU1JRUE9OTUxLSklJSEdGRUREQ0JBQEA/Pj08PDs6OTk4Nzc2NTQ0MzIyMTAwLy4uLSwsKyoqKSkoJycmJSUkJCMiIiEhIB8fHh4dHRwb/4ABgAICAIAMERAQDw4ODQ0MDAsLAwsKCgMKCQkDCQgIAwgHBwQHBwYGBAYGBQWEBYYEiAOKApABtABI+vbz8O3p5uPf3NnV09HPzcvJyMbFw8LBv769u7q5uLe1tLOysbCvrq2srKuqqainpqalpKSjo6KhoaCfn56enZycm5uampmZB5mYmJeXlpYDlpWVA5WUlAOUk5MDk5KSA5KRkQSRkZCQA5CPj4OPhY6GjYaMh4uArqikoJyZlpORjoyJh4WDgX99fHp4dnVzcnBvbWxraWhnZWRjYmFfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhIR0ZFRENDQkFAPz8+PTw7Ozo5OTg3NjY1NDMzMjExMC8vLi0tLCsrKikpKCgnJiYlJCQjIyIhISAgHx4eHR0cHBv/gAGAAgIAgA0RERAPDw4ODQ0MDAsLBQsKCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhwSIA4oCkAGzAEr69/Pw7erm4+Dd2dbT0c/OzMrIx8XEw8HAv768u7q5uLe1tLOysrGwr66trKuqqamop6ampaWko6OioqGgoJ+fnp6dnZycm5uamgWamZmYmAOYl5cDl5aWA5aVlQOVlJQElJSTkwSTk5KSBJKSkZGDkYaQh4+JjoCvqaWhnZqXlJGPjIqIhoOBgH58enh3dXRycW9ubGtqaGdmZGNiYV9eXVxbWllYV1ZVVFNSUVBPTk1MS0pJSEdHRkVEQ0JCQUA/Pj49PDs6Ojk4ODc2NTU0MzIyMTAwLy4uLSwsKyoqKSgoJycmJSUkIyMiIiEgIB8fHh0dHBwbG/+AAYACAgCAEBIREBAPDw4ODQ0MDAsLCgoDCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhwSHA4sCjwGzAEf69/Tw7ern5ODd2tfU0tDOzcvJyMbFxMLBwL69vLu6ubi3trW0s7KxsK+uraysq6qpqKinp6alpaSko6OioqGhoJ+fnp6dnQWdnJybmwWbmpqZmQSZmZiYBJiYl5cDl5aWBJaWlZUElZWUlIOUh5OHkomRApCQgLCqpaGempeUko+NioiGhIKAfnx6eXd1dHJxb25sa2poZ2ZkY2JhYF5dXFtaWVhXVlVUU1JRUE9OTUxLSklIR0ZGRURDQkFBQD8+PT08Ozo5OTg3NjY1NDQzMjExMC8vLi0tLCsrKikpKCcnJiYlJCQjIiIhISAfHx4eHRwcGxsa/4ABgAICAIAMEhEREBAPDg4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYcEhwOKApABsgBJ+vf08e3q5+Th3tvY1dLRz83MysjHxsTDwsG/vr28u7q5uLe2tbSzsrGwsK+urayrq6qpqainp6ampaWkpKOjoqKhoaCgn5+engOenZ0FnZycm5sEm5uamgSampmZBJmZmJgEmJiXl4OXhZaIlYuUhJOAsaumop6bmJWSkI2LiYaEgoB+fXt5d3Z0c3Fwbm1ramhnZmVjYmFgXl1cW1pZWFdWVVRSUVBQT05NTEtKSUhHRkVFRENCQUA/Pz49PDw7Ojk4ODc2NTU0MzMyMTAwLy4uLSwsKyoqKSgoJyYmJSUkIyMiISEgIB8eHh0dHBsbGhr/gAGAAgIAgA8SEhEQEA8PDg4NDQwMCwsDCwoKAwoJCQMJCAgECAgHBwMHBgaDBoUFhgSIA4oCkAGxAEb69/Tx7uvo5eLf3NnW09HQzszLycjGxcTDwcC/vr28u7q5uLe2tbSzsrKxsK+urq2sq6uqqamoqKenpqalpaSko6OioqGhA6GgoAWgn5+engOenZ0EnZ2cnAScnJubg5uFmoWZh5iLl4iWgLKsp6OfnJmWk5COi4mHhYOBf317eXh2dHNxcG5ta2ppZ2ZlY2JhYF9dXFtaWVhXVlVTUlFQT05NTUxLSklIR0ZFRENDQkFAPz4+PTw7Ojo5ODc3NjU0NDMyMjEwLy8uLS0sKysqKSkoJycmJSUkJCMiIiEgIB8fHh0dHBwbGhoZ/4ABgAICAIAQExISERAQDw8ODg0NDAwLCwMLCgoDCgkJAwkICAMIBwcEBwcGBoMGhQWGBIgDigKPAbEAP/r39PHu6+jl4t/c2dbU0tDPzcvKycfGxcTCwcC/vr28u7q5uLe2tbS0s7KxsbCvrq2trKurqqqpqaiop6empgmmpaWkpKOjoqIDoqGhA6GgoASgoJ+fA5+enoOehZ2FnIebi5qMmYCyraikoJyZlpORjoyKh4WDgX99fHp4dnVzcnBubWxqaWdmZWRiYWBfXVxbWllYV1ZUU1JRUE9OTUxLSkpJSEdGRURDQkJBQD8+PT08Ozo5OTg3NjY1NDMzMjEwMC8uLi0sLCsqKikoKCcmJiUkJCMiIiEhIB8fHh4dHBwbGxoZGf+AAYACAgCADBMTEhEREBAPDg4NDQUNDAwLCwMLCgoDCgkJAwkICAMIBwcEBwcGBoMGhQWGBIgDigKPAbAAPvr39PHu6+nm4+Dd2tfU09HPzszLycjHxsTDwsHAv769vLu6ubi3tra1tLOzsrGwsK+ura2srKurqqqpqaioBainp6amBaalpaSkA6SjowOjoqIEoqKhoQOhoKCDoIafh56JnZKcgLOtqaShnZqXlJGPjIqIhoSCgH58enh3dXNycG9tbGppaGZlZGJhYF9dXFtaWVhXVVRTUlFQT05NTEtKSUhIR0ZFRENCQUFAPz49PDw7Ojk4ODc2NTU0MzIyMTAvLy4tLSwrKyopKSgnJyYlJSQjIyIhISAgHx4eHR0cGxsaGhkY/4ABgAICAIAPFBMSEhEREA8PDg4NDQwMAwwLCwULCgoJCQQJCQgIAwgHBwQHBwYGgwaFBYYEiAOJApABrwA9+vf08e/s6ebj4N7b2NXT0tDOzcvKycfGxcTDwsHAv769vLu6ubi4t7a1tbSzsrKxsLCvrq6traysq6uqqgWqqamoqAOop6cFp6ampaUDpaSkg6SEo4Wih6GJoJefgLSuqaWhnpuYlZKPjYuIhoSCgH58enl3dXRycG9tbGtpaGZlZGJhYF9dXFtaWVhXVVRTUlFQT05NTEtKSUhHRkZFRENCQUA/Pz49PDs6Ojk4Nzc2NTQzMzIxMTAvLi4tLCwrKikpKCcnJiUlJCQjIiIhICAfHx4dHRwbGxoaGRkY/4ABgAICAIAQFBMTEhIREBAPDw4ODQ0MDAUMCwsKCgMKCQkECQkICAMIBwcEBwcGBoMGhQWGBIcDigKPAa8APvr39PLv7Onn5OHe3NnW1NLRz87My8nIx8bFxMPCwcC/vr28u7q5ubi3tra1tLSzsrKxsLCvr66ura2srKurA6uqqgOqqakDqaioA6inpwOnpqYEpqalpYOlhqSIo5CiBqGhoqKhoYahAqKigLWvqqain5uYlZOQjouJh4WCgH99e3l3dnRycW9ubGtpaGdlZGNhYF9eXFtaWVhXVVRTUlFQT05NTEtKSUhHRkVERENCQUA/Pj09PDs6OTk4NzY1NTQzMjIxMC8vLi0tLCsqKikoKCcmJiUkJCMiIiEhIB8fHh0dHBwbGhoZGRgX/4ABgAICAIARFRQTExIRERAQDw8ODg0NDAwFDAsLCgoDCgkJBAkJCAgDCAcHBAcHBgaDBoUFhgSHA4oCjwGuAD369/Xy7+zq5+Ti39za19TT0dDOzcvKycjHxsXEw8LBwL++vby7u7q5uLi3tra1tLSzs7KxsbCwr6+urq2tA62srAOsq6sDq6qqBKqqqakDqaioBKiop6eEp4emjKWYpIC2sKuno5+cmZaTkY6MiYeFg4F/fXt5eHZ0c3FvbmxraWhnZWRjYWBfXlxbWllYVlVUU1JRUE9OTUxLSklIR0ZFRENCQkFAPz49PDw7Ojk4Nzc2NTQ0MzIxMTAvLi4tLCsrKikpKCcnJiUlJCMjIiEhICAfHh4dHBwbGxoZGRgYF/+AAYACAgCAEhUUFBMTEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkECQkICAMIBwcEBwcGBoMGhQWGBIcDigKOAa4APvr39fLv7ern5eLg3drY1dPS0M/OzMvKycfGxcTDw8LBwL++vb28u7q5ubi3t7a2tbS0s7OysrGxsLCvr66uBK6ura0Era2srAOsq6sEq6uqqgSqqqmphKmJqKKngLexrKikoJ2al5SRj4yKiIWDgX99fHp4dnVzcXBubWtqaGdlZGNhYF9eXFtaWVhWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQEA/Pj08Ozo6OTg3NjY1NDMyMjEwLy8uLS0sKyoqKSgoJyYmJSQkIyIiISAgHx4eHR0cGxsaGhkYGBcX/4ABgAICAIATFhUUFBMSEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkECQkICAMIBwcEBwcGBoMGhQWGBIcDigKOAa0APfr49fLw7ero5ePg3tvZ1tTS0dDOzczKycjHxsXEw8LCwcC/vr69vLu7urm5uLi3tra1tbS0s7OysrGxsLADsK+vBK+vrq4Erq6trQStraysg6yHq46qjqmOqoC4sq2ppaGempeVko+NioiGhIKAfnx6eHd1c3Fwbm1ramhnZmRjYmBfXlxbWllYVlVUU1JRUE9OTUxLSklIR0ZFRENCQUA/Pj49PDs6OTg4NzY1NDQzMjExMC8uLi0sKysqKSkoJycmJSQkIyIiISEgHx8eHR0cGxsaGhkYGBcXFv+AAYACAgCADxYVFRQUExISEREQDw8ODgcODQ0MDAsLAwsKCgMKCQkDCQgIBAgIBwcEBwcGBgQGBgUFhAWGBIcDiQKOAa0APPr49fLw7evo5uPh3tzZ19TT0tDPzszLysnIx8bFxMPCwsHAv7++vby8u7q6ubm4uLe3tra1tbS0s7OysgOysbEDsbCwg7CFr4WuiK2jrIatgLqzrqmlop6bmJWSkI2LiYaEgoB+fHp5d3VzcnBvbWtqaWdmZGNiYF9eXFtaWVhWVVRTUlFQT05NS0pJSEdHRkVEQ0JBQD8+PTw8Ozo5ODc3NjU0MzMyMTAvLy4tLCwrKiopKCcnJiUlJCMjIiEhIB8fHh4dHBwbGhoZGRgXFxYW/4ABgAICAIAQFxYVFRQTExISERAQDw8ODgcODQ0MDAsLAwsKCgMKCQkDCQgIBAgIBwcEBwcGBgQGBgUFhAWFBIgDiQKOAawANvr49fPw7uvp5uTh39za2NXU0tHQzs3My8rJyMfGxcTDwsLBwMC/vr69vLu7urq5ubi4t7e2tgW2tbW0tAW0s7OysoSyhbGGsImvl66Or4OwgLu0r6qmo5+cmZaTkI6MiYeFg4F/fXt5d3V0cnBvbWxqaWdmZGNiYF9eXFtaWVhWVVRTUlFQTk1MS0pJSEdGRURDQkJBQD8+PTw7Ojo5ODc2NTU0MzIxMTAvLi4tLCsrKikoKCcmJiUkJCMiIiEgIB8eHh0cHBsbGhkZGBcXFhYV/4ABgAICAIATFxcWFRUUExMSEhEQEA8PDg4NDQUNDAwLCwMLCgoDCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhgSHA4oCjQGsADf6+PXz8O7s6efk4uDd29jW1NPR0M/OzcvKycjIx8bFxMPDwsHBwL+/vr29vLy7u7q6ubm4uLe3Bbe2trW1A7W0tAS0tLOzhbOHso6xhLCVsYqygLy1sKuno6CdmpeUkY+MioeFg4F/fXt5d3Z0cnFvbWxqaWdmZWNiYF9eXFtaWVhWVVRTUlFPTk1MS0pJSEdGRURDQkFAPz8+PTw7Ojk4ODc2NTQzMzIxMC8vLi0sLCsqKSkoJycmJSQkIyIiISAgHx4eHR0cGxsaGRkYGBcWFhUV/4ABgAICAIAUGBcWFhUUFBMTEhEREBAPDw4ODQ0FDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYYEhwOJAo4BqwAz+vj18/Hu7Onn5eLg3tzZ19XT0tHQzs3My8rJyMfHxsXExMPCwsHAwL++vr29vLy7u7q6Bbq5ubi4A7i3twO3trYDtrW1hLWJtKCzi7SHtYC9trGsqKShnZqXlZKPjYqIhoSCf318enh2dHNxb25sa2loZmVjYmBfXlxbWllXVlVUU1JQT05NTEtKSUhHRkVEQ0JBQD8+PTw8Ozo5ODc2NTU0MzIxMTAvLi4tLCsqKikoKCcmJSUkIyMiISEgHx8eHR0cGxsaGhkYGBcXFhUVFP+AAYACAgCAFRkYFxYWFRQUExMSEREQEA8PDg4NDQUNDAwLCwMLCgoDCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhgSHA4kCjQGrADH6+Pbz8e7s6ujl4+He3NrY1tTT0dDPzs3My8rJyMfHxsXExMPCwsHBwMC/vr69vby8A7y7uwO7uroDurm5A7m4uAO4t7cEt7e2toq2mrWLtom3hLiAvreyramlop6bmJWSkI2LiYaEgoB+fHp4dnVzcW9ubGtpaGZlY2JhX15dW1pZV1ZVVFNRUE9OTUxLSklIR0ZFRENCQUA/Pj08Ozo5OTg3NjU0MzMyMTAvLy4tLCwrKikpKCcmJiUkJCMiIiEgHx8eHh0cHBsaGhkYGBcXFhUVFBT/gAGAAgIAgBYZGBgXFhYVFBQTExIRERAQDw8ODg0NBQ0MDAsLAwsKCgMKCQkDCQgIBAgIBwcEBwcGBgQGBgUFgwWGBIcDiQKNAaoAL/r49vPx7+zq6Obj4d/d29nW1NPS0dDPzszLy8rJyMfHxsXFxMPDwsLBwcDAv76+A769vQO9vLwDvLu7A7u6ugO6ubkEubm4uIa4nLeLuIi5h7oCu7uAv7mzrqqmop+cmZaTkI6LiYeFgoB+fHp5d3VzcXBubGtpaGZlY2JhX15dW1pZV1ZVVFNRUE9OTUxLSklHRkVEQ0JBQEA/Pj08Ozo5ODc2NjU0MzIxMTAvLi0tLCsqKikoJycmJSUkIyIiISAgHx4eHRwcGxoaGRkYFxcWFhUUFBP/gAGAAgIAgBcaGRgYFxYWFRQUExMSEREQEA8PDg4NDQUNDAwLCwMLCgoDCgkJAwkICAQICAcHBAcHBgYEBgYFBYMFhgSGA4kCjQGqADL6+Pbz8e/t6+jm5OLg3tvZ19XU09HQz87NzMvKycnIx8fGxcXExMPDwsLBwcDAv7++vgO+vb0Evb28vAS8vLu7BLu7urqDupq5i7qJu4i8hr2Awbq0r6uno6CdmpeUkY+MioeFg4F/fXt5d3VzcnBubWtqaGZlY2JhX15dW1pZV1ZVVFJRUE9OTUxKSUhHRkVEQ0JBQD8+PTw7Ozo5ODc2NTQ0MzIxMC8vLi0sKysqKSgoJyYlJSQjIyIhISAfHx4dHRwbGxoZGRgXFxYWFRQUExP/gAGAAgIAgBgbGhkYGBcWFhUUFBMTEhEREBAPDw4ODQ0FDQwMCwsDCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQWDBYUEhwOJAo0BqQAw+vj29PHv7evp5+Ti4N7c2tjW1NPS0dDPzs3My8rJycjIx8bGxcXExMPDwsLBwcDAA8C/vwO/vr4Evr69vYO9hbybu4q8h72Ivoe/g8CAwru1sKyopKGempeVko+NioiGg4F/fXt5d3Z0cnBvbWtqaGdlZGJhX15dW1pZV1ZVVFJRUE9OTUtKSUhHRkVEQ0JBQD8+PTw7Ojk4ODc2NTQzMjExMC8uLS0sKyopKSgnJiYlJCQjIiEhIB8fHh0dHBsbGhkZGBgXFhYVFRQTExL/gAGAAgIAgBcbGhoZGBgXFhYVFBQTExIRERAQDw8ODgcODQ0MDAsLAwsKCgMKCQkDCQgIBAgIBwcEBwcGBgQGBgUFgwWFBIcDiAKNAakAKfr49vTy7+3r6efl4+Hf3dvZ19XU09HQz87OzczLysnJyMjHx8bFxcTEBcTDw8LCBcLBwcDABMDAv7+Dv4W+ir0EvLy9vY69ib6Iv4fAhsGGwgHDgMO8t7KtqaWinpuYlZOQjYuIhoSCgH58enh2dHJwb21ramhnZWRiYV9eXVtaWVdWVVNSUVBPTUxLSklIR0ZFRENCQUA/Pj08Ozo5ODc2NTQ0MzIxMC8vLi0sKysqKSgnJyYlJSQjIiIhICAfHh4dHBwbGhoZGBgXFhYVFRQTExIS/4ABgAICAIAYHBsaGhkYGBcWFhUUFBMTEhEREBAPDw4OBQ4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwQHBwYGBAYGBQUEBQUEBIQEhwOIAo0BqAAp+vj29PLw7uvp5+Xj4d/d29nY1tTT0tHQz87NzMzLysrJyMjHx8bGxcUFxcTEw8MDw8LCA8LBwQTBwcDAhMCJv4m+i7+JwIjBhsKGw4bEhMWAxb64s66qpqOfnJmWk5GOjImHhIKAfnx6eHZ0cnFvbWxqaGdlZGJhX15dW1pYV1ZVU1JRUE5NTEtKSUhHRURDQkFAPz49PDs6OTk4NzY1NDMyMTEwLy4tLCwrKikpKCcmJSUkIyMiISAgHx4eHRwcGxoaGRgYFxcWFRUUExMSEhH/gAGAAgIAgBkdHBsaGhkYGBcWFhUUFBMTEhEREBAPDw4OBQ4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwMHBgaDBoQFhgSGA4kCjAGoACv6+Pb08vDu7Oro5uTi4N7c2tjW1dPT0tHQz87NzMzLysrJycjIx8fGxsXFA8XExATExMPDA8PCwoPCisGOwIjBicKHw4bEhsWGxoXHAciAxr+5tK+rp6SgnZqXlJGPjIqHhYOBfnx6eHZ1c3FvbmxqaWdlZGJhX15dW1pYV1ZVU1JRUE5NTEtKSUdGRURDQkFAPz49PDs6OTg3NjU1NDMyMTAvLi4tLCsqKikoJycmJSQkIyIhISAfHx4dHBwbGhoZGRgXFxYVFRQUExISERH/gAGAAgIAgBoeHRwbGhoZGBgXFhYVFBQTExIRERAQDw8ODgUODQ0MDAUMCwsKCgMKCQkDCQgIBAgIBwcDBwYGBAYGBQWDBYUEhwOIAowBqAAm+vj29PLw7uzq6Obk4uDf3dvZ19XU09LR0M/Pzs3MzMvKysnJyMgFyMfHxsYDxsXFBMXFxMQExMTDw4XDl8KHw4jEhcWHxoXHhsiFyYPKgMjAurWxrKiloZ6bmJWSj42KiIaDgX99e3l3dXNxb25samlnZWRiYV9eXVtaWFdWVFNSUU9OTUxLSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTEwLy4tLCwrKikoKCcmJSQkIyIiISAfHx4dHRwbGxoZGRgXFxYVFRQUExISEREQ/4ABgAICAIAZHh4dHBsaGhkYGBcWFhUUFBMTEhIREBAPDwcPDg4NDQwMBQwLCwoKAwoJCQMJCAgECAgHBwMHBgYEBgYFBYMFhQSHA4gCjAGnACP6+Pb08vDu7Oro5+Xj4d/d3NrY1tTT09LR0M/Ozs3MzMvKygXKycnIyAPIx8cDx8bGg8aExZ7EhsWHxobHhciGyYXKhcuFzIDJwry2sq2ppqKfnJiWk5CNi4iGhIJ/fXt5d3VzcnBubGtpZ2ZkYmFfXl1bWlhXVlRTUlBPTk1MSklIR0ZFRENBQD8+PTw7Ojk4NzY2NTQzMjEwLy4uLSwrKikpKCcmJSUkIyIiISAgHx4dHRwbGxoZGRgXFxYWFRQUExMSEREQEP+AAYACAgCAGB8eHh0cGxoaGRgYFxYWFRQUExMSEhEQEAkQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAQICAcHAwcGBgQGBgUFgwWFBIYDiAKMAacAJfr49vTy8O7s6+nn5ePh4N7c2tnX1dTT0tHR0M/Ozs3MzMvLysoFysnJyMgEyMjHx4THhcaQxY3GhceGyIbJhcqFy4XMhc2GzgHPgMvDvbizrqqno6CcmZaTkY6MiYeEgoB+fHp3dnRycG5sa2lnZmRjYV9eXVtaWFdWVFNSUE9OTUtKSUhHRURDQkFAPz49PDs6OTg3NjU0MzIxMTAvLi0sKysqKSgnJyYlJCMjIiEgIB8eHh0cHBsaGhkYGBcWFhUUFBMTEhEREBAP/4ABgAICAIAiIB8eHh0cGxsaGRgYFxYWFRUUExMSEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkDCQgIBAgIBwcDBwYGBAYGBQUEBQUEBIQEhgOIAosBpwAk+vj29PLw7+3r6efl5OLg3t3b2djW1NPT0tHQ0M/Ozs3MzMvLA8vKygPKyckEycnIyITImseIyIXJhcqGy4XMhc2FzoXPhdCD0YDMxb65tLCsqKShnZqXlJGPjIqHhYOAfnx6eHZ0cnBubWtpZ2ZkY2FfXlxbWlhXVVRTUVBPTkxLSklIRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0tLCsqKSgoJyYlJCQjIiEhIB8fHh0cHBsaGhkYGBcWFhUVFBMTEhEREBAPD/+AAYACAgCAIyEgHx8eHRwbGxoZGBgXFhYVFRQTExISEREQEA8PDg4NDQwMBQwLCwoKAwoJCQMJCAgDCAcHBAcHBgYEBgYFBQQFBQQEgwSGA4gCjAGmACP6+Pb08/Hv7evp5+bk4uHf3dza2NfV1NPS0tHQ0M/Ozs3MzAPMy8sDy8rKg8qIyY3IjMmIyoTLhcyFzYbOhM+F0ITRhdKF04DOxsC6tbGtqaWinpuYlZKPjYqIhYOBf3x6eHZ0cnBvbWtpaGZkY2FfXlxbWlhXVVRTUVBPTUxLSkhHRkVEQ0JAPz49PDs6OTg3NjU0MzIxMDAvLi0sKyoqKSgnJiUlJCMiIiEgHx8eHR0cGxoaGRgYFxYWFRUUExMSEhEQEA8PDv+AAYACAgCAJCIhIB8fHh0cGxsaGRkYFxcWFRUUExMSEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkDCQgIAwgHBwQHBwYGBAYGBQUEBQUEBIMEhgOHAowBpgAl+vj39fPx7+3r6ujm5OPh397c29nY1tXU09LR0dDQz87Ozc3MzAPMy8uDy5rKicuHzIXNhM6Ez4bQhNGF0oXThdSF1YDQyMG8t7Kuqqajn5yZlpOQjYuIhoSBf317eXd1c3FvbWtpaGZkY2FfXlxbWVhXVVRSUVBOTUxLSUhHRkVDQkFAPz49PDs6OTg3NjU0MzIxMC8uLSwsKyopKCcnJiUkIyMiISAgHx4dHRwbGxoZGRgXFxYVFRQTExISERAQDw8ODv+AAYACAgCAJSMiISAgHx4dHBwbGhkZGBcXFhUVFBMTEhIRERAQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAMIBwcEBwcGBgMGBQWDBYUEhQOIAosBpgAk+vn39fPx7+3r6ujm5ePh4N7d29rY19XU09PS0dHQ0M/Ozs3NA83MzITMlsuHzIfNhs6Fz4TQhNGF0oTThdSG1YTWhdcB2IDSycO9uLOvq6ekoJ2al5SRjoyJhoSCf317eXd1c3FvbWtqaGZkY2FfXlxbWVhWVVRSUVBOTUxKSUhHRURDQkFAPz08Ozo5ODc2NTQzMjEwMC8uLSwrKikoKCcmJSQkIyIhICAfHh4dHBsbGhkZGBcXFhUVFBMTEhIREBAPDw4ODf+AAYACAgCAJiQjIiEgIB8eHRwcGxoZGRgXFxYVFRQUExISEREQEA8PDg4NDQwMBQwLCwoKAwoJCQMJCAgDCAcHAwcGBgQGBgUFBAUFBASDBIYDhwKLAaYAJvv59/Xz8e/t7Oro5+Xj4uDf3dza2djW1dTT0tLR0dDQz8/Ozs3Ng82TzIjNhs6Gz4XQhdGE0oTThNSF1YXWhdeF2IXZAdqA08vFv7q1sKyopaGem5eVko+MioeFgoB+e3l3dXNxb21ramhmZGNhX15cW1lYVlVTUlFPTk1LSklIRkVEQ0JAPz49PDs6OTg3NjU0MzIxMC8uLSwrKiopKCcmJSUkIyIhISAfHh4dHBwbGhkZGBcXFhUVFBQTEhIREBAPDw4ODQz/gAGAAgIAgCclJCMiISEgHx4dHRwbGhoZGBcXFhUVFBQTEhIRERAQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAMIBwcDBwYGBAYGBQUEBQUEBIMEhQOIAooBpgAj+/n39fPx7+7s6ujn5eTi4d/e3Nva2NfW1NTT0tLR0dDQz88Dz87OBM7Ozc2OzYnOhc+F0IXRhtKE04XUg9WE1oXXhdiE2YbahdsB3IDVzcbAu7ayrammop+bmJWSkI2KiIWDgH58enh1c3FvbmxqaGZlY2FfXlxbWVhWVVNSUE9OTEtKSUdGRURCQUA/Pj08Ojk4NzY1NDMyMTAvLi4tLCsqKSgnJyYlJCMiIiEgHx8eHRwcGxoaGRgXFxYVFRQUExISEREQDw8ODg0NDP+AAYACAgCAKCYlJCMiIiEgHx4dHRwbGhoZGBgXFhYVFBQTExIRERAQDw8ODg0NDAwFDAsLCgoDCgkJAwkICAMIBwcDBwYGBAYGBQUEBQUEBAQEBAMDhAOHAosBpQAg+/n39fPx7+7s6unn5uTj4eDe3dva2djW1dTT09LS0dEF0dDQz88Ez8/Ozo3Oh8+H0ITRhNKF04XUhdWE1oTXhNiE2YXahduF3IXdAd6A18/Iwry4s6+rp6OgnJmWk5COi4iGg4F/fHp4dnRycG5samhmZWNhX15cW1lYVlVTUlBPTUxLSkhHRkRDQkFAPz08Ozo5ODc2NTQzMjEwLy4tLCsqKSgoJyYlJCMjIiEgHx8eHRwcGxoaGRgYFxYWFRQUExISEREQDw8ODg0NDAv/gAGAAgIAgCknJiUkJCMiISAfHh4dHBsbGhkYGBcWFhUUFBMTEhEREBAPDw4ODQ0MDAUMCwsKCgMKCQkFCQgIBwcEBwcGBgMGBQUEBQUEBIMEhQOHAosBpQAf+/n39fPx7+7s6unn5uTj4eDf3dzb2djX1tXU09PS0gPS0dED0dDQA9DPz43PhtCG0YXShNOE1ITVhdaF14TYhNmE2oTbhdyE3Ybehd+A2dHKw765tLCsqKShnZqXlJGOjImGhIF/fXp4dnRycG5samhmZWNhX15cW1lXVlRTUVBPTUxLSUhHRURDQkA/Pj08Ozo4NzY1NDMyMTAvLi0sLCsqKSgnJiUkJCMiISAgHx4dHRwbGhoZGBgXFhYVFBQTEhIRERAPDw4ODQ0MCwv/gAGAAgIAgCooKCcmJSQjIiEgHx8eHRwbGxoZGRgXFhYVFRQTExISERAQDw8ODg0NDAwFDAsLCgoFCgkJCAgDCAcHAwcGBgQGBgUFBAUFBAQEBAQDA4QDhwKKAaUAHvv59/Xz8fDu7Ovp5+bk4+Lg397c29rZ2NfW1NTT0wPT0tID0tHRBNHR0NCL0IfRhNKF04XUg9WE1oTXhdiE2YXahNuE3ITdhd6E34XgheGA29PLxcC6trGtqaWinpuYlZKPjIqHhIJ/fXt5dnRycG5samhmZWNhX15cWllXVlRTUVBOTUxKSUhGRURCQUA/Pjw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJiUkIyIhISAfHh4dHBsbGhkYGBcWFhUUFBMSEhEREA8PDg4NDQwMCwr/gAGAAgIAgCsqKSgnJiUkIyIhICAfHh0cHBsaGRkYFxcWFRUUExMSEhEQEA8PDg4NDQwMBwwLCwoKCQkDCQgIAwgHBwMHBgYEBgYFBQMFBASDBIUDhwKKAaUAH/v59/Xz8fDu7Ovp6Obl4+Lh397d3Nva2NfW1dTU09ME09PS0gTS0tHRi9GH0oTThNSE1YTWhNeD2ITZhdqE24XchN2E3oTfheCE4Ybig+OA3tTNx8G8t7Ouqqejn5yZlpOQjYqHhYKAfnt5d3VycG5samhnZWNhX15cWllXVlRSUVBOTUtKSUdGRUNCQUA+PTw7Ojk3NjU0MzIxMC8uLSwrKikoKCcmJSQjIiIhIB8eHh0cGxsaGRkYFxYWFRQUExMSEREQDw8ODg0NDAwLCgr/gAGAAgIAgCwrKikoJyYlJCMiISEgHx4dHRwbGhoZGBcXFhUVFBMTEhIREBAPDw4ODQ0MDAcMCwsKCgkJAwkICAMIBwcDBwYGAwYFBQQFBQQEBAQEAwOEA4YCigGlAB77+ff18/Hw7uzr6ejm5ePi4eDf3dzb2tnY19bV1NQD1NPTg9OO0oXThNSE1YTWg9eF2IPZhNqE24Tchd2E3oTfhOCE4YbihOOG5AHlgODXz8nDvrm0sKyopKCdmpeTkI6LiIWDgH58eXd1c3FubGpoZ2VjYV9eXFpZV1VUUlFPTkxLSkhHRURDQkA/Pj08Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIyIhIB8fHh0cGxsaGRkYFxYWFRQUExMSEREQEA8ODg0NDAwLCgoJ/4ABgAICAIAvLCsqKSgnJiUkIyMiISAfHh0dHBsaGhkYFxcWFRUUExMSEhEREA8PDg4NDQwMCwsFCwoKCQkFCQgIBwcDBwYGBAYGBQUDBQQEgwSFA4YCigGlAB/7+ff18/Hw7uzr6ejm5eTi4eDf3t3c29rZ2NfW1dTUg9SQ04TUhNWE1oPXg9iE2YTahNuD3IPdhN6G34TghOGE4oXjhuSE5YXmgOLZ0cvFv7q2sa2ppaGem5eUkY6LiYaDgX58end1c3FvbWtpZ2VjYV9dXFpYV1VUUlBPTUxLSUhGRURCQUA/PTw7Ojk4NjU0MzIxMC8uLSwrKikoJyYlJSQjIiEgIB8eHRwcGxoZGRgXFxYVFRQTExIRERAQDw4ODQ0MDAsKCgkJ/4ABgAICAIAyLi0sKikoKCcmJSQjIiEgHx4eHRwbGxoZGBgXFhUVFBQTEhIRERAPDw4ODQ0MDAsLCgoFCgkJCAgDCAcHAwcGBgMGBQUEBQUEBAQEBAMDgwOHAokBpQAf+/n39fPx8O7s6+no5uXk4+Hg397d3Nva2dnY19bV1QPV1NSQ1IPVhNaE14PYg9mD2oTbhNyD3YPehN+E4IXhhOKE44XkheWG5oXnAujogOTb08zGwby3sq6qpqOfnJiVko+MiYeEgX98enh1c3FvbWtpZ2VjYV9dXFpYV1VTUlBPTUxKSUdGRUNCQT8+PTw6OTg3NjU0MzEwLy4tLCsqKSgoJyYlJCMiISAgHx4dHBwbGhkZGBcXFhUVFBMTEhEREBAPDg4NDQwMCwoKCQkI/4ABgAICAIA1Ly4tLCsqKSgnJiUkIyIhICAfHh0cGxsaGRgYFxYWFRQUExISEREQDw8ODg0NDAwLCwoKCQkDCQgIAwgHBwMHBgYDBgUFAwUEBIMEhQOGAooBpAAh+/n39fPx7+7s6+no5uXk4+Lg397d3dzb2tnY2NfW1tXVkNWE1oPXg9iE2YPag9uD3IPdhN6D34PghOGE4oTjheSG5YTmheeG6IXpgOfd1c7Iw725tLCrp6SgnZmWk5CNioeEgn99enh2c3FvbWtpZ2VjYV9dW1pYVlVTUVBOTUtKSEdGRENCQD8+PDs6OTg2NTQzMjEwLy4tLCsqKSgnJiUkIyIiISAfHh0dHBsaGhkYFxcWFRUUExMSEREQEA8ODg0NDAwLCgoJCQgI/4ABgAICAIA2MS8uLSwrKikoJyYlJCMiISEgHx4dHBwbGhkZGBcWFhUUFBMSEhEREA8PDg4NDQwMCwsKCgkJBQkICAcHAwcGBgMGBQUEBQUEBAQEBAMDgwOGAooBpAAh+vn39fPx7+7s6+no5uXk4+Lh4N/e3dzb29rZ2NjX19bWjtaF14PYg9mE2oPbg9yD3YPeg9+D4IThg+KE44PkheWG5oTnheiG6YbqAuvrf+nf19DKxL+6tbGtqaWhnpqXlJGOi4iFgoB9e3h2dHFvbWtpZ2VjYV9dW1pYVlRTUVBOTEtJSEdFREJBQD49PDs5ODc2NTQyMTAvLi0sKyopKCcmJSQjIyIhIB8eHR0cGxoaGRgXFxYVFRQTExIRERAQDw4ODQ0MDAsKCgkJCAgBCP+AAYACAgCAOTIxMC8uLSsqKSgnJiUkJCMiISAfHh0dHBsaGRkYFxYWFRQUExISERAQDw8ODg0NDAwLCwoKCQkICAMIBwcDBwYGAwYFBQMFBAQEBAQDA4MDhgKKAaQAI/r49/Xz8e/u7Ovp6Obl5OPi4eDf3t3d3Nva2tnZ2NjX19bWBNbW19eH14XYhNmD2oPbg9yD3QTe3t/fA9/g4APg4eED4eLiBOLi4+ME4+Pk5APk5eUD5ebmBObm5+eD54bohemF6ofrhOx+7OLa08zGwby3sq6qpqKfm5iUkY6LiIaDgH57eXZ0cm9ta2lnZWNhX11bWVhWVFJRT05MS0lIRkVDQkE/Pj07Ojk4NjU0MzIxMC4tLCsqKSgnJiUlJCMiISAfHh4dHBsaGhkYFxcWFRUUExMSEREQEA8ODg0NDAwLCgoJCQgIAggH/4ABgAICAIA1NDIxMC8uLSwrKikoJyYlJCMiISAfHh4dHBsaGhkYFxYWFRQUExISERAQDw8ODQ0MDAsLCgoHCgkJCAgHBwMHBgYDBgUFBAUFBAQEBAQDAwQDAwIChAKKAaQAIPr49vXz8e/u7Ovp6Obl5OPi4eDf3t7d3Nzb2trZ2djYA9jX14TXhtiE2YTahNuD3ATd3d7eA97f3wPf4OAD4OHhA+Hi4gPi4+MD4+TkBOTk5eUD5ebmA+bn5wTn5+jog+iF6YbqheuF7Ijtf+/k3NXOyMO9uLSvq6ejoJyZlZKPjImGg4F+e3l2dHJvbWtpZ2VjYV9dW1lXVlRSUE9NTEpJR0ZEQ0FAPz08Ozk4NzY1MzIxMC8uLSwrKikoJyYlJCMiISAfHx4dHBsbGhkYFxcWFRUUExMSEREQEA8ODg0NDAwLCgoJCQgIBwcBB/+AAYACAgCAODU0MzIxLy4tLCsqKSgnJiUkIyIhIB8fHh0cGxoaGRgXFxYVFBQTEhIREBAPDw4NDQwMCwsKCgkJBQkICAcHAwcGBgMGBQUDBQQEBAQEAwODA4YCiQGkACD6+Pb08/Hv7ezq6ejm5eTj4uHg39/e3d3c3Nvb2trZ2QPZ2NiF2ITZhNqD24TchN0E3t7f3wPf4OAD4OHhA+Hi4gPi4+MD4+TkA+Tl5QPl5uYE5ubn5wPn6OgE6Ojp6QTp6erqg+qF64bshu2I7gHvfvLn3tfQysS/urWxrailoZ2alpOQjYqHhIF+fHl3dHJwbWtpZ2VjYV9dW1lXVVRSUE5NS0pIR0VEQkE/Pj07Ojk4NjU0MzIwLy4tLCsqKSgnJiUkIyIhICAfHh0cGxsaGRgYFxYVFRQTExIRERAPDw4ODQ0MCwsKCgkJCAgHBwIHBv+AAYACAgCAPTc2NDMyMTAvLiwrKikoJyYlJCMiISEgHx4dHBsaGhkYFxcWFRQUExISERAQDw4ODQ0MDAsLCgoJCQgIBwcDBwYGAwYFBQMFBAQEBAQDA4MDhgKJAaQAHfr49vTz8e/t7Orp5+bl5OPi4eDg397e3d3c3NvbA9va2gPa2dmF2YPahNuD3ITdg96D34Pgg+GD4gTj4+TkBOTk5eUD5ebmA+bn5wPn6OgE6Ojp6QTp6erqBOrq6+sE6+vs7IPsh+2G7ojvAvDwffXq4dnSzMbBvLeyrqqmop6bl5SQjYqHhIJ/fHl3dHJwbWtpZ2ViYF5cW1lXVVNRUE5MS0lIRkVDQkA/PTw7OTg3NjQzMjEwLy0sKyopKCcmJSQjIiEhIB8eHRwbGxoZGBgXFhUVFBMTEhEREA8PDg4NDQwLCwoKCQkICAcHAwcGBv+AAYACAgCAOTk3NjU0MzEwLy4tLCsqKSgnJiUkIyIhIB8eHRwbGxoZGBcXFhUUExMSEREQEA8ODg0NDAsLCgoJCQUJCAgHBwUHBgYFBQQFBQQEAwQDA4MDhgKJAaQAGfr49vTy8e/t7Orp5+bl5OPi4eDg397e3d0D3dzcA9zb24PbhtqD24Pcg92D3oPfhOCD4YPiBOPj5OQD5OXlA+Xm5gbm5ufn6OgD6OnpBOnp6uqD6oTrhOyF7Ybuh++H8ITxfPjt5NzVzsjDvbm0r6uno5+cmJWRjouIhYJ/fHp3dXJwbWtpZ2RiYF5cWlhWVVNRT05MSklHRkRDQUA+PTs6OTg2NTQzMTAvLi0sKykoJyYlJCMjIiEgHx4dHBsbGhkYGBcWFRUUExMSEREQDw8ODg0NDAsLCgoJCQgIBwcEBwYGBf+AAYACAgCAPjo5ODc1NDMyMS8uLSwrKikoJyYlJCMiISAfHh0cGxsaGRgXFhYVFBMTEhEREA8PDg0NDAwLCwoKCQkICAcHAwcGBgMGBQUDBQQEBAQEAwMEAwMCAoQCiQGkABr6+Pb08vDv7evq6Ofm5eTj4uHg4N/f3t7d3QTd3dzchNyG24PcBN3d3t4D3t/fA9/g4APg4eED4eLiA+Lj4wPj5OQD5OXlA+Xm5gPm5+cD5+joA+jp6QPp6uoE6urr6wTr6+zsg+yE7YXuhu+I8IfxhPJ7++/m3tfQysW/urWxrKikoJ2ZlZKPi4iFgoB9end1cnBta2lnZGJgXlxaWFZUUlFPTUxKSEdFREJBPz48Ozk4NzY0MzIxLy4tLCsqKSgnJiUkIyIhIB8eHRwcGxoZGBgXFhUVFBMTEhEREA8PDg4NDAwLCwoKCQkICAcHBQcGBgUF/4ABgAICAIA6PDs6ODc2NTMyMTAvLi0rKikoJyYlJCMiISAfHh0cHBsaGRgXFhYVFBMTEhEREA8PDg0NDAwLCgoJCQcJCAgHBwYGAwYFBQMFBAQEBAQDAwQDAwIChAKJAaQAGPr49vTy8O7t6+ro5+bl5OPi4eDg39/e3gPe3d2H3YPcht0E3t7f3wXf4ODh4QXh4uLj4wPj5OQD5OXlBOXl5uYD5ufnA+fo6APo6ekD6erqBOrq6+sD6+zsBOzs7e0E7e3u7oTuhO+G8InxiPKD83z+8unh2dPMx8G8t7KuqaWhnpqWk4+MiYaDgH16eHVycG1raWZkYmBeXFpYVlRSUE5NS0lIRkRDQUA+PTw6OTc2NTQyMTAvLSwrKikoJyYlJCMiISAfHh0cHBsaGRgYFxYVFRQTExIRERAPDw4ODQwMCwsKCgkJCAgHBwYGBAYFBQT/gAGAAgIAgD8fPTs6OTg2NTQzMTAvLi0sKyooJyYlJCMiISAfHh0cHBsaGRgXFhYVFBMSEhEQEA8ODg0MDAsLCgoJCQgIBwcDBwYGAwYFBQMFBAQDBAMDBAMDAgKEAokBpAAWffj29PLw7uzr6ejn5uTj4+Lh4ODf3wPf3t6R3oPfBuDg4eHi4gXi4+Pk5APk5eUD5ebmA+bn5wPn6OgE6Ojp6QPp6uoD6uvrBOvr7OwE7Ozt7QTt7e7uBO7u7+8E7+/w8ITwhvGJ8ojzg/R7gfbs49zVz8nDvrm0r6uno5+bl5SQjYqGg4B9e3h1c3Bua2lmZGJgXltZV1VUUlBOTEtJR0VEQkE/Pjw7OTg3NTQzMTAvLi0rKikoJyYlJCMiISAfHh0dHBsaGRgYFxYVFRQTEhIRERAPDw4NDQwMCwsKCgkJCAgHBwYGBQYFBQQEA4GAgP2AAgIAgD0gPz08Ozk4NzY0MzIxMC4tLCsqKSgnJiQjIiEgHx4dHBsbGhkYFxYVFRQTEhIREA8PDg0NDAwLCgoJCQgIBQgHBwYGAwYFBQMFBAQDBAMDgwOFAokBpAAUffj29PLw7uzr6ejm5eTj4uLh4OAD4N/fBN/f3t6G3obfheCD4Qji4uPj5OTl5QXl5ubn5wPn6OgD6OnpBOnp6uoD6uvrBOvr7OwE7Ozt7QTt7e7uBO7u7+8E7+/w8IPwhvGG8ofzi/QC9fV6gvnv5t/X0cvFv7q1sayopKCcmJSRjYqHhIF+e3h1c3Bua2lmZGJfXVtZV1VTUU9NTEpIR0VDQkA/PTw6OTc2NTMyMS8uLSwrKignJiUkIyIhIB8eHR0cGxoZGBgXFhUVFBMSEhEQEA8PDg0NDAwLCwoKCQkICAcHBgYFBgUFBAQBBAOBgID9gAICAIBCIUE/Pj07Ojk3NjU0MjEwLy4sKyopKCcmJSQiISAfHh0cGxsaGRgXFhUUFBMSEREQDw4ODQ0MCwsKCgkJCAgHBwYGAwYFBQMFBAQDBAMDgwOFAogBpQAUffj28/Hv7uzq6efm5eTj4uLh4OAD4N/fit+E4IfhBuLi4+Pk5Afk5eXm5ufnBefo6OnpA+nq6gPq6+sE6+vs7ATs7O3tBO3t7u6D7oTvhPCF8YfyhvOF9I31AfZ5hPzy6eHa083Hwby3sq6ppaGdmZWSjouHhIF+e3h1c3Bua2hmZGFfXVtZV1VTUU9NS0lIRkRDQT8+PDs5ODc1NDIxMC8tLCsqKSgmJSQjIiEgHx4eHRwbGhkYGBcWFRUUExISERAQDw4ODQ0MDAsLCgoJCQgIBwcGBgUGBQUEBAIEAwOBgID9gAICAIBAIiFBQD89PDs5ODc1NDMyMC8uLSwqKSgnJiUkIyEgHx4dHBsbGhkYFxYVFBMTEhEQEA8ODQ0MDAsKCgkJCAgHBwUHBgYFBQMFBAQEBAQDAwQDAwICgwKIAaUAFH189fPx7+3r6ujn5uXk4+Lh4eDgBODg39+E34Xgg+GF4oXjCuTk5eXm5ufn6OgF6Onp6uoD6uvrA+vs7APs7e0E7e3u7oPuhO+F8IXxhvKG84f0hvWM9nOGgPXs5NzWz8nDvrm0r6qmop6alpKPi4iFgX57eHZzcG1raGZkYV9dWlhWVFJQTkxLSUdFQ0JAPz08Ojk3NjQzMjAvLi0rKikoJyYlIyIhIB8fHh0cGxoZGBgXFhUUFBMSEhEQEA8ODg0NDAwLCgoJCQgIBwgHBwYGBQUDBQQEAwQDAwSBgYCA/IACAgCARSMiREJBPz48Ozo4NzY0MzIxLy4tLCspKCcmJSQjIiAfHh0cGxoZGBcXFhUUExIRERAPDg4NDAwLCwoKCQkICAcHBgYFBQMFBAQEBAQDAwQDAwICgwKIAaUAFH189fPx7+3r6ujn5uTj4+Lh4eDgiuCD4YPig+OE5IXlCubm5+fo6Onp6uoF6uvr7OwD7O3tA+3u7gTu7u/vg++E8ITxhvKH84b0iPWH9or3dIiB+e/n39jRy8XAurWwrKejn5uXk4+MiIWCf3x5dnNwbWtoZmNhX1xaWFZUUlBOTEpIRkVDQT8+PDs5ODY1MzIxLy4tLCopKCcmJSQjIiEgHx4dHBsaGRgXFxYVFBQTEhIREBAPDg4NDQwLCwoKCQkICAcHBQcGBgUFAwUEBAMEAwMBAwSBgYCA/IACAgCAQyQjRkRDQUA+PTw6OTg2NTQyMTAvLSwrKignJiUkIyIgHx4dHBsaGRgXFhUUFBMSERAQDw4NDQwLCwoKCQkICAcHBgYFBgUFBAQEBAQDAwQDAwICgwKIAaUAEn189fPx7u3r6ejm5eTj4uLh4QPh4OCG4IPhg+KD44PkBOXl5uYE5ubn5wbn5+jo6ekH6erq6+vs7APs7e0D7e7uA+7v7wTv7/DwBPDw8fEE8fHy8oPyhvOI9Ib1ifaI94f4c4qD/PLq4tvUzcfCvLeyramkoJyYlJCMiYaCf3x5dnNwbWtoZWNhXlxaV1VTUU9NS0lHRkRCQD89Ozo4NzU0MzEwLi0sKykoJyYlJCMiISAfHh0cGxoZGBcXFhUUFBMSEREQDw8ODg0MDAsLCgoJCQgIBwcFBwYGBQUDBQQEAwQDAwIDAgSBgYCA/IACAgCAQyUkJEZFQ0JAPz48Ozk4NzU0MzEwLy4sKyopJyYlJCMiIB8eHRwbGhkYFxYVFBMSEhEQDw4ODQwMCwoKCQkICAcHBgYDBgUFAwUEBAMEAwMEAwMCAoMCiAGlABJ9e3ry8O7s6unn5uXk4+Li4eED4eDgg+CE4YPiBOPj5OQF5OXl5uYF5ufn6OgD6Onpg+kE6urr6wfr7Ozt7e7uA+7v7wTv7/DwA/Dx8QTx8fLyBPLy8/OD84b0iPWI9ov3jPh0jIWA9u3l3dbQycS+ubOuqqWhnZmVkY2JhoN/fHl2c3BtamhlY2BeW1lXVVNQTkxKSUdFQ0FAPjw7OTc2NDMyMC8uLCsqKScmJSQjIiEgHx4dHBsaGRgXFxYVFBMTEhEREA8PDg0NDAwLCwoKCQkICAcHBgYDBgUFBQUEBAMDBAMDAgKDgf2AAgIAgEMmJiVJR0ZEQ0FAPj07Ojk3NjQzMjAvLi0rKiknJiUkIyEgHx4dHBsaGRgXFhUUExIREBAPDg0NDAsLCgkJCAgHBwYGAwYFBQMFBAQDBAMDBAMDAgKDAogBpQARfXt68vDu7Oro5+bk4+Pi4eEE4eHg4APg4eEE4eHi4gfi4+Pk5OXlCeXm5ufn6Ojp6QPp6uoD6uvrBOvr7OwD7O3tBe3u7u/vA+/w8ATw8PHxA/Hy8gPy8/ME8/P09IX0hvWH9ov3i/iJ+WyPh4H58Ojg2dLMxsC6tbCrpqKemZWRjoqGg398eXZzcG1qaGViYF1bWVZUUlBOTEpIRkRCQD89Ozo4NzU0MjEvLi0rKikoJiUkIyIhIB8eHRwbGhkYFxYWFRQTExIREBAPDw4NDQwMCwoKCQkHCQgIBwcGBgUGBQUEBAMEAwMEAwMCAgECg4H9gAICAIBBKCcmS0lIRkVDQkA/PTw6OTg2NTMyMS8uLSsqKScmJSQiISAfHh0bGhkYFxYVFBMSEhEQDw4ODQwLCwoKCQkIBwcFBwYGBQUDBQQEAwQDAwQDAwICgwKIAaUAEX17evLv7evp6Obl5OPi4uHhiOEI4uLj4+Tk5eUN5ebm5+fo6Onp6urr6wPr7OwD7O3tBO3t7u4D7u/vA+/w8APw8fED8fLyA/Lz8wTz8/T0g/SG9Yf2h/eP+Iz5g/pvkYqD/fPr49vUzsjCvLexrKijnpqWko6Kh4OAfHl2c3BtamdlYl9dWlhWU1FPTUtJR0VDQT8+PDo5NzY0MzEwLi0sKikoJiUkIyIhIB8eHRwbGhkYFxYWFRQTEhIREBAPDg4NDQwLCwoKCQkICAcHBQcGBgUFAwUEBAMEAwMDAwICAwICAYOB/YACAgCARikoJyZMSklHRURCQT8+PDs5ODc1NDIxMC4tKyopJyYlIyIhIB4dHBsaGRgXFhUUExIREA8PDg0MDAsKCgkJCAgHBwYGBQUDBQQEAwQDAwQDAwICgwKIAaUAEX17ennv7evp5+bl5OPi4uHhhuEE4uLj4xLj5OTl5ebm5+jo6enq6uvr7OwF7O3t7u4E7u7v74Pvg/CD8YPyg/OF9IX1hfaJ94f4lfmH+nCUjIaA9+7m3tfQysS+uLOuqaSfm5eTj4uHg4B8eXZzcG1qZ2RiX1xaV1VTUU5MSkhGREJAPz07OTg2NTMxMC8tLCopKCclJCMiISAfHh0cGxoZGBcWFRUUExISERAQDw4ODQwMCwsKCgkJCAgHBwYGAwYFBQMFBAQDBAMDAwMCAgQCAgEBhIH8gAICAIBGKikpKE5NS0lIRkVDQUA+PTs6ODc2NDMxMC4tKyopJyYlIyIhHx4dHBsZGBcWFRQTEhEREA8ODQ0MCwsKCQkICAcHBgYFBQMFBAQDBAMDBAMDAgKDAocBpgAQfXt6eO/s6unn5uTj4+Lh4YXhg+IX4+Pk5OXl5ubn5+jp6erq6+vs7O3t7u4F7u/v8PAE8PDx8YTxg/KD84T0hfWF9ob3iPiM+ZP6g/tvlo6Igvvx6eHa08zGwLq0r6qloJyYk4+Lh4SAfXl2c3BsaWdkYV5cWVdUUlBOS0lHRUNBPz48Ojg3NTMyMC8uLCspKCcmJCMiISAfHh0cGxoZGBcWFRQUExIRERAPDw4NDQwMCwsKCgkJCAgHBwYGBQYFBQQEBAQEAwMDAwICBAICAQEBAYSB/IACAgCARiwrKilRT01MSkhHRURCQD89PDo5NzY0MzEwLi0rKignJiQjIiAfHhwbGhkYFxYVFBMSERAPDg0NDAsLCgkJCAgHBwYGBQUDBQQEAwQDAwQDAwICgwKHAaYAEH17enju7Oro5uXk4+Li4eGE4YPiGuPj5OTl5ubn5+jp6erq6+vs7O3t7u7v7/DwA/Dx8QPx8vIE8vLz84TzhPSE9YX2hveG+I35i/qQ+2uZkYqE/vXs5NzVzsjBvLaxq6ahnZiUkIyIhIB9eXZyb2xpZmNhXltZVlRRT01LSEZEQkA+PTs5NzY0MjEvLiwrKignJiQjIiEgHx4dHBsaGRgXFhUUExMSEREQDw4ODQ0MCwsKCgkJCAgHBwUHBgYFBQMFBAQDBAMDBAMDAgIEAgIBAQIBAYSB/IACAgCARi0sKyopUVBOTEtJR0ZEQ0E/Pjw7OTg2NDMxMC4tKyooJyUkIiEgHh0cGxkYFxYVFBMSERAPDg4NDAwLCgoJCAgHBwYGBQUDBQQEAwQDAwQDAwICgwKHAaYAEH17eXh36+nn5uXk4+Li4eGD4YPiFuPk5OXl5ubn6Ojp6urr6+zs7e7u7+8F7/Dw8fED8fLyA/Lz8wPz9PQE9PT19YX1hfaG94b4iPmO+pb7bJyTjIaB+O/n39jRysO9uLKtp6KemZWQjIiEgH15dnJvbGlmY2BdW1hVU1BOTEpHRUNBPz07Ojg2NDMxMC4tKyooJyYlIyIhIB8eHBsaGRkYFxYVFBMTEhEQEA8ODg0MDAsLCgoJCQgIBwcGBgMGBQUDBQQEAwQDAwMDAgKDAoUBhYH7gAICAIBGLi0tLCtUUlFPTUtKSEZFQ0JAPj07OTg2NDMxMC4sKykoJiUjIiEfHh0bGhkYFxUUExIREBAPDg0MDAsKCgkICAcHBgYFBQMFBAQDBAMDBAMDAgKDAocBpgAPfXt5eHbr6efl5OPi4uHhg+Ec4uLj4+Tk5ebm5+fo6enq6+vs7O3u7u/v8PDx8QPx8vIF8vPz9PQD9PX1BPX19vaI9oX3hviH+Yz6kPuN/Gaflo+Ig/zz6uLa08zFv7mzrqmjn5qVkYyIhIB9eXVyb2toZWJfXVpXVVJQTUtJRkRCQD48Ojk3NTMyMC4tKyopJyYlIyIhIB8dHBsaGRgXFxYVFBMSEhEQDw8ODQ0MDAsKCgkJCAgHCAcHBgYFBQMFBAQDBAMDBAMDAgIEAgIBAYQBAQCFgfuAAgIAgEQwLy4tLCtVU1FQTkxKSUdFREJAPz07Ojg2NDMxLy4sKiknJiQjISAfHRwbGRgXFhUUExIREA8ODQ0MCwoKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGmAA99e3l4dnXo5uXk4+Li4eED4eLiHOLj4+Tk5ebm5+jp6erq6+zs7e7u7+/w8PHx8vIF8vPz9PQD9PX1A/X29gT29vf3iveF+If5ivqS+5H8aaKZkYuFgPbt5d3VzsfBu7WvqqSfmpaRjYmEgH15dXJua2hlYl9cWVZUUU9MSkhFQ0E/PTs5NzY0MjAvLSwqKScmJSMiISAfHRwbGhkYFxYVFRQTEhEREA8ODg0NDAsLCgoJCQgIBwcGBgMGBQUDBQQEAwQDAwQDAwICBAICAQGEAQIAAIaB+oACAgCARDEwLy4tLFhWVFJQT01LSUhGREJBPz07Ojg2NDIxLy0sKignJSQiIR8eHBsaGRcWFRQTEhEQDw4NDQwLCgoJCQgHBwYGBQYFBQQEAwQDAwQDAwICBAICAQGGAaYADH17eXd2dejm5OPi4gXi4eHi4h3i4+Pk5eXm5+fo6erq6+zs7e3u7+/w8PHx8vLz8wXz9PT19QP19vYE9vb39wT39/j4hviL+Yn6i/uW/If9Y6WclI2Hgvrx6ODY0cnDvLawq6Wgm5aSjYmEgHx5dXFuamdkYV5bWFVTUE5LSUZEQkA+PDo4NjQyMS8tLCopJyYlIyIhIB4dHBsaGRgXFhUUExMSERAQDw4ODQwMCwsKCQkICAcIBwcGBgUFAwUEBAMEAwMEAwMCAoMChgGDAIaB+oACAgCARDMyMTAvLlpYV1VTUU9OTEpIRkVDQT89Ozk4NjQyMC4tKykoJiQjISAeHRwaGRgXFRQTEhEQDw4ODQwLCwoJCQgHBwYGBQYFBQQEAwQDAwQDAwICBAICAQGFAacAEHx6eXd2dOfl5OPi4uHh4uIe4uPj5OXl5ufo6Onq6+vs7e3u7+/w8PHx8vLz8/T0BfT19fb2A/b394P3hfiG+ZH6ivuR/JD9Zqmfl5CKhP706+Pb08zFvriyrKahnJeSjYmFgHx4dXFtamZjYF1aV1RST01KSEVDQT89Ojk3NTMxLy4sKykoJiUjIiEgHh0cGxoZGBcWFRQTEhIREA8PDg0NDAsLCgoJCQgIBwcGBgMGBQUDBQQEAwQDAwQDAwICBAICAQGEAYUAhoH6gAICAIBENTMyMTAvLltZV1ZUUlBOTEpJR0VDQT89Ozk3NTMyMC4sKiknJSQiIR8eHBsZGBcWFRQSERAPDw4NDAsLCgkJCAgHBgYFBgUFBAQDBAMDAwMCAoMChwGnAAt8enh3dXRz5ePi4gTi4eLiH+Lj4+Tl5ubn6Onp6uvs7O3u7+/w8PHx8vLz8/T09fUD9fb2A/b39wT39/j4BPj4+fmD+Yj6h/uD+or7j/yW/WKtopqSjIaB+O7m3dXOx8C5s62nopyXko6JhIB8eHRwbWlmYl9cWVZTUU5LSUZEQj89Ozk3NTMyMC4sKykoJiUjIiEfHh0cGxoZGBcWFRQTEhEREA8ODg0MDAsLCgkJCAgHBwUHBgYFBQMFBAQDBAMDBAMDAgKDAoYBhgCHgfmAAgIAgEQ2NTQzMjEwXlxaWFZVU1FPTUtJR0VDQT89Ozk3NTMxLy0rKSgmJCMhIB4dGxoZFxYVFBMSERAPDg0MCwsKCQkICAcGBgUGBQUEBAMEAwMDAwICgwKHAacAC3x6eHZ1dHPk4+LihOIY4+Pk5ebm5+jp6uvr7O3u7u/w8PHx8vPzB/P09PX19vYD9vf3BPf3+PgE+Pj5+YP5hvqV+4/8mf0B/mOxpp2Vj4iD/PLp4NjQycK7tK6oop2Yk46JhIB8eHRwbGhlYl5bWFVST01KSEVDQD48Ojg2NDIwLi0rKSgmJSMiIR8eHRwbGRgXFhUUFBMSERAPDw4NDQwLCwoKCQkICAcHBgYFBgUFBAQEBAQDAwQDAwICBAICAQGFAYcAh4H5gAICAIBEODc1NDMyMTBfXVtZV1VTUU9NS0lHRUNBPzw6ODY0MjAuLCopJyUjIiAfHRwaGRgWFRQTEhEQDw4NDAwLCgkJCAgHBgYFBgUFBAQDBAMDAwMCAoMChwGnAAt8enh2dXNycuPi4oPiGePj5OXm5+fo6err7O3t7u/v8PHx8vPz9PQH9PX19vb39wT39/j4BPj4+fkE+fn6+oT6i/uY/JT9i/5htamgmJGLhYD17OPa0svDvLavqaOemJOOiYSAe3dzb2toZGFdWldUUU5LSUZEQT89Ojg2NDIwLy0rKSgmJSMiIB8eHRsaGRgXFhUUExIRERAPDg4NDAwLCgoJCQgIBwcGBgMGBQUDBQQEAwQDAwQDAwICgwKGAYkAiIH4gAICAIBEOjg3NjU0MzJiYF5cWlhWVFJQTktJR0VCQD48Ojc1MzEvLSspJyYkIiEfHhwbGRgXFRQTEhEQDw4NDAwLCgkJCAgHBgYFBgUFBAQDBAMDAwMCAoMChwGnAAp8enh2dHNyceLig+Ia4+Pk5ebn6Onp6uvs7e7v7/Dx8fLz8/T09fUF9fb29/cD9/j4BPj4+fkE+fn6+oT6ifuM/Ij9hfyV/Y7+Xbmto5uUjYeC+e/m3dXNxb63sKqknpiTjomEf3t3cm5qZ2NgXFlWU1BNSkdFQkA9Ozk3NTMxLy0rKSgmJSMiIB8eHBsaGRgXFhUUExIREA8PDg0NDAsLCgoJCAgHBwUHBgYFBQMFBAQDBAMDBAMDAgKDAocBigCIgfiAAgIAgEY7Ojk4NjU0M2VjYV9dW1lXVFJQTktJR0RCQD07OTc0MjAuLCooJiUjISAeHBsaGBcWFBMSERAPDg0MDAsKCQkICAcGBgUFAwUEBAMEAwMDAwICgwKGAagACnx6d3Z0c3Jx4uKD4hzj5OXm5+jp6uvs7O3u7/Dw8fLy8/T09fX29vf3A/f4+AT4+Pn5BPn5+vqE+oj7i/yj/ZL+YL6xp56XkIqE/fPp4NfPx7+4saulnpmTjomEf3p2cm1qZmJeW1hUUU5LSEZDQT48OTc1MzEvLSsqKCYlIyIgHx0cGxoZFxYVFBMSEhEQDw4ODQwMCwoKCQkICAcHBgYFBQMFBAQDBAMDBAMDAgKDAocBjACIgfiAAgIAgEY9PDo5ODc2NTRmZGJgXlxZV1VSUE1LSEZEQT88Ojg1MzEvLSspJyUjIiAeHRsaGBcWFRMSERAPDg0MDAsKCQkICAcGBgUFAwUEBAMEAwMDAwICBAICAQGFAagAC3x5d3V0cnJxceLiHOLj5OXm5+jp6uvs7e7v7/Dx8vLz9PT19fb29/cD9/j4BPj4+fkD+fr6g/qI+4v8kP2I/ov9lv5cw7WropqTjIaA9uzi2dHJwbmyq6WfmZOOiIN+enVxbWhkYV1aVlNQTUpHREE/PDo4NTMxLy0rKigmJCMhIB8dHBsZGBcWFRQTEhEQDw8ODQwMCwsKCQkICAcHBgYFBgUFBAQEBAQDAwMDAgKDAocBjgCJgfeAAgIAgEY/Pjw7Ojg3NjVpZ2VjYV5cWVdVUk9NSkhFQ0A+Ozk3NDIwLiwqKCYkIiAfHRwaGRcWFRQSERAPDg0MDAsKCQkICAcGBgUFAwUEBAMEAwMDAwICBAICAQGFAagACHx5d3VzcnFxHXHi4uPk5ebn6Onq6+zt7u/w8fLy8/P09fX29vf3A/f4+AP4+fkD+fr6g/qH+4r8kP2S/gT9/f7+mP5ayLqvpZ2Vj4iC+u/l3NPKwruzrKafmZONiIN+eXRwa2djX1xYVVFOS0hFQkA9Ozg2NDEvLSsqKCYkIyEgHh0cGhkYFxYVFBMSERAPDg0NDAsLCgkJCAgHBwYGAwYFBQMFBAQDBAMDBAMDAgIEAgIBAYYBjwCJgfeAAgIAgEZBPz49Ozo5ODdsamhmZGFfXFpXVFJPTEpHREI/PDo4NTMxLiwqKCYkIiEfHRwaGRcWFRQSERAPDg0NDAsKCQkICAcGBgUFBQUEBAMDBAMDAgIEAgIBAYUBqAAIfHl2dHNycXEdceLj5OXm5+jp6uvt7u/w8PHy8/P09fX29vf3+PgD+Pn5A/n6+oP6hvuJ/I79sP6F/1bNv7OpoZiRi4T98uje1czEvLStpp+Zk42Hgn14c29qZmJeWlZTUExJRkNAPjs5NjQyMC0rKSgmJCMhHx4dGxoZFxYVFBMSERAPDw4NDAwLCgoJCAgHBwUHBgYFBQMFBAQDBAMDBAMDAgIEAgIBAYYBkQCJgfeAAgIAgEZDQUA+PTw7Ojk4bWtpZ2RhX1xZVlRRTktIRkNAPjs5NjQxLy0rKSclIyEfHhwbGRgWFRQTERAPDg0NDAsKCgkICAcGBgUFBQUEBAMDBAMDAgIEAgIBAYUBqAAHfHl2dHNxcYNxFuPk5ufo6ers7e7v8PHy8/P09fX29/cF9/j4+fkE+fn6+gP6+/uE+4n8iv2e/ob/j/6K/1nTxLitpJyUjYaA9uvh187FvbWtpp+ZkoyHgXx3cm1pZGBcWFVRTkpHREE+PDk3NDIwLispKCYkIiEfHhwbGRgXFhUUExIREA8ODQwMCwoKCQkICAcHBgYFBQMFBAQDBAMDBAMDAgIEAgIBAYYBkwCKgfaAAgIAgEZFQ0FAPz48Ozo5cW9samdkYV9cWVZTUE1KR0RCPzw6NzQyMC0rKSclIyEgHhwbGRgWFRQTEhAPDg4NDAsKCgkICAcGBgUFBQUEBAMDBAMDAgIEAgIBAYUBqAAHfHh2dHJxcYNxFuTl5+jp6+zt7u/w8fLz9PX19vf3+PgD+Pn5A/n6+gT6+vv7g/uI/Ij9nP6n/1faybyxqJ+XkImC+e7j2c/Gvraupp+YkoyGgHt1cWxnY15aVlNPTEhFQj88Ojc0MjAuKyknJSQiIB8dHBoZGBYVFBMSERAPDg0NDAsLCgkJCAgHBwYGBQUDBQQEAwQDAwMDAgKDAocBlgCKgfaAAgIAgEZHRUNCQD8+PTw7dHJvbWpnZGFeW1hVUk5LSUZDQD06ODUzMC4sKiglJCIgHh0bGRgXFRQTEhEQDw4NDAsKCQkICAcGBgUFBQUEBAMDBAMDAgIEAgIBAYQBqQAHfHh1c3JxcRdxcXLl5ujp6+zt7/Dx8vP09fX29/f4+AX4+fn6+gP6+/uD+4f8h/2S/rf/VeDPwbasopqSi4T88ebb0ci/tq6mn5iRi4V/eXRvamVhXVhUUU1JRkNAPTo3NTIwLSspJyUjIiAeHRsaGBcWFRQSERAPDw4NDAsLCgkJCAgHBwYGBQUDBQQEAwQDAwMDAgKDAocBmACKgfaAAgIAgEZJR0VEQkFAPz49PHVzcG1qZ2NgXVpWU1BNSkdEQT47OTYzMS8sKigmJCIgHh0bGhgXFRQTEhEQDw4NDAsKCQkICAcGBgUFBQUEBAMDAwMCAoMChgGpAAZ7eHVzcXGDcRVyc+jp6+zu7/Dx8/P09fb39/j4+fkD+fr6A/r7+wT7+/z8hPyH/ZD+vf9V59XHu7CmnZWNhoD06N3TycC3rqafl5GKhH54cm1oY19aVlJOS0dEQD06ODUyMC0rKSclIyEfHhwbGRgWFRQTEhEQDw4NDAwLCgkJCAgHBwYGBQUEBAMEAwMEAwMCAoMChwGaAIuB9YACAgCASEtJR0VEQ0JBQD89eXZzcGxpZmJfXFhVUk5LSEVCPzw5NzQxLy0qKCYkIiAfHRsaGBcWFBMSERAPDg0MCwoJCQgIBwYGBQUEBAMEAwMDAwICgwKGAakABnt3dHJxcRZxcXJzc+nr7O7v8fLz9PX29vf4+Pn5Bfn6+vv7g/uF/Ib9j/7C/1Pv3M3AtKqgmJCIgvfq39TKwLeupp6Xj4mCfHZxa2ZhXVhUUExIRUE+Ozg1MjAtKyknJSMhHx0cGhkXFhUTEhEQDw4NDAwLCgkJCAgHBwYGBQUEBAMEAwMEAwMCAgQCAgEBhgGcAIuB9YACAgCASE1KSUdGRURDQkA/fHl2c29saGRhXVpWU09MSUZDQD06NzQyLy0rKSYkIiEfHRsaGBcWFBMSERAPDg0MCwoJCQgHBwYGBQUEBAMEAwMDAwICBAICAQGFAakABnt3dHJxcRZxcnJzdOvs7vDx8vP09fb3+Pj5+fr6A/r7+wT7+/z8g/yG/Y3+x/9R+OPTxbmupJuSi4P57eHVy8G3rqadlo6HgXp0bmlkX1pWUU1JRUI+Ozg1MjAtKygmJCIgHh0bGRgWFRQTERAPDg0NDAsKCgkICAcHBgYFBQQEAwQDAwMDAgKDAocBnwCLgfWAAgIAgEgnTEpJSEdGRURCQX98eXVybmpmY19bWFRQTUpGQ0A9Ojg1MjAtKyknJSMhHx0cGhgXFhQTEhEQDw4NDAsKCQkIBwcGBgUFBAQDBAMDAwMCAgQCAgEBhQGpAAY9d3NycXEUcXJzdHXs7vDx8/T19vf4+Pn5+voD+vv7A/v8/IP8hf2N/sv/TIDr2cq+sqeelY2F/O/i18zBt66lnJSNhX94cmxmYVxXU05KRkM/PDg1MjAtKigmIyEfHhwaGRcWFBMSERAPDg0MCwoKCQgIBwYGBQUDBQQEAwQDAwMDAgKDAocBoQADgoGBiIH1gAICAIBIKE5MS0pJSEdGREODf3x4dHBsaGRgXVlVUk5KR0RBPjs4NTMwLispJyUjIR8dHBoYFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYUBqQAFPXZzcXEVcXJzdHV27vDy8/T19vf4+fn6+vv7BPv7/PwE/Pz9/YP9jP7P/0qF8+DQw7aroZiPh//x5NjMwbetpJuTi4N8dm9pZF5ZVFBLR0M/PDg1Mi8tKiclIyEfHRsZGBYVExIREA8ODQwLCgkJCAcHBgYFBQUFBAQDAwQDAwICBAICAQGFAaQAA4KBgYiB9YACAgCASClQTk1MS0pJSEZEQ4J+enZybmpmYl5aVlJPS0hFQT47ODYzMC4sKSclIyEfHRwaGRcWFBMSERAPDg0MCwoJCQgHBwYGBQUEBAMEAwMDAwICBAICAQGFAakABT12cnFxE3Fyc3V2d3jy8/X29/j4+fn6+/sE+/v8/AP8/f2D/Yv+zv+EgAH/Sor86NfIu6+kmpGJgfPl2MzBtqyimZGJgXpzbGZhW1ZRTEhEQDw4NTIvLCknJCIgHhwaGBcVFBMREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYUBpwADgoGBiYHvgISBAYACAgCASCopUE9OTUxLSUhGRIWBfXl0cGtnY19bV1NQTEhFQj88OTYzMS4sKSclIyEfHRwaGRcWFBMSERAPDg0MCwoJCQgHBwYGBQUEBAMEAwMDAwICBAICAQGFAakAFj06cnFxcnN0dnd4efT19vf4+fn6+/sD+/z8BPz8/f0E/f3+/oj+zv+JgEqQgvDezsCzqJ2TioL159nMwLWqoZeOhn53cGljXVdSTUlEQDw4NTIuKykmJCEfHRsZFxYUExIQDw4NDAsKCQkIBwcGBgUFBAQDAwMDAgKDAoYBqgAEgoKBgYiB64CJgQICAIBIKypSUVBPTk1LSkhGiIR/enZxbWhkYFxYVFBNSUZCPzw5NjQxLiwqJyUjIR8dHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYQBqgAXPTpycXFzdHV3eHl69ff4+Pn6+vv7/PwD/P39BP39/v6I/sz/joBFloj45dTFuKugloyD9+fZzL+zqJ6Vi4N7c2xlX1lUTklFQDw4NTEuKyglIyAeHBoYFhUTEhAPDg0MCwoJCAgHBgYFBQQEAwQDAwMDAgIEAgIBAYQBrQAEgoKBgYiB5oCOgQICAIBILCoqU1JRUE9NS0lHioaBfHdzbmplYV1ZVVFNSkZDPzw5NzQxLywqJyUjIR8eHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYQBqgAVPTo4cXJzdXZ4eXp79/j5+vr7+/z8A/z9/QT9/f7+hv7L/5OARZ2Nge3byryvo5iOhPjo2cu+saackYh/d29oYVtVT0pFQDw4NDAtKickIh8dGxkXFRMSEQ8ODQwLCgkICAcGBgUFBAQDAwMDAgIEAgIBAYQBsACDgomB4YCTgQICAIBILSsqVVRUUlFPTUtJjYiDfnl0b2tmYl5ZVVFOSkZDQD06NzQxLywqKCUjIR8eHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYQBqgATPDk4cXN0dnd5ent7+Pn6+/v8/AP8/f0D/f7+hv7I/5mAQqWThvXi0MGzppqPhfno2Mm8r6OYjoR7c2tjXVZQSkVAPDczMCwpJiMgHhwZFxUUEhEPDg0MCwoJCAcHBgUFBAQDAwMDAgIEAgIBAYQBswCDgomB24CZgQICAIBILiwrV1dWVVNRT0xKj4qEf3p1cGxnY15aVlJOSkdDQD06NzQxLywqKCUjIR8eHBoZFxYUExIREA8ODQwLCgkJCAcHBgYFBQQEAwQDAwMDAgIEAgIBAYQBqgAUPDk4cnN1d3l6e3x8+vr7+/z8/f0D/f7+hf7E/6CAQq6ai/7p1sW2qJyQhvnn1se5q5+UiX92bmZeV1FLRUA7NzIvKyglIh8cGhgWFBIRDw4NDAoJCQgHBgYFBQQEAwMCAgQCAgEBhAG2AIOCiYHUgKCBAgIAgEovLSwsWVhXVVNQTUuRi4aAe3ZxbGhjX1pWUk5LR0RAPTo3NDEvLCooJiMhIB4cGhkXFhQTEhEQDg4NDAsKCQkIBwcGBgUFBAQDAwQDAwICBAICAQGEAaoAFDw5ODl1d3h6e3x8ffv7/Pz9/f7+hf7A/6eAPbeikYTx3Mq6q56Rhvjm1MS1p5uPhHpxaGBYUktFQDs2MS0qJiMgHRsYFhQSEQ8ODAsKCQgHBwYFBQQEAwMDAwICAwIBAYQBuQCEgoiBzYCngQICAIADMC4uRy5bWllWVFFOTJKNh4J8d3JtaGRfW1dTT0tHREA9Ojc0Mi8tKigmIyEgHhwaGRcWFBMSERAODQ0MCwoJCQgHBwYGBQUEBAMDBAMDAgIFAgIBAACtABI8ODg5dnh6e3x8fX38/P39/v6E/rv/r4A6wqqYifnjz76tn5KG9+PRwLCilYl+dGphWVJLRT86NTAsKCQhHhsZFhQSEQ8ODAsKCQgHBgUFBAQDAwMDAgIDAgEBgwG9AISCiIHFgK+BAgIAgAMxLy9ILy9dWlhVUk9MlI6Ig314c25pZF9bV1NPS0dEQT06NzQyLy0qKCYkISAeHBoZFxYUExIREA4NDQwLCgkJCAcHBgYFBQQEAwEBhQGwABA7ODk6O3l7fHx9fX79/f7+g/62/7eAN86zn4+B6dTBsKCShfTgzLurnI6Cd2xjWlJLRD44My4qJiIfHBkXFBIQDw0MCwkIBwYGBQQEAwMDAwICAwIBAYMBwACFgoeBvYC3gQICAIADMTAwQDAwXlxZVlNQTZWPiYN+eHNuaWRgW1dTT0tIREE+Ojc1Mi8tKigmJCEgHhwaGRcWFBMSEQ8ODQwMCwoJCQgHAwMDAwICBAICAQGGAbAACzs4OTs8e3x9fX5+A37+/oP+sP+/gDbcvaeVhfDZxLGhkoTw2sa0o5SGem9kWlJKQzw2MSwoJCAdGhcUEhAODQsKCQgHBgUEBAMDAgIDAgEBgwHEAIWCh4G1gL+BAgIAgD8yMTEyMWBdWldUUU6WkIqEfnlzbmllYFxXU09MSERBPjo3NTIvLSooJiQhIB4cGhkXFhQTEhEQDg0GBgUFBAQDBAMDBAMDAgIEAgIBAYYBsAAKOjg6PD18fX1+fgZ+f/7+//+p/8eAM+vJsJuK993HsqGQguvUvqyai31xZVtRSUE6NC8qJSEdGhcUEhAODAsJCAcGBQUEAwMCAgMCAQGDAccAhYKHga2Ax4ECAgCAOjMyMzMyYl9bWFVRnZeQioR/eXRvamVgXFhTT0xIREE+Ozc1Mi8tKigmJCEgHhwaGRcWCgkJCAgHBgYFBgUFBAQDBAMDBAMDAgIEAgIBAYYBsAAOOjk7PD59fX5+f3/+//+k/86ANP3WuqKP/uLJsp+O/uPLtaGQgHJmWlBHPzgxLCYiHhoXFBEPDQsKCQcGBQUEAwMCAgEBAADMAIWChoGngM6BAgIAgDoZMzQ0MzFgXFlVUp6XkYuFf3p0b2plYFxYVFBMSERBPjs4NTIvLSooJiQREA8ODQwLCwoJCQgIBwYGBQYFBQQEAwQDAwQDAwICBAICAQGGAbAACRw5PD0+Pn5/fwR/f///nf/WgCyJ5cWqlYLlyrGdivTYv6iUg3NlWU5EPDQuKCMeGhYTEQ4MCgkIBgUEBAMBAQMBAADRAAODgoKDgoWBn4DWgQICAIA6GjU2NTMyYV1ZVlKemJGLhX96dG9qZWFcWFRQTEhEQT47ODUZFxYVFBMSERAPDg0MCwsKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGwAAgcOj0+Pj9/f4N/mP/dgCWW99GymoXnya+YhefJsJiFc2RWS0E3MCkjHhoWExANCwkIBgICAwIBAQMBAADVAAODgoKDgoWBmIDdgQICAIA6Ghs3NjQyYV1aVqWfmJKLhYB6dG9qZWFcWFRQTCQiIB8dHBoZFxYVFBMSERAPDg0MCwsKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGwAAgcHT4+Pz9/fwR/f///kP/kgCSlhd67n4fnxqmR+dW3nYVyYVJGOzIqIx4ZFREOBgUEAwICAQEEAQEAANgABIODgoIEgoKBgQSBgYCAkIDkgQICAIA6Ghw4NjQyYV5aVqafmJKMhYB6dW9qZTAuLCooJiQiIB8dHBoZFxYVFBMSERAPDg0MCwsKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGwAAUcHj4/PwM/f38Ef3///4r/6oAhuJHtw6OH5MCgh+K9n4VuXEw/NCskHQwJCAYFBAMCAgEBAwEAANwABIODgoIEgoKBgQSBgYCAioDqgQICAIA6Gx05NzUzYl5araafmJKMhkA9Ojc1MzAuLCooJiQiIB8dHBoZFxYVFBMSERAPDg0MCwsKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhgGwAAQcHz8/BD8/f38Df///hf/wgB3Qn/3LpYbctJLww56BaVREGxURDQsIBgUEAwIBAQMBAADgAASDg4KCBIKCgYEDgYCAhYDwgQICAIA6HB0cNzUzYl61raafTElGQ0A9Ojc1MzAuLCooJiQiIB8dHBoZFxYVFBMSERAPDg0MCwsKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhQGxAAUdHx8/PwU/f3///wT//4CA8oAc77CH0qWBzKH7xpp4LiQbFRAMCQcFAwICAQEAAOQAg4ODggSBgYCABICAgYHygQICAIA6Dh0cNzVmYl5aV1NPTElGQ0A9Ojg1MzAuLCooJiQiIB8dHBoZFxYVFBMSERAPDg0MCwsKCQkIBwcGBgUGBQUEBAMEAwMEAwMCAgQCAgEBhQGxAAkPHx8/P39/gID3gBiMxI/Tneqvg2BHNCYbFA4KBwQDAgEBAADoAAeEg4OCgoGB+YECAgCAOg8eHDc1ZmJeWldTT0xJRkNAPTo4NTMwLiwqKCYkIiAfHRwaGRcWFRQTEhEQDw4NDAsLCgkJCAcHBgYFBgUFBAQDBAMDBAMDAgIEAgIBAYUBsQAHDx8fPz+AgPmAE6rbk8qKvIFYOScZEAoGBAIBAADtAAeEg4OCgoGB+YECAgCAOg8eHTdrZmJeWldTT0xJRkNAPTo4NTMwLiwqKCYkIiAfHRwaGRcWFRQTEhEQDw4NDAsLCgkJCAcHBgYFBgUFBAQDBAMDBAMDAgIEAgIBAYUBsQAGDyAgQICA+oAP2PCNpsJwQCQSCgUCAQAA8QAGhIODgoGB+oECAgCAOgceOW9rZmJeWldTT0xJRkNAPTo4NTMwLiwqKCYkIiAfHRwaGRcWFRQTEhEQDw4NDAsLCgkJCAcHBgYFBgUFBAQDBAMDBAMDAgIEAgIBAYUBsQAFBx9AgIDsgAP/gICIgAT/gP//CpLqwp86FQcCAAD2AAWFg4KBgeyBA4CBgYiBBICBgIA=";
    const RGBDMaxRange = 255;
    class PBRDefaultDFG {
        static get defaultDFG() {
            return PBRDefaultDFG._defaultDFG;
        }
        static set defaultDFG(value) {
            PBRDefaultDFG._defaultDFG = value;
        }
        static DefaultDfgTexture() {
            let hdrBuffer = Laya.Base64Tool.decode(dfg_128);
            let hdrInfo = Laya.HDRTextureInfo.getHDRInfo(hdrBuffer);
            let supportFloatTex = Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.TextureFormat_R32G32B32A32);
            let supportFloatLinearFiltering = Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Texture_FloatLinearFiltering);
            let tex;
            if (supportFloatTex && supportFloatLinearFiltering) {
                tex = new Laya.Texture2D(hdrInfo.width, hdrInfo.height, hdrInfo.format, false, false, false);
                tex.setHDRData(hdrInfo);
            }
            else {
                tex = new Laya.Texture2D(hdrInfo.width, hdrInfo.height, Laya.TextureFormat.R8G8B8A8, false, false, false);
                let pixelCount = hdrInfo.width * hdrInfo.height;
                let hdrPixelData = hdrInfo.readScanLine();
                let rgbdPixelData = new Uint8Array(pixelCount * 4);
                for (let index = 0; index < pixelCount; index++) {
                    let r = hdrPixelData[index * 4];
                    let g = hdrPixelData[index * 4 + 1];
                    let b = hdrPixelData[index * 4 + 2];
                    let maxRGB = Math.max(r, g, b, 1e-5);
                    let d = Math.max(1.0, RGBDMaxRange / maxRGB);
                    d = Math.min(1, Math.max(0, (d / 255)));
                    rgbdPixelData[index * 4] = Math.min(1, Math.max(0, (r * d))) * 255;
                    rgbdPixelData[index * 4 + 1] = Math.min(1, Math.max(0, (g * d))) * 255;
                    rgbdPixelData[index * 4 + 2] = Math.min(1, Math.max(0, (b * d))) * 255;
                    rgbdPixelData[index * 4 + 3] = d * 255;
                }
                tex.setPixelsData(rgbdPixelData, false, false);
            }
            tex.lock = true;
            tex.wrapModeU = Laya.WrapMode.Clamp;
            tex.wrapModeV = Laya.WrapMode.Clamp;
            tex.anisoLevel = 1;
            this._defaultDFG = tex;
        }
    }

    exports.ShaderDataType = void 0;
    (function (ShaderDataType) {
        ShaderDataType[ShaderDataType["None"] = 0] = "None";
        ShaderDataType[ShaderDataType["Int"] = 1] = "Int";
        ShaderDataType[ShaderDataType["Bool"] = 2] = "Bool";
        ShaderDataType[ShaderDataType["Float"] = 3] = "Float";
        ShaderDataType[ShaderDataType["Vector2"] = 4] = "Vector2";
        ShaderDataType[ShaderDataType["Vector3"] = 5] = "Vector3";
        ShaderDataType[ShaderDataType["Vector4"] = 6] = "Vector4";
        ShaderDataType[ShaderDataType["Color"] = 7] = "Color";
        ShaderDataType[ShaderDataType["Matrix4x4"] = 8] = "Matrix4x4";
        ShaderDataType[ShaderDataType["Texture2D"] = 9] = "Texture2D";
        ShaderDataType[ShaderDataType["Texture3D"] = 10] = "Texture3D";
        ShaderDataType[ShaderDataType["TextureCube"] = 11] = "TextureCube";
        ShaderDataType[ShaderDataType["Buffer"] = 12] = "Buffer";
        ShaderDataType[ShaderDataType["Matrix3x3"] = 13] = "Matrix3x3";
        ShaderDataType[ShaderDataType["Texture2DArray"] = 14] = "Texture2DArray";
    })(exports.ShaderDataType || (exports.ShaderDataType = {}));
    function checkShaderDataValueLegal(value, shaderType) {
        let legal = false;
        switch (shaderType) {
            case exports.ShaderDataType.Int:
            case exports.ShaderDataType.Float:
                legal = typeof value == "number";
                break;
            case exports.ShaderDataType.Bool:
                legal = typeof value == "boolean";
                break;
            case exports.ShaderDataType.Vector2:
                legal = value instanceof Laya.Vector2;
                break;
            case exports.ShaderDataType.Vector3:
                legal = value instanceof Laya.Vector3;
                break;
            case exports.ShaderDataType.Vector4:
                legal = value instanceof Laya.Vector4;
                break;
            case exports.ShaderDataType.Color:
                legal = value instanceof Laya.Color;
                break;
            case exports.ShaderDataType.Matrix4x4:
                legal = value instanceof Laya.Matrix4x4;
                break;
            case exports.ShaderDataType.Texture2D:
                legal = value instanceof Laya.BaseTexture;
                break;
            case exports.ShaderDataType.TextureCube:
                legal = value instanceof Laya.BaseTexture;
                break;
            case exports.ShaderDataType.Buffer:
                legal = value instanceof ArrayBuffer;
                break;
            case exports.ShaderDataType.Matrix3x3:
                legal = value instanceof Laya.Matrix3x3;
                break;
            default:
                legal = false;
                break;
        }
        if (!legal)
            console.warn("The setting value and Shader type do not match");
        return legal;
    }
    function ShaderDataDefaultValue(type) {
        switch (type) {
            case exports.ShaderDataType.Int:
                return 0;
            case exports.ShaderDataType.Bool:
                return false;
            case exports.ShaderDataType.Float:
                return 0;
            case exports.ShaderDataType.Vector2:
                return Laya.Vector2.ZERO;
            case exports.ShaderDataType.Vector3:
                return Laya.Vector3.ZERO;
            case exports.ShaderDataType.Vector4:
                return Laya.Vector4.ZERO;
            case exports.ShaderDataType.Color:
                return Laya.Color.BLACK;
            case exports.ShaderDataType.Matrix4x4:
                return Laya.Matrix4x4.DEFAULT;
            case exports.ShaderDataType.Matrix3x3:
                return Laya.Matrix3x3.DEFAULT;
        }
        return null;
    }
    class ShaderData {
        constructor(ownerResource = null) {
            this._ownerResource = ownerResource;
        }
        getDefineData() {
            throw new Laya.NotImplementedError();
        }
        getData() {
            throw new Laya.NotImplementedError();
        }
        addDefine(define) {
            throw new Laya.NotImplementedError();
        }
        addDefines(define) {
            throw new Laya.NotImplementedError();
        }
        removeDefine(define) {
            throw new Laya.NotImplementedError();
        }
        hasDefine(define) {
            throw new Laya.NotImplementedError();
        }
        clearDefine() {
            throw new Laya.NotImplementedError();
        }
        clearData() {
            throw new Laya.NotImplementedError();
        }
        getBool(index) {
            throw new Laya.NotImplementedError();
        }
        setBool(index, value) {
            throw new Laya.NotImplementedError();
        }
        getInt(index) {
            throw new Laya.NotImplementedError();
        }
        setInt(index, value) {
            throw new Laya.NotImplementedError();
        }
        getNumber(index) {
            throw new Laya.NotImplementedError();
        }
        setNumber(index, value) {
            throw new Laya.NotImplementedError();
        }
        getVector2(index) {
            throw new Laya.NotImplementedError();
        }
        setVector2(index, value) {
            throw new Laya.NotImplementedError();
        }
        getVector3(index) {
            throw new Laya.NotImplementedError();
        }
        setVector3(index, value) {
            throw new Laya.NotImplementedError();
        }
        getVector(index) {
            throw new Laya.NotImplementedError();
        }
        setVector(index, value) {
            throw new Laya.NotImplementedError();
        }
        getColor(index) {
            throw new Laya.NotImplementedError();
        }
        setColor(index, value) {
            throw new Laya.NotImplementedError();
        }
        getMatrix4x4(index) {
            throw new Laya.NotImplementedError();
        }
        setMatrix4x4(index, value) {
            throw new Laya.NotImplementedError();
        }
        getMatrix3x3(index) {
            throw new Laya.NotImplementedError();
        }
        setMatrix3x3(index, value) {
            throw new Laya.NotImplementedError();
        }
        getBuffer(index) {
            throw new Laya.NotImplementedError();
        }
        setBuffer(index, value) {
            throw new Laya.NotImplementedError();
        }
        setTexture(index, value) {
            throw new Laya.NotImplementedError();
        }
        getTexture(index) {
            throw new Laya.NotImplementedError();
        }
        setShaderData(uniformIndex, type, value) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    this.setInt(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Bool:
                    this.setBool(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Float:
                    this.setNumber(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector2:
                    this.setVector2(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector3:
                    this.setVector3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Vector4:
                    this.setVector(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Color:
                    this.setColor(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix4x4:
                    this.setMatrix4x4(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Matrix3x3:
                    this.setMatrix3x3(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    this.setTexture(uniformIndex, value);
                    break;
                case exports.ShaderDataType.Buffer:
                    this.setBuffer(uniformIndex, value);
                    break;
                default:
                    throw new Error(`unknown shader data type: ${type}`);
            }
        }
        getShaderData(uniformIndex, type) {
            switch (type) {
                case exports.ShaderDataType.Int:
                    return this.getInt(uniformIndex);
                case exports.ShaderDataType.Bool:
                    return this.getBool(uniformIndex);
                case exports.ShaderDataType.Float:
                    return this.getNumber(uniformIndex);
                case exports.ShaderDataType.Vector2:
                    return this.getVector2(uniformIndex);
                case exports.ShaderDataType.Vector3:
                    return this.getVector3(uniformIndex);
                case exports.ShaderDataType.Vector4:
                    return this.getVector(uniformIndex);
                case exports.ShaderDataType.Color:
                    return this.getColor(uniformIndex);
                case exports.ShaderDataType.Texture2D:
                case exports.ShaderDataType.TextureCube:
                    return this.getTexture(uniformIndex);
                case exports.ShaderDataType.Buffer:
                    return this.getBuffer(uniformIndex);
                case exports.ShaderDataType.Matrix3x3:
                    return this.getMatrix3x3(uniformIndex);
                case exports.ShaderDataType.Matrix4x4:
                    return this.getMatrix4x4(uniformIndex);
                default:
                    throw "unknown shader data type.";
            }
        }
        _setInternalTexture(index, value) {
            throw new Laya.NotImplementedError();
        }
        cloneTo(destObject) {
            throw new Laya.NotImplementedError();
        }
        clone() {
            throw new Laya.NotImplementedError();
        }
        destroy() {
            throw new Laya.NotImplementedError();
        }
    }

    class PBRShaderLib {
        static init() {
            PBRShaderLib.DEFINE_EMISSION = Laya.Shader3D.getDefineByName("EMISSION");
            PBRShaderLib.DEFINE_CLEARCOAT = Laya.Shader3D.getDefineByName("CLEARCOAT");
            PBRShaderLib.DEFINE_CLEARCOAT_NORMAL = Laya.Shader3D.getDefineByName("CLEARCOAT_NORMAL");
            PBRShaderLib.DEFINE_ANISOTROPY = Laya.Shader3D.getDefineByName("ANISOTROPIC");
            PBRShaderLib.DEFINE_IOR = Laya.Shader3D.getDefineByName("IOR");
            PBRShaderLib.DEFINE_IRIDESCENCE = Laya.Shader3D.getDefineByName("IRIDESCENCE");
            PBRShaderLib.DEFINE_SHEEN = Laya.Shader3D.getDefineByName("SHEEN");
            PBRShaderLib.DEFINE_TRANSMISSION = Laya.Shader3D.getDefineByName("TRANSMISSION");
            PBRShaderLib.DEFINE_THICKNESS = Laya.Shader3D.getDefineByName("THICKNESS");
            Laya.Shader3D.addInclude("BRDF.glsl", BRDFGLSL);
            Laya.Shader3D.addInclude("PBRGI.glsl", PBRGIGLSL);
            Laya.Shader3D.addInclude("PBRCommon.glsl", PBRCommonGLSL);
            Laya.Shader3D.addInclude("PBRVertex.glsl", PBRVertexGLSL);
            Laya.Shader3D.addInclude("PBRFrag.glsl", PBRFragGLSL);
            PBRDefaultDFG.DefaultDfgTexture();
            Laya.SubShader.regIncludeBindUnifrom("PBRGI.glsl", { "u_IBLDFG": exports.ShaderDataType.Texture2D }, { "u_IBLDFG": PBRDefaultDFG.defaultDFG });
            Laya.Shader3D.addInclude("PBRMetallicFrag.glsl", PBRMetallicGLSL);
        }
    }

    exports.PBRRenderMode = void 0;
    (function (PBRRenderMode) {
        PBRRenderMode[PBRRenderMode["Opaque"] = 0] = "Opaque";
        PBRRenderMode[PBRRenderMode["Cutout"] = 1] = "Cutout";
        PBRRenderMode[PBRRenderMode["Fade"] = 2] = "Fade";
        PBRRenderMode[PBRRenderMode["Transparent"] = 3] = "Transparent";
    })(exports.PBRRenderMode || (exports.PBRRenderMode = {}));
    class PBRMaterial extends Laya.Material {
        static __init__() {
            PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE = Laya.Shader3D.getDefineByName("ALBEDOTEXTURE");
            PBRMaterial.SHADERDEFINE_NORMALTEXTURE = Laya.Shader3D.getDefineByName("NORMALTEXTURE");
            PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE = Laya.Shader3D.getDefineByName("PARALLAXTEXTURE");
            PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE = Laya.Shader3D.getDefineByName("OCCLUSIONTEXTURE");
            PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE = Laya.Shader3D.getDefineByName("EMISSIONTEXTURE");
            PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND = Laya.Shader3D.getDefineByName("TRANSPARENTBLEND");
            PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_HIGH = Laya.Shader3D.getDefineByName("LAYA_PBR_BRDF_HIGH");
            PBRMaterial.SHADERDEFINE_LAYA_PBR_BRDF_LOW = Laya.Shader3D.getDefineByName("LAYA_PBR_BRDF_LOW");
            PBRMaterial.SHADERDEFINE_DETAILALBEDO = Laya.Shader3D.getDefineByName("DETAILTEXTURE");
            PBRMaterial.SHADERDEFINE_DETAILNORMAL = Laya.Shader3D.getDefineByName("DETAILNORMAL");
            PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
            PBRMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_AlbedoTexture");
            PBRMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_AlbedoColor");
            PBRMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
            PBRMaterial.NORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_NormalTexture");
            PBRMaterial.NORMALSCALE = Laya.Shader3D.propertyNameToID("u_NormalScale");
            PBRMaterial.SMOOTHNESS = Laya.Shader3D.propertyNameToID("u_Smoothness");
            PBRMaterial.OCCLUSIONTEXTURE = Laya.Shader3D.propertyNameToID("u_OcclusionTexture");
            PBRMaterial.OCCLUSIONSTRENGTH = Laya.Shader3D.propertyNameToID("u_OcclusionStrength");
            PBRMaterial.PARALLAXTEXTURE = Laya.Shader3D.propertyNameToID("u_ParallaxTexture");
            PBRMaterial.PARALLAXSCALE = Laya.Shader3D.propertyNameToID("u_ParallaxScale");
            PBRMaterial.EMISSIONTEXTURE = Laya.Shader3D.propertyNameToID("u_EmissionTexture");
            PBRMaterial.EMISSIONCOLOR = Laya.Shader3D.propertyNameToID("u_EmissionColor");
            PBRMaterial.EMISSIONIntensity = Laya.Shader3D.propertyNameToID("u_EmissionIntensity");
            PBRMaterial.DETAILALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_DetailAlbedoTexture");
            PBRMaterial.DETAILNORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_DetailNormalTexture");
            PBRMaterial.DETAILTILLINGOFFSET = Laya.Shader3D.propertyNameToID("u_DetailTillingOffset");
            PBRMaterial.DETAILNORMALSCALE = Laya.Shader3D.propertyNameToID("u_DetailNormalScale");
            PBRMaterial.CLEARCOAT = Laya.Shader3D.propertyNameToID("u_ClearCoatFactor");
            PBRMaterial.SHADERDEFINE_CLEARCOATTEXTURE = Laya.Shader3D.getDefineByName("CLEARCOATMAP");
            PBRMaterial.CLEARCOATTEXTURE = Laya.Shader3D.propertyNameToID("u_ClearCoatTexture");
            PBRMaterial.CLEARCOATROUGHNESS = Laya.Shader3D.propertyNameToID("u_ClearCoatRoughness");
            PBRMaterial.SHADERDEFINE_CLEARCOATROUGHNESSTEXTURE = Laya.Shader3D.getDefineByName("CLEARCOAT_ROUGHNESSMAP");
            PBRMaterial.CLEARCOATROUGHNESSTEXTURE = Laya.Shader3D.propertyNameToID("u_ClearCoatRoughnessTexture");
            PBRMaterial.CLEARCOATNORMALTEXTURE = Laya.Shader3D.propertyNameToID("u_ClearCoatNormalTexture");
            PBRMaterial.ANISOTROPY = Laya.Shader3D.propertyNameToID("u_AnisotropyStrength");
            PBRMaterial.SHADERDEFINE_ANISOTROPYTEXTURE = Laya.Shader3D.getDefineByName("ANISOTROPYMAP");
            PBRMaterial.ANISOTROPYTEXTURE = Laya.Shader3D.propertyNameToID("u_AnisotropyTexture");
            PBRMaterial.ANISOTROPYROTATION = Laya.Shader3D.propertyNameToID("u_AnisotropyRotation");
        }
        get albedoColor() {
            return this._shaderValues.getColor(PBRMaterial.ALBEDOCOLOR);
        }
        set albedoColor(value) {
            this._shaderValues.setColor(PBRMaterial.ALBEDOCOLOR, value);
        }
        get albedoTexture() {
            if (this.hasDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE)) {
                return this._shaderValues.getTexture(PBRMaterial.ALBEDOTEXTURE);
            }
            else {
                return null;
            }
        }
        set albedoTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            this.setTextureByIndex(PBRMaterial.ALBEDOTEXTURE, value);
        }
        get normalTexture() {
            if (this.hasDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE)) {
                return this._shaderValues.getTexture(PBRMaterial.NORMALTEXTURE);
            }
            else {
                return null;
            }
        }
        set normalTexture(value) {
            if (value) {
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE);
            }
            else {
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_NORMALTEXTURE);
            }
            this.setTextureByIndex(PBRMaterial.NORMALTEXTURE, value);
        }
        get normalTextureScale() {
            return this._shaderValues.getNumber(PBRMaterial.NORMALSCALE);
        }
        set normalTextureScale(value) {
            this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, value);
        }
        get parallaxTexture() {
            return this._shaderValues.getTexture(PBRMaterial.PARALLAXTEXTURE);
        }
        set parallaxTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_PARALLAXTEXTURE);
            this.setTextureByIndex(PBRMaterial.PARALLAXTEXTURE, value);
        }
        get parallaxTextureScale() {
            return this._shaderValues.getNumber(PBRMaterial.PARALLAXSCALE);
        }
        set parallaxTextureScale(value) {
            this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, Math.max(0.005, Math.min(0.08, value)));
        }
        get occlusionTexture() {
            return this._shaderValues.getTexture(PBRMaterial.OCCLUSIONTEXTURE);
        }
        set occlusionTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_OCCLUSIONTEXTURE);
            this.setTextureByIndex(PBRMaterial.OCCLUSIONTEXTURE, value);
        }
        get occlusionTextureStrength() {
            return this._shaderValues.getNumber(PBRMaterial.OCCLUSIONSTRENGTH);
        }
        set occlusionTextureStrength(value) {
            this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, Math.max(0.0, Math.min(1.0, value)));
        }
        get smoothness() {
            return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS);
        }
        set smoothness(value) {
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0.0, Math.min(1.0, value)));
        }
        get enableVertexColor() {
            return this.hasDefine(PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set enableVertexColor(value) {
            if (value)
                this.addDefine(PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            else
                this.removeDefine(PBRMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        get enableEmission() {
            return this._shaderValues.hasDefine(PBRShaderLib.DEFINE_EMISSION);
        }
        set enableEmission(value) {
            if (value)
                this._shaderValues.addDefine(PBRShaderLib.DEFINE_EMISSION);
            else
                this._shaderValues.removeDefine(PBRShaderLib.DEFINE_EMISSION);
        }
        get emissionColor() {
            return this._shaderValues.getColor(PBRMaterial.EMISSIONCOLOR);
        }
        set emissionColor(value) {
            this._shaderValues.setColor(PBRMaterial.EMISSIONCOLOR, value);
        }
        get emissionIntensity() {
            return this._shaderValues.getNumber(PBRMaterial.EMISSIONIntensity);
        }
        set emissionIntensity(value) {
            this._shaderValues.setNumber(PBRMaterial.EMISSIONIntensity, value);
        }
        get emissionTexture() {
            return this._shaderValues.getTexture(PBRMaterial.EMISSIONTEXTURE);
        }
        set emissionTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_EMISSIONTEXTURE);
            this.setTextureByIndex(PBRMaterial.EMISSIONTEXTURE, value);
        }
        get tilingOffset() {
            return this._shaderValues.getVector(PBRMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, value);
            }
            else {
                this._shaderValues.getVector(PBRMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get detailAlbedoTexture() {
            return this._shaderValues.getTexture(PBRMaterial.DETAILALBEDOTEXTURE);
        }
        set detailAlbedoTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_DETAILALBEDO);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_DETAILALBEDO);
            this.setTextureByIndex(PBRMaterial.DETAILALBEDOTEXTURE, value);
        }
        get detailNormalTexture() {
            return this._shaderValues.getTexture(PBRMaterial.DETAILNORMALTEXTURE);
        }
        set detailNormalTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_DETAILNORMAL);
            else
                this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_DETAILNORMAL);
            this.setTextureByIndex(PBRMaterial.DETAILNORMALTEXTURE, value);
        }
        get detailTilingOffset() {
            return this._shaderValues.getVector(PBRMaterial.DETAILTILLINGOFFSET);
        }
        set detailTilingOffset(value) {
            if (value) {
                this._shaderValues.setVector(PBRMaterial.DETAILTILLINGOFFSET, value);
            }
            else {
                this._shaderValues.getVector(PBRMaterial.DETAILTILLINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        get detailNormalScale() {
            return this._shaderValues.getNumber(PBRMaterial.DETAILNORMALSCALE);
        }
        set detailNormalScale(value) {
            this._shaderValues.setNumber(PBRMaterial.DETAILNORMALSCALE, value);
        }
        set renderMode(value) {
            switch (value) {
                case exports.PBRRenderMode.Opaque:
                    this.alphaTest = false;
                    this.renderQueue = Laya.Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case exports.PBRRenderMode.Cutout:
                    this.renderQueue = Laya.Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case exports.PBRRenderMode.Fade:
                    this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.removeDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                case exports.PBRRenderMode.Transparent:
                    this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_ONE;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    this._shaderValues.addDefine(PBRMaterial.SHADERDEFINE_TRANSPARENTBLEND);
                    break;
                default:
                    throw new Error("unknown renderMode: " + value);
            }
        }
        get anisotropyEnable() {
            return this.shaderData.hasDefine(PBRShaderLib.DEFINE_ANISOTROPY);
        }
        set anisotropyEnable(value) {
            if (value) {
                this.shaderData.addDefine(PBRShaderLib.DEFINE_ANISOTROPY);
            }
            else {
                this.shaderData.removeDefine(PBRShaderLib.DEFINE_ANISOTROPY);
            }
        }
        get anisotropy() {
            return this.getFloatByIndex(PBRMaterial.ANISOTROPY);
        }
        set anisotropy(value) {
            this.setFloatByIndex(PBRMaterial.ANISOTROPY, Math.min(1, Math.max(-1, value)));
        }
        get anisotropyTexture() {
            return this.getTextureByIndex(PBRMaterial.ANISOTROPYTEXTURE);
        }
        set anisotropyTexture(value) {
            this.setTextureByIndex(PBRMaterial.ANISOTROPYTEXTURE, value);
            if (value) {
                this.addDefine(PBRMaterial.SHADERDEFINE_ANISOTROPYTEXTURE);
            }
            else {
                this.removeDefine(PBRMaterial.SHADERDEFINE_ANISOTROPYTEXTURE);
            }
        }
        get anisotropyRotation() {
            return this.getFloatByIndex(PBRMaterial.ANISOTROPYROTATION);
        }
        set anisotropyRotation(value) {
            value = Math.max(Math.min(value, 1.0), 0.0);
            this.setFloatByIndex(PBRMaterial.ANISOTROPYROTATION, value);
        }
        get clearCoatEnable() {
            return this.shaderData.hasDefine(PBRShaderLib.DEFINE_CLEARCOAT);
        }
        set clearCoatEnable(value) {
            if (value) {
                this.shaderData.addDefine(PBRShaderLib.DEFINE_CLEARCOAT);
            }
            else {
                this.shaderData.removeDefine(PBRShaderLib.DEFINE_CLEARCOAT);
            }
        }
        get clearCoat() {
            return this.shaderData.getNumber(PBRMaterial.CLEARCOAT);
        }
        set clearCoat(value) {
            this.shaderData.setNumber(PBRMaterial.CLEARCOAT, value);
        }
        get clearCoatTexture() {
            return this.shaderData.getTexture(PBRMaterial.CLEARCOATTEXTURE);
        }
        set clearCoatTexture(value) {
            if (value) {
                this.shaderData.addDefine(PBRMaterial.SHADERDEFINE_CLEARCOATTEXTURE);
            }
            else {
                this.shaderData.removeDefine(PBRMaterial.SHADERDEFINE_CLEARCOATTEXTURE);
            }
            this.setTextureByIndex(PBRMaterial.CLEARCOATTEXTURE, value);
        }
        get clearCoatRoughness() {
            return this.shaderData.getNumber(PBRMaterial.CLEARCOATROUGHNESS);
        }
        set clearCoatRoughness(value) {
            this.shaderData.setNumber(PBRMaterial.CLEARCOATROUGHNESS, value);
        }
        get clearCoatRoughnessTexture() {
            return this.shaderData.getTexture(PBRMaterial.CLEARCOATROUGHNESSTEXTURE);
        }
        set clearCoatRoughnessTexture(value) {
            if (value) {
                this.shaderData.addDefine(PBRMaterial.SHADERDEFINE_CLEARCOATROUGHNESSTEXTURE);
            }
            else {
                this.shaderData.removeDefine(PBRMaterial.SHADERDEFINE_CLEARCOATROUGHNESSTEXTURE);
            }
            this.setTextureByIndex(PBRMaterial.CLEARCOATROUGHNESSTEXTURE, value);
        }
        get clearCoatNormalTexture() {
            return this.shaderData.getTexture(PBRMaterial.CLEARCOATNORMALTEXTURE);
        }
        set clearCoatNormalTexture(value) {
            if (value) {
                this.shaderData.addDefine(PBRShaderLib.DEFINE_CLEARCOAT_NORMAL);
            }
            else {
                this.shaderData.removeDefine(PBRShaderLib.DEFINE_CLEARCOAT_NORMAL);
            }
            this.setTextureByIndex(PBRMaterial.CLEARCOATNORMALTEXTURE, value);
        }
        constructor() {
            super();
            this._shaderValues.setColor(PBRMaterial.ALBEDOCOLOR, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            this._shaderValues.setColor(PBRMaterial.EMISSIONCOLOR, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            this._shaderValues.setVector(PBRMaterial.TILINGOFFSET, new Laya.Vector4(1.0, 1.0, 0.0, 0.0));
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, 0.5);
            this._shaderValues.setNumber(PBRMaterial.OCCLUSIONSTRENGTH, 1.0);
            this._shaderValues.setNumber(PBRMaterial.NORMALSCALE, 1.0);
            this._shaderValues.setNumber(PBRMaterial.PARALLAXSCALE, 0.001);
            this._shaderValues.setNumber(Laya.Material.ALPHATESTVALUE, 0.5);
            this.renderMode = exports.PBRRenderMode.Opaque;
        }
        get smoothnessTextureScale() {
            return this._shaderValues.getNumber(PBRMaterial.SMOOTHNESS);
        }
        set smoothnessTextureScale(value) {
            this._shaderValues.setNumber(PBRMaterial.SMOOTHNESS, Math.max(0.0, Math.min(1.0, value)));
        }
    }
    PBRMaterial.renderQuality = exports.PBRRenderQuality.High;

    exports.PBRMetallicSmoothnessSource = void 0;
    (function (PBRMetallicSmoothnessSource) {
        PBRMetallicSmoothnessSource[PBRMetallicSmoothnessSource["MetallicGlossTextureAlpha"] = 0] = "MetallicGlossTextureAlpha";
        PBRMetallicSmoothnessSource[PBRMetallicSmoothnessSource["AlbedoTextureAlpha"] = 1] = "AlbedoTextureAlpha";
    })(exports.PBRMetallicSmoothnessSource || (exports.PBRMetallicSmoothnessSource = {}));
    class PBRStandardMaterial extends PBRMaterial {
        static __init__() {
            PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE = Laya.Shader3D.getDefineByName("METALLICGLOSSTEXTURE");
            PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA = Laya.Shader3D.getDefineByName("SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA");
            PBRStandardMaterial.METALLICGLOSSTEXTURE = Laya.Shader3D.propertyNameToID("u_MetallicGlossTexture");
            PBRStandardMaterial.METALLIC = Laya.Shader3D.propertyNameToID("u_Metallic");
        }
        get metallicGlossTexture() {
            return this._shaderValues.getTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE);
        }
        set metallicGlossTexture(value) {
            if (value)
                this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
            else
                this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_METALLICGLOSSTEXTURE);
            this._shaderValues.setTexture(PBRStandardMaterial.METALLICGLOSSTEXTURE, value);
        }
        get metallic() {
            return this._shaderValues.getNumber(PBRStandardMaterial.METALLIC);
        }
        set metallic(value) {
            this._shaderValues.setNumber(PBRStandardMaterial.METALLIC, Math.max(0.0, Math.min(1.0, value)));
        }
        get smoothnessSource() {
            return this._smoothnessSource;
        }
        set smoothnessSource(value) {
            if (value)
                this._shaderValues.addDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
            else
                this._shaderValues.removeDefine(PBRStandardMaterial.SHADERDEFINE_SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA);
            this._smoothnessSource = value;
        }
        constructor() {
            super();
            this._smoothnessSource = 0;
            this.setShaderName("PBR");
        }
        clone() {
            var dest = new PBRStandardMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }

    class SkyBoxMaterial extends Laya.Material {
        static __initDefine__() {
            SkyBoxMaterial.TINTCOLOR = Laya.Shader3D.propertyNameToID("u_TintColor");
            SkyBoxMaterial.EXPOSURE = Laya.Shader3D.propertyNameToID("u_Exposure");
            SkyBoxMaterial.ROTATION = Laya.Shader3D.propertyNameToID("u_Rotation");
            SkyBoxMaterial.TEXTURECUBE = Laya.Shader3D.propertyNameToID("u_CubeTexture");
        }
        get tintColor() {
            return this._shaderValues.getColor(SkyBoxMaterial.TINTCOLOR);
        }
        set tintColor(value) {
            this._shaderValues.setColor(SkyBoxMaterial.TINTCOLOR, value);
        }
        get exposure() {
            return this._shaderValues.getNumber(SkyBoxMaterial.EXPOSURE);
        }
        set exposure(value) {
            this._shaderValues.setNumber(SkyBoxMaterial.EXPOSURE, value);
        }
        get rotation() {
            return this._shaderValues.getNumber(SkyBoxMaterial.ROTATION);
        }
        set rotation(value) {
            this._shaderValues.setNumber(SkyBoxMaterial.ROTATION, value);
        }
        get textureCube() {
            return this._shaderValues.getTexture(SkyBoxMaterial.TEXTURECUBE);
        }
        set textureCube(value) {
            this._shaderValues.setTexture(SkyBoxMaterial.TEXTURECUBE, value);
        }
        clone() {
            var dest = new SkyBoxMaterial();
            this.cloneTo(dest);
            return dest;
        }
        constructor() {
            super();
            this.setShaderName("SkyBox");
        }
    }

    class SkyProceduralMaterial extends Laya.Material {
        static __initDefine__() {
            SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY = Laya.Shader3D.getDefineByName("SUN_HIGH_QUALITY");
            SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE = Laya.Shader3D.getDefineByName("SUN_SIMPLE");
            SkyProceduralMaterial.SUNSIZE = Laya.Shader3D.propertyNameToID("u_SunSize");
            SkyProceduralMaterial.SUNSIZECONVERGENCE = Laya.Shader3D.propertyNameToID("u_SunSizeConvergence");
            SkyProceduralMaterial.ATMOSPHERETHICKNESS = Laya.Shader3D.propertyNameToID("u_AtmosphereThickness");
            SkyProceduralMaterial.SKYTINT = Laya.Shader3D.propertyNameToID("u_SkyTint");
            SkyProceduralMaterial.GROUNDTINT = Laya.Shader3D.propertyNameToID("u_GroundTint");
            SkyProceduralMaterial.EXPOSURE = Laya.Shader3D.propertyNameToID("u_Exposure");
        }
        get sunDisk() {
            return this._sunDisk;
        }
        set sunDisk(value) {
            switch (value) {
                case SkyProceduralMaterial.SUN_HIGH_QUALITY:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    break;
                case SkyProceduralMaterial.SUN_SIMPLE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    this._shaderValues.addDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;
                case SkyProceduralMaterial.SUN_NODE:
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_HIGH_QUALITY);
                    this._shaderValues.removeDefine(SkyProceduralMaterial.SHADERDEFINE_SUN_SIMPLE);
                    break;
                default:
                    throw "SkyBoxProceduralMaterial: unknown sun value.";
            }
            this._sunDisk = value;
        }
        get sunSize() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZE);
        }
        set sunSize(value) {
            value = Math.min(Math.max(0.0, value), 1.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZE, value);
        }
        get sunSizeConvergence() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE);
        }
        set sunSizeConvergence(value) {
            value = Math.min(Math.max(0.0, value), 20.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.SUNSIZECONVERGENCE, value);
        }
        get atmosphereThickness() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS);
        }
        set atmosphereThickness(value) {
            value = Math.min(Math.max(0.0, value), 5.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.ATMOSPHERETHICKNESS, value);
        }
        get skyTint() {
            return this._shaderValues.getColor(SkyProceduralMaterial.SKYTINT);
        }
        set skyTint(value) {
            this._shaderValues.setColor(SkyProceduralMaterial.SKYTINT, value);
        }
        get groundTint() {
            return this._shaderValues.getColor(SkyProceduralMaterial.GROUNDTINT);
        }
        set groundTint(value) {
            this._shaderValues.setColor(SkyProceduralMaterial.GROUNDTINT, value);
        }
        get exposure() {
            return this._shaderValues.getNumber(SkyProceduralMaterial.EXPOSURE);
        }
        set exposure(value) {
            value = Math.min(Math.max(0.0, value), 8.0);
            this._shaderValues.setNumber(SkyProceduralMaterial.EXPOSURE, value);
        }
        constructor() {
            super();
            this.setShaderName("SkyProcedural");
            this.sunDisk = SkyProceduralMaterial.SUN_HIGH_QUALITY;
            this.sunSize = 0.04;
            this.sunSizeConvergence = 5;
            this.atmosphereThickness = 1.0;
            this.skyTint = new Laya.Color(0.5, 0.5, 0.5, 1.0);
            this.groundTint = new Laya.Color(0.369, 0.349, 0.341, 1.0);
            this.exposure = 1.3;
        }
        clone() {
            var dest = new SkyProceduralMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }
    SkyProceduralMaterial.SUN_NODE = 0;
    SkyProceduralMaterial.SUN_SIMPLE = 1;
    SkyProceduralMaterial.SUN_HIGH_QUALITY = 2;

    class UnlitMaterial extends Laya.Material {
        static __initDefine__() {
            UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE = Laya.Shader3D.getDefineByName("ALBEDOTEXTURE");
            UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR = Laya.Shader3D.getDefineByName("ENABLEVERTEXCOLOR");
            UnlitMaterial.ALBEDOTEXTURE = Laya.Shader3D.propertyNameToID("u_AlbedoTexture");
            UnlitMaterial.ALBEDOCOLOR = Laya.Shader3D.propertyNameToID("u_AlbedoColor");
            UnlitMaterial.TILINGOFFSET = Laya.Shader3D.propertyNameToID("u_TilingOffset");
        }
        get albedoColor() {
            return this.getColorByIndex(UnlitMaterial.ALBEDOCOLOR);
        }
        set albedoColor(value) {
            this.setColorByIndex(UnlitMaterial.ALBEDOCOLOR, value.scale(this._albedoIntensity));
        }
        get albedoIntensity() {
            return this._albedoIntensity;
        }
        set albedoIntensity(value) {
            this._albedoIntensity = value;
        }
        get albedoTexture() {
            return this.getTextureByIndex(UnlitMaterial.ALBEDOTEXTURE);
        }
        set albedoTexture(value) {
            if (value)
                this.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            else
                this.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            this.setTextureByIndex(UnlitMaterial.ALBEDOTEXTURE, value);
        }
        get tilingOffset() {
            return this.getVector4ByIndex(UnlitMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, value);
            }
            else {
                this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, new Laya.Vector4(1.0, 1.0, 0.0, 0.0));
            }
        }
        get enableVertexColor() {
            return this.hasDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        set enableVertexColor(value) {
            if (value)
                this.addDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
            else
                this.removeDefine(UnlitMaterial.SHADERDEFINE_ENABLEVERTEXCOLOR);
        }
        constructor() {
            super();
            this.setShaderName("Unlit");
            this.renderMode = UnlitMaterial.RENDERMODE_OPAQUE;
            this.albedoIntensity = 1.0;
        }
        clone() {
            var dest = new UnlitMaterial();
            this.cloneTo(dest);
            return dest;
        }
        set renderMode(value) {
            switch (value) {
                case UnlitMaterial.RENDERMODE_OPAQUE:
                    this.alphaTest = false;
                    this.renderQueue = Laya.Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case UnlitMaterial.RENDERMODE_CUTOUT:
                    this.renderQueue = Laya.Material.RENDERQUEUE_ALPHATEST;
                    this.alphaTest = true;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case UnlitMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                default:
                    throw new Error("unknown renderMode: " + value);
            }
        }
    }
    UnlitMaterial.RENDERMODE_OPAQUE = 0;
    UnlitMaterial.RENDERMODE_CUTOUT = 1;
    UnlitMaterial.RENDERMODE_TRANSPARENT = 2;
    UnlitMaterial.RENDERMODE_ADDTIVE = 3;

    exports.BaseRenderType = void 0;
    (function (BaseRenderType) {
        BaseRenderType[BaseRenderType["BaseRender"] = 0] = "BaseRender";
        BaseRenderType[BaseRenderType["MeshRender"] = 1] = "MeshRender";
        BaseRenderType[BaseRenderType["ParticleRender"] = 2] = "ParticleRender";
        BaseRenderType[BaseRenderType["TrailRender"] = 3] = "TrailRender";
        BaseRenderType[BaseRenderType["LineRender"] = 4] = "LineRender";
        BaseRenderType[BaseRenderType["TerrainRender"] = 5] = "TerrainRender";
        BaseRenderType[BaseRenderType["SkyRender"] = 7] = "SkyRender";
        BaseRenderType[BaseRenderType["SimpleSkinRender"] = 8] = "SimpleSkinRender";
        BaseRenderType[BaseRenderType["SkinnedMeshRender"] = 9] = "SkinnedMeshRender";
    })(exports.BaseRenderType || (exports.BaseRenderType = {}));
    exports.ENodeCustomData = void 0;
    (function (ENodeCustomData) {
        ENodeCustomData[ENodeCustomData["custom_0"] = 0] = "custom_0";
        ENodeCustomData[ENodeCustomData["custom_1"] = 1] = "custom_1";
        ENodeCustomData[ENodeCustomData["custom_2"] = 2] = "custom_2";
    })(exports.ENodeCustomData || (exports.ENodeCustomData = {}));

    class Laya3DRender {
    }

    class MeshSprite3DShaderDeclaration {
    }

    class MeshUtil {
        static getMeshDefine(mesh, out) {
            out.length = 0;
            let vertexElements = mesh._vertexBuffer.vertexDeclaration._vertexElements;
            for (const element of vertexElements) {
                switch (element.elementUsage) {
                    case Laya.VertexMesh.MESH_COLOR0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
                        break;
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
                        break;
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT);
                        break;
                }
            }
        }
    }

    class MeshFilter extends Laya.Component {
        constructor() {
            super();
            this.runInEditor = true;
        }
        _onEnable() {
            const render = this.owner.getComponent(MeshRenderer);
            render && render._enabled && render._onMeshChange(this._sharedMesh);
        }
        _onDisable() {
            this.owner.getComponent(MeshRenderer);
        }
        get sharedMesh() {
            return this._sharedMesh;
        }
        set sharedMesh(value) {
            if (this._sharedMesh !== value) {
                var lastValue = this._sharedMesh;
                if (lastValue) {
                    lastValue._removeReference();
                }
                if (value) {
                    value._addReference();
                }
                this._sharedMesh = value;
                const render = this.owner.getComponent(MeshRenderer);
                if (!render) {
                    return;
                }
                render._onMeshChange(value);
                this._sharedMesh = value;
            }
        }
        _onDestroy() {
            (this._sharedMesh) && (this._sharedMesh._removeReference(), this._sharedMesh = null);
        }
        _cloneTo(dest) {
            dest.sharedMesh = this.sharedMesh;
            super._cloneTo(dest);
        }
    }
    MeshFilter._meshVerticeDefine = [];

    exports.StaticFlag = void 0;
    (function (StaticFlag) {
        StaticFlag[StaticFlag["Normal"] = 1] = "Normal";
        StaticFlag[StaticFlag["StaticBatch"] = 2] = "StaticBatch";
    })(exports.StaticFlag || (exports.StaticFlag = {}));
    class Sprite3D extends Laya.Node {
        static __init__() {
            Sprite3D.WORLDMATRIX = Laya.Shader3D.propertyNameToID("u_WorldMat");
            Sprite3D.WORLDINVERTFRONT = Laya.Shader3D.propertyNameToID("u_WorldInvertFront");
            Sprite3D.sprite3DCommandUniformMap = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite3D");
            Sprite3D.sprite3DCommandUniformMap.addShaderUniform(Sprite3D.WORLDMATRIX, "u_WorldMat", exports.ShaderDataType.Matrix4x4);
            Sprite3D.sprite3DCommandUniformMap.addShaderUniform(Sprite3D.WORLDINVERTFRONT, "u_WorldInvertFront", exports.ShaderDataType.Vector4);
        }
        static instantiate(original, parent = null, worldPositionStays = true, position = null, rotation = null) {
            var destSprite3D = original.clone();
            (parent) && (parent.addChild(destSprite3D));
            var transform = destSprite3D.transform;
            if (worldPositionStays) {
                var worldMatrix = transform.worldMatrix;
                original.transform.worldMatrix.cloneTo(worldMatrix);
                transform.worldMatrix = worldMatrix;
            }
            else {
                (position) && (transform.position = position);
                (rotation) && (transform.rotation = rotation);
            }
            return destSprite3D;
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url).then((res) => {
                complete && complete.runWith([res === null || res === void 0 ? void 0 : res.create()]);
            });
        }
        get id() {
            return this._id;
        }
        get layer() {
            return this._layer;
        }
        set layer(value) {
            if (this._layer !== value) {
                if (value >= 0 && value <= 30) {
                    this._layer = value;
                    this.event(Laya.Event.LAYER_CHANGE, value);
                }
                else {
                    throw new Error("Layer value must be 0-30.");
                }
            }
        }
        get isStatic() {
            return !!(this._isStatic >> 1 | 0x0);
        }
        set isStatic(value) {
            this._isStatic = value ? exports.StaticFlag.StaticBatch : exports.StaticFlag.Normal;
            this.event(Laya.Event.STATIC_MASK, this._isStatic);
        }
        get transform() {
            return this._transform;
        }
        get scene() {
            return this._scene;
        }
        constructor(name, isStatic) {
            super();
            this._isRenderNode = 0;
            this._nodeType = 1;
            this._id = ++_uniqueIDCounter;
            this._transform = Laya3DRender.Render3DModuleDataFactory.createTransform(this);
            this._isStatic = isStatic ? exports.StaticFlag.StaticBatch : exports.StaticFlag.Normal;
            this.layer = 0;
            this.name = name ? name : "New Sprite3D";
        }
        _onActive() {
            super._onActive();
            Laya.Stat.sprite3DCount++;
        }
        _onInActive() {
            super._onInActive();
            Laya.Stat.sprite3DCount--;
        }
        _onAdded() {
            if (this._parent instanceof Sprite3D) {
                var parent3D = this._parent;
                this.transform._setParent(parent3D.transform);
            }
            else
                this.transform._onWorldTransform();
            super._onAdded();
        }
        _onRemoved() {
            super._onRemoved();
            if (this._parent instanceof Sprite3D)
                this.transform._setParent(null);
        }
        onStartListeningToType(type) {
            super.onStartListeningToType(type);
            if (type.startsWith("collision") || type.startsWith("trigger"))
                this.event(Laya.Event.UPDATE_PHY_EVENT_FILTER);
        }
        _cloneTo(destObject, srcRoot, dstRoot) {
            if (this._destroyed)
                throw new Error("Sprite3D: Can't be cloned if the Sprite3D has destroyed.");
            var trans = this._transform;
            var destTrans = destObject._transform;
            destObject.name = this.name;
            destObject.tag = this.tag;
            destObject._destroyed = this._destroyed;
            destObject.active = this.active;
            destTrans.localPosition = trans.localPosition;
            destTrans.localRotation = trans.localRotation;
            destTrans.localScale = trans.localScale;
            destObject._isStatic = this._isStatic;
            destObject.layer = this.layer;
            super._cloneTo(destObject, srcRoot, dstRoot);
        }
        static _createSprite3DInstance(scrSprite) {
            let node = new (Object.getPrototypeOf(scrSprite).constructor)();
            let children = scrSprite._children;
            for (let i = 0, n = children.length; i < n; i++) {
                let child = Sprite3D._createSprite3DInstance(children[i]);
                node.addChild(child);
            }
            return node;
        }
        static _parseSprite3DInstance(srcRoot, dstRoot, scrSprite, dstSprite) {
            let srcChildren = scrSprite._children;
            let dstChildren = dstSprite._children;
            for (let i = 0, n = srcChildren.length; i < n; i++)
                Sprite3D._parseSprite3DInstance(srcRoot, dstRoot, srcChildren[i], dstChildren[i]);
            scrSprite._cloneTo(dstSprite, srcRoot, dstRoot);
        }
        clone() {
            let dstSprite3D = Sprite3D._createSprite3DInstance(this);
            Sprite3D._parseSprite3DInstance(this, dstSprite3D, this, dstSprite3D);
            return dstSprite3D;
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._transform = null;
        }
    }
    var _uniqueIDCounter = 0;

    class RenderableSprite3D extends Sprite3D {
        static __init__() {
            RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW = Laya.Shader3D.getDefineByName("RECEIVESHADOW");
            RenderableSprite3D.SAHDERDEFINE_LIGHTMAP = Laya.Shader3D.getDefineByName("LIGHTMAP");
            RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL = Laya.Shader3D.getDefineByName("LIGHTMAP_DIRECTIONAL");
            RenderableSprite3D.LIGHTMAPSCALEOFFSET = Laya.Shader3D.propertyNameToID("u_LightmapScaleOffset");
            RenderableSprite3D.LIGHTMAP = Laya.Shader3D.propertyNameToID("u_LightMap");
            RenderableSprite3D.LIGHTMAP_DIRECTION = Laya.Shader3D.propertyNameToID("u_LightMapDirection");
            RenderableSprite3D.PICKCOLOR = Laya.Shader3D.propertyNameToID("u_PickColor");
            const commandUniform = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("Sprite3D");
            RenderableSprite3D.SHADERDEFINE_MORPHTARGET = Laya.Shader3D.getDefineByName("MORPHTARGETS");
            RenderableSprite3D.SHADERDEFINE_MORPHTARGET_POSITION = Laya.Shader3D.getDefineByName("MORPHTARGETS_POSITION");
            RenderableSprite3D.SHADERDEFINE_MORPHTARGET_NORMAL = Laya.Shader3D.getDefineByName("MORPHTARGETS_NORMAL");
            RenderableSprite3D.SHADERDEFINE_MORPHTARGET_TANGENT = Laya.Shader3D.getDefineByName("MORPHTARGETS_TANGENT");
            RenderableSprite3D.MorphTex = Laya.Shader3D.propertyNameToID("u_MorphTargetsTex");
            RenderableSprite3D.MorphParams = Laya.Shader3D.propertyNameToID("u_MorphParams");
            RenderableSprite3D.MorphAttriOffset = Laya.Shader3D.propertyNameToID("u_MorphAttrOffset");
            RenderableSprite3D.MorphActiceTargets = Laya.Shader3D.propertyNameToID("u_MorphActiveTargets");
            RenderableSprite3D.MorphActiveCount = Laya.Shader3D.propertyNameToID("u_MorphTargetActiveCount");
            commandUniform.addShaderUniform(RenderableSprite3D.MorphTex, "u_MorphTargetsTex", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(RenderableSprite3D.MorphParams, "u_MorphParams", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(RenderableSprite3D.MorphAttriOffset, "u_MorphAttrOffset", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(RenderableSprite3D.MorphActiceTargets, "u_MorphActiveTargets", exports.ShaderDataType.Buffer);
            commandUniform.addShaderUniform(RenderableSprite3D.MorphActiveCount, "u_MorphTargetActiveCount", exports.ShaderDataType.Int);
            commandUniform.addShaderUniform(RenderableSprite3D.LIGHTMAPSCALEOFFSET, "u_LightmapScaleOffset", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(RenderableSprite3D.LIGHTMAP, "u_LightMap", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(RenderableSprite3D.LIGHTMAP_DIRECTION, "u_LightMapDirection", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(RenderableSprite3D.PICKCOLOR, "u_PickColor", exports.ShaderDataType.Vector3);
            RenderableSprite3D.REFLECTIONTEXTURE = Laya.Shader3D.propertyNameToID("u_ReflectTexture");
            RenderableSprite3D.REFLECTIONCUBE_HDR_PARAMS = Laya.Shader3D.propertyNameToID("u_ReflectCubeHDRParams");
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONTEXTURE, "u_ReflectTexture", exports.ShaderDataType.TextureCube);
            commandUniform.addShaderUniform(RenderableSprite3D.REFLECTIONCUBE_HDR_PARAMS, "u_ReflectCubeHDRParams", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHAR = Laya.Shader3D.propertyNameToID("u_AmbientSHAr");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHAR, "u_AmbientSHAr", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHAG = Laya.Shader3D.propertyNameToID("u_AmbientSHAg");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHAG, "u_AmbientSHAg", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHAB = Laya.Shader3D.propertyNameToID("u_AmbientSHAb");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHAB, "u_AmbientSHAb", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHBR = Laya.Shader3D.propertyNameToID("u_AmbientSHBr");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHBR, "u_AmbientSHBr", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHBG = Laya.Shader3D.propertyNameToID("u_AmbientSHBg");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHBG, "u_AmbientSHBg", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHBB = Laya.Shader3D.propertyNameToID("u_AmbientSHBb");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHBB, "u_AmbientSHBb", exports.ShaderDataType.Vector4);
            RenderableSprite3D.AMBIENTSHC = Laya.Shader3D.propertyNameToID("u_AmbientSHC");
            commandUniform.addShaderUniform(RenderableSprite3D.AMBIENTSHC, "u_AmbientSHC", exports.ShaderDataType.Vector4);
        }
        constructor(name) {
            super(name);
        }
        _onInActive() {
            super._onInActive();
        }
        _onActive() {
            super._onActive();
        }
        _onActiveInScene() {
            super._onActiveInScene();
        }
        _addToInitStaticBatchManager() {
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
        }
        _setUnBelongScene() {
            super._setUnBelongScene();
        }
    }

    class Bounds {
        static merge(box1, box2, out) {
            Laya.Vector3.min(box1.min, box2.min, out.min);
            Laya.Vector3.max(box1.max, box2.max, out.max);
            out.min = out.min;
            out.max = out.max;
        }
        static containPoint(box, point) {
            let max = box._imp.getMax();
            let min = box._imp.getMin();
            if (point.x > max.x || point.x < min.x)
                return false;
            if (point.y > max.y || point.y < min.y)
                return false;
            if (point.z > max.z || point.z < min.z)
                return false;
            return true;
        }
        get min() {
            return this.getMin();
        }
        set min(value) {
            this.setMin(value);
        }
        get max() {
            return this.getMax();
        }
        set max(value) {
            this.setMax(value);
        }
        setMin(value) {
            this._imp.setMin(value);
        }
        getMin() {
            return this._imp.getMin();
        }
        setMax(value) {
            this._imp.setMax(value);
        }
        getMax() {
            return this._imp.getMax();
        }
        setCenter(value) {
            this._imp.setCenter(value);
        }
        getCenter() {
            return this._imp.getCenter();
        }
        setExtent(value) {
            this._imp.setExtent(value);
        }
        getExtent() {
            return this._imp.getExtent();
        }
        constructor(min, max) {
            this._imp = Laya3DRender.Render3DModuleDataFactory.createBounds(min, max);
        }
        _getUpdateFlag(type) {
            return this._imp._getUpdateFlag(type);
        }
        _setUpdateFlag(type, value) {
            this._imp._setUpdateFlag(type, value);
        }
        _getCenter(min, max, out) {
            Laya.Vector3.add(min, max, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getExtent(min, max, out) {
            Laya.Vector3.subtract(max, min, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getMin(center, extent, out) {
            Laya.Vector3.subtract(center, extent, out);
        }
        _getMax(center, extent, out) {
            Laya.Vector3.add(center, extent, out);
        }
        _rotateExtents(extents, rotation, out) {
            var extentsX = extents.x;
            var extentsY = extents.y;
            var extentsZ = extents.z;
            var matE = rotation.elements;
            out.x = Math.abs(matE[0] * extentsX) + Math.abs(matE[4] * extentsY) + Math.abs(matE[8] * extentsZ);
            out.y = Math.abs(matE[1] * extentsX) + Math.abs(matE[5] * extentsY) + Math.abs(matE[9] * extentsZ);
            out.z = Math.abs(matE[2] * extentsX) + Math.abs(matE[6] * extentsY) + Math.abs(matE[10] * extentsZ);
        }
        _tranform(matrix, out) {
            this._imp._tranform(matrix, out._imp);
        }
        getCorners(corners) {
            this._imp.getCorners(corners);
        }
        getBoundBox(box) {
            this._imp._getBoundBox().cloneTo(box);
        }
        calculateBoundsintersection(bounds) {
            return this._imp.calculateBoundsintersection(bounds._imp);
        }
        cloneTo(destObject) {
            this._imp.cloneTo(destObject._imp);
        }
        clone() {
            var dest = new Bounds(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    Bounds._UPDATE_MIN = 0x01;
    Bounds._UPDATE_MAX = 0x02;
    Bounds._UPDATE_CENTER = 0x04;
    Bounds._UPDATE_EXTENT = 0x08;

    exports.volumeIntersectType = void 0;
    (function (volumeIntersectType) {
        volumeIntersectType[volumeIntersectType["contain"] = 0] = "contain";
        volumeIntersectType[volumeIntersectType["intersect"] = 1] = "intersect";
        volumeIntersectType[volumeIntersectType["Disjoint"] = 2] = "Disjoint";
    })(exports.volumeIntersectType || (exports.volumeIntersectType = {}));
    class volumeIntersectInfo {
    }
    class Volume extends Laya.Component {
        constructor() {
            super();
            this._aroundVolumeCacheNum = 0;
            this._bounds = new Bounds();
            this._primitiveBounds = new Bounds();
            this._importance = 0;
            this.runInEditor = true;
        }
        get type() {
            return this._type;
        }
        get bounds() {
            return this._bounds;
        }
        get boundsMax() {
            return this._primitiveBounds.getMax();
        }
        set boundsMax(value) {
            this._primitiveBounds.setMax(value);
            this._reCaculateBoundBox();
        }
        get boundsMin() {
            return this._primitiveBounds.getMin();
        }
        set boundsMin(value) {
            this._primitiveBounds.setMin(value);
            this._reCaculateBoundBox();
        }
        get probePosition() {
            return this.owner.transform.position;
        }
        get importance() {
            return this._importance;
        }
        set importance(value) {
            this._importance = value;
        }
        _onEnable() {
            this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._VolumeChange);
            this._volumeManager = this.owner.scene._volumeManager;
            this._volumeManager.add(this);
            this._reCaculateBoundBox();
        }
        _onDisable() {
            this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._VolumeChange);
            this._volumeManager.remove(this);
        }
        _VolumeChange() {
            this._volumeManager._needUpdateAllRender = true;
            let reManager = this._volumeManager._regVolumeManager[this.type];
            if (reManager) {
                reManager._needUpdateAllRender = true;
            }
            this._reCaculateBoundBox();
        }
        _reCaculateBoundBox() {
            this.owner && this._primitiveBounds._tranform(this.owner.transform.worldMatrix, this._bounds);
        }
    }

    class ReflectionProbeManager {
        constructor() {
            this._reflectionProbes = new Laya.SingletonList();
            this._needUpdateAllRender = false;
            this._sceneReflectionProbe = new ReflectionProbe();
            this._sceneReflectionProbe.boxProjection = false;
            this._sceneReflectionProbe._isScene = true;
        }
        get sceneReflectionProbe() {
            return this._sceneReflectionProbe;
        }
        set sceneReflectionProbe(value) {
            this._sceneReflectionProbe = value;
            this._needUpdateAllRender = true;
        }
        _updateRenderObject(baseRender) {
            if (this._reflectionProbes.length == 0) {
                baseRender.probReflection = this._sceneReflectionProbe;
                return;
            }
            var elements = this._reflectionProbes.elements;
            var maxOverlap = 0;
            var mainProbe;
            var renderBounds = baseRender.bounds;
            var overlop;
            for (var i = 0, n = this._reflectionProbes.length; i < n; i++) {
                let probe = elements[i];
                if (!mainProbe) {
                    overlop = renderBounds.calculateBoundsintersection(probe.bounds);
                    if (overlop < maxOverlap)
                        continue;
                }
                else {
                    if (mainProbe.importance > probe.importance)
                        continue;
                    overlop = renderBounds.calculateBoundsintersection(probe.bounds);
                    if (overlop < maxOverlap && mainProbe.importance == probe.importance)
                        continue;
                }
                mainProbe = probe;
                maxOverlap = overlop;
            }
            if (!mainProbe && this._sceneReflectionProbe)
                mainProbe = this._sceneReflectionProbe;
            baseRender.probReflection = mainProbe;
        }
        add(volume) {
            this._reflectionProbes.add(volume);
            this._needUpdateAllRender = true;
        }
        remove(volume) {
            this._reflectionProbes.remove(volume);
            this._needUpdateAllRender = true;
        }
        handleMotionlist(motionObjects) {
            var elements = motionObjects.elements;
            let render;
            for (var i = 0, n = motionObjects.length; i < n; i++) {
                render = elements[i];
                if (render._surportReflectionProbe && render.reflectionMode == 1) {
                    this._updateRenderObject(elements[i]);
                }
            }
        }
        reCaculateAllRenderObjects(baseRenders) {
            var elements = baseRenders.elements;
            let render;
            for (var i = 0, n = baseRenders.length; i < n; i++) {
                render = elements[i];
                if (render._surportReflectionProbe && render.reflectionMode == 1) {
                    this._updateRenderObject(render);
                }
                this._needUpdateAllRender = false;
            }
        }
        destroy() {
            for (let index = 0; index < this._reflectionProbes.length; index++) {
                let probe = this._reflectionProbes.elements[index];
                probe.destroy();
            }
            this._reflectionProbes.length = 0;
            this._sceneReflectionProbe.destroy();
            this._sceneReflectionProbe = null;
        }
    }

    class VolumetricGI extends Volume {
        static init() {
            VolumetricGI.SHADERDEFINE_VOLUMETRICGI = Laya.Shader3D.getDefineByName("VOLUMETRICGI");
            VolumetricGI.VOLUMETRICGI_PROBECOUNTS = Laya.Shader3D.propertyNameToID("u_VolGIProbeCounts");
            VolumetricGI.VOLUMETRICGI_PROBESTEPS = Laya.Shader3D.propertyNameToID("u_VolGIProbeStep");
            VolumetricGI.VOLUMETRICGI_PROBESTARTPOS = Laya.Shader3D.propertyNameToID("u_VolGIProbeStartPosition");
            VolumetricGI.VOLUMETRICGI_PROBEPARAMS = Laya.Shader3D.propertyNameToID("u_VolGIProbeParams");
            VolumetricGI.VOLUMETRICGI_IRRADIANCE = Laya.Shader3D.propertyNameToID("u_ProbeIrradiance");
            VolumetricGI.VOLUMETRICGI_DISTANCE = Laya.Shader3D.propertyNameToID("u_ProbeDistance");
            let uniformMap = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap(VolumetricGI.BlockName);
            uniformMap.addShaderUniform(VolumetricGI.VOLUMETRICGI_PROBECOUNTS, "u_VolGIProbeCounts", exports.ShaderDataType.Vector3);
            uniformMap.addShaderUniform(VolumetricGI.VOLUMETRICGI_PROBESTEPS, "u_VolGIProbeStep", exports.ShaderDataType.Vector3);
            uniformMap.addShaderUniform(VolumetricGI.VOLUMETRICGI_PROBESTARTPOS, "u_VolGIProbeStartPosition", exports.ShaderDataType.Vector3);
            uniformMap.addShaderUniform(VolumetricGI.VOLUMETRICGI_PROBEPARAMS, "u_VolGIProbeParams", exports.ShaderDataType.Vector4);
            uniformMap.addShaderUniform(VolumetricGI.VOLUMETRICGI_IRRADIANCE, "u_ProbeIrradiance", exports.ShaderDataType.Texture2D);
            uniformMap.addShaderUniform(VolumetricGI.VOLUMETRICGI_DISTANCE, "u_ProbeDistance", exports.ShaderDataType.Texture2D);
        }
        static getID() {
            return VolumetricGI.volumetricCount++;
        }
        get shaderData() {
            return this._dataModule.shaderData;
        }
        constructor() {
            super();
            this._type = VolumeManager.VolumetricGIType;
            this._probeCounts = new Laya.Vector3();
            this._probeStep = new Laya.Vector3();
            this._params = new Laya.Vector4(8, 16, 0, 0);
            this._dataModule = Laya3DRender.Render3DModuleDataFactory.createVolumetricGI();
            this._dataModule.setParams(this._params);
            this._volumetricProbeID = VolumetricGI.getID();
            this._dataModule.intensity = 1;
        }
        _onEnable() {
            super._onEnable();
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get irradiance() {
            return this._irradiance;
        }
        set irradiance(value) {
            if (this._irradiance == value)
                return;
            this._irradiance && (this._irradiance._removeReference());
            if (value) {
                value._addReference();
                this._dataModule.irradiance = value._texture;
            }
            else {
                this._dataModule.irradiance = null;
            }
            this._irradiance = value;
            this._irradiance = value;
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get distance() {
            return this._distance;
        }
        set distance(value) {
            if (this._distance == value)
                return;
            this._distance && (this._distance._removeReference());
            if (value) {
                value._addReference();
                this._dataModule.distance = value._texture;
            }
            else {
                this._dataModule.distance = null;
            }
            this._distance = value;
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get normalBias() {
            return this._params.z;
        }
        set normalBias(value) {
            this._params.z = value;
            this._dataModule.setParams(this._params);
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get viewBias() {
            return this._params.w;
        }
        set viewBias(value) {
            this._params.w = value;
            this._dataModule.setParams(this._params);
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get irradianceTexel() {
            return this._params.x;
        }
        get distanceTexel() {
            return this._params.y;
        }
        get intensity() {
            return this._dataModule.intensity;
        }
        set intensity(value) {
            if (value == this._dataModule.intensity)
                return;
            value = Math.max(value, 0.0);
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get probeCounts() {
            return this._probeCounts;
        }
        set probeCounts(value) {
            if (value.equal(this._probeCounts))
                return;
            value.cloneTo(this._probeCounts);
            this._dataModule.setProbeCounts(value);
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get probeStep() {
            return this._probeStep;
        }
        set probeStep(value) {
            if (value.equal(this._probeStep))
                return;
            value.cloneTo(this._probeStep);
            this._dataModule.setProbeStep(value);
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        _reCaculateBoundBox() {
            super._reCaculateBoundBox();
            this.bounds.cloneTo(this._dataModule.bound);
        }
        _onDestroy() {
            this.irradiance = null;
            this.distance = null;
            this._dataModule.destroy();
            this._dataModule = null;
        }
        _cloneTo(dest) {
            dest.irradiance = this.irradiance;
            dest.distance = this.distance;
            this._probeCounts.cloneTo(dest._probeCounts);
            this.probeStep.cloneTo(dest.probeStep);
            dest.normalBias = this.normalBias;
            dest.viewBias = this.viewBias;
            dest.intensity = this.intensity;
        }
    }
    VolumetricGI.BlockName = "VolumetricGIProbe";
    VolumetricGI.volumetricCount = 0;

    class VolumetricGIManager {
        constructor() {
            this._GIVolumes = new Laya.SingletonList();
            this._needUpdateAllRender = true;
        }
        removeVolumetricGI(renderer) {
            let shaderData = renderer._baseRenderNode.shaderData;
            shaderData.removeDefine(VolumetricGI.SHADERDEFINE_VOLUMETRICGI);
            renderer.lightProbe = null;
        }
        add(volume) {
            this._GIVolumes.add(volume);
            this._needUpdateAllRender = true;
        }
        remove(volume) {
            this._GIVolumes.remove(volume);
            this._needUpdateAllRender = true;
        }
        _updateRenderObject(renderer) {
            if (this._GIVolumes.length == 0) {
                this.removeVolumetricGI(renderer);
                return;
            }
            let renderBounds = renderer.bounds;
            let maxOverlap = 0, overlap = 0;
            let currentVolume;
            let volumes = this._GIVolumes.elements;
            for (let index = 0; index < this._GIVolumes.length; index++) {
                let volume = volumes[index];
                if (!currentVolume) {
                    overlap = renderBounds.calculateBoundsintersection(volume.bounds);
                    if (overlap < maxOverlap)
                        continue;
                }
                else {
                    if (currentVolume.importance > volume.importance)
                        continue;
                    overlap = renderBounds.calculateBoundsintersection(volume.bounds);
                    if (overlap < maxOverlap && currentVolume.importance == volume.importance)
                        continue;
                }
                currentVolume = volume;
                maxOverlap = overlap;
            }
            if (currentVolume) {
                renderer.lightProbe = currentVolume;
            }
            else {
                this.removeVolumetricGI(renderer);
            }
        }
        handleMotionlist(motionObjects) {
            for (let index = 0; index < motionObjects.length; index++) {
                let render = motionObjects.elements[index];
                if (render._surportVolumetricGI) {
                    this._updateRenderObject(render);
                }
            }
            this._needUpdateAllRender = false;
        }
        reCaculateAllRenderObjects(renders) {
            for (let index = 0; index < renders.length; index++) {
                let render = renders.elements[index];
                if (render._surportVolumetricGI) {
                    this._updateRenderObject(render);
                }
            }
            this._needUpdateAllRender = false;
        }
        destroy() {
            let count = this._GIVolumes.length;
            for (var i = 0; i < count; i++) {
                this._GIVolumes.elements[i].destroy();
            }
        }
    }

    class VolumeManager {
        constructor() {
            this._motionObjects = new Laya.SingletonList();
            this._volumeList = new Laya.SingletonList();
            this._needUpdateAllRender = false;
            this._regVolumeManager = {};
            this._reflectionProbeManager = new ReflectionProbeManager();
            this._regVolumeManager[VolumeManager.ReflectionProbeVolumeType] = this._reflectionProbeManager;
            this._volumetricGIManager = new VolumetricGIManager();
            this._regVolumeManager[VolumeManager.VolumetricGIType] = this._volumetricGIManager;
        }
        get reflectionProbeManager() {
            return this._reflectionProbeManager;
        }
        get volumetricGIManager() {
            return this._volumetricGIManager;
        }
        add(volume) {
            let reManager = this._regVolumeManager[volume.type];
            if (reManager) {
                reManager.add(volume);
            }
            else {
                this._volumeList.add(volume);
                this._needUpdateAllRender = true;
            }
        }
        remove(volume) {
            let reManager = this._regVolumeManager[volume.type];
            if (reManager) {
                reManager.remove(volume);
            }
            else {
                this._volumeList.remove(volume);
                this._needUpdateAllRender = true;
            }
        }
        addMotionObject(renderObj) {
            this._motionObjects.add(renderObj);
        }
        removeMotionObject(renderObj) {
            this._motionObjects.remove(renderObj);
        }
        _updateRenderObject(baseRender) {
            let elements = this._volumeList.elements;
            let renderBounds = baseRender.bounds;
            let center = renderBounds.getCenter();
            let mainVolume;
            for (var i = 0, n = this._volumeList.length; i < n; i++) {
                let volume = elements[i];
                let bounds = volume.bounds;
                if (Bounds.containPoint(bounds, center)) {
                    mainVolume = volume;
                    continue;
                }
            }
            baseRender.volume = mainVolume;
        }
        handleMotionlist() {
            var elements = this._motionObjects.elements;
            for (var i = 0, n = this._motionObjects.length; i < n; i++) {
                this._updateRenderObject(elements[i]);
            }
            if (!this.reflectionProbeManager._needUpdateAllRender)
                this.reflectionProbeManager.handleMotionlist(this._motionObjects);
            if (!this.volumetricGIManager._needUpdateAllRender)
                this.volumetricGIManager.handleMotionlist(this._motionObjects);
            this.clearMotionObjects();
        }
        reCaculateAllRenderObjects(baseRenders) {
            if (this._needUpdateAllRender) {
                var elements = baseRenders.elements;
                for (var i = 0, n = baseRenders.length; i < n; i++) {
                    this._updateRenderObject(elements[i]);
                }
                this._needUpdateAllRender = false;
            }
            else {
                this.handleMotionlist();
            }
            if (this.reflectionProbeManager._needUpdateAllRender) {
                this.reflectionProbeManager.reCaculateAllRenderObjects(baseRenders);
            }
            else {
                this.reflectionProbeManager.handleMotionlist(this._motionObjects);
            }
            if (this.volumetricGIManager._needUpdateAllRender) {
                this.volumetricGIManager.reCaculateAllRenderObjects(baseRenders);
            }
            else {
                this.volumetricGIManager.handleMotionlist(this._motionObjects);
            }
        }
        needreCaculateAllRenderObjects() {
            return this._needUpdateAllRender || this.reflectionProbeManager._needUpdateAllRender || this.volumetricGIManager._needUpdateAllRender;
        }
        clearMotionObjects() {
            this._motionObjects.length = 0;
            if (this._motionObjects.elements.length > 100) {
                this._motionObjects.elements.length = 100;
            }
            this._motionObjects.elements.fill(null);
        }
        destroy() {
            this._reflectionProbeManager.destroy();
            this._volumetricGIManager.destroy();
        }
    }
    VolumeManager.ReflectionProbeVolumeType = 1;
    VolumeManager.VolumetricGIType = 2;

    exports.AmbientMode = void 0;
    (function (AmbientMode) {
        AmbientMode[AmbientMode["SolidColor"] = 0] = "SolidColor";
        AmbientMode[AmbientMode["SphericalHarmonics"] = 1] = "SphericalHarmonics";
    })(exports.AmbientMode || (exports.AmbientMode = {}));

    exports.ReflectionProbeMode = void 0;
    (function (ReflectionProbeMode) {
        ReflectionProbeMode[ReflectionProbeMode["off"] = 0] = "off";
        ReflectionProbeMode[ReflectionProbeMode["simple"] = 1] = "simple";
    })(exports.ReflectionProbeMode || (exports.ReflectionProbeMode = {}));
    class ReflectionProbe extends Volume {
        static getID() {
            return ReflectionProbe.reflectionCount++;
        }
        static init() {
            ReflectionProbe.SHADERDEFINE_GI_IBL = Laya.Shader3D.getDefineByName("GI_IBL");
            let unifomrMap = ReflectionProbe.CommandMap = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap(ReflectionProbe.BlockName);
            const addUniform = (name, type, arrayLength = 0) => {
                let unifomrIndex = Laya.Shader3D.propertyNameToID(name);
                if (arrayLength > 0) {
                    unifomrMap.addShaderUniformArray(unifomrIndex, name, type, arrayLength);
                }
                else {
                    unifomrMap.addShaderUniform(unifomrIndex, name, type);
                }
                return unifomrIndex;
            };
            ReflectionProbe.AMBIENTCOLOR = addUniform("u_AmbientColor", exports.ShaderDataType.Vector4);
            ReflectionProbe.AMBIENTSH = addUniform("u_IblSH", exports.ShaderDataType.Vector3, 9);
            ReflectionProbe.IBLTEX = addUniform("u_IBLTex", exports.ShaderDataType.TextureCube);
            ReflectionProbe.IBLROUGHNESSLEVEL = addUniform("u_IBLRoughnessLevel", exports.ShaderDataType.Float);
            ReflectionProbe.AMBIENTINTENSITY = addUniform("u_AmbientIntensity", exports.ShaderDataType.Float);
            ReflectionProbe.REFLECTIONINTENSITY = addUniform("u_ReflectionIntensity", exports.ShaderDataType.Float);
            ReflectionProbe.REFLECTIONCUBE_PROBEPOSITION = addUniform("u_SpecCubeProbePosition", exports.ShaderDataType.Vector3);
            ReflectionProbe.REFLECTIONCUBE_PROBEBOXMAX = addUniform("u_SpecCubeBoxMax", exports.ShaderDataType.Vector3);
            ReflectionProbe.REFLECTIONCUBE_PROBEBOXMIN = addUniform("u_SpecCubeBoxMin", exports.ShaderDataType.Vector3);
        }
        constructor() {
            super();
            this._ambientColor = new Laya.Color();
            this._isScene = false;
            this._importance = 0;
            this._type = VolumeManager.ReflectionProbeVolumeType;
            this._dataModule = Laya3DRender.Render3DModuleDataFactory.createReflectionProbe();
            this._dataModule.bound = this._bounds;
            this.ambientIntensity = 1.0;
            this.reflectionIntensity = 1.0;
            this.boundsMax = new Laya.Vector3(5, 5, 5);
            this.boundsMin = new Laya.Vector3(-5, -5, -5);
            this._reflectionProbeID = ReflectionProbe.getID();
            this.ambientMode = exports.AmbientMode.SolidColor;
            this._dataModule.updateMark = -1;
        }
        get shaderData() {
            return this._dataModule.shaderData;
        }
        get boxProjection() {
            return this._dataModule.boxProjection;
        }
        set boxProjection(value) {
            if (value != this._dataModule.boxProjection) {
                this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
            }
            this._dataModule.boxProjection = value;
        }
        get importance() {
            return this._importance;
        }
        set importance(value) {
            this._importance = value;
        }
        get ambientIntensity() {
            return this._dataModule.ambientIntensity;
        }
        set ambientIntensity(value) {
            if (value == this._dataModule.ambientIntensity)
                return;
            this._dataModule.ambientIntensity = value;
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get reflectionIntensity() {
            return this._dataModule.reflectionIntensity;
        }
        set reflectionIntensity(value) {
            if (value == this._dataModule.reflectionIntensity)
                return;
            value = Math.max(value, 0.0);
            this._dataModule.reflectionIntensity = value;
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        _reCaculateBoundBox() {
            super._reCaculateBoundBox();
            this.owner && this._dataModule.setProbePosition(this.owner.transform.position);
            this.bounds.cloneTo(this._dataModule.bound);
        }
        get bounds() {
            return this._bounds;
        }
        get boundsMax() {
            return this._primitiveBounds.getMax();
        }
        set boundsMax(value) {
            super.boundsMax = value;
            if (this.boxProjection)
                this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get boundsMin() {
            return this._primitiveBounds.getMin();
        }
        set boundsMin(value) {
            super.boundsMin = value;
            if (this.boxProjection)
                this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get probePosition() {
            return this.owner.transform.position;
        }
        get ambientColor() {
            return this._ambientColor;
        }
        set ambientColor(value) {
            value.cloneTo(this._ambientColor);
            this._dataModule.setAmbientColor(this._ambientColor);
            if (this.ambientMode == exports.AmbientMode.SolidColor)
                this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get ambientSH() {
            return this._ambientSH;
        }
        set ambientSH(value) {
            if (this.ambientMode == exports.AmbientMode.SphericalHarmonics)
                this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
            this._ambientSH = value;
            this._dataModule.setAmbientSH(this._ambientSH);
        }
        get ambientMode() {
            return this._dataModule.ambientMode;
        }
        set ambientMode(value) {
            if (value == this.ambientMode)
                return;
            this._dataModule.ambientMode = value;
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get iblTex() {
            return this._iblTex;
        }
        set iblTex(value) {
            if (this._iblTex == value)
                return;
            if (this._iblTex)
                this._iblTex._removeReference();
            this._iblTex = value;
            this._dataModule.iblTex = null;
            if (value) {
                value._addReference();
                this._dataModule.iblTex = value._texture;
            }
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        get iblTexRGBD() {
            return this._dataModule.iblTexRGBD;
        }
        set iblTexRGBD(value) {
            if (value == this._dataModule.iblTexRGBD)
                return;
            this._dataModule.iblTexRGBD = value;
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        _onEnable() {
            super._onEnable();
            this._dataModule.updateMark = Laya.ILaya.Scene3D._updateMark;
        }
        _onDestroy() {
            this.iblTex = null;
            this._dataModule.destroy();
        }
    }
    ReflectionProbe.BlockName = "ReflectionProbe";
    ReflectionProbe.reflectionCount = 0;
    ReflectionProbe.defaultTextureHDRDecodeValues = new Laya.Vector4(1.0, 1.0, 0.0, 0.0);

    class Sprite3DRenderDeclaration {
    }

    exports.RenderBitFlag = void 0;
    (function (RenderBitFlag) {
        RenderBitFlag[RenderBitFlag["RenderBitFlag_CullFlag"] = 0] = "RenderBitFlag_CullFlag";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_Batch"] = 1] = "RenderBitFlag_Batch";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_Editor"] = 2] = "RenderBitFlag_Editor";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_InstanceBatch"] = 3] = "RenderBitFlag_InstanceBatch";
        RenderBitFlag[RenderBitFlag["RenderBitFlag_VertexMergeBatch"] = 4] = "RenderBitFlag_VertexMergeBatch";
    })(exports.RenderBitFlag || (exports.RenderBitFlag = {}));
    exports.IrradianceMode = void 0;
    (function (IrradianceMode) {
        IrradianceMode[IrradianceMode["LightMap"] = 0] = "LightMap";
        IrradianceMode[IrradianceMode["VolumetricGI"] = 1] = "VolumetricGI";
        IrradianceMode[IrradianceMode["Common"] = 2] = "Common";
    })(exports.IrradianceMode || (exports.IrradianceMode = {}));
    class BaseRender extends Laya.Component {
        static __init__() {
            BaseRender.shaderValueInit();
        }
        static getMeshDefine(mesh, out) {
            out.length = 0;
            var define;
            for (var i = 0, n = mesh._subMeshes.length; i < n; i++) {
                var subMesh = mesh.getSubMesh(i);
                var vertexElements = subMesh._vertexBuffer.vertexDeclaration._vertexElements;
                for (var j = 0, m = vertexElements.length; j < m; j++) {
                    var vertexElement = vertexElements[j];
                    var name = vertexElement._elementUsage;
                    switch (name) {
                        case Laya.VertexMesh.MESH_COLOR0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
                            break;
                        case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
                            break;
                        case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                            break;
                        case Laya.VertexMesh.MESH_TANGENT0:
                            out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT);
                            break;
                    }
                }
            }
            return define;
        }
        static changeVertexDefine(oldMesh, mesh, defineDatas) {
            var lastValue = oldMesh;
            if (lastValue) {
                BaseRender.getMeshDefine(lastValue, BaseRender._meshVerticeDefine);
                for (var i = 0, n = BaseRender._meshVerticeDefine.length; i < n; i++)
                    defineDatas.removeDefine(BaseRender._meshVerticeDefine[i]);
            }
            if (mesh) {
                BaseRender.getMeshDefine(mesh, BaseRender._meshVerticeDefine);
                for (var i = 0, n = BaseRender._meshVerticeDefine.length; i < n; i++)
                    defineDatas.addDefine(BaseRender._meshVerticeDefine[i]);
            }
        }
        static shaderValueInit() {
            Sprite3DRenderDeclaration.SHADERDEFINE_GI_LEGACYIBL = Laya.Shader3D.getDefineByName("GI_LEGACYIBL");
            Sprite3DRenderDeclaration.SHADERDEFINE_IBL_RGBD = Laya.Shader3D.getDefineByName("IBL_RGBD");
            Sprite3DRenderDeclaration.SHADERDEFINE_SPECCUBE_BOX_PROJECTION = Laya.Shader3D.getDefineByName("SPECCUBE_BOX_PROJECTION");
        }
        get enabled() {
            return super.enabled;
        }
        set enabled(value) {
            super.enabled = value;
            this._baseRenderNode.enable = value;
        }
        get sortingFudge() {
            return this._baseRenderNode.sortingFudge;
        }
        set sortingFudge(value) {
            this._baseRenderNode.sortingFudge = value;
        }
        get renderbitFlag() {
            return this._baseRenderNode.renderbitFlag;
        }
        get boundsChange() {
            return this._baseRenderNode.boundsChange;
        }
        set boundsChange(value) {
            this._baseRenderNode.boundsChange = value;
        }
        get renderNode() {
            return this._baseRenderNode;
        }
        get distanceForSort() {
            return this._baseRenderNode.distanceForSort;
        }
        set distanceForSort(value) {
            this._baseRenderNode.distanceForSort = value;
        }
        get geometryBounds() {
            return this._baseRenderNode.baseGeometryBounds;
        }
        set geometryBounds(value) {
            this._baseRenderNode.baseGeometryBounds = value;
        }
        get lightmapIndex() {
            return this._baseRenderNode.lightmapIndex;
        }
        set lightmapIndex(value) {
            this._baseRenderNode.lightmapIndex = value;
        }
        setLightmapIndex(value) {
            let scene = this._scene;
            if (value != -1 && (scene.lightmaps[value])) {
                this._baseRenderNode.lightmap = scene.lightmaps[value]._dataModule;
            }
            else {
                this._baseRenderNode.lightmap = null;
            }
            this._getIrradientMode();
        }
        get irradientMode() {
            return this._baseRenderNode.irradientMode;
        }
        get lightmapScaleOffset() {
            return this._lightmapScaleOffset;
        }
        set lightmapScaleOffset(value) {
            value.cloneTo(this._lightmapScaleOffset);
            this._baseRenderNode.setLightmapScaleOffset(this._lightmapScaleOffset);
        }
        get sharedMaterial() {
            return this._sharedMaterials[0];
        }
        set sharedMaterial(value) {
            var lastValue = this._sharedMaterials[0];
            this._changeMaterialReference(lastValue, value);
            this._sharedMaterials[0] = value;
            let element = this._renderElements[0];
            if (element && element.material != value) {
                this._materialsInstance[0] = false;
                element.material = value;
            }
            this._isSupportRenderFeature();
        }
        get sharedMaterials() {
            return this._sharedMaterials.slice();
        }
        set sharedMaterials(value) {
            var materialsInstance = this._materialsInstance;
            var sharedMats = this._sharedMaterials;
            if (value) {
                let count = value.length;
                for (let i = 0; i < count; i++) {
                    let mat = value[i];
                    let lastMat = sharedMats[i];
                    this._changeMaterialReference(lastMat, mat);
                    sharedMats[i] = mat;
                    let element = this._renderElements[i];
                    if (element && element.material != mat) {
                        materialsInstance[i] = false;
                        element.material = mat;
                    }
                }
                for (let i = count, n = sharedMats.length; i < n; i++) {
                    let mat = sharedMats[i];
                    mat && mat._removeReference();
                    let element = this._renderElements[i];
                    element && (element.material = null);
                }
                materialsInstance.length = count;
                sharedMats.length = count;
            }
            else {
                for (let i = 0, n = sharedMats.length; i < n; i++) {
                    let lastMat = sharedMats[i];
                    lastMat && lastMat._removeReference();
                }
                this._sharedMaterials = [];
            }
            this._isSupportRenderFeature();
        }
        get bounds() {
            return this._baseRenderNode.bounds;
        }
        get receiveShadow() {
            return this._receiveShadow;
        }
        set receiveShadow(value) {
            if (this._receiveShadow !== value) {
                this._receiveShadow = value;
                if (value)
                    this._baseRenderNode.shaderData.addDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
                else
                    this._baseRenderNode.shaderData.removeDefine(RenderableSprite3D.SHADERDEFINE_RECEIVE_SHADOW);
            }
            this._baseRenderNode.receiveShadow = value;
        }
        get castShadow() {
            return this._baseRenderNode.castShadow;
        }
        set castShadow(value) {
            this._baseRenderNode.castShadow = value;
        }
        get reflectionMode() {
            return this._baseRenderNode.reflectionMode;
        }
        set reflectionMode(value) {
            this._baseRenderNode.reflectionMode = value;
        }
        get volume() {
            return this._volume;
        }
        set volume(value) {
            if (!value) {
                if (this._volume) {
                    this._volume._removeRenderNode && this._volume._removeRenderNode(this);
                    this._volume = null;
                }
                return;
            }
            if (this._volume != value) {
                value._addRenderNode && value._addRenderNode(this);
                this._volume = value;
                return;
            }
            else {
                value._motionInVolume && value._motionInVolume(this);
            }
        }
        get probReflection() {
            return this._probReflection;
        }
        set probReflection(value) {
            if (this._probReflection == value)
                return;
            this._probReflection = value;
            const ReflectionProbeBlockName = ReflectionProbe.BlockName;
            if (value) {
                this._baseRenderNode.probeReflection = value._dataModule;
                this._baseRenderNode.additionShaderData.set(ReflectionProbeBlockName, value.shaderData);
            }
            else {
                this._baseRenderNode.probeReflection = null;
                this._baseRenderNode.additionShaderData.delete(ReflectionProbeBlockName);
            }
            this._baseRenderNode.additionShaderData = this._baseRenderNode.additionShaderData;
            this._getIrradientMode();
        }
        get lightProbe() {
            return this._lightProb;
        }
        set lightProbe(volumetricGI) {
            if (this._lightProb == volumetricGI) {
                return;
            }
            this._baseRenderNode.lightProbUpdateMark = -1;
            this._lightProb = volumetricGI;
            const VolumeGIBlockName = VolumetricGI.BlockName;
            if (volumetricGI) {
                this._baseRenderNode.volumetricGI = volumetricGI._dataModule;
                this._baseRenderNode.additionShaderData.set(VolumeGIBlockName, volumetricGI.shaderData);
            }
            else {
                this._baseRenderNode.volumetricGI = null;
                this._baseRenderNode.additionShaderData.delete(VolumeGIBlockName);
            }
            this._baseRenderNode.additionShaderData = this._baseRenderNode.additionShaderData;
            this._getIrradientMode();
        }
        setNodeCustomData(dataSlot, data) {
            this.renderNode.setNodeCustomData(dataSlot, data);
        }
        constructor() {
            super();
            this._sharedMaterials = [];
            this._sceneUpdateMark = -1;
            this._updateMark = -1;
            this._surportReflectionProbe = false;
            this._surportVolumetricGI = false;
            this._motionIndexList = -1;
            this._LOD = -1;
            this._lightmapScaleOffset = new Laya.Vector4();
            this._renderElements = [];
            this._baseRenderNode = this._createBaseRenderNode();
            this._baseRenderNode.setCommonUniformMap(this._getcommonUniformMap());
            this._baseRenderNode.shaderData = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
            this._renderid = ++BaseRender._uniqueIDCounter;
            this._baseRenderNode.bounds = this._bounds = new Bounds(Laya.Vector3.ZERO, Laya.Vector3.ZERO);
            this._enabled = true;
            this._baseRenderNode.enable = true;
            this._materialsInstance = [];
            this.lightmapIndex = -1;
            this.receiveShadow = false;
            this._baseRenderNode.sortingFudge = 0.0;
            this.reflectionMode = exports.ReflectionProbeMode.simple;
            if (!!this._calculateBoundingBox) {
                this._baseRenderNode.set_caculateBoundingBox(this, this._calculateBoundingBox);
            }
            if (!!this._renderUpdate) {
                this._baseRenderNode.set_renderUpdatePreCall(this, this._renderUpdate);
            }
            this.runInEditor = true;
            this._asynNative = true;
            this.boundsChange = true;
            this._baseRenderNode.renderbitFlag = 0;
            this._baseRenderNode.staticMask = 1;
            this.castShadow = false;
            this._baseRenderNode.renderNodeType = 0;
        }
        _setRenderElements() {
            var _a, _b, _c;
            let arrayElement = [];
            if (this._renderElements.length == 0 && this._inRenderList) {
                (_a = this.owner) === null || _a === void 0 ? void 0 : _a.scene._removeRenderObject(this);
            }
            if (((_b = this.owner) === null || _b === void 0 ? void 0 : _b.activeInHierarchy) && this.enabled && ((_c = this.owner) === null || _c === void 0 ? void 0 : _c.scene) && this._renderElements.length > 0 && !this._inRenderList)
                this.owner.scene._addRenderObject(this);
            this._renderElements.forEach(element => {
                arrayElement.push(element._renderElementOBJ);
            });
            this._baseRenderNode.setRenderelements(arrayElement);
        }
        _onWorldMatNeedChange(flag) {
            this.boundsChange = true;
            this._addReflectionProbeUpdate();
            this._batchRender && this._batchRender._updateOneRender(this);
        }
        _getcommonUniformMap() {
            return ["Sprite3D"];
        }
        _createBaseRenderNode() {
            return Laya3DRender.Render3DModuleDataFactory.createBaseRenderNode();
        }
        renderUpdate(context) {
        }
        _onAdded() {
            this._transform = this.owner.transform;
            this.owner._isRenderNode++;
            this.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_Editor, this.owner._getBit(Laya.NodeFlags.HIDE_BY_EDITOR));
            this._baseRenderNode.transform = this._transform;
            this._changeLayer(this.owner.layer);
            this._changeStaticMask(this.owner._isStatic);
        }
        _onEnable() {
            super._onEnable();
            this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
            this.owner.on(Laya.Event.LAYER_CHANGE, this, this._changeLayer);
            this.owner.on(Laya.Event.STATIC_MASK, this, this._changeStaticMask);
            this._changeLayer(this.owner.layer);
            this._changeStaticMask(this.owner._isStatic);
            this.owner.scene._addRenderObject(this);
            this._setBelongScene(this.owner.scene);
        }
        _onDisable() {
            this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
            this.owner.off(Laya.Event.LAYER_CHANGE, this, this._changeLayer);
            this.owner.off(Laya.Event.STATIC_MASK, this, this._changeStaticMask);
            this.owner.scene._removeRenderObject(this);
            this._setUnBelongScene();
            this.volume = null;
        }
        _onDestroy() {
            if (this.owner)
                this.owner._isRenderNode--;
            (this._motionIndexList !== -1) && (this._scene._sceneRenderManager.removeMotionObject(this));
            (this._scene) && this._scene.sceneRenderableManager.removeRenderObject(this);
            this._baseRenderNode.destroy();
            this._baseRenderNode = null;
            this._renderElements.forEach(element => {
                element.destroy();
            });
            this._renderElements = null;
            for (let i = 0, n = this._sharedMaterials.length; i < n; i++) {
                let m = this._sharedMaterials[i];
                m && !m.destroyed && m._removeReference();
            }
            this._sharedMaterials = null;
            this._bounds = null;
            this._lightmapScaleOffset = null;
            this._scene = null;
            this._transform = null;
            this._batchRender = null;
        }
        _getIrradientMode() {
            if (this.lightmapIndex >= 0) {
                this._baseRenderNode.irradientMode = exports.IrradianceMode.LightMap;
            }
            else if (this.lightProbe) {
                this._baseRenderNode.irradientMode = exports.IrradianceMode.VolumetricGI;
            }
            else {
                this._baseRenderNode.irradientMode = exports.IrradianceMode.Common;
            }
        }
        _changeLayer(layer) {
            this._baseRenderNode.layer = layer;
        }
        _changeStaticMask(staticmask) {
            this._baseRenderNode.staticMask = staticmask;
        }
        _changeMaterialReference(lastValue, value) {
            (lastValue) && (lastValue._removeReference());
            value && value._addReference();
        }
        _getInstanceMaterial(material, index) {
            var insMat = material.clone();
            insMat.name = insMat.name + "(Instance)";
            this._materialsInstance[index] = true;
            this._changeMaterialReference(this._sharedMaterials[index], insMat);
            this._sharedMaterials[index] = insMat;
            return insMat;
        }
        _isSupportRenderFeature() {
            let preReflection = this._surportReflectionProbe;
            let prelightprob = this._surportVolumetricGI;
            this._surportReflectionProbe = false;
            this._surportVolumetricGI = false;
            var sharedMats = this._sharedMaterials;
            for (var i = 0, n = sharedMats.length; i < n; i++) {
                var mat = sharedMats[i];
                this._surportReflectionProbe || (this._surportReflectionProbe = this._surportReflectionProbe || (mat && mat._shader._supportReflectionProbe));
                this._surportVolumetricGI || (this._surportVolumetricGI = this._surportVolumetricGI || (mat && mat._shader._surportVolumetricGI));
            }
            if ((!preReflection && this._surportReflectionProbe) || (!prelightprob && this._surportVolumetricGI))
                this._addReflectionProbeUpdate();
        }
        _addReflectionProbeUpdate() {
            this._scene && this._scene._volumeManager.addMotionObject(this);
        }
        _setBelongScene(scene) {
            this._scene = scene;
            this._onWorldMatNeedChange(1);
            this._isSupportRenderFeature();
            this._batchRender && this._batchRender._batchOneRender(this);
            this.setLightmapIndex(this.lightmapIndex);
            this._statAdd();
        }
        _statAdd() {
            Laya.Stat.renderNode++;
        }
        _statRemove() {
            Laya.Stat.renderNode--;
        }
        _setUnBelongScene() {
            this._statRemove();
            this._scene._volumeManager.removeMotionObject(this);
            let batch = this._batchRender;
            this._batchRender && this._batchRender._removeOneRender(this);
            this._batchRender = batch;
            this._scene = null;
        }
        _needRender(boundFrustum, context) {
            if (boundFrustum)
                return boundFrustum.intersects(this.bounds);
            else
                return true;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest.receiveShadow = this.receiveShadow;
            dest.sharedMaterials = this.sharedMaterials;
            dest.reflectionMode = this.reflectionMode;
            dest.castShadow = this.castShadow;
            dest.sortingFudge = this.sortingFudge;
        }
        setRenderbitFlag(flag, pass) {
            if (pass)
                this._baseRenderNode.renderbitFlag |= (1 << flag);
            else
                this._baseRenderNode.renderbitFlag &= ~(1 << flag);
        }
        get material() {
            var material = this._sharedMaterials[0];
            if (material && !this._materialsInstance[0]) {
                var insMat = this._getInstanceMaterial(material, 0);
                var renderElement = this._renderElements[0];
                (renderElement) && (renderElement.material = insMat);
            }
            return this._sharedMaterials[0];
        }
        set material(value) {
            this.sharedMaterial = value;
            this._isSupportRenderFeature();
        }
        get materials() {
            for (var i = 0, n = this._sharedMaterials.length; i < n; i++) {
                if (!this._materialsInstance[i]) {
                    var insMat = this._getInstanceMaterial(this._sharedMaterials[i], i);
                    var renderElement = this._renderElements[i];
                    (renderElement) && (renderElement.material = insMat);
                }
            }
            return this._sharedMaterials.slice();
        }
        set materials(value) {
            this.sharedMaterials = value;
            this._isSupportRenderFeature();
        }
    }
    BaseRender._meshVerticeDefine = [];
    BaseRender._uniqueIDCounter = 0;
    BaseRender._tempBoundBoxCorners = [new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3()];
    BaseRender._defaultLightmapScaleOffset = new Laya.Vector4(1.0, 1.0, 0.0, 0.0);

    class RenderElement {
        get transform() {
            return this._renderElementOBJ.transform;
        }
        set transform(value) {
            this._transform = value;
            this._renderElementOBJ.transform = value;
        }
        get material() {
            return this._material;
        }
        set material(value) {
            if (this._material) {
                this._material._removeOwnerElement(this._renderElementOBJ);
            }
            if (value) {
                this._material = value;
                this.material._setOwner3DElement(this._renderElementOBJ);
            }
            else {
                this._material = null;
                this._renderElementOBJ.materialShaderData = null;
                this._renderElementOBJ.materialRenderQueue = 0;
                this._renderElementOBJ.subShader = this._subShader = null;
                this._renderElementOBJ.materialId = -1;
            }
        }
        get renderSubShader() {
            return this._subShader;
        }
        set renderSubShader(value) {
            this._subShader = value;
            this._renderElementOBJ.subShader = value;
        }
        get subShaderIndex() {
            return this._subShaderIndex;
        }
        set subShaderIndex(value) {
            this._subShaderIndex = value;
        }
        get render() {
            return this._baseRender;
        }
        set render(value) {
            this._baseRender = value;
            this._renderElementOBJ.renderShaderData = value._baseRenderNode.shaderData;
        }
        constructor() {
            this._subShaderIndex = 0;
            this._createRenderElementOBJ();
        }
        _createRenderElementOBJ() {
            this._renderElementOBJ = Laya3DRender.Render3DPassFactory.createRenderElement3D();
        }
        setTransform(transform) {
            this.transform = transform;
            this._renderElementOBJ.transform = transform;
        }
        setGeometry(geometry) {
            this._geometry = geometry;
            this._renderElementOBJ.geometry = geometry._geometryElementOBj;
        }
        destroy() {
            this.material = null;
            this._renderElementOBJ = null;
            this._geometry = null;
            this._baseRender = null;
            this._baseRender = null;
            this._subShader = null;
        }
    }

    class SubMeshRenderElement extends RenderElement {
        constructor() {
            super();
            this._dynamicWorldPositionNormalNeedUpdate = true;
            this._renderElementOBJ.canDynamicBatch = true;
        }
        _onWorldMatrixChanged() {
            this._dynamicWorldPositionNormalNeedUpdate = true;
        }
        setTransform(transform) {
            if (this.transform !== transform) {
                (this.transform) && (this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged));
                (transform) && (transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged));
                this._dynamicWorldPositionNormalNeedUpdate = true;
                this.transform = transform;
            }
        }
        setGeometry(geometry) {
            if (this._geometry !== geometry) {
                this._geometry = geometry;
                this._renderElementOBJ.geometry = geometry._geometryElementOBj;
            }
        }
        destroy() {
            if (!this._renderElementOBJ)
                return;
            (this.transform) && this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatrixChanged);
            super.destroy();
            this.instanceSubMesh = null;
            this.staticBatchElementList && this.staticBatchElementList.destroy();
            this.instanceBatchElementList && this.instanceBatchElementList.destroy();
            this.vertexBatchElementList && this.vertexBatchElementList.destroy();
            this.vertexBatchVertexDeclaration = null;
        }
    }

    class MeshRenderer extends BaseRender {
        static __init__() {
            MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0 = Laya.Shader3D.getDefineByName("UV");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR = Laya.Shader3D.getDefineByName("COLOR");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1 = Laya.Shader3D.getDefineByName("UV1");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT = Laya.Shader3D.getDefineByName("TANGENT");
            MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE = Laya.Shader3D.getDefineByName("GPU_INSTANCE");
        }
        constructor() {
            super();
            this._revertStaticBatchDefineUV1 = false;
            this.morphTargetActiveCount = 0;
            this._morphWeightChange = true;
            this._morphTargetValues = {};
            this._meshChange = false;
            this._projectionViewWorldMatrix = new Laya.Matrix4x4();
            this._baseRenderNode.renderNodeType = exports.BaseRenderType.MeshRender;
        }
        _createBaseRenderNode() {
            return Laya3DRender.Render3DModuleDataFactory.createMeshRenderNode();
        }
        _createRenderElement() {
            return new SubMeshRenderElement();
        }
        getMesh() {
            return this._mesh;
        }
        _onEnable() {
            super._onEnable();
            const filter = this.owner.getComponent(MeshFilter);
            if (filter)
                filter._enabled && this._onMeshChange(filter.sharedMesh);
        }
        _getMeshDefine(mesh, out) {
            let define;
            out.length = 0;
            MeshUtil.getMeshDefine(mesh, out);
            return define;
        }
        _changeVertexDefine(mesh) {
            var defineDatas = this._baseRenderNode.shaderData;
            var lastValue = this._mesh;
            if (lastValue) {
                this._getMeshDefine(lastValue, MeshFilter._meshVerticeDefine);
                for (var i = 0, n = MeshFilter._meshVerticeDefine.length; i < n; i++)
                    defineDatas.removeDefine(MeshFilter._meshVerticeDefine[i]);
            }
            if (mesh) {
                this._getMeshDefine(mesh, MeshFilter._meshVerticeDefine);
                for (var i = 0, n = MeshFilter._meshVerticeDefine.length; i < n; i++)
                    defineDatas.addDefine(MeshFilter._meshVerticeDefine[i]);
            }
        }
        get morphTargetValues() {
            return this._morphTargetValues;
        }
        set morphTargetValues(value) {
            this._morphTargetValues = value;
        }
        _changeMorphTargetValue(key) {
            this._morphWeightChange = true;
        }
        setMorphChannelWeight(channelName, weight) {
            let mesh = this._mesh;
            if (mesh && mesh.morphTargetData) {
                let morphData = mesh.morphTargetData;
                let channel = morphData.getMorphChannel(channelName);
                this.morphTargetValues[channel.name] = weight;
                this._morphWeightChange = true;
            }
        }
        _applyMorphdata() {
            let mesh = this._mesh;
            let shaderData = this._baseRenderNode.shaderData;
            if (this._morphWeightChange && mesh) {
                let morphData = mesh.morphTargetData;
                let channelCount = morphData.channelCount;
                for (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {
                    let channel = morphData.getMorphChannelbyIndex(channelIndex);
                    let weight = this.morphTargetValues[channel.name];
                    let lastFullWeight = 0;
                    channel.targets.forEach(target => {
                        if (weight <= target.fullWeight) {
                            this.morphTargetWeight[target._index] = (weight - lastFullWeight) / (target.fullWeight - lastFullWeight);
                        }
                        else {
                            this.morphTargetWeight[target._index] = 1;
                        }
                        lastFullWeight = target.fullWeight;
                    });
                }
                let activeIndex = 0;
                this.morphTargetWeight.forEach((weight, index) => {
                    if (weight > 0) {
                        let offset = activeIndex * 4;
                        this.morphTargetActiveData[offset] = index;
                        this.morphTargetActiveData[offset + 1] = weight;
                        activeIndex++;
                    }
                });
                this.morphTargetActiveCount = Math.min(activeIndex, Laya.Config3D.maxMorphTargetCount);
                if (Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Texture3D)) {
                    shaderData.setInt(RenderableSprite3D.MorphActiveCount, this.morphTargetActiveCount);
                    shaderData.setBuffer(RenderableSprite3D.MorphActiceTargets, this.morphTargetActiveData);
                }
                this._morphWeightChange = false;
            }
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
        }
        _setUnBelongScene() {
            super._setUnBelongScene();
        }
        _statAdd() {
            Laya.Stat.renderNode++;
            Laya.Stat.meshRenderNode++;
        }
        _statRemove() {
            Laya.Stat.renderNode--;
            Laya.Stat.meshRenderNode--;
        }
        _changeMorphData(mesh) {
            let shaderData = this._baseRenderNode.shaderData;
            let oldMesh = this._mesh;
            const maxMorphTargetCount = Laya.Config3D.maxMorphTargetCount;
            let maxCount = maxMorphTargetCount;
            this.morphTargetActiveData = new Float32Array(maxCount * 4);
            if (Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Texture3D)) {
                if (oldMesh && oldMesh.morphTargetData) {
                    let morphData = oldMesh.morphTargetData;
                    shaderData.removeDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET);
                    let morphVertexDec = morphData.vertexDec;
                    morphVertexDec._vertexElements.forEach(element => {
                        switch (element.elementUsage) {
                            case Laya.VertexMesh.MESH_POSITION0:
                                shaderData.removeDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET_POSITION);
                                break;
                            case Laya.VertexMesh.MESH_NORMAL0:
                                shaderData.removeDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET_NORMAL);
                                break;
                            case Laya.VertexMesh.MESH_TANGENT0:
                                shaderData.removeDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET_TANGENT);
                                break;
                        }
                    });
                }
                if (mesh && mesh.morphTargetData) {
                    let morphData = mesh.morphTargetData;
                    shaderData.addDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET);
                    let morphVertexDec = morphData.vertexDec;
                    morphVertexDec._vertexElements.forEach(element => {
                        switch (element.elementUsage) {
                            case Laya.VertexMesh.MESH_POSITION0:
                                shaderData.addDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET_POSITION);
                                break;
                            case Laya.VertexMesh.MESH_NORMAL0:
                                shaderData.addDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET_NORMAL);
                                break;
                            case Laya.VertexMesh.MESH_TANGENT0:
                                shaderData.addDefine(RenderableSprite3D.SHADERDEFINE_MORPHTARGET_TANGENT);
                                break;
                        }
                    });
                    shaderData.setVector(RenderableSprite3D.MorphAttriOffset, mesh.morphTargetData.attributeOffset);
                    shaderData.setTexture(RenderableSprite3D.MorphTex, mesh.morphTargetData.targetTexture);
                    shaderData.setVector(RenderableSprite3D.MorphParams, morphData.params);
                    shaderData.setBuffer(RenderableSprite3D.MorphActiceTargets, this.morphTargetActiveData);
                }
            }
            if (oldMesh && oldMesh.morphTargetData) {
                this.morphTargetWeight = null;
                this.morphtargetChannels = null;
                this._morphTargetValues = {};
            }
            if (mesh && mesh.morphTargetData) {
                let morphData = mesh.morphTargetData;
                let channelCount = morphData.channelCount;
                this.morphTargetWeight = new Float32Array(morphData.targetCount);
                this.morphtargetChannels = new Array(channelCount);
                for (let index = 0; index < channelCount; index++) {
                    let channel = morphData.getMorphChannelbyIndex(index);
                    this.morphtargetChannels[index] = channel;
                    this._morphTargetValues[channel.name] = 0;
                }
            }
        }
        _onMeshChange(mesh) {
            if (mesh && this._mesh != mesh) {
                this._changeVertexDefine(mesh);
                this._changeMorphData(mesh);
                this._mesh = mesh;
                if (mesh.morphTargetData)
                    this.geometryBounds = mesh.morphTargetData.bounds;
                else
                    this.geometryBounds = mesh.bounds;
                var count = mesh.subMeshCount;
                this._renderElements.length = count;
                let materials = this.sharedMaterials;
                materials.length = count;
                for (var i = 0; i < count; i++) {
                    var renderElement = this._renderElements[i];
                    if (!renderElement) {
                        renderElement = this._renderElements[i] = this._renderElements[i] ? this._renderElements[i] : this._createRenderElement();
                        this.owner && renderElement.setTransform(this.owner._transform);
                        renderElement.render = this;
                    }
                    materials[i] = materials[i] || BlinnPhongMaterial.defaultMaterial;
                    renderElement.setGeometry(mesh.getSubMesh(i));
                }
                this.sharedMaterials = materials;
                this.boundsChange = true;
            }
            else if (!mesh) {
                this._renderElements.forEach;
                this._renderElements.forEach(element => {
                    element._renderElementOBJ.destroy();
                    element.destroy();
                });
                this._renderElements.length = 0;
                this._mesh = null;
                this._changeVertexDefine(null);
                this._changeMorphData(null);
                this.boundsChange = false;
            }
            this._setRenderElements();
            this._meshChange = true;
        }
        _onWorldMatNeedChange(flag) {
            super._onWorldMatNeedChange(flag);
            if (!this._mesh) {
                this.boundsChange = false;
            }
        }
        renderUpdate(context) {
            if (!this._mesh) {
                return;
            }
            this._mesh.morphTargetData && this._applyMorphdata();
            if (!this._meshChange) {
                return;
            }
            if (this._renderElements.length == 1) {
                this._renderElements[0]._renderElementOBJ.isRender = this._renderElements[0]._geometry._prepareRender(context);
                this._renderElements[0]._geometry._updateRenderParams(context);
                let material = this.sharedMaterial;
                this._renderElements[0].material = material;
            }
            else {
                for (var i = 0, n = this._renderElements.length; i < n; i++) {
                    this._renderElements[i]._renderElementOBJ.isRender = this._renderElements[i]._geometry._prepareRender(context);
                    this._renderElements[i]._geometry._updateRenderParams(context);
                    let material = this.sharedMaterials[i];
                    this._renderElements[i].material = material;
                }
            }
            this._meshChange = false;
        }
        _onDestroy() {
            super._onDestroy();
            this._morphTargetValues = null;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest._onMeshChange(this._mesh);
            if (this.morphTargetWeight) {
                dest.morphTargetWeight = new Float32Array(this.morphTargetWeight);
            }
            for (const key in this._morphTargetValues) {
                dest._morphTargetValues[key] = this._morphTargetValues[key];
            }
        }
    }

    class MeshSprite3D extends RenderableSprite3D {
        get meshFilter() {
            return this._meshFilter;
        }
        get meshRenderer() {
            return this._render;
        }
        constructor(mesh = null, name = null) {
            super(name);
            this._meshFilter = this.addComponent(MeshFilter);
            this._render = this.addComponent(MeshRenderer);
            (mesh) && (this._meshFilter.sharedMesh = mesh);
        }
    }

    class PixelLineVertex {
        static get vertexDeclaration() {
            return PixelLineVertex._vertexDeclaration;
        }
        static __init__() {
            PixelLineVertex._vertexDeclaration = new Laya.VertexDeclaration(40, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, Laya.VertexMesh.MESH_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector4, Laya.VertexMesh.MESH_COLOR0),
                new Laya.VertexElement(28, Laya.VertexElementFormat.Vector3, Laya.VertexMesh.MESH_NORMAL0)
            ]);
        }
        get vertexDeclaration() {
            return PixelLineVertex._vertexDeclaration;
        }
        constructor() {
        }
    }

    class Command {
        static __init__() {
            Command._screenShader = Laya.Shader3D.find("BlitScreen");
            Command.SCREENTEXTURE_ID = Laya.Shader3D.propertyNameToID(Command.SCREENTEXTURE_NAME);
            Command.SCREENTEXTUREOFFSETSCALE_ID = Laya.Shader3D.propertyNameToID(Command.SCREENTEXTUREOFFSETSCALE_NAME);
            Command.MAINTEXTURE_TEXELSIZE_ID = Laya.Shader3D.propertyNameToID(Command.MAINTEXTURE_TEXELSIZE_NAME);
        }
        constructor() {
            this._commandBuffer = null;
        }
        recover() {
            this._commandBuffer = null;
        }
        destroy() {
            this._commandBuffer = null;
            this._context = null;
        }
    }
    Command.SCREENTEXTURE_NAME = "u_MainTex";
    Command.SCREENTEXTUREOFFSETSCALE_NAME = "u_OffsetScale";
    Command.MAINTEXTURE_TEXELSIZE_NAME = "u_MainTex_TexelSize";

    class RenderContext3D {
        static __init__() {
            RenderContext3D._instance = new RenderContext3D();
            this.GammaCorrect = Laya.Shader3D.getDefineByName("GAMMACORRECT");
        }
        get camera() {
            return this._camera;
        }
        set camera(value) {
            this._camera = value;
            this._contextOBJ.cameraModuleData = value ? value._renderDataModule : null;
        }
        set destTarget(value) {
            this._contextOBJ.setRenderTarget(value ? value._renderTarget : null, Laya.RenderClearFlag.Nothing);
        }
        set viewport(value) {
            this._contextOBJ.setViewPort(value);
        }
        set scissor(value) {
            this._contextOBJ.setScissor(value);
        }
        get invertY() {
            return this._contextOBJ.invertY;
        }
        set invertY(value) {
            this._contextOBJ.invertY = value;
        }
        get pipelineMode() {
            return this._contextOBJ.pipelineMode;
        }
        set pipelineMode(value) {
            this._contextOBJ.pipelineMode = value;
        }
        get cameraShaderValue() {
            return this._contextOBJ.cameraData;
        }
        set cameraShaderValue(value) {
            this._contextOBJ.cameraData = value;
        }
        get scene() {
            return this._scene;
        }
        set scene(value) {
            if (value) {
                this._contextOBJ.sceneData = value._shaderValues;
                this._scene = value;
                this._contextOBJ.sceneModuleData = value._sceneModuleData;
            }
            else {
                this._contextOBJ.sceneModuleData = null;
                this._contextOBJ.sceneData = null;
                this._scene = null;
            }
        }
        changeViewport(x, y, width, height) {
            Laya.Viewport.TEMP.set(x, y, width, height);
            this.viewport = Laya.Viewport.TEMP;
        }
        changeScissor(x, y, width, height) {
            Laya.Vector4.TEMP.setValue(x, y, width, height);
            this.scissor = Laya.Vector4.TEMP;
        }
        applyContext(cameraUpdateMark) {
            this._contextOBJ.cameraUpdateMask = cameraUpdateMark;
        }
        drawRenderElement(renderelemt) {
            this._contextOBJ.drawRenderElementOne(renderelemt);
        }
        constructor() {
            this.configPipeLineMode = "Forward";
            this._contextOBJ = Laya3DRender.Render3DPassFactory.createRenderContext3D();
        }
    }

    class TextureGenerator {
        constructor() {
        }
        static lightAttenTexture(x, y, maxX, maxY, index, data) {
            var sqrRange = x / maxX;
            var atten = 1.0 / (1.0 + 25.0 * sqrRange);
            if (sqrRange >= 0.64) {
                if (sqrRange > 1.0) {
                    atten = 0;
                }
                else {
                    atten *= 1 - (sqrRange - 0.64) / (1 - 0.64);
                }
            }
            data[index] = Math.floor(atten * 255.0 + 0.5);
        }
        static haloTexture(x, y, maxX, maxY, index, data) {
            maxX >>= 1;
            maxY >>= 1;
            var xFac = (x - maxX) / maxX;
            var yFac = (y - maxY) / maxY;
            var sqrRange = xFac * xFac + yFac * yFac;
            if (sqrRange > 1.0) {
                sqrRange = 1.0;
            }
            data[index] = Math.floor((1.0 - sqrRange) * 255.0 + 0.5);
        }
        static _generateTexture2D(texture, textureWidth, textureHeight, func) {
            var index = 0;
            var size = 0;
            switch (texture.format) {
                case Laya.TextureFormat.R8G8B8:
                    size = 3;
                    break;
                case Laya.TextureFormat.R8G8B8A8:
                    size = 4;
                    break;
                case Laya.TextureFormat.Alpha8:
                    size = 1;
                    break;
                default:
                    throw "GeneratedTexture._generateTexture: unkonw texture format.";
            }
            var data = new Uint8Array(textureWidth * textureHeight * size);
            for (var y = 0; y < textureHeight; y++) {
                for (var x = 0; x < textureWidth; x++) {
                    func(x, y, textureWidth, textureHeight, index, data);
                    index += size;
                }
            }
            texture.setPixelsData(data, false, false);
        }
    }

    class Utils3D {
        static _createFloatTextureBuffer(width, height) {
            var floatTex = new Laya.Texture2D(width, height, Laya.TextureFormat.R32G32B32A32, false, false);
            floatTex.setPixelsData(null, false, false);
            floatTex.filterMode = Laya.FilterMode.Point;
            floatTex.wrapModeU = Laya.WrapMode.Clamp;
            floatTex.wrapModeV = Laya.WrapMode.Clamp;
            floatTex.anisoLevel = 1;
            return floatTex;
        }
        static _rotationTransformScaleSkinAnimation(tx, ty, tz, qx, qy, qz, qw, sx, sy, sz, outArray, outOffset) {
            var re = _tempArray16_0;
            var se = _tempArray16_1;
            var tse = _tempArray16_2;
            var x2 = qx + qx;
            var y2 = qy + qy;
            var z2 = qz + qz;
            var xx = qx * x2;
            var yx = qy * x2;
            var yy = qy * y2;
            var zx = qz * x2;
            var zy = qz * y2;
            var zz = qz * z2;
            var wx = qw * x2;
            var wy = qw * y2;
            var wz = qw * z2;
            re[15] = 1;
            re[0] = 1 - yy - zz;
            re[1] = yx + wz;
            re[2] = zx - wy;
            re[4] = yx - wz;
            re[5] = 1 - xx - zz;
            re[6] = zy + wx;
            re[8] = zx + wy;
            re[9] = zy - wx;
            re[10] = 1 - xx - yy;
            se[15] = 1;
            se[0] = sx;
            se[5] = sy;
            se[10] = sz;
            var i, ai0, ai1, ai2, ai3;
            for (i = 0; i < 4; i++) {
                ai0 = re[i];
                ai1 = re[i + 4];
                ai2 = re[i + 8];
                ai3 = re[i + 12];
                tse[i] = ai0;
                tse[i + 4] = ai1;
                tse[i + 8] = ai2;
                tse[i + 12] = ai0 * tx + ai1 * ty + ai2 * tz + ai3;
            }
            for (i = 0; i < 4; i++) {
                ai0 = tse[i];
                ai1 = tse[i + 4];
                ai2 = tse[i + 8];
                ai3 = tse[i + 12];
                outArray[i + outOffset] = ai0 * se[0] + ai1 * se[1] + ai2 * se[2] + ai3 * se[3];
                outArray[i + outOffset + 4] = ai0 * se[4] + ai1 * se[5] + ai2 * se[6] + ai3 * se[7];
                outArray[i + outOffset + 8] = ai0 * se[8] + ai1 * se[9] + ai2 * se[10] + ai3 * se[11];
                outArray[i + outOffset + 12] = ai0 * se[12] + ai1 * se[13] + ai2 * se[14] + ai3 * se[15];
            }
        }
        static billboardTrans(v0, cameraDir, cameraUp, out) {
            Laya.Vector3.normalize(cameraUp, _tempVector3_1);
            Laya.Vector3.cross(cameraDir, cameraUp, _tempVector3_0);
            Laya.Vector3.normalize(_tempVector3_0, _tempVector3_0);
            Laya.Vector3.scale(_tempVector3_0, v0.x, out);
            Laya.Vector3.scale(cameraUp, v0.y, _tempVector3_1);
            Laya.Vector3.add(out, _tempVector3_1, out);
        }
        static PointinTriangle(A, B, C, P) {
            let v0 = C.vsub(A, _tempVector3_0);
            let v1 = B.vsub(A, _tempVector3_1);
            let v2 = P.vsub(A, _tempVector3_2);
            let dot00 = v0.dot(v0);
            let dot01 = v0.dot(v1);
            let dot02 = v0.dot(v2);
            let dot11 = v1.dot(v1);
            let dot12 = v1.dot(v2);
            let inverDeno = 1 / (dot00 * dot11 - dot01 * dot01);
            let u = (dot11 * dot02 - dot01 * dot12) * inverDeno;
            if (u < 0 || u > 1) {
                return false;
            }
            let v = (dot00 * dot12 - dot01 * dot02) * inverDeno;
            if (v < 0 || v > 1) {
                return false;
            }
            return u + v <= 1;
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxix(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas, boneIndexToMesh) {
            var offset = 0;
            var matOffset = 0;
            var i;
            var parentOffset;
            var boneLength = bones.length;
            for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) {
                Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], outBonesDatas, matOffset);
                if (i != 0) {
                    parentOffset = bones[i].parentIndex * 16;
                    Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset);
                }
            }
            var n = inverGlobalBindPose.length;
            for (i = 0; i < n; i++) {
                Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, boneIndexToMesh[i] * 16, inverGlobalBindPose[i], outAnimationDatas, i * 16);
            }
        }
        static _computeAnimationDatasByArrayAndMatrixFast(inverGlobalBindPose, bonesDatas, outAnimationDatas, boneIndexToMesh) {
            for (var i = 0, n = inverGlobalBindPose.length; i < n; i++)
                Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, boneIndexToMesh[i] * 16, inverGlobalBindPose[i], outAnimationDatas, i * 16);
        }
        static _computeBoneAndAnimationDatasByBindPoseMatrxixOld(bones, curData, inverGlobalBindPose, outBonesDatas, outAnimationDatas) {
            var offset = 0;
            var matOffset = 0;
            var i;
            var parentOffset;
            var boneLength = bones.length;
            for (i = 0; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++) {
                Utils3D._rotationTransformScaleSkinAnimation(curData[offset + 7], curData[offset + 8], curData[offset + 9], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 0], curData[offset + 1], curData[offset + 2], outBonesDatas, matOffset);
                if (i != 0) {
                    parentOffset = bones[i].parentIndex * 16;
                    Utils3D.mulMatrixByArray(outBonesDatas, parentOffset, outBonesDatas, matOffset, outBonesDatas, matOffset);
                }
            }
            var n = inverGlobalBindPose.length;
            for (i = 0; i < n; i++) {
                var arrayOffset = i * 16;
                Utils3D.mulMatrixByArrayAndMatrixFast(outBonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset);
            }
        }
        static _computeAnimationDatasByArrayAndMatrixFastOld(inverGlobalBindPose, bonesDatas, outAnimationDatas) {
            var n = inverGlobalBindPose.length;
            for (var i = 0; i < n; i++) {
                var arrayOffset = i * 16;
                Utils3D.mulMatrixByArrayAndMatrixFast(bonesDatas, arrayOffset, inverGlobalBindPose[i], outAnimationDatas, arrayOffset);
            }
        }
        static _computeRootAnimationData(bones, curData, animationDatas) {
            for (var i = 0, offset = 0, matOffset = 0, boneLength = bones.length; i < boneLength; offset += bones[i].keyframeWidth, matOffset += 16, i++)
                Utils3D.createAffineTransformationArray(curData[offset + 0], curData[offset + 1], curData[offset + 2], curData[offset + 3], curData[offset + 4], curData[offset + 5], curData[offset + 6], curData[offset + 7], curData[offset + 8], curData[offset + 9], animationDatas, matOffset);
        }
        static transformVector3ArrayByQuat(sourceArray, sourceOffset, rotation, outArray, outOffset) {
            var x = sourceArray[sourceOffset], y = sourceArray[sourceOffset + 1], z = sourceArray[sourceOffset + 2], qx = rotation.x, qy = rotation.y, qz = rotation.z, qw = rotation.w, ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            outArray[outOffset] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            outArray[outOffset + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            outArray[outOffset + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static mulMatrixByArray(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
            var i, ai0, ai1, ai2, ai3;
            if (outArray === rightArray) {
                rightArray = _tempArray16_3;
                for (i = 0; i < 16; ++i) {
                    rightArray[i] = outArray[outOffset + i];
                }
                rightOffset = 0;
            }
            for (i = 0; i < 4; i++) {
                ai0 = leftArray[leftOffset + i];
                ai1 = leftArray[leftOffset + i + 4];
                ai2 = leftArray[leftOffset + i + 8];
                ai3 = leftArray[leftOffset + i + 12];
                outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3];
                outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7];
                outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11];
                outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15];
            }
        }
        static mulMatrixByArrayFast(leftArray, leftOffset, rightArray, rightOffset, outArray, outOffset) {
            var i, ai0, ai1, ai2, ai3;
            for (i = 0; i < 4; i++) {
                ai0 = leftArray[leftOffset + i];
                ai1 = leftArray[leftOffset + i + 4];
                ai2 = leftArray[leftOffset + i + 8];
                ai3 = leftArray[leftOffset + i + 12];
                outArray[outOffset + i] = ai0 * rightArray[rightOffset + 0] + ai1 * rightArray[rightOffset + 1] + ai2 * rightArray[rightOffset + 2] + ai3 * rightArray[rightOffset + 3];
                outArray[outOffset + i + 4] = ai0 * rightArray[rightOffset + 4] + ai1 * rightArray[rightOffset + 5] + ai2 * rightArray[rightOffset + 6] + ai3 * rightArray[rightOffset + 7];
                outArray[outOffset + i + 8] = ai0 * rightArray[rightOffset + 8] + ai1 * rightArray[rightOffset + 9] + ai2 * rightArray[rightOffset + 10] + ai3 * rightArray[rightOffset + 11];
                outArray[outOffset + i + 12] = ai0 * rightArray[rightOffset + 12] + ai1 * rightArray[rightOffset + 13] + ai2 * rightArray[rightOffset + 14] + ai3 * rightArray[rightOffset + 15];
            }
        }
        static mulMatrixByArrayAndMatrixFast(leftArray, leftOffset, rightMatrix, outArray, outOffset) {
            var i, ai0, ai1, ai2, ai3;
            var rightMatrixE = rightMatrix.elements;
            var m11 = rightMatrixE[0], m12 = rightMatrixE[1], m13 = rightMatrixE[2], m14 = rightMatrixE[3];
            var m21 = rightMatrixE[4], m22 = rightMatrixE[5], m23 = rightMatrixE[6], m24 = rightMatrixE[7];
            var m31 = rightMatrixE[8], m32 = rightMatrixE[9], m33 = rightMatrixE[10], m34 = rightMatrixE[11];
            var m41 = rightMatrixE[12], m42 = rightMatrixE[13], m43 = rightMatrixE[14], m44 = rightMatrixE[15];
            var ai0LeftOffset = leftOffset;
            var ai1LeftOffset = leftOffset + 4;
            var ai2LeftOffset = leftOffset + 8;
            var ai3LeftOffset = leftOffset + 12;
            var ai0OutOffset = outOffset;
            var ai1OutOffset = outOffset + 4;
            var ai2OutOffset = outOffset + 8;
            var ai3OutOffset = outOffset + 12;
            for (i = 0; i < 4; i++) {
                ai0 = leftArray[ai0LeftOffset + i];
                ai1 = leftArray[ai1LeftOffset + i];
                ai2 = leftArray[ai2LeftOffset + i];
                ai3 = leftArray[ai3LeftOffset + i];
                outArray[ai0OutOffset + i] = ai0 * m11 + ai1 * m12 + ai2 * m13 + ai3 * m14;
                outArray[ai1OutOffset + i] = ai0 * m21 + ai1 * m22 + ai2 * m23 + ai3 * m24;
                outArray[ai2OutOffset + i] = ai0 * m31 + ai1 * m32 + ai2 * m33 + ai3 * m34;
                outArray[ai3OutOffset + i] = ai0 * m41 + ai1 * m42 + ai2 * m43 + ai3 * m44;
            }
        }
        static createAffineTransformationArray(tX, tY, tZ, rX, rY, rZ, rW, sX, sY, sZ, outArray, outOffset) {
            var x2 = rX + rX, y2 = rY + rY, z2 = rZ + rZ;
            var xx = rX * x2, xy = rX * y2, xz = rX * z2, yy = rY * y2, yz = rY * z2, zz = rZ * z2;
            var wx = rW * x2, wy = rW * y2, wz = rW * z2;
            outArray[outOffset + 0] = (1 - (yy + zz)) * sX;
            outArray[outOffset + 1] = (xy + wz) * sX;
            outArray[outOffset + 2] = (xz - wy) * sX;
            outArray[outOffset + 3] = 0;
            outArray[outOffset + 4] = (xy - wz) * sY;
            outArray[outOffset + 5] = (1 - (xx + zz)) * sY;
            outArray[outOffset + 6] = (yz + wx) * sY;
            outArray[outOffset + 7] = 0;
            outArray[outOffset + 8] = (xz + wy) * sZ;
            outArray[outOffset + 9] = (yz - wx) * sZ;
            outArray[outOffset + 10] = (1 - (xx + yy)) * sZ;
            outArray[outOffset + 11] = 0;
            outArray[outOffset + 12] = tX;
            outArray[outOffset + 13] = tY;
            outArray[outOffset + 14] = tZ;
            outArray[outOffset + 15] = 1;
        }
        static transformVector3ArrayToVector3ArrayCoordinate(source, sourceOffset, transform, result, resultOffset) {
            var coordinateX = source[sourceOffset + 0];
            var coordinateY = source[sourceOffset + 1];
            var coordinateZ = source[sourceOffset + 2];
            var transformElem = transform.elements;
            var w = ((coordinateX * transformElem[3]) + (coordinateY * transformElem[7]) + (coordinateZ * transformElem[11]) + transformElem[15]);
            result[resultOffset] = (coordinateX * transformElem[0]) + (coordinateY * transformElem[4]) + (coordinateZ * transformElem[8]) + transformElem[12] / w;
            result[resultOffset + 1] = (coordinateX * transformElem[1]) + (coordinateY * transformElem[5]) + (coordinateZ * transformElem[9]) + transformElem[13] / w;
            result[resultOffset + 2] = (coordinateX * transformElem[2]) + (coordinateY * transformElem[6]) + (coordinateZ * transformElem[10]) + transformElem[14] / w;
        }
        static transformVector3ArrayToVector3ArrayNormal(source, sourceOffset, transform, result, resultOffset) {
            var coordinateX = source[sourceOffset + 0];
            var coordinateY = source[sourceOffset + 1];
            var coordinateZ = source[sourceOffset + 2];
            var transformElem = transform.elements;
            result[resultOffset] = coordinateX * transformElem[0] + coordinateY * transformElem[4] + coordinateZ * transformElem[8];
            result[resultOffset + 1] = coordinateX * transformElem[1] + coordinateY * transformElem[5] + coordinateZ * transformElem[9];
            result[resultOffset + 2] = coordinateX * transformElem[2] + coordinateY * transformElem[6] + coordinateZ * transformElem[10];
        }
        static transformLightingMapTexcoordArray(source, sourceOffset, lightingMapScaleOffset, result, resultOffset) {
            result[resultOffset + 0] = source[sourceOffset + 0] * lightingMapScaleOffset.x + lightingMapScaleOffset.z;
            result[resultOffset + 1] = 1.0 - ((1.0 - source[sourceOffset + 1]) * lightingMapScaleOffset.y + lightingMapScaleOffset.w);
        }
        static getURLVerion(url) {
            var index = url.indexOf("?");
            return index >= 0 ? url.substr(index) : null;
        }
        static _createAffineTransformationArray(trans, rot, scale, outE) {
            var x = rot.x, y = rot.y, z = rot.z, w = rot.w, x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2, sx = scale.x, sy = scale.y, sz = scale.z;
            outE[0] = (1 - (yy + zz)) * sx;
            outE[1] = (xy + wz) * sx;
            outE[2] = (xz - wy) * sx;
            outE[3] = 0;
            outE[4] = (xy - wz) * sy;
            outE[5] = (1 - (xx + zz)) * sy;
            outE[6] = (yz + wx) * sy;
            outE[7] = 0;
            outE[8] = (xz + wy) * sz;
            outE[9] = (yz - wx) * sz;
            outE[10] = (1 - (xx + yy)) * sz;
            outE[11] = 0;
            outE[12] = trans.x;
            outE[13] = trans.y;
            outE[14] = trans.z;
            outE[15] = 1;
        }
        static _mulMatrixArray(left, right, rightOffset, outArray, outOffset) {
            var l = right;
            var r = left;
            var e = outArray;
            var l11 = l[rightOffset], l12 = l[rightOffset + 1], l13 = l[rightOffset + 2], l14 = l[rightOffset + 3];
            var l21 = l[rightOffset + 4], l22 = l[rightOffset + 5], l23 = l[rightOffset + 6], l24 = l[rightOffset + 7];
            var l31 = l[rightOffset + 8], l32 = l[rightOffset + 9], l33 = l[rightOffset + 10], l34 = l[rightOffset + 11];
            var l41 = l[rightOffset + 12], l42 = l[rightOffset + 13], l43 = l[rightOffset + 14], l44 = l[rightOffset + 15];
            var r11 = r[0], r12 = r[1], r13 = r[2], r14 = r[3];
            var r21 = r[4], r22 = r[5], r23 = r[6], r24 = r[7];
            var r31 = r[8], r32 = r[9], r33 = r[10], r34 = r[11];
            var r41 = r[12], r42 = r[13], r43 = r[14], r44 = r[15];
            e[outOffset] = (l11 * r11) + (l12 * r21) + (l13 * r31) + (l14 * r41);
            e[outOffset + 1] = (l11 * r12) + (l12 * r22) + (l13 * r32) + (l14 * r42);
            e[outOffset + 2] = (l11 * r13) + (l12 * r23) + (l13 * r33) + (l14 * r43);
            e[outOffset + 3] = (l11 * r14) + (l12 * r24) + (l13 * r34) + (l14 * r44);
            e[outOffset + 4] = (l21 * r11) + (l22 * r21) + (l23 * r31) + (l24 * r41);
            e[outOffset + 5] = (l21 * r12) + (l22 * r22) + (l23 * r32) + (l24 * r42);
            e[outOffset + 6] = (l21 * r13) + (l22 * r23) + (l23 * r33) + (l24 * r43);
            e[outOffset + 7] = (l21 * r14) + (l22 * r24) + (l23 * r34) + (l24 * r44);
            e[outOffset + 8] = (l31 * r11) + (l32 * r21) + (l33 * r31) + (l34 * r41);
            e[outOffset + 9] = (l31 * r12) + (l32 * r22) + (l33 * r32) + (l34 * r42);
            e[outOffset + 10] = (l31 * r13) + (l32 * r23) + (l33 * r33) + (l34 * r43);
            e[outOffset + 11] = (l31 * r14) + (l32 * r24) + (l33 * r34) + (l34 * r44);
            e[outOffset + 12] = (l41 * r11) + (l42 * r21) + (l43 * r31) + (l44 * r41);
            e[outOffset + 13] = (l41 * r12) + (l42 * r22) + (l43 * r32) + (l44 * r42);
            e[outOffset + 14] = (l41 * r13) + (l42 * r23) + (l43 * r33) + (l44 * r43);
            e[outOffset + 15] = (l41 * r14) + (l42 * r24) + (l43 * r34) + (l44 * r44);
        }
        static arcTanAngle(x, y) {
            if (x == 0) {
                if (y == 1)
                    return Math.PI / 2;
                return -Math.PI / 2;
            }
            if (x > 0)
                return Math.atan(y / x);
            if (x < 0) {
                if (y > 0)
                    return Math.atan(y / x) + Math.PI;
                return Math.atan(y / x) - Math.PI;
            }
            return 0;
        }
        static angleTo(from, location, angle) {
            Laya.Vector3.subtract(location, from, TEMPVector30);
            Laya.Vector3.normalize(TEMPVector30, TEMPVector30);
            angle.x = Math.asin(TEMPVector30.y);
            angle.y = Utils3D.arcTanAngle(-TEMPVector30.z, -TEMPVector30.x);
        }
        static transformQuat(source, rotation, out) {
            var re = rotation;
            var x = source.x, y = source.y, z = source.z, qx = re[0], qy = re[1], qz = re[2], qw = re[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        }
        static quaternionWeight(f, weight, e) {
            e.x = f.x * weight;
            e.y = f.y * weight;
            e.z = f.z * weight;
            e.w = f.w;
        }
        static quaternionConjugate(value, result) {
            result.x = -value.x;
            result.y = -value.y;
            result.z = -value.z;
            result.w = value.w;
        }
        static scaleWeight(s, w, out) {
            var sX = s.x, sY = s.y, sZ = s.z;
            out.x = sX > 0 ? Math.pow(Math.abs(sX), w) : -Math.pow(Math.abs(sX), w);
            out.y = sY > 0 ? Math.pow(Math.abs(sY), w) : -Math.pow(Math.abs(sY), w);
            out.z = sZ > 0 ? Math.pow(Math.abs(sZ), w) : -Math.pow(Math.abs(sZ), w);
        }
        static scaleBlend(sa, sb, w, out) {
            var saw = _tempVector3_0;
            var sbw = _tempVector3_1;
            Utils3D.scaleWeight(sa, 1.0 - w, saw);
            Utils3D.scaleWeight(sb, w, sbw);
            var sng = w > 0.5 ? sb : sa;
            out.x = sng.x > 0 ? Math.abs(saw.x * sbw.x) : -Math.abs(saw.x * sbw.x);
            out.y = sng.y > 0 ? Math.abs(saw.y * sbw.y) : -Math.abs(saw.y * sbw.y);
            out.z = sng.z > 0 ? Math.abs(saw.z * sbw.z) : -Math.abs(saw.z * sbw.z);
        }
        static matrix4x4MultiplyFFF(a, b, e) {
            var i, ai0, ai1, ai2, ai3;
            if (e === b) {
                b = new Float32Array(16);
                for (i = 0; i < 16; ++i) {
                    b[i] = e[i];
                }
            }
            var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
            var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
            var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
            for (i = 0; i < 4; i++) {
                ai0 = a[i];
                ai1 = a[i + 4];
                ai2 = a[i + 8];
                ai3 = a[i + 12];
                e[i] = ai0 * b0 + ai1 * b1 + ai2 * b2 + ai3 * b3;
                e[i + 4] = ai0 * b4 + ai1 * b5 + ai2 * b6 + ai3 * b7;
                e[i + 8] = ai0 * b8 + ai1 * b9 + ai2 * b10 + ai3 * b11;
                e[i + 12] = ai0 * b12 + ai1 * b13 + ai2 * b14 + ai3 * b15;
            }
        }
        static matrix4x4MultiplyMFM(left, right, out) {
            Utils3D.matrix4x4MultiplyFFF(left.elements, right, out.elements);
        }
        static _buildTexture2D(width, height, format, colorFunc, mipmaps = false) {
            var texture = new Laya.Texture2D(width, height, format, mipmaps, true);
            texture.anisoLevel = 1;
            texture.filterMode = Laya.FilterMode.Point;
            TextureGenerator._generateTexture2D(texture, width, height, colorFunc);
            return texture;
        }
        static _drawBound(debugLine, boundBox, color) {
            if (debugLine.lineCount + 12 > debugLine.maxLineCount)
                debugLine.maxLineCount += 12;
            var start = _tempVector3_0;
            var end = _tempVector3_1;
            var min = boundBox.min;
            var max = boundBox.max;
            start.setValue(min.x, min.y, min.z);
            end.setValue(max.x, min.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, min.z);
            end.setValue(min.x, min.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, min.y, min.z);
            end.setValue(max.x, min.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, max.z);
            end.setValue(max.x, min.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, min.z);
            end.setValue(min.x, max.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, min.y, max.z);
            end.setValue(min.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, min.y, min.z);
            end.setValue(max.x, max.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, min.y, max.z);
            end.setValue(max.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, max.y, min.z);
            end.setValue(max.x, max.y, min.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, max.y, min.z);
            end.setValue(min.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(max.x, max.y, min.z);
            end.setValue(max.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
            start.setValue(min.x, max.y, max.z);
            end.setValue(max.x, max.y, max.z);
            debugLine.addLine(start, end, color, color);
        }
        static _getHierarchyPath(rootSprite, checkSprite, path) {
            path.length = 0;
            var sprite = checkSprite;
            while (sprite !== rootSprite) {
                var parent = sprite._parent;
                if (parent)
                    path.push(parent.getChildIndex(sprite));
                else
                    return null;
                sprite = parent;
            }
            return path;
        }
        static _getNodeByHierarchyPath(rootSprite, invPath) {
            var sprite = rootSprite;
            for (var i = invPath.length - 1; i >= 0; i--) {
                sprite = sprite.getChildAt(invPath[i]);
            }
            return sprite;
        }
        static _getParentNodeByHierarchyPath(rootSprite, path) {
            let pathlength = path.length;
            let node = rootSprite;
            for (let i = 0; i < pathlength; i++) {
                if (node)
                    node = node.parent;
                else
                    return null;
            }
            return node;
        }
        static uint8ArrayToArrayBuffer(rendertexture) {
            return Laya.Utils.uint8ArrayToArrayBuffer(rendertexture);
        }
        static uint8ArrayToArrayBufferAsync(rendertexture) {
            return Laya.Utils.uint8ArrayToArrayBufferAsync(rendertexture);
        }
    }
    window.getRTBase64 = Utils3D.uint8ArrayToArrayBuffer;
    const TEMPVector30 = new Laya.Vector3();
    const _tempVector3_0 = new Laya.Vector3();
    const _tempVector3_1 = new Laya.Vector3();
    const _tempVector3_2 = new Laya.Vector3();
    const _tempArray16_0 = new Float32Array(16);
    const _tempArray16_1 = new Float32Array(16);
    const _tempArray16_2 = new Float32Array(16);
    const _tempArray16_3 = new Float32Array(16);

    class LightBound {
    }
    class ClusterData {
        constructor() {
            this.updateMark = -1;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            this.indices = [];
        }
    }
    class Cluster {
        constructor(xSlices, ySlices, zSlices, maxLightsPerClusterAverage) {
            this._updateMark = 0;
            this._depthSliceParam = new Laya.Vector2();
            this._xSlices = xSlices;
            this._ySlices = ySlices;
            this._zSlices = zSlices;
            var clusterTexWidth = xSlices * ySlices;
            var clisterTexHeight = zSlices * (1 + Math.ceil(maxLightsPerClusterAverage / 4));
            this._clusterTexture = Utils3D._createFloatTextureBuffer(clusterTexWidth, clisterTexHeight);
            this._clusterTexture.lock = true;
            this._clusterPixels = new Float32Array(clusterTexWidth * clisterTexHeight * 4);
            var clusterDatas = new Array(this._zSlices);
            for (var z = 0; z < this._zSlices; z++) {
                clusterDatas[z] = new Array(this._ySlices);
                for (var y = 0; y < this._ySlices; y++) {
                    clusterDatas[z][y] = new Array(this._xSlices);
                    for (var x = 0; x < this._xSlices; x++)
                        clusterDatas[z][y][x] = new ClusterData();
                }
            }
            this._clusterDatas = clusterDatas;
        }
        _placePointLightToClusters(lightIndex, lightBound) {
            var clusterDatas = this._clusterDatas;
            var updateMark = this._updateMark;
            for (var z = lightBound.zMin, zEnd = lightBound.zMax; z < zEnd; z++) {
                for (var y = lightBound.yMin, yEnd = lightBound.yMax; y < yEnd; y++) {
                    for (var x = lightBound.xMin, xEnd = lightBound.xMax; x < xEnd; x++) {
                        var data = clusterDatas[z][y][x];
                        if (data.updateMark != updateMark) {
                            data.pointLightCount = 0;
                            data.spotLightCount = 0;
                            data.updateMark = updateMark;
                        }
                        var indices = data.indices;
                        var lightCount = data.pointLightCount++;
                        if (lightCount < indices.length)
                            indices[lightCount] = lightIndex;
                        else
                            indices.push(lightIndex);
                    }
                }
            }
        }
        _placeSpotLightToClusters(lightIndex, lightBound) {
            var clusterDatas = this._clusterDatas;
            var updateMark = this._updateMark;
            for (var z = lightBound.zMin, zEnd = lightBound.zMax; z < zEnd; z++) {
                for (var y = lightBound.yMin, yEnd = lightBound.yMax; y < yEnd; y++) {
                    for (var x = lightBound.xMin, xEnd = lightBound.xMax; x < xEnd; x++) {
                        var data = clusterDatas[z][y][x];
                        if (data.updateMark != updateMark) {
                            data.pointLightCount = 0;
                            data.spotLightCount = 0;
                            data.updateMark = updateMark;
                        }
                        var indices = data.indices;
                        var lightCount = data.pointLightCount + data.spotLightCount++;
                        if (lightCount < indices.length)
                            indices[lightCount] = lightIndex;
                        else
                            indices.push(lightIndex);
                    }
                }
            }
        }
        _insertConePlane(origin, forward, radius, halfAngle, pNor) {
            var V1 = _tempVector36;
            var V2 = _tempVector37;
            Laya.Vector3.cross(pNor, forward, V1);
            Laya.Vector3.cross(V1, forward, V2);
            Laya.Vector3.normalize(V2, V2);
            var tanR = radius * Math.tan(halfAngle);
            var capRimX = origin.x + radius * forward.x + tanR * V2.x;
            var capRimY = origin.y + radius * forward.y + tanR * V2.y;
            var capRimZ = origin.z + radius * forward.z + tanR * V2.z;
            return capRimX * pNor.x + capRimY * pNor.y + capRimZ * pNor.z <= 0 || origin.x * pNor.x + origin.y * pNor.y + origin.z * pNor.z <= 0;
        }
        _shrinkSphereLightZPerspective(near, far, lightviewPos, radius, lightBound) {
            var lvZ = lightviewPos.z;
            var minZ = lvZ - radius;
            var maxZ = lvZ + radius;
            if ((minZ > far) || (maxZ <= near))
                return false;
            var depthSliceParam = this._depthSliceParam;
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkSpotLightZPerspective(near, far, viewLightPos, viewConeCap, radius, halfAngle, lightBound) {
            var pbX = viewConeCap.x, pbY = viewConeCap.y, pbZ = viewConeCap.z;
            var rb = Math.tan(halfAngle) * radius;
            var paX = viewLightPos.x, paY = viewLightPos.y, paZ = viewLightPos.z;
            var aX = pbX - paX, aY = pbY - paY, aZ = pbZ - paZ;
            var dotA = aX * aX + aY * aY + aZ * aZ;
            var eZ = Math.sqrt(1.0 - aZ * aZ / dotA);
            var minZ = Math.max(Math.min(paZ, pbZ - eZ * rb), viewLightPos.z - radius);
            var maxZ = Math.min(Math.max(paZ, pbZ + eZ * rb), viewLightPos.z + radius);
            if ((minZ > far) || (maxZ <= near))
                return false;
            var depthSliceParam = this._depthSliceParam;
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkSphereLightByBoundOrth(halfX, halfY, near, far, lightviewPos, radius, lightBound) {
            var lvZ = lightviewPos.z;
            var minZ = lvZ - radius, maxZ = lvZ + radius;
            if ((minZ > far) || (maxZ <= near))
                return false;
            var lvX = lightviewPos.x;
            var minX = lvX - radius, maxX = lvX + radius;
            if ((minX > halfX) || (maxX <= -halfX))
                return false;
            var lvY = lightviewPos.y;
            var minY = lvY - radius, maxY = lvY + radius;
            if ((minY > halfY) || (maxY <= -halfY))
                return false;
            var xSlices = this._xSlices, ySlices = this._ySlices;
            var depthSliceParam = this._depthSliceParam;
            var xStride = halfX * 2 / xSlices, yStride = halfY * 2 / ySlices;
            lightBound.xMin = Math.max(Math.floor((minX + halfX) / xStride), 0);
            lightBound.xMax = Math.min(Math.ceil((maxX + halfX) / xStride), xSlices);
            lightBound.yMin = Math.max(Math.floor((halfY - maxY) / yStride), 0);
            lightBound.yMax = Math.min(Math.ceil((halfY - minY) / yStride), ySlices);
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkSpotLightByBoundOrth(halfX, halfY, near, far, viewLightPos, viewConeCap, radius, halfAngle, lightBound) {
            var pbX = viewConeCap.x, pbY = viewConeCap.y, pbZ = viewConeCap.z;
            var rb = Math.tan(halfAngle) * radius;
            var paX = viewLightPos.x, paY = viewLightPos.y, paZ = viewLightPos.z;
            var aX = pbX - paX, aY = pbY - paY, aZ = pbZ - paZ;
            var dotA = aX * aX + aY * aY + aZ * aZ;
            var eZ = Math.sqrt(1.0 - aZ * aZ / dotA);
            var minZ = Math.max(Math.min(paZ, pbZ - eZ * rb), viewLightPos.z - radius);
            var maxZ = Math.min(Math.max(paZ, pbZ + eZ * rb), viewLightPos.z + radius);
            if ((minZ > far) || (maxZ <= near))
                return false;
            var eX = Math.sqrt(1.0 - aX * aX / dotA);
            var minX = Math.max(Math.min(paX, pbX - eX * rb), viewLightPos.x - radius);
            var maxX = Math.min(Math.max(paX, pbX + eX * rb), viewLightPos.x + radius);
            if ((minX > halfX) || (maxX <= -halfX))
                return false;
            var eY = Math.sqrt(1.0 - aY * aY / dotA);
            var minY = Math.max(Math.min(paY, pbY - eY * rb), viewLightPos.y - radius);
            var maxY = Math.min(Math.max(paY, pbY + eY * rb), viewLightPos.y + radius);
            if ((minY > halfY) || (maxY <= -halfY))
                return false;
            var xSlices = this._xSlices, ySlices = this._ySlices;
            var depthSliceParam = this._depthSliceParam;
            var xStride = halfX * 2 / xSlices, yStride = halfY * 2 / ySlices;
            lightBound.xMin = Math.max(Math.floor((minX + halfX) / xStride), 0);
            lightBound.xMax = Math.min(Math.ceil((maxX + halfX) / xStride), xSlices);
            lightBound.yMin = Math.max(Math.floor((halfY - maxY) / yStride), 0);
            lightBound.yMax = Math.min(Math.ceil((halfY - minY) / yStride), ySlices);
            lightBound.zMin = Math.floor(Math.log2(Math.max(minZ, near)) * depthSliceParam.x - depthSliceParam.y);
            lightBound.zMax = Math.min(Math.ceil(Math.log2(maxZ) * depthSliceParam.x - depthSliceParam.y), this._zSlices);
            return true;
        }
        _shrinkXYByRadiusPerspective(lightviewPos, radius, lightBound, xPlanes, yPlanes) {
            var xMin, yMin;
            var xMax, yMax;
            var lvX = lightviewPos.x, lvY = lightviewPos.y, lvZ = lightviewPos.z;
            var i;
            var n = this._ySlices + 1;
            for (i = 0; i < n; i++) {
                var plane = yPlanes[i];
                if (lvY * plane.y + lvZ * plane.z < radius) {
                    yMin = Math.max(0, i - 1);
                    break;
                }
            }
            if (i == n)
                return false;
            yMax = this._ySlices;
            for (i = yMin + 1; i < n; i++) {
                var plane = yPlanes[i];
                if (lvY * plane.y + lvZ * plane.z <= -radius) {
                    yMax = Math.max(0, i);
                    break;
                }
            }
            n = this._xSlices + 1;
            for (i = 0; i < n; i++) {
                var plane = xPlanes[i];
                if (lvX * plane.x + lvZ * plane.z < radius) {
                    xMin = Math.max(0, i - 1);
                    break;
                }
            }
            xMax = this._xSlices;
            for (i = xMin + 1; i < n; i++) {
                var plane = xPlanes[i];
                if (lvX * plane.x + lvZ * plane.z <= -radius) {
                    xMax = Math.max(0, i);
                    break;
                }
            }
            lightBound.xMin = xMin;
            lightBound.xMax = xMax;
            lightBound.yMin = yMin;
            lightBound.yMax = yMax;
            return true;
        }
        _shrinkSpotXYByConePerspective(lightviewPos, viewForward, radius, halfAngle, lightBound, xPlanes, yPlanes) {
            var xMin, yMin;
            var xMax, yMax;
            var normal = _tempVector32$1;
            var n = lightBound.yMax + 1;
            for (var i = lightBound.yMin + 1; i < n; i++) {
                if (this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, yPlanes[i])) {
                    yMin = Math.max(0, i - 1);
                    break;
                }
            }
            yMax = lightBound.yMax;
            for (var i = yMin + 1; i < n; i++) {
                var plane = yPlanes[i];
                normal.setValue(0, -plane.y, -plane.z);
                if (!this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, normal)) {
                    yMax = Math.max(0, i);
                    break;
                }
            }
            n = lightBound.xMax + 1;
            for (var i = lightBound.xMin + 1; i < n; i++) {
                if (this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, xPlanes[i])) {
                    xMin = Math.max(0, i - 1);
                    break;
                }
            }
            xMax = lightBound.xMax;
            for (var i = xMin + 1; i < n; i++) {
                var plane = xPlanes[i];
                normal.setValue(-plane.x, 0, -plane.z);
                if (!this._insertConePlane(lightviewPos, viewForward, radius, halfAngle, normal)) {
                    xMax = Math.max(0, i);
                    break;
                }
            }
            lightBound.xMin = xMin;
            lightBound.xMax = xMax;
            lightBound.yMin = yMin;
            lightBound.yMax = yMax;
        }
        _updatePointLightPerspective(near, far, viewMat, pointLight, lightIndex, xPlanes, yPlanes) {
            var lightBound = _tempLightBound;
            var lightviewPos = _tempVector30$4;
            Laya.Vector3.transformV3ToV3(pointLight.owner._transform.position, viewMat, lightviewPos);
            lightviewPos.z *= -1;
            if (!this._shrinkSphereLightZPerspective(near, far, lightviewPos, pointLight.range, lightBound))
                return;
            if (!this._shrinkXYByRadiusPerspective(lightviewPos, pointLight.range, lightBound, xPlanes, yPlanes))
                return;
            this._placePointLightToClusters(lightIndex, lightBound);
        }
        _updateSpotLightPerspective(near, far, viewMat, spotLight, lightIndex, xPlanes, yPlanes) {
            var lightBound = _tempLightBound;
            var viewPos = _tempVector30$4;
            var forward = _tempVector31$4;
            var viewConeCap = _tempVector34$1;
            var position = spotLight.owner._transform.position;
            var range = spotLight.range;
            spotLight.owner._transform.worldMatrix.getForward(forward);
            Laya.Vector3.normalize(forward, forward);
            Laya.Vector3.scale(forward, range, viewConeCap);
            Laya.Vector3.add(position, viewConeCap, viewConeCap);
            Laya.Vector3.transformV3ToV3(position, viewMat, viewPos);
            Laya.Vector3.transformV3ToV3(viewConeCap, viewMat, viewConeCap);
            viewPos.z *= -1;
            viewConeCap.z *= -1;
            var halfAngle = (spotLight.spotAngle / 2) * Math.PI / 180;
            if (!this._shrinkSpotLightZPerspective(near, far, viewPos, viewConeCap, range, halfAngle, lightBound))
                return;
            if (!this._shrinkXYByRadiusPerspective(viewPos, range, lightBound, xPlanes, yPlanes))
                return;
            var viewFor = _tempVector33$1;
            viewFor.x = viewConeCap.x - viewPos.x, viewFor.y = viewConeCap.y - viewPos.y, viewFor.z = viewConeCap.z - viewPos.z;
            Laya.Vector3.normalize(viewFor, viewFor);
            this._shrinkSpotXYByConePerspective(viewPos, viewFor, range, halfAngle, lightBound, xPlanes, yPlanes);
            this._placeSpotLightToClusters(lightIndex, lightBound);
        }
        _updatePointLightOrth(halfX, halfY, near, far, viewMat, pointLight, lightIndex) {
            var lightBound = _tempLightBound;
            var lightviewPos = _tempVector30$4;
            Laya.Vector3.transformV3ToV3(pointLight.owner._transform.position, viewMat, lightviewPos);
            lightviewPos.z *= -1;
            if (!this._shrinkSphereLightByBoundOrth(halfX, halfY, near, far, lightviewPos, pointLight.range, lightBound))
                return;
            this._placePointLightToClusters(lightIndex, lightBound);
        }
        _updateSpotLightOrth(halfX, halfY, near, far, viewMat, spotLight, lightIndex) {
            var lightBound = _tempLightBound;
            var viewPos = _tempVector30$4;
            var forward = _tempVector31$4;
            var viewConeCap = _tempVector34$1;
            var position = spotLight.owner._transform.position;
            var range = spotLight.range;
            spotLight.owner._transform.worldMatrix.getForward(forward);
            Laya.Vector3.normalize(forward, forward);
            Laya.Vector3.scale(forward, range, viewConeCap);
            Laya.Vector3.add(position, viewConeCap, viewConeCap);
            Laya.Vector3.transformV3ToV3(position, viewMat, viewPos);
            Laya.Vector3.transformV3ToV3(viewConeCap, viewMat, viewConeCap);
            viewPos.z *= -1;
            viewConeCap.z *= -1;
            var halfAngle = (spotLight.spotAngle / 2) * Math.PI / 180;
            if (!this._shrinkSpotLightByBoundOrth(halfX, halfY, near, far, viewPos, viewConeCap, range, halfAngle, lightBound))
                return;
            this._placeSpotLightToClusters(lightIndex, lightBound);
        }
        update(camera, scene) {
            this._updateMark++;
            var camNear = camera.nearPlane;
            this._depthSliceParam.x = Laya.Config3D.lightClusterCount.z / Math.log2(camera.farPlane / camNear);
            this._depthSliceParam.y = Math.log2(camNear) * this._depthSliceParam.x;
            var near = camera.nearPlane;
            var far = camera.farPlane;
            var viewMat = camera.viewMatrix;
            var curCount = scene._directionLights._length;
            var pointLights = scene._pointLights;
            var poiCount = pointLights._length;
            var poiElements = pointLights._elements;
            var spotLights = scene._spotLights;
            var spoCount = spotLights._length;
            var spoElements = spotLights._elements;
            if (camera.orthographic) {
                var halfY = camera.orthographicVerticalSize / 2.0;
                var halfX = halfY * camera.aspectRatio;
                for (var i = 0; i < poiCount; i++, curCount++)
                    this._updatePointLightOrth(halfX, halfY, near, far, viewMat, poiElements[i], curCount);
                for (var i = 0; i < spoCount; i++, curCount++)
                    this._updateSpotLightOrth(halfX, halfY, near, far, viewMat, spoElements[i], curCount);
            }
            else {
                camera._updateClusterPlaneXY();
                var xPlanes = camera._clusterXPlanes;
                var yPlanes = camera._clusterYPlanes;
                for (var i = 0; i < poiCount; i++, curCount++)
                    this._updatePointLightPerspective(near, far, viewMat, poiElements[i], curCount, xPlanes, yPlanes);
                for (var i = 0; i < spoCount; i++, curCount++)
                    this._updateSpotLightPerspective(near, far, viewMat, spoElements[i], curCount, xPlanes, yPlanes);
            }
            if (poiCount + spoCount > 0) {
                var xSlices = this._xSlices, ySlices = this._ySlices, zSlices = this._zSlices;
                var widthFloat = xSlices * ySlices * 4;
                var lightOff = widthFloat * zSlices;
                var clusterPixels = this._clusterPixels;
                var clusterPixelsCount = clusterPixels.length;
                var clusterDatas = this._clusterDatas;
                var updateMark = this._updateMark;
                var freeSpace = true;
                for (var z = 0; z < zSlices; z++) {
                    for (var y = 0; y < ySlices; y++) {
                        for (var x = 0; x < xSlices; x++) {
                            var data = clusterDatas[z][y][x];
                            var clusterOff = (x + y * xSlices + z * xSlices * ySlices) * 4;
                            if (data.updateMark !== updateMark) {
                                clusterPixels[clusterOff] = 0;
                                clusterPixels[clusterOff + 1] = 0;
                            }
                            else {
                                if (freeSpace) {
                                    var indices = data.indices;
                                    var pCount = data.pointLightCount;
                                    var sCount = data.spotLightCount;
                                    var count = pCount + sCount;
                                    if (lightOff + count < clusterPixelsCount) {
                                        clusterPixels[clusterOff] = pCount;
                                        clusterPixels[clusterOff + 1] = sCount;
                                        clusterPixels[clusterOff + 2] = Math.floor(lightOff / widthFloat);
                                        clusterPixels[clusterOff + 3] = lightOff % widthFloat;
                                        for (var i = 0; i < count; i++)
                                            clusterPixels[lightOff++] = indices[i];
                                    }
                                    else {
                                        count = clusterPixelsCount - (lightOff + count);
                                        pCount = Math.min(pCount, count);
                                        clusterPixels[clusterOff] = pCount;
                                        clusterPixels[clusterOff + 1] = Math.min(sCount, count - pCount);
                                        clusterPixels[clusterOff + 2] = Math.floor(lightOff / widthFloat);
                                        clusterPixels[clusterOff + 3] = lightOff % widthFloat;
                                        for (var i = 0; i < count; i++)
                                            clusterPixels[lightOff++] = indices[i];
                                        freeSpace = false;
                                    }
                                }
                            }
                        }
                    }
                }
                var width = this._clusterTexture.width;
                this._clusterTexture.setSubPixelsData(0, 0, width, Math.ceil(lightOff / (4 * width)), clusterPixels, 0, false, false, false);
            }
        }
    }
    const _tempVector30$4 = new Laya.Vector3();
    const _tempVector31$4 = new Laya.Vector3();
    const _tempVector32$1 = new Laya.Vector3();
    const _tempVector33$1 = new Laya.Vector3();
    const _tempVector34$1 = new Laya.Vector3();
    new Laya.Vector3();
    const _tempVector36 = new Laya.Vector3();
    const _tempVector37 = new Laya.Vector3();
    const _tempLightBound = new LightBound();

    class PhysicsSettings {
        constructor() {
            this.flags = 0;
            this.maxSubSteps = 1;
            this.fixedTimeStep = 1.0 / 60.0;
            this.enableCCD = false;
            this.ccdThreshold = 0.0001;
            this.ccdSphereRadius = 0.0001;
        }
    }

    class Transform3D extends Laya.EventDispatcher {
        get isDefaultMatrix() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX)) {
                this.localMatrix;
            }
            return this._isDefaultMatrix;
        }
        get _isFrontFaceInvert() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                var scale = this.getWorldLossyScale();
                var isInvert = scale.x < 0;
                (scale.y < 0) && (isInvert = !isInvert);
                (scale.z < 0) && (isInvert = !isInvert);
                this._faceInvert = isInvert;
                this._frontFaceValue = this._faceInvert ? -1 : 1;
            }
            return this._faceInvert;
        }
        getFrontFaceValue() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._isFrontFaceInvert;
            }
            return this._frontFaceValue;
        }
        get owner() {
            return this._owner;
        }
        get worldNeedUpdate() {
            return this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX);
        }
        get localPositionX() {
            return this._localPosition.x;
        }
        set localPositionX(x) {
            this._localPosition.x = x;
            this.localPosition = this._localPosition;
        }
        get localPositionY() {
            return this._localPosition.y;
        }
        set localPositionY(y) {
            this._localPosition.y = y;
            this.localPosition = this._localPosition;
        }
        get localPositionZ() {
            return this._localPosition.z;
        }
        set localPositionZ(z) {
            this._localPosition.z = z;
            this.localPosition = this._localPosition;
        }
        get localPosition() {
            return this._localPosition;
        }
        set localPosition(value) {
            if (this._localPosition !== value)
                value.cloneTo(this._localPosition);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._onWorldPositionTransform();
        }
        get localRotationX() {
            return this.localRotation.x;
        }
        set localRotationX(x) {
            let rot = this.localRotation;
            rot.x = x;
            this.localRotation = rot;
        }
        get localRotationY() {
            return this.localRotation.y;
        }
        set localRotationY(y) {
            let rot = this.localRotation;
            rot.y = y;
            this.localRotation = rot;
        }
        get localRotationZ() {
            return this.localRotation.z;
        }
        set localRotationZ(z) {
            let rot = this.localRotation;
            rot.z = z;
            this.localRotation = rot;
        }
        get localRotationW() {
            return this.localRotation.w;
        }
        set localRotationW(w) {
            let rot = this.localRotation;
            rot.w = w;
            this.localRotation = rot;
        }
        get localRotation() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION)) {
                var eulerE = this._localRotationEuler;
                Laya.Quaternion.createFromYawPitchRoll(eulerE.y / Transform3D._angleToRandin, eulerE.x / Transform3D._angleToRandin, eulerE.z / Transform3D._angleToRandin, this._localRotation);
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, false);
            }
            return this._localRotation;
        }
        set localRotation(value) {
            if (this._localRotation !== value)
                value.cloneTo(this._localRotation);
            this._localRotation.normalize(this._localRotation);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION, false);
            this._onWorldRotationTransform();
        }
        get localScaleX() {
            return this._localScale.x;
        }
        set localScaleX(value) {
            this._localScale.x = value;
            this.localScale = this._localScale;
        }
        get localScaleY() {
            return this._localScale.y;
        }
        set localScaleY(value) {
            this._localScale.y = value;
            this.localScale = this._localScale;
        }
        get localScaleZ() {
            return this._localScale.z;
        }
        set localScaleZ(value) {
            this._localScale.z = value;
            this.localScale = this._localScale;
        }
        get localScale() {
            return this._localScale;
        }
        set localScale(value) {
            if (this._localScale !== value)
                value.cloneTo(this._localScale);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._onWorldScaleTransform();
        }
        get localRotationEulerX() {
            return this.localRotationEuler.x;
        }
        set localRotationEulerX(value) {
            let rot = this.localRotationEuler;
            rot.x = value;
            this.localRotationEuler = rot;
        }
        get localRotationEulerY() {
            return this.localRotationEuler.y;
        }
        set localRotationEulerY(value) {
            let rot = this.localRotationEuler;
            rot.y = value;
            this.localRotationEuler = rot;
        }
        get localRotationEulerZ() {
            return this.localRotationEuler.z;
        }
        set localRotationEulerZ(value) {
            let rot = this.localRotationEuler;
            rot.z = value;
            this.localRotationEuler = rot;
        }
        get localRotationEuler() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALEULER)) {
                this._localRotation.getYawPitchRoll(_tempVector30$3);
                var euler = _tempVector30$3;
                var localRotationEuler = this._localRotationEuler;
                localRotationEuler.x = euler.y * Transform3D._angleToRandin;
                localRotationEuler.y = euler.x * Transform3D._angleToRandin;
                localRotationEuler.z = euler.z * Transform3D._angleToRandin;
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, false);
            }
            return this._localRotationEuler;
        }
        set localRotationEuler(value) {
            if (this._localRotationEuler !== value)
                value.cloneTo(this._localRotationEuler);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, false);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALMATRIX, true);
            this._onWorldRotationTransform();
        }
        get localMatrix() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX)) {
                Laya.Matrix4x4.createAffineTransformation(this._localPosition, this.localRotation, this._localScale, this._localMatrix);
                this._isDefaultMatrix = this._localMatrix.isIdentity();
                this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, false);
            }
            return this._localMatrix;
        }
        set localMatrix(value) {
            if (this._localMatrix !== value)
                value.cloneTo(this._localMatrix);
            this._isDefaultMatrix = this._localMatrix.isIdentity();
            this._localMatrix.decomposeTransRotScale(this._localPosition, this._localRotation, this._localScale);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALEULER, true);
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALMATRIX, false);
            this._onWorldTransform();
        }
        get position() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                if (this._parent != null) {
                    var worldMatE = this.worldMatrix.elements;
                    this._position.x = worldMatE[12];
                    this._position.y = worldMatE[13];
                    this._position.z = worldMatE[14];
                }
                else {
                    this._localPosition.cloneTo(this._position);
                }
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
            }
            return this._position;
        }
        set position(value) {
            if (this._parent != null) {
                var parentInvMat = _tempMatrix0$1;
                this._parent.worldMatrix.invert(parentInvMat);
                Laya.Vector3.transformCoordinate(value, parentInvMat, this._localPosition);
            }
            else {
                value.cloneTo(this._localPosition);
            }
            this.localPosition = this._localPosition;
            if (this._position !== value)
                value.cloneTo(this._position);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION, false);
        }
        get rotation() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION)) {
                if (this._parent != null)
                    Laya.Quaternion.multiply(this._parent.rotation, this.localRotation, this._rotation);
                else
                    this.localRotation.cloneTo(this._rotation);
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
            }
            return this._rotation;
        }
        set rotation(value) {
            if (this._parent != null) {
                this._parent.rotation.invert(_tempQuaternion0);
                Laya.Quaternion.multiply(_tempQuaternion0, value, this._localRotation);
            }
            else {
                value.cloneTo(this._localRotation);
            }
            this.localRotation = this._localRotation;
            if (value !== this._rotation)
                value.cloneTo(this._rotation);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION, false);
        }
        get rotationEuler() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                this.rotation.getYawPitchRoll(_tempVector30$3);
                var eulerE = _tempVector30$3;
                var rotationEulerE = this._rotationEuler;
                rotationEulerE.x = eulerE.y * Transform3D._angleToRandin;
                rotationEulerE.y = eulerE.x * Transform3D._angleToRandin;
                rotationEulerE.z = eulerE.z * Transform3D._angleToRandin;
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, false);
            }
            return this._rotationEuler;
        }
        set rotationEuler(value) {
            Laya.Quaternion.createFromYawPitchRoll(value.y / Transform3D._angleToRandin, value.x / Transform3D._angleToRandin, value.z / Transform3D._angleToRandin, this._rotation);
            this.rotation = this._rotation;
            if (this._rotationEuler !== value)
                value.cloneTo(this._rotationEuler);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDEULER, false);
        }
        get worldMatrix() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX)) {
                if (this._parent != null) {
                    let effectiveTrans = this._parent;
                    while (effectiveTrans._parent && effectiveTrans.isDefaultMatrix) {
                        effectiveTrans = effectiveTrans._parent;
                    }
                    Laya.Matrix4x4.multiply(effectiveTrans.worldMatrix, this.localMatrix, this._worldMatrix);
                }
                else
                    this.localMatrix.cloneTo(this._worldMatrix);
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, false);
            }
            return this._worldMatrix;
        }
        set worldMatrix(value) {
            if (this._parent === null) {
                value.cloneTo(this._localMatrix);
            }
            else {
                this._parent.worldMatrix.invert(this._localMatrix);
                Laya.Matrix4x4.multiply(this._localMatrix, value, this._localMatrix);
            }
            this.localMatrix = this._localMatrix;
            if (this._worldMatrix !== value)
                value.cloneTo(this._worldMatrix);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX, false);
        }
        constructor(owner) {
            super();
            this._localPosition = new Laya.Vector3(0, 0, 0);
            this._localRotation = new Laya.Quaternion(0, 0, 0, 1);
            this._localScale = new Laya.Vector3(1, 1, 1);
            this._localRotationEuler = new Laya.Vector3(0, 0, 0);
            this._localMatrix = new Laya.Matrix4x4();
            this._position = new Laya.Vector3(0, 0, 0);
            this._rotation = new Laya.Quaternion(0, 0, 0, 1);
            this._scale = new Laya.Vector3(1, 1, 1);
            this._rotationEuler = new Laya.Vector3(0, 0, 0);
            this._worldMatrix = new Laya.Matrix4x4();
            this._children = null;
            this._isDefaultMatrix = false;
            this._faceInvert = false;
            this._frontFaceValue = 1;
            this._parent = null;
            this._transformFlag = 0;
            this._owner = owner;
            this._children = [];
            this._initProperty();
        }
        _initProperty() {
            this._setTransformFlag(Transform3D.TRANSFORM_LOCALQUATERNION | Transform3D.TRANSFORM_LOCALEULER | Transform3D.TRANSFORM_LOCALMATRIX, false);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE | Transform3D.TRANSFORM_WORLDMATRIX, true);
        }
        _getScaleMatrix() {
            var invRotation = _tempQuaternion0;
            var invRotationMat = _tempMatrix3x30;
            var worldRotScaMat = _tempMatrix3x31;
            var scaMat = _tempMatrix3x32;
            Laya.Matrix3x3.createFromMatrix4x4(this.worldMatrix, worldRotScaMat);
            this.rotation.invert(invRotation);
            Laya.Matrix3x3.createRotationQuaternion(invRotation, invRotationMat);
            Laya.Matrix3x3.multiply(invRotationMat, worldRotScaMat, scaMat);
            return scaMat;
        }
        _setTransformFlag(type, value) {
            if (value)
                this._transformFlag |= type;
            else
                this._transformFlag &= ~type;
        }
        _getTransformFlag(type) {
            return (this._transformFlag & type) != 0;
        }
        _setParent(value) {
            if (this._parent !== value) {
                if (this._parent) {
                    var parentChilds = this._parent._children;
                    var index = parentChilds.indexOf(this);
                    parentChilds.splice(index, 1);
                }
                if (value) {
                    value._children.push(this);
                    (value) && (this._onWorldTransform());
                }
                this._parent = value;
            }
        }
        _onWorldPositionRotationTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionRotationTransform();
        }
        _onWorldPositionScaleTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDSCALE, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionScaleTransform();
        }
        _onWorldPositionTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionTransform();
        }
        _onWorldRotationTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionRotationTransform();
        }
        _onWorldScaleTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDSCALE, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldPositionScaleTransform();
        }
        _onWorldTransform() {
            if (!this._getTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDPOSITION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDQUATERNION) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDEULER) || !this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDMATRIX | Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDEULER | Transform3D.TRANSFORM_WORLDSCALE, true);
                this.event(Laya.Event.TRANSFORM_CHANGED, this._transformFlag);
            }
            for (var i = 0, n = this._children.length; i < n; i++)
                this._children[i]._onWorldTransform();
        }
        translate(translation, isLocal = true) {
            if (isLocal) {
                Laya.Matrix4x4.createFromQuaternion(this.localRotation, _tempMatrix0$1);
                Laya.Vector3.transformCoordinate(translation, _tempMatrix0$1, _tempVector30$3);
                Laya.Vector3.add(this.localPosition, _tempVector30$3, this._localPosition);
                this.localPosition = this._localPosition;
            }
            else {
                Laya.Vector3.add(this.position, translation, this._position);
                this.position = this._position;
            }
        }
        rotate(rotation, isLocal = true, isRadian = true) {
            var rot;
            if (isRadian) {
                rot = rotation;
            }
            else {
                Laya.Vector3.scale(rotation, Math.PI / 180.0, _tempVector30$3);
                rot = _tempVector30$3;
            }
            Laya.Quaternion.createFromYawPitchRoll(rot.y, rot.x, rot.z, _tempQuaternion0);
            if (isLocal) {
                Laya.Quaternion.multiply(this.localRotation, _tempQuaternion0, this._localRotation);
                this.localRotation = this._localRotation;
            }
            else {
                Laya.Quaternion.multiply(_tempQuaternion0, this.rotation, this._rotation);
                this.rotation = this._rotation;
            }
        }
        getForward(forward) {
            var worldMatElem = this.worldMatrix.elements;
            forward.x = -worldMatElem[8];
            forward.y = -worldMatElem[9];
            forward.z = -worldMatElem[10];
        }
        getUp(up) {
            var worldMatElem = this.worldMatrix.elements;
            up.x = worldMatElem[4];
            up.y = worldMatElem[5];
            up.z = worldMatElem[6];
        }
        getRight(right) {
            var worldMatElem = this.worldMatrix.elements;
            right.x = worldMatElem[0];
            right.y = worldMatElem[1];
            right.z = worldMatElem[2];
        }
        lookAt(target, up, isLocal = false, isCamera = true) {
            var eye;
            if (isLocal) {
                eye = this.localPosition;
                if (Math.abs(eye.x - target.x) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < Laya.MathUtils3D.zeroTolerance)
                    return;
                if (isCamera) {
                    Laya.Quaternion.lookAt(this.localPosition, target, up, this._localRotation);
                    this._localRotation.invert(this._localRotation);
                }
                else {
                    Laya.Vector3.subtract(this.localPosition, target, _tempVector30$3);
                    Laya.Quaternion.rotationLookAt(_tempVector30$3, up, this._localRotation);
                    this._localRotation.invert(this._localRotation);
                }
                this.localRotation = this._localRotation;
            }
            else {
                var worldPosition = this.position;
                eye = worldPosition;
                if (Math.abs(eye.x - target.x) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.y - target.y) < Laya.MathUtils3D.zeroTolerance && Math.abs(eye.z - target.z) < Laya.MathUtils3D.zeroTolerance)
                    return;
                if (isCamera) {
                    Laya.Quaternion.lookAt(worldPosition, target, up, this._rotation);
                    this._rotation.invert(this._rotation);
                }
                else {
                    Laya.Vector3.subtract(this.position, target, _tempVector30$3);
                    Laya.Quaternion.rotationLookAt(_tempVector30$3, up, this._rotation);
                    this._rotation.invert(this._rotation);
                }
                this.rotation = this._rotation;
            }
        }
        objLookat(target, up, isLocal = false) {
            this.lookAt(target, up, isLocal, false);
        }
        getWorldLossyScale() {
            if (this._getTransformFlag(Transform3D.TRANSFORM_WORLDSCALE)) {
                if (this._parent !== null) {
                    var scaMatE = this._getScaleMatrix().elements;
                    this._scale.x = scaMatE[0];
                    this._scale.y = scaMatE[4];
                    this._scale.z = scaMatE[8];
                }
                else {
                    this._localScale.cloneTo(this._scale);
                }
                this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
            }
            return this._scale;
        }
        setWorldLossyScale(value) {
            if (this._parent !== null) {
                var scaleMat = _tempMatrix3x33;
                var localScaleMat = _tempMatrix3x33;
                var localScaleMatE = localScaleMat.elements;
                var parInvScaleMat = this._parent._getScaleMatrix();
                parInvScaleMat.invert(parInvScaleMat);
                Laya.Matrix3x3.createFromScaling(value, scaleMat);
                Laya.Matrix3x3.multiply(parInvScaleMat, scaleMat, localScaleMat);
                this._localScale.x = localScaleMatE[0];
                this._localScale.y = localScaleMatE[4];
                this._localScale.z = localScaleMatE[8];
            }
            else {
                value.cloneTo(this._localScale);
            }
            this.localScale = this._localScale;
            if (this._scale !== value)
                value.cloneTo(this._scale);
            this._setTransformFlag(Transform3D.TRANSFORM_WORLDSCALE, false);
        }
        localToGlobal(value, out) {
            Laya.Vector3.transformV3ToV3(value, this.worldMatrix, out);
        }
        globalToLocal(pos, out) {
            this.worldMatrix.invert(_tempMatrix0$1);
            Laya.Vector3.transformV3ToV3(pos, _tempMatrix0$1, out);
        }
        toLocalNormal(pos, out) {
            this.worldMatrix.invert(_tempMatrix0$1);
            Laya.Vector3.TransformNormal(pos, _tempMatrix0$1, out);
        }
        toDir(forward, dir) {
            this.rotationTo(this.rotation, forward, dir);
            this.rotation = this.rotation;
        }
        rotationTo(out, a, b) {
            var dot = Laya.Vector3.dot(a, b);
            if (dot < -0.999999) {
                Laya.Vector3.cross(Laya.Vector3.UnitX, a, tmpVec3);
                if (Laya.Vector3.scalarLength(tmpVec3) < 0.000001)
                    Laya.Vector3.cross(Laya.Vector3.UnitY, a, tmpVec3);
                Laya.Vector3.normalize(tmpVec3, tmpVec3);
                Laya.Quaternion.createFromAxisAngle(tmpVec3, Math.PI, out);
                return true;
            }
            else if (dot > 0.999999) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return false;
            }
            else {
                Laya.Vector3.cross(a, b, tmpVec3);
                out.x = tmpVec3.x;
                out.y = tmpVec3.y;
                out.z = tmpVec3.z;
                out.w = 1 + dot;
                out.normalize(out);
                return true;
            }
        }
        get scale() {
            console.warn("Transfrm3D: discard function,please use getWorldLossyScale instead.");
            return this.getWorldLossyScale();
        }
        set scale(value) {
            console.warn("Transfrm3D: discard function,please use setWorldLossyScale instead.");
            this.setWorldLossyScale(value);
        }
    }
    Transform3D.TRANSFORM_LOCALQUATERNION = 0x01;
    Transform3D.TRANSFORM_LOCALEULER = 0x02;
    Transform3D.TRANSFORM_LOCALMATRIX = 0x04;
    Transform3D.TRANSFORM_WORLDPOSITION = 0x08;
    Transform3D.TRANSFORM_WORLDQUATERNION = 0x10;
    Transform3D.TRANSFORM_WORLDSCALE = 0x20;
    Transform3D.TRANSFORM_WORLDMATRIX = 0x40;
    Transform3D.TRANSFORM_WORLDEULER = 0x80;
    Transform3D.TRANSFORM_LOCALPOS = 0x100;
    Transform3D.TRANSFORM_LOCALSCALE = 0x200;
    Transform3D._angleToRandin = 180 / Math.PI;
    const _tempVector30$3 = new Laya.Vector3();
    const _tempQuaternion0 = new Laya.Quaternion();
    const _tempMatrix0$1 = new Laya.Matrix4x4();
    const _tempMatrix3x30 = new Laya.Matrix3x3();
    const _tempMatrix3x31 = new Laya.Matrix3x3();
    const _tempMatrix3x32 = new Laya.Matrix3x3();
    const _tempMatrix3x33 = new Laya.Matrix3x3();
    const tmpVec3 = new Laya.Vector3();

    class GeometryElement {
        set bufferState(value) {
            this._geometryElementOBj.bufferState = value._deviceBufferState;
            this._bufferState = value;
        }
        get bufferState() {
            return this._bufferState;
        }
        set mode(value) {
            this._geometryElementOBj.mode = value;
        }
        get mode() {
            return this._geometryElementOBj.mode;
        }
        set drawType(value) {
            this._geometryElementOBj.drawType = value;
        }
        get drawType() {
            return this._geometryElementOBj.drawType;
        }
        setDrawArrayParams(first, count) {
            this._geometryElementOBj.setDrawArrayParams(first, count);
        }
        setDrawElemenParams(count, offset) {
            this._geometryElementOBj.setDrawElemenParams(count, offset);
        }
        set instanceCount(value) {
            this._geometryElementOBj.instanceCount = value;
        }
        get instanceCount() {
            return this._geometryElementOBj.instanceCount;
        }
        set indexFormat(value) {
            this._geometryElementOBj.indexFormat = value;
        }
        get indexFormat() {
            return this._geometryElementOBj.indexFormat;
        }
        get destroyed() {
            return this._destroyed;
        }
        constructor(mode, drawType) {
            this._destroyed = false;
            this._geometryElementOBj = Laya.LayaGL.renderDeviceFactory.createRenderGeometryElement(mode, drawType);
            this._id = ++GeometryElement._uniqueIDCounter;
        }
        _getType() {
            throw new Error("GeometryElement:must override it.");
        }
        _prepareRender(state) {
            return true;
        }
        _updateRenderParams(state) {
            throw new Error("GeometryElement:must override it.");
        }
        destroy() {
            if (this._destroyed)
                return;
            this._destroyed = true;
            this._geometryElementOBj.destroy();
        }
        clearRenderParams() {
            this._geometryElementOBj.clearRenderParams();
        }
    }
    GeometryElement._uniqueIDCounter = 0;
    GeometryElement._typeCounter = 0;

    class SkyBox extends GeometryElement {
        static __init__() {
            SkyBox.instance = new SkyBox();
        }
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            var halfHeight = 1.0;
            var halfWidth = 1.0;
            var halfDepth = 1.0;
            var vertices = new Float32Array([-halfDepth, halfHeight, -halfWidth, halfDepth, halfHeight, -halfWidth, halfDepth, halfHeight, halfWidth, -halfDepth, halfHeight, halfWidth,
                -halfDepth, -halfHeight, -halfWidth, halfDepth, -halfHeight, -halfWidth, halfDepth, -halfHeight, halfWidth, -halfDepth, -halfHeight, halfWidth]);
            var indices = new Uint16Array([
                0, 2, 1, 2, 0, 3,
                4, 6, 7, 6, 4, 5,
                0, 7, 3, 7, 0, 4,
                1, 6, 5, 6, 1, 2,
                3, 6, 2, 6, 3, 7,
                0, 5, 4, 5, 0, 1
            ]);
            var verDec = Laya.VertexMesh.getVertexDeclaration("POSITION");
            let vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(verDec.vertexStride * 8, Laya.BufferUsage.Static, false);
            vertexBuffer.vertexDeclaration = verDec;
            let indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, 36, Laya.BufferUsage.Static, false);
            vertexBuffer.setData(vertices);
            indexBuffer.setData(indices);
            this.bufferState = new Laya.BufferState();
            this.bufferState.applyState([vertexBuffer], indexBuffer);
            this._geometryElementOBj.setDrawElemenParams(36, 0);
            this.indexFormat = Laya.IndexFormat.UInt16;
        }
        _updateRenderParams(state) {
        }
    }

    class VertexPositionTexture {
        static get vertexDeclaration() {
            return VertexPositionTexture._vertexDeclaration;
        }
        static __init__() {
            VertexPositionTexture._vertexDeclaration = new Laya.VertexDeclaration(20, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector3, Laya.VertexMesh.MESH_POSITION0),
                new Laya.VertexElement(12, Laya.VertexElementFormat.Vector2, Laya.VertexMesh.MESH_TEXTURECOORDINATE0)]);
        }
        get position() {
            return this._position;
        }
        get textureCoordinate0() {
            return this._textureCoordinate0;
        }
        get vertexDeclaration() {
            return VertexPositionTexture._vertexDeclaration;
        }
        constructor(position, textureCoordinate0) {
            this._position = position;
            this._textureCoordinate0 = textureCoordinate0;
        }
    }

    class SkyDome extends GeometryElement {
        static __init__() {
            SkyDome.instance = new SkyDome();
        }
        get stacks() {
            return this._stacks;
        }
        get slices() {
            return this._slices;
        }
        constructor(stacks = 48, slices = 48) {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this._stacks = stacks;
            this._slices = slices;
            var vertexDeclaration = VertexPositionTexture.vertexDeclaration;
            var vertexFloatCount = vertexDeclaration.vertexStride / 4;
            var numberVertices = (this._stacks + 1) * (this._slices + 1);
            var numberIndices = (3 * this._stacks * (this._slices + 1)) * 2;
            var vertices = new Float32Array(numberVertices * vertexFloatCount);
            var indices = new Uint16Array(numberIndices);
            var stackAngle = Math.PI / this._stacks;
            var sliceAngle = (Math.PI * 2.0) / this._slices;
            var vertexIndex = 0;
            var vertexCount = 0;
            var indexCount = 0;
            for (var stack = 0; stack < (this._stacks + 1); stack++) {
                var r = Math.sin(stack * stackAngle);
                var y = Math.cos(stack * stackAngle);
                for (var slice = 0; slice < (this._slices + 1); slice++) {
                    var x = r * Math.sin(slice * sliceAngle);
                    var z = r * Math.cos(slice * sliceAngle);
                    vertices[vertexCount + 0] = x * SkyDome._radius;
                    vertices[vertexCount + 1] = y * SkyDome._radius;
                    vertices[vertexCount + 2] = z * SkyDome._radius;
                    vertices[vertexCount + 3] = -(slice / this._slices) + 0.75;
                    vertices[vertexCount + 4] = stack / this._stacks;
                    vertexCount += vertexFloatCount;
                    if (stack != (this._stacks - 1)) {
                        indices[indexCount++] = vertexIndex + 1;
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + (this._slices + 1);
                        indices[indexCount++] = vertexIndex + (this._slices + 1);
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + (this._slices);
                        vertexIndex++;
                    }
                }
            }
            let vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vertices.length * 4, Laya.BufferUsage.Static, false);
            vertexBuffer.vertexDeclaration = vertexDeclaration;
            let indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, indices.length, Laya.BufferUsage.Static, false);
            vertexBuffer.setData(vertices.buffer);
            indexBuffer.setData(indices);
            var bufferState = new Laya.BufferState();
            bufferState.applyState([vertexBuffer], indexBuffer);
            this.bufferState = bufferState;
            this.indexFormat = Laya.IndexFormat.UInt16;
            this._geometryElementOBj.setDrawElemenParams(indexBuffer.indexCount, 0);
        }
        _updateRenderParams(state) {
        }
    }
    SkyDome._radius = 1;

    class SkyRenderer {
        static __init__() {
            SkyRenderer.SUNLIGHTDIRECTION = Laya.Shader3D.propertyNameToID("u_SunLight_direction");
            SkyRenderer.SUNLIGHTDIRCOLOR = Laya.Shader3D.propertyNameToID("u_SunLight_color");
            SkyRenderer.SKYVIEWMATRIX = Laya.Shader3D.propertyNameToID("u_SkyViewMat");
            SkyRenderer.SKYPROJECTIONMATRIX = Laya.Shader3D.propertyNameToID("u_SkyProjectionMat");
            SkyRenderer.SKYPROJECTIONVIEWMATRIX = Laya.Shader3D.propertyNameToID("u_SkyProjectionViewMat");
            const commandUniform = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("SkyRenderer");
            commandUniform.addShaderUniform(SkyRenderer.SUNLIGHTDIRECTION, "u_SunLight_direction", exports.ShaderDataType.Vector3);
            commandUniform.addShaderUniform(SkyRenderer.SUNLIGHTDIRCOLOR, "u_SunLight_color", exports.ShaderDataType.Color);
            commandUniform.addShaderUniform(SkyRenderer.SKYVIEWMATRIX, "u_SkyViewMat", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(SkyRenderer.SKYPROJECTIONMATRIX, "u_SkyProjectionMat", exports.ShaderDataType.Matrix4x4);
            commandUniform.addShaderUniform(SkyRenderer.SKYPROJECTIONVIEWMATRIX, "u_SkyProjectionViewMat", exports.ShaderDataType.Matrix4x4);
        }
        get material() {
            return this._material;
        }
        set material(value) {
            if (this._material !== value) {
                (this._material) && (this._material._removeReference());
                this._material = value;
                this._cacheRenderElement && (this._cacheRenderElement.material = value);
                if (value) {
                    value._addReference();
                }
            }
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(value) {
            if (this._mesh !== value) {
                this._mesh = value;
                this._cacheRenderElement && this._cacheRenderElement.setGeometry(this.mesh);
            }
        }
        get meshType() {
            return this.mesh == SkyBox.instance ? "box" : (this.mesh == SkyDome.instance ? "dome" : "");
        }
        set meshType(value) {
            if (value == "dome")
                this.mesh = SkyDome.instance;
            else
                this.mesh = SkyBox.instance;
        }
        constructor() {
            this.mesh = SkyDome.instance;
            this._renderData = new BaseRender();
            this._baseRenderNode = Laya3DRender.Render3DModuleDataFactory.createBaseRenderNode();
            this._baseRenderNode.transform = new Transform3D(null);
        }
        _isAvailable() {
            return this._material && this._mesh ? true : false;
        }
        renderUpdate(context) {
            let geomettry = this.mesh;
            this._renderGeometry = geomettry._prepareRender(context);
            geomettry._updateRenderParams(context);
        }
        setRenderElement(skyRenderElement) {
            if (!skyRenderElement)
                return;
            if (this._cacheRenderElement != skyRenderElement) {
                skyRenderElement.setGeometry(this.mesh);
                skyRenderElement.material = this._material;
                skyRenderElement.render = this._renderData;
                skyRenderElement._renderElementOBJ.isRender = this._renderGeometry;
                this._baseRenderNode.setRenderelements([skyRenderElement._renderElementOBJ]);
                this._baseRenderNode.setCommonUniformMap([
                    "Sprite3D",
                    "SkyRenderer"
                ]);
                this._cacheRenderElement = skyRenderElement;
            }
            else {
                skyRenderElement.setGeometry(this.mesh);
                skyRenderElement.material = this._material;
                skyRenderElement.render = this._renderData;
                skyRenderElement._renderElementOBJ.isRender = this._renderGeometry;
            }
        }
        destroy() {
            if (this._material) {
                this._material._removeReference();
                this._material = null;
            }
            this._renderData.destroy();
            this._cacheRenderElement = null;
            this._baseRenderNode.setRenderelements([]);
            this._baseRenderNode.destroy();
        }
    }

    const InvertYScaleMat = new Laya.Matrix4x4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    class SkyRenderElement extends RenderElement {
        constructor() {
            super();
            this._viewMatrix = new Laya.Matrix4x4();
            this._projectionMatrix = new Laya.Matrix4x4();
            this._projectViewMatrix = new Laya.Matrix4x4();
        }
        calculateViewMatrix(cameraViewMat) {
            cameraViewMat.cloneTo(this._viewMatrix);
            this._viewMatrix.setTranslationVector(Laya.Vector3.ZERO);
        }
        caluclateProjectionMatrix(cameraProjMat, aspectRatio, nearPlane, farPlane, fov, orthographic) {
            if (orthographic) {
                let halfWidth = 0.2;
                let halfHeight = halfWidth;
                Laya.Matrix4x4.createOrthoOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, nearPlane, farPlane, this._projectionMatrix);
            }
            else {
                cameraProjMat.cloneTo(this._projectionMatrix);
                let epsilon = 1e-6;
                let yScale = 1.0 / Math.tan(Math.PI * fov / 180 * 0.5);
                this._projectionMatrix.elements[0] = yScale / aspectRatio;
                this._projectionMatrix.elements[5] = yScale;
                this._projectionMatrix.elements[10] = epsilon - 1.0;
                this._projectionMatrix.elements[11] = -1.0;
                this._projectionMatrix.elements[14] = -0;
            }
        }
        renderpre(context) {
            if (context.invertY) {
                Laya.Matrix4x4.multiply(InvertYScaleMat, this._projectionMatrix, Laya.Matrix4x4.TEMP);
                Laya.Matrix4x4.multiply(Laya.Matrix4x4.TEMP, this._viewMatrix, tmpMatrix);
                this._renderElementOBJ.renderShaderData.setMatrix4x4(SkyRenderer.SKYPROJECTIONMATRIX, Laya.Matrix4x4.TEMP);
                this._renderElementOBJ.renderShaderData.setMatrix4x4(SkyRenderer.SKYPROJECTIONVIEWMATRIX, tmpMatrix);
            }
            else {
                Laya.Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectViewMatrix);
                this._renderElementOBJ.renderShaderData.setMatrix4x4(SkyRenderer.SKYPROJECTIONMATRIX, this._projectionMatrix);
                this._renderElementOBJ.renderShaderData.setMatrix4x4(SkyRenderer.SKYPROJECTIONVIEWMATRIX, this._projectViewMatrix);
            }
            this._renderElementOBJ.renderShaderData.setMatrix4x4(SkyRenderer.SKYVIEWMATRIX, this._viewMatrix);
            this._renderElementOBJ.renderShaderData.setColor(SkyRenderer.SUNLIGHTDIRCOLOR, context.scene._sunColor);
            this._renderElementOBJ.renderShaderData.setVector3(SkyRenderer.SUNLIGHTDIRECTION, context.scene._sundir);
        }
    }
    const tmpMatrix = new Laya.Matrix4x4();

    class BaseCamera extends Sprite3D {
        static shaderValueInit() {
            BaseCamera.SHADERDEFINE_DEPTH = Laya.Shader3D.getDefineByName("DEPTHMAP");
            BaseCamera.SHADERDEFINE_DEPTHNORMALS = Laya.Shader3D.getDefineByName("DEPTHNORMALSMAP");
            BaseCamera.SHADERDEFINE_ORTHOGRAPHIC = Laya.Shader3D.getDefineByName("CAMERAORTHOGRAPHIC");
            BaseCamera.SHADERDEFINE_FXAA = Laya.Shader3D.getDefineByName("FXAA");
            BaseCamera.CAMERAPOS = Laya.Shader3D.propertyNameToID("u_CameraPos");
            BaseCamera.VIEWMATRIX = Laya.Shader3D.propertyNameToID("u_View");
            BaseCamera.VIEWPROJECTMATRIX = Laya.Shader3D.propertyNameToID("u_ViewProjection");
            BaseCamera.PROJECTMATRIX = Laya.Shader3D.propertyNameToID("u_Projection");
            BaseCamera.CAMERADIRECTION = Laya.Shader3D.propertyNameToID("u_CameraDirection");
            BaseCamera.CAMERAUP = Laya.Shader3D.propertyNameToID("u_CameraUp");
            BaseCamera.VIEWPORT = Laya.Shader3D.propertyNameToID("u_Viewport");
            BaseCamera.PROJECTION_PARAMS = Laya.Shader3D.propertyNameToID("u_ProjectionParams");
            BaseCamera.DEPTHTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthTexture");
            BaseCamera.DEPTHNORMALSTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthNormalsTexture");
            BaseCamera.OPAQUETEXTURE = Laya.Shader3D.propertyNameToID("u_CameraOpaqueTexture");
            BaseCamera.OPAQUETEXTUREPARAMS = Laya.Shader3D.propertyNameToID("u_OpaqueTextureParams");
            BaseCamera.DEPTHZBUFFERPARAMS = Laya.Shader3D.propertyNameToID("u_ZBufferParams");
            let camerauniformMap = BaseCamera.cameraUniformMap = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap(BaseCamera.cameraBlockName);
            camerauniformMap.addShaderUniform(BaseCamera.CAMERAPOS, "u_CameraPos", exports.ShaderDataType.Vector3);
            camerauniformMap.addShaderUniform(BaseCamera.VIEWMATRIX, "u_View", exports.ShaderDataType.Matrix4x4);
            camerauniformMap.addShaderUniform(BaseCamera.PROJECTMATRIX, "u_Projection", exports.ShaderDataType.Matrix4x4);
            camerauniformMap.addShaderUniform(BaseCamera.VIEWPROJECTMATRIX, "u_ViewProjection", exports.ShaderDataType.Matrix4x4);
            camerauniformMap.addShaderUniform(BaseCamera.CAMERADIRECTION, "u_CameraDirection", exports.ShaderDataType.Vector3);
            camerauniformMap.addShaderUniform(BaseCamera.CAMERAUP, "u_CameraUp", exports.ShaderDataType.Vector3);
            camerauniformMap.addShaderUniform(BaseCamera.VIEWPORT, "u_Viewport", exports.ShaderDataType.Vector4);
            camerauniformMap.addShaderUniform(BaseCamera.PROJECTION_PARAMS, "u_ProjectionParams", exports.ShaderDataType.Vector4);
            camerauniformMap.addShaderUniform(BaseCamera.DEPTHTEXTURE, "u_CameraDepthTexture", exports.ShaderDataType.Texture2D);
            camerauniformMap.addShaderUniform(BaseCamera.DEPTHNORMALSTEXTURE, "u_CameraDepthNormalsTexture", exports.ShaderDataType.Texture2D);
            camerauniformMap.addShaderUniform(BaseCamera.OPAQUETEXTURE, "u_CameraOpaqueTexture", exports.ShaderDataType.Texture2D);
            camerauniformMap.addShaderUniform(BaseCamera.OPAQUETEXTUREPARAMS, "u_OpaqueTextureParams", exports.ShaderDataType.Vector4);
            camerauniformMap.addShaderUniform(BaseCamera.DEPTHZBUFFERPARAMS, "u_ZBufferParams", exports.ShaderDataType.Vector4);
        }
        static __init__() {
            BaseCamera.shaderValueInit();
        }
        get clearColor() {
            return this._clearColor;
        }
        set clearColor(value) {
            this._clearColor = value;
            value.toLinear(this._linearClearColor);
        }
        get skyRenderElement() {
            return this._skyRenderElement;
        }
        get fieldOfView() {
            return this._fieldOfView;
        }
        set fieldOfView(value) {
            this._fieldOfView = value;
            this._calculateProjectionMatrix();
            this._caculateMaxLocalYRange();
        }
        get maxlocalYDistance() {
            return this._yrange;
        }
        get nearPlane() {
            return this._nearPlane;
        }
        set nearPlane(value) {
            this._nearPlane = value;
            this._calculateProjectionMatrix();
        }
        get farPlane() {
            return this._farPlane;
        }
        set farPlane(vaule) {
            this._farPlane = vaule;
            this._calculateProjectionMatrix();
            this._caculateMaxLocalYRange();
        }
        get orthographic() {
            return this._orthographic;
        }
        set orthographic(vaule) {
            this._orthographic = vaule;
            this._calculateProjectionMatrix();
            if (vaule) {
                this._shaderValues.addDefine(BaseCamera.SHADERDEFINE_ORTHOGRAPHIC);
            }
            else
                this._shaderValues.removeDefine(BaseCamera.SHADERDEFINE_ORTHOGRAPHIC);
        }
        get orthographicVerticalSize() {
            return this._orthographicVerticalSize;
        }
        set orthographicVerticalSize(vaule) {
            this._orthographicVerticalSize = vaule;
            this._calculateProjectionMatrix();
        }
        get cullingMask() {
            return this._cullingMask;
        }
        set cullingMask(value) {
            this._cullingMask = value;
        }
        get renderingOrder() {
            return this._renderingOrder;
        }
        set renderingOrder(value) {
            this._renderingOrder = value;
            this._sortCamerasByRenderingOrder();
        }
        constructor(nearPlane = 0.3, farPlane = 1000) {
            super();
            this._forward = new Laya.Vector3();
            this._up = new Laya.Vector3();
            this._shaderValues = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
            this._linearClearColor = new Laya.Color();
            this.clearColor = new Laya.Color(100 / 255, 149 / 255, 237 / 255, 255 / 255);
            this._fieldOfView = 60;
            this._useUserProjectionMatrix = false;
            this._orthographicVerticalSize = 10;
            this.renderingOrder = 0;
            this._nearPlane = nearPlane;
            this._farPlane = farPlane;
            this.cullingMask = 2147483647;
            this.staticMask = 0xffffffff;
            this.useOcclusionCulling = true;
            this._renderEngine = Laya.LayaGL.renderEngine;
            this._orthographic = false;
            this._skyRenderElement = new SkyRenderElement();
        }
        _caculateMaxLocalYRange() {
            let halffield = 3.1416 * this.fieldOfView / 180.0 / 2;
            let dist = this.farPlane;
            this._yrange = Math.tan(halffield) * dist * 2;
        }
        _calculateProjectionMatrix() {
        }
        _onScreenSizeChanged() {
            this._calculateProjectionMatrix();
        }
        _sortCamerasByRenderingOrder() {
            if (this.displayedInStage) {
                var cameraPool = this.scene._cameraPool;
                var n = cameraPool.length - 1;
                for (var i = 0; i < n; i++) {
                    if (cameraPool[i].renderingOrder > cameraPool[n].renderingOrder) {
                        var tempCamera = cameraPool[i];
                        cameraPool[i] = cameraPool[n];
                        cameraPool[n] = tempCamera;
                    }
                }
            }
        }
        _prepareCameraToRender() {
            this.transform.getForward(this._forward);
            this.transform.getUp(this._up);
            this._shaderValues.setVector3(BaseCamera.CAMERAPOS, this.transform.position);
            this._shaderValues.setVector3(BaseCamera.CAMERADIRECTION, this._forward);
            this._shaderValues.setVector3(BaseCamera.CAMERAUP, this._up);
        }
        render(scene) {
        }
        addLayer(layer) {
            this.cullingMask |= Math.pow(2, layer);
        }
        removeLayer(layer) {
            this.cullingMask &= ~Math.pow(2, layer);
        }
        addAllLayers() {
            this.cullingMask = 2147483647;
        }
        removeAllLayers() {
            this.cullingMask = 0;
        }
        resetProjectionMatrix() {
            this._useUserProjectionMatrix = false;
            this._calculateProjectionMatrix();
        }
        _onActive() {
            this._scene._addCamera(this);
            super._onActive();
        }
        _onInActive() {
            this._scene._removeCamera(this);
            super._onInActive();
        }
        destroy(destroyChild = true) {
            this._skyRenderElement.destroy();
            this._skyRenderElement = null;
            Laya.ILaya.stage.off(Laya.Event.RESIZE, this, this._onScreenSizeChanged);
            super.destroy(destroyChild);
        }
    }
    BaseCamera.cameraBlockName = "BaseCamera";
    BaseCamera.RENDERINGTYPE_SHADERDEFINE_FXAA = "FXAA";
    BaseCamera.RENDERINGTYPE_DEFERREDLIGHTING = "DEFERREDLIGHTING";
    BaseCamera.RENDERINGTYPE_FORWARDRENDERING = "FORWARDRENDERING";
    BaseCamera._invertYScaleMatrix = new Laya.Matrix4x4(1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    BaseCamera._invertYProjectionMatrix = new Laya.Matrix4x4();
    BaseCamera._invertYProjectionViewMatrix = new Laya.Matrix4x4();

    class LightQueue {
        constructor() {
            this._length = 0;
            this._elements = [];
        }
        add(light) {
            let index = this._elements.indexOf(light);
            if (index != -1 && index < this._length) {
                return;
            }
            if (this._length === this._elements.length)
                this._elements.push(light);
            else
                this._elements[this._length] = light;
            this._length++;
        }
        remove(light) {
            var index = this._elements.indexOf(light);
            if (index == -1)
                return;
            this._length--;
            if (index !== this._length) {
                var end = this._elements[this._length];
                this._elements[index] = end;
            }
        }
        shift() {
            this._length--;
            return this._elements.shift();
        }
        getBrightestLight() {
            var maxIntIndex;
            var maxIntensity = -1;
            var elements = this._elements;
            for (var i = 0; i < this._length; i++) {
                var intensity = elements[i]._intensity;
                if (maxIntensity < intensity) {
                    maxIntensity = intensity;
                    maxIntIndex = i;
                }
            }
            return maxIntIndex;
        }
        normalLightOrdering(brightestIndex) {
            var firstLight = this._elements[0];
            this._elements[0] = this._elements[brightestIndex];
            this._elements[brightestIndex] = firstLight;
        }
    }
    class AlternateLightQueue extends LightQueue {
        remove(light) {
            var index = this._elements.indexOf(light);
            this._elements.splice(index, 1);
            this._length--;
        }
    }

    class Lightmap {
        get lightmapColor() {
            return this._lightmapColor;
        }
        set lightmapColor(value) {
            if (this._lightmapColor == value)
                return;
            this._lightmapColor && this._lightmapColor._removeReference();
            this._lightmapColor = value;
            if (value) {
                value._addReference();
                this._dataModule.lightmapColor = value._texture;
            }
            else {
                this._dataModule.lightmapColor = null;
            }
        }
        get lightmapDirection() {
            return this._lightmapDirection;
        }
        set lightmapDirection(value) {
            if (this._lightmapDirection == value)
                return;
            this._lightmapDirection && this._lightmapDirection._removeReference();
            this._lightmapDirection = value;
            if (value) {
                value._addReference();
                this._dataModule.lightmapDirection = value._texture;
            }
            else {
                this._dataModule.lightmapDirection = null;
            }
        }
        constructor() {
            this._dataModule = Laya3DRender.Render3DModuleDataFactory.createLightmapData();
        }
    }
    Lightmap.ApplyLightmapEvent = "ApplyLightmap";

    class Scene3DShaderDeclaration {
    }

    exports.ShadowCascadesMode = void 0;
    (function (ShadowCascadesMode) {
        ShadowCascadesMode[ShadowCascadesMode["NoCascades"] = 0] = "NoCascades";
        ShadowCascadesMode[ShadowCascadesMode["TwoCascades"] = 1] = "TwoCascades";
        ShadowCascadesMode[ShadowCascadesMode["FourCascades"] = 2] = "FourCascades";
    })(exports.ShadowCascadesMode || (exports.ShadowCascadesMode = {}));

    class Plane {
        constructor(normal = new Laya.Vector3, d = 0) {
            this.normal = normal;
            this.distance = d;
        }
        static createPlaneBy3P(point0, point1, point2, out) {
            var x1 = point1.x - point0.x;
            var y1 = point1.y - point0.y;
            var z1 = point1.z - point0.z;
            var x2 = point2.x - point0.x;
            var y2 = point2.y - point0.y;
            var z2 = point2.z - point0.z;
            var yz = (y1 * z2) - (z1 * y2);
            var xz = (z1 * x2) - (x1 * z2);
            var xy = (x1 * y2) - (y1 * x2);
            var invPyth = 1.0 / (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));
            var x = yz * invPyth;
            var y = xz * invPyth;
            var z = xy * invPyth;
            var normal = out.normal;
            normal.x = x;
            normal.y = y;
            normal.z = z;
            out.normal = normal.normalize();
            out.distance = -((x * point0.x) + (y * point0.y) + (z * point0.z));
        }
        normalize() {
            var normalEX = this.normal.x;
            var normalEY = this.normal.y;
            var normalEZ = this.normal.z;
            var magnitude = 1.0 / Math.sqrt(normalEX * normalEX + normalEY * normalEY + normalEZ * normalEZ);
            this.normal.x = normalEX * magnitude;
            this.normal.y = normalEY * magnitude;
            this.normal.z = normalEZ * magnitude;
            this.distance *= magnitude;
        }
        cloneTo(destObject) {
            this.normal.cloneTo(destObject.normal);
            destObject.distance = this.distance;
        }
        clone() {
            var dest = new Plane();
            this.cloneTo(dest);
            return dest;
        }
    }
    Plane.PlaneIntersectionType_Back = 0;
    Plane.PlaneIntersectionType_Front = 1;
    Plane.PlaneIntersectionType_Intersecting = 2;

    class Ray {
        constructor(origin, direction) {
            this.origin = origin;
            this.direction = direction;
        }
        at(t, out) {
            Laya.Vector3.scale(this.direction, t, out);
            Laya.Vector3.add(this.origin, out, out);
        }
    }

    class ContainmentType {
    }
    ContainmentType.Disjoint = 0;
    ContainmentType.Contains = 1;
    ContainmentType.Intersects = 2;

    class CollisionUtils {
        constructor() {
        }
        static distancePlaneToPoint(plane, point) {
            var dot = Laya.Vector3.dot(plane.normal, point);
            return dot + plane.distance;
        }
        static distanceBoxToPoint(box, point) {
            var boxMin = box.min;
            var boxMineX = boxMin.x;
            var boxMineY = boxMin.y;
            var boxMineZ = boxMin.z;
            var boxMax = box.max;
            var boxMaxeX = boxMax.x;
            var boxMaxeY = boxMax.y;
            var boxMaxeZ = boxMax.z;
            var pointeX = point.x;
            var pointeY = point.y;
            var pointeZ = point.z;
            var distance = 0;
            if (pointeX < boxMineX)
                distance += (boxMineX - pointeX) * (boxMineX - pointeX);
            if (pointeX > boxMaxeX)
                distance += (boxMaxeX - pointeX) * (boxMaxeX - pointeX);
            if (pointeY < boxMineY)
                distance += (boxMineY - pointeY) * (boxMineY - pointeY);
            if (pointeY > boxMaxeY)
                distance += (boxMaxeY - pointeY) * (boxMaxeY - pointeY);
            if (pointeZ < boxMineZ)
                distance += (boxMineZ - pointeZ) * (boxMineZ - pointeZ);
            if (pointeZ > boxMaxeZ)
                distance += (boxMaxeZ - pointeZ) * (boxMaxeZ - pointeZ);
            return Math.sqrt(distance);
        }
        static distanceBoxToBox(box1, box2) {
            var box1Mine = box1.min;
            var box1MineX = box1Mine.x;
            var box1MineY = box1Mine.y;
            var box1MineZ = box1Mine.z;
            var box1Maxe = box1.max;
            var box1MaxeX = box1Maxe.x;
            var box1MaxeY = box1Maxe.y;
            var box1MaxeZ = box1Maxe.z;
            var box2Mine = box2.min;
            var box2MineX = box2Mine.x;
            var box2MineY = box2Mine.y;
            var box2MineZ = box2Mine.z;
            var box2Maxe = box2.max;
            var box2MaxeX = box2Maxe.x;
            var box2MaxeY = box2Maxe.y;
            var box2MaxeZ = box2Maxe.z;
            var distance = 0;
            var delta;
            if (box1MineX > box2MaxeX) {
                delta = box1MineX - box2MaxeX;
                distance += delta * delta;
            }
            else if (box2MineX > box1MaxeX) {
                delta = box2MineX - box1MaxeX;
                distance += delta * delta;
            }
            if (box1MineY > box2MaxeY) {
                delta = box1MineY - box2MaxeY;
                distance += delta * delta;
            }
            else if (box2MineY > box1MaxeY) {
                delta = box2MineY - box1MaxeY;
                distance += delta * delta;
            }
            if (box1MineZ > box2MaxeZ) {
                delta = box1MineZ - box2MaxeZ;
                distance += delta * delta;
            }
            else if (box2MineZ > box1MaxeZ) {
                delta = box2MineZ - box1MaxeZ;
                distance += delta * delta;
            }
            return Math.sqrt(distance);
        }
        static distanceSphereToPoint(sphere, point) {
            var distance = Math.sqrt(Laya.Vector3.distanceSquared(sphere.center, point));
            distance -= sphere.radius;
            return Math.max(distance, 0);
        }
        static distanceSphereToSphere(sphere1, sphere2) {
            var distance = Math.sqrt(Laya.Vector3.distanceSquared(sphere1.center, sphere2.center));
            distance -= sphere1.radius + sphere2.radius;
            return Math.max(distance, 0);
        }
        static intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, out) {
            var rayO = ray.origin;
            var rayOeX = rayO.x;
            var rayOeY = rayO.y;
            var rayOeZ = rayO.z;
            var rayD = ray.direction;
            var rayDeX = rayD.x;
            var rayDeY = rayD.y;
            var rayDeZ = rayD.z;
            var v1eX = vertex1.x;
            var v1eY = vertex1.y;
            var v1eZ = vertex1.z;
            var v2eX = vertex2.x;
            var v2eY = vertex2.y;
            var v2eZ = vertex2.z;
            var v3eX = vertex3.x;
            var v3eY = vertex3.y;
            var v3eZ = vertex3.z;
            var _tempV30eX = _tempV30$1.x;
            var _tempV30eY = _tempV30$1.y;
            var _tempV30eZ = _tempV30$1.z;
            _tempV30eX = v2eX - v1eX;
            _tempV30eY = v2eY - v1eY;
            _tempV30eZ = v2eZ - v1eZ;
            var _tempV31eX = _tempV31$1.x;
            var _tempV31eY = _tempV31$1.y;
            var _tempV31eZ = _tempV31$1.z;
            _tempV31eX = v3eX - v1eX;
            _tempV31eY = v3eY - v1eY;
            _tempV31eZ = v3eZ - v1eZ;
            var _tempV32eX = _tempV32$1.x;
            var _tempV32eY = _tempV32$1.y;
            var _tempV32eZ = _tempV32$1.z;
            _tempV32eX = (rayDeY * _tempV31eZ) - (rayDeZ * _tempV31eY);
            _tempV32eY = (rayDeZ * _tempV31eX) - (rayDeX * _tempV31eZ);
            _tempV32eZ = (rayDeX * _tempV31eY) - (rayDeY * _tempV31eX);
            var determinant = (_tempV30eX * _tempV32eX) + (_tempV30eY * _tempV32eY) + (_tempV30eZ * _tempV32eZ);
            if (Laya.MathUtils3D.isZero(determinant)) {
                return false;
            }
            var inversedeterminant = 1 / determinant;
            var _tempV33eX = _tempV33$1.x;
            var _tempV33eY = _tempV33$1.y;
            var _tempV33eZ = _tempV33$1.z;
            _tempV33eX = rayOeX - v1eX;
            _tempV33eY = rayOeY - v1eY;
            _tempV33eZ = rayOeZ - v1eZ;
            var triangleU = (_tempV33eX * _tempV32eX) + (_tempV33eY * _tempV32eY) + (_tempV33eZ * _tempV32eZ);
            triangleU *= inversedeterminant;
            if (triangleU < 0 || triangleU > 1) {
                return false;
            }
            var _tempV34eX = _tempV34$1.x;
            var _tempV34eY = _tempV34$1.y;
            var _tempV34eZ = _tempV34$1.z;
            _tempV34eX = (_tempV33eY * _tempV30eZ) - (_tempV33eZ * _tempV30eY);
            _tempV34eY = (_tempV33eZ * _tempV30eX) - (_tempV33eX * _tempV30eZ);
            _tempV34eZ = (_tempV33eX * _tempV30eY) - (_tempV33eY * _tempV30eX);
            var triangleV = ((rayDeX * _tempV34eX) + (rayDeY * _tempV34eY)) + (rayDeZ * _tempV34eZ);
            triangleV *= inversedeterminant;
            if (triangleV < 0 || triangleU + triangleV > 1) {
                return false;
            }
            var raydistance = (_tempV31eX * _tempV34eX) + (_tempV31eY * _tempV34eY) + (_tempV31eZ * _tempV34eZ);
            raydistance *= inversedeterminant;
            if (raydistance < 0) {
                return false;
            }
            return true;
        }
        static intersectsRayAndTriangleRP(ray, vertex1, vertex2, vertex3, out) {
            var distance;
            if (!CollisionUtils.intersectsRayAndTriangleRD(ray, vertex1, vertex2, vertex3, distance)) {
                Laya.Vector3.ZERO.cloneTo(out);
                return false;
            }
            Laya.Vector3.scale(ray.direction, distance, _tempV30$1);
            Laya.Vector3.add(ray.origin, _tempV30$1, out);
            return true;
        }
        static intersectsRayAndPoint(ray, point) {
            Laya.Vector3.subtract(ray.origin, point, _tempV30$1);
            var b = Laya.Vector3.dot(_tempV30$1, ray.direction);
            var c = Laya.Vector3.dot(_tempV30$1, _tempV30$1) - Laya.MathUtils3D.zeroTolerance;
            if (c > 0 && b > 0)
                return false;
            var discriminant = b * b - c;
            if (discriminant < 0)
                return false;
            return true;
        }
        static intersectsRayAndRay(ray1, ray2, out) {
            var ray1o = ray1.origin;
            var ray1oeX = ray1o.x;
            var ray1oeY = ray1o.y;
            var ray1oeZ = ray1o.z;
            var ray1d = ray1.direction;
            var ray1deX = ray1d.x;
            var ray1deY = ray1d.y;
            var ray1deZ = ray1d.z;
            var ray2o = ray2.origin;
            var ray2oeX = ray2o.x;
            var ray2oeY = ray2o.y;
            var ray2oeZ = ray2o.z;
            var ray2d = ray2.direction;
            var ray2deX = ray2d.x;
            var ray2deY = ray2d.y;
            var ray2deZ = ray2d.z;
            Laya.Vector3.cross(ray1d, ray2d, _tempV30$1);
            var tempV3 = _tempV30$1;
            var denominator = Laya.Vector3.scalarLength(_tempV30$1);
            if (Laya.MathUtils3D.isZero(denominator)) {
                if (Laya.MathUtils3D.nearEqual(ray2oeX, ray1oeX) && Laya.MathUtils3D.nearEqual(ray2oeY, ray1oeY) && Laya.MathUtils3D.nearEqual(ray2oeZ, ray1oeZ)) {
                    Laya.Vector3.ZERO.cloneTo(out);
                    return true;
                }
            }
            denominator = denominator * denominator;
            var m11 = ray2oeX - ray1oeX;
            var m12 = ray2oeY - ray1oeY;
            var m13 = ray2oeZ - ray1oeZ;
            var m21 = ray2deX;
            var m22 = ray2deY;
            var m23 = ray2deZ;
            var m31 = tempV3.x;
            var m32 = tempV3.y;
            var m33 = tempV3.z;
            var dets = m11 * m22 * m33 + m12 * m23 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 - m13 * m22 * m31;
            m21 = ray1deX;
            m22 = ray1deY;
            m23 = ray1deZ;
            var s = dets / denominator;
            Laya.Vector3.scale(ray1d, s, _tempV30$1);
            Laya.Vector3.scale(ray2d, s, _tempV31$1);
            Laya.Vector3.add(ray1o, _tempV30$1, _tempV32$1);
            Laya.Vector3.add(ray2o, _tempV31$1, _tempV33$1);
            var point1e = _tempV32$1;
            var point2e = _tempV33$1;
            if (!Laya.MathUtils3D.nearEqual(point2e.x, point1e.x) || !Laya.MathUtils3D.nearEqual(point2e.y, point1e.y) || !Laya.MathUtils3D.nearEqual(point2e.z, point1e.z)) {
                Laya.Vector3.ZERO.cloneTo(out);
                return false;
            }
            out = _tempV32$1;
            return true;
        }
        static intersectsPlaneAndTriangle(plane, vertex1, vertex2, vertex3) {
            var test1 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex1);
            var test2 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex2);
            var test3 = CollisionUtils.intersectsPlaneAndPoint(plane, vertex3);
            if (test1 == Plane.PlaneIntersectionType_Front && test2 == Plane.PlaneIntersectionType_Front && test3 == Plane.PlaneIntersectionType_Front)
                return Plane.PlaneIntersectionType_Front;
            if (test1 == Plane.PlaneIntersectionType_Back && test2 == Plane.PlaneIntersectionType_Back && test3 == Plane.PlaneIntersectionType_Back)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsRayAndPlaneRD(ray, plane) {
            var planeNor = plane.normal;
            var direction = Laya.Vector3.dot(planeNor, ray.direction);
            if (Math.abs(direction) < Laya.MathUtils3D.zeroTolerance)
                return -1;
            var position = Laya.Vector3.dot(planeNor, ray.origin);
            var distance = (-plane.distance - position) / direction;
            if (distance < 0) {
                if (distance < -Laya.MathUtils3D.zeroTolerance)
                    return -1;
                distance = 0;
            }
            return distance;
        }
        static intersectsRayAndPlaneRP(ray, plane, out) {
            var distance = CollisionUtils.intersectsRayAndPlaneRD(ray, plane);
            if (distance == -1) {
                out.setValue(0, 0, 0);
                return false;
            }
            var scaDis = _tempV30$1;
            Laya.Vector3.scale(ray.direction, distance, scaDis);
            Laya.Vector3.add(ray.origin, scaDis, out);
            return true;
        }
        static intersectsRayAndBoxRD(ray, box) {
            var rayoe = ray.origin;
            var rayoeX = rayoe.x;
            var rayoeY = rayoe.y;
            var rayoeZ = rayoe.z;
            var rayde = ray.direction;
            var raydeX = rayde.x;
            var raydeY = rayde.y;
            var raydeZ = rayde.z;
            var boxMine = box.min;
            var boxMineX = boxMine.x;
            var boxMineY = boxMine.y;
            var boxMineZ = boxMine.z;
            var boxMaxe = box.max;
            var boxMaxeX = boxMaxe.x;
            var boxMaxeY = boxMaxe.y;
            var boxMaxeZ = boxMaxe.z;
            var out = 0;
            var tmax = Laya.MathUtils3D.MaxValue;
            if (Laya.MathUtils3D.isZero(raydeX)) {
                if (rayoeX < boxMineX || rayoeX > boxMaxeX) {
                    return -1;
                }
            }
            else {
                var inverse = 1 / raydeX;
                var t1 = (boxMineX - rayoeX) * inverse;
                var t2 = (boxMaxeX - rayoeX) * inverse;
                if (t1 > t2) {
                    var temp = t1;
                    t1 = t2;
                    t2 = temp;
                }
                out = Math.max(t1, out);
                tmax = Math.min(t2, tmax);
                if (out > tmax) {
                    return -1;
                }
            }
            if (Laya.MathUtils3D.isZero(raydeY)) {
                if (rayoeY < boxMineY || rayoeY > boxMaxeY) {
                    return -1;
                }
            }
            else {
                var inverse1 = 1 / raydeY;
                var t3 = (boxMineY - rayoeY) * inverse1;
                var t4 = (boxMaxeY - rayoeY) * inverse1;
                if (t3 > t4) {
                    var temp1 = t3;
                    t3 = t4;
                    t4 = temp1;
                }
                out = Math.max(t3, out);
                tmax = Math.min(t4, tmax);
                if (out > tmax) {
                    return -1;
                }
            }
            if (Laya.MathUtils3D.isZero(raydeZ)) {
                if (rayoeZ < boxMineZ || rayoeZ > boxMaxeZ) {
                    return -1;
                }
            }
            else {
                var inverse2 = 1 / raydeZ;
                var t5 = (boxMineZ - rayoeZ) * inverse2;
                var t6 = (boxMaxeZ - rayoeZ) * inverse2;
                if (t5 > t6) {
                    var temp2 = t5;
                    t5 = t6;
                    t6 = temp2;
                }
                out = Math.max(t5, out);
                tmax = Math.min(t6, tmax);
                if (out > tmax) {
                    return -1;
                }
            }
            return out;
        }
        static intersectsRayAndBoxRP(ray, box, out) {
            var distance = CollisionUtils.intersectsRayAndBoxRD(ray, box);
            if (distance === -1) {
                Laya.Vector3.ZERO.cloneTo(out);
                return distance;
            }
            Laya.Vector3.scale(ray.direction, distance, _tempV30$1);
            Laya.Vector3.add(ray.origin, _tempV30$1, _tempV31$1);
            _tempV31$1.cloneTo(out);
            return distance;
        }
        static intersectsRayAndSphereRD(ray, sphere) {
            var sphereR = sphere.radius;
            Laya.Vector3.subtract(ray.origin, sphere.center, _tempV30$1);
            var b = Laya.Vector3.dot(_tempV30$1, ray.direction);
            var c = Laya.Vector3.dot(_tempV30$1, _tempV30$1) - (sphereR * sphereR);
            if (c > 0 && b > 0) {
                return -1;
            }
            var discriminant = b * b - c;
            if (discriminant < 0) {
                return -1;
            }
            var distance = -b - Math.sqrt(discriminant);
            if (distance < 0)
                distance = 0;
            return distance;
        }
        static intersectsRayAndSphereRP(ray, sphere, out) {
            var distance = CollisionUtils.intersectsRayAndSphereRD(ray, sphere);
            if (distance === -1) {
                Laya.Vector3.ZERO.cloneTo(out);
                return distance;
            }
            Laya.Vector3.scale(ray.direction, distance, _tempV30$1);
            Laya.Vector3.add(ray.origin, _tempV30$1, _tempV31$1);
            _tempV31$1.cloneTo(out);
            return distance;
        }
        static intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3) {
            var sphereC = sphere.center;
            var sphereR = sphere.radius;
            CollisionUtils.closestPointPointTriangle(sphereC, vertex1, vertex2, vertex3, _tempV30$1);
            Laya.Vector3.subtract(_tempV30$1, sphereC, _tempV31$1);
            var dot = Laya.Vector3.dot(_tempV31$1, _tempV31$1);
            return dot <= sphereR * sphereR;
        }
        static intersectsPlaneAndPoint(plane, point) {
            var distance = Laya.Vector3.dot(plane.normal, point) + plane.distance;
            if (distance > 0)
                return Plane.PlaneIntersectionType_Front;
            if (distance < 0)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndPlane(plane1, plane2) {
            Laya.Vector3.cross(plane1.normal, plane2.normal, _tempV30$1);
            var denominator = Laya.Vector3.dot(_tempV30$1, _tempV30$1);
            if (Laya.MathUtils3D.isZero(denominator))
                return false;
            return true;
        }
        static intersectsPlaneAndPlaneRL(plane1, plane2, line) {
            var plane1nor = plane1.normal;
            var plane2nor = plane2.normal;
            Laya.Vector3.cross(plane1nor, plane2nor, _tempV34$1);
            var denominator = Laya.Vector3.dot(_tempV34$1, _tempV34$1);
            if (Laya.MathUtils3D.isZero(denominator))
                return false;
            Laya.Vector3.scale(plane2nor, plane1.distance, _tempV30$1);
            Laya.Vector3.scale(plane1nor, plane2.distance, _tempV31$1);
            Laya.Vector3.subtract(_tempV30$1, _tempV31$1, _tempV32$1);
            Laya.Vector3.cross(_tempV32$1, _tempV34$1, _tempV33$1);
            Laya.Vector3.normalize(_tempV34$1, _tempV34$1);
            new Ray(_tempV33$1, _tempV34$1);
            return true;
        }
        static intersectsPlaneAndBox(plane, box) {
            var planeD = plane.distance;
            var planeNor = plane.normal;
            var planeNoreX = planeNor.x;
            var planeNoreY = planeNor.y;
            var planeNoreZ = planeNor.z;
            var boxMine = box.min;
            var boxMineX = boxMine.x;
            var boxMineY = boxMine.y;
            var boxMineZ = boxMine.z;
            var boxMaxe = box.max;
            var boxMaxeX = boxMaxe.x;
            var boxMaxeY = boxMaxe.y;
            var boxMaxeZ = boxMaxe.z;
            _tempV30$1.x = (planeNoreX > 0) ? boxMineX : boxMaxeX;
            _tempV30$1.y = (planeNoreY > 0) ? boxMineY : boxMaxeY;
            _tempV30$1.z = (planeNoreZ > 0) ? boxMineZ : boxMaxeZ;
            _tempV31$1.x = (planeNoreX > 0) ? boxMaxeX : boxMineX;
            _tempV31$1.y = (planeNoreY > 0) ? boxMaxeY : boxMineY;
            _tempV31$1.z = (planeNoreZ > 0) ? boxMaxeZ : boxMineZ;
            var distance = Laya.Vector3.dot(planeNor, _tempV30$1);
            if (distance + planeD > 0)
                return Plane.PlaneIntersectionType_Front;
            distance = Laya.Vector3.dot(planeNor, _tempV31$1);
            if (distance + planeD < 0)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsPlaneAndSphere(plane, sphere) {
            var sphereR = sphere.radius;
            var distance = Laya.Vector3.dot(plane.normal, sphere.center) + plane.distance;
            if (distance > sphereR)
                return Plane.PlaneIntersectionType_Front;
            if (distance < -sphereR)
                return Plane.PlaneIntersectionType_Back;
            return Plane.PlaneIntersectionType_Intersecting;
        }
        static intersectsBoxAndBox(box1, box2) {
            var box1Mine = box1.min;
            var box1Maxe = box1.max;
            var box2Mine = box2.min;
            var box2Maxe = box2.max;
            if (box1Mine.x > box2Maxe.x || box2Mine.x > box1Maxe.x)
                return false;
            if (box1Mine.y > box2Maxe.y || box2Mine.y > box1Maxe.y)
                return false;
            if (box1Mine.z > box2Maxe.z || box2Mine.z > box1Maxe.z)
                return false;
            return true;
        }
        static intersectsBoxAndSphere(box, sphere) {
            var center = sphere.center;
            var radius = sphere.radius;
            var nearest = _tempV30$1;
            Laya.Vector3.Clamp(center, box.min, box.max, nearest);
            var distance = Laya.Vector3.distanceSquared(center, nearest);
            return distance <= radius * radius;
        }
        static intersectsSphereAndSphere(sphere1, sphere2) {
            var radiisum = sphere1.radius + sphere2.radius;
            return Laya.Vector3.distanceSquared(sphere1.center, sphere2.center) <= radiisum * radiisum;
        }
        static boxContainsPoint(box, point) {
            var boxMine = box.min;
            var boxMaxe = box.max;
            if (boxMine.x <= point.x && boxMaxe.x >= point.x && boxMine.y <= point.y && boxMaxe.y >= point.y && boxMine.z <= point.z && boxMaxe.z >= point.z)
                return ContainmentType.Contains;
            return ContainmentType.Disjoint;
        }
        static boxContainsBox(box1, box2) {
            var box1Mine = box1.min;
            var box1MineX = box1Mine.x;
            var box1MineY = box1Mine.y;
            var box1MineZ = box1Mine.z;
            var box1Maxe = box1.max;
            var box1MaxeX = box1Maxe.x;
            var box1MaxeY = box1Maxe.y;
            var box1MaxeZ = box1Maxe.z;
            var box2Mine = box2.min;
            var box2MineX = box2Mine.x;
            var box2MineY = box2Mine.y;
            var box2MineZ = box2Mine.z;
            var box2Maxe = box2.max;
            var box2MaxeX = box2Maxe.x;
            var box2MaxeY = box2Maxe.y;
            var box2MaxeZ = box2Maxe.z;
            if (box1MaxeX < box2MineX || box1MineX > box2MaxeX)
                return ContainmentType.Disjoint;
            if (box1MaxeY < box2MineY || box1MineY > box2MaxeY)
                return ContainmentType.Disjoint;
            if (box1MaxeZ < box2MineZ || box1MineZ > box2MaxeZ)
                return ContainmentType.Disjoint;
            if (box1MineX <= box2MineX && box2MaxeX <= box1MaxeX && box1MineY <= box2MineY && box2MaxeY <= box1MaxeY && box1MineZ <= box2MineZ && box2MaxeZ <= box1MaxeZ) {
                return ContainmentType.Contains;
            }
            return ContainmentType.Intersects;
        }
        static boxContainsSphere(box, sphere) {
            var boxMin = box.min;
            var boxMineX = boxMin.x;
            var boxMineY = boxMin.y;
            var boxMineZ = boxMin.z;
            var boxMax = box.max;
            var boxMaxeX = boxMax.x;
            var boxMaxeY = boxMax.y;
            var boxMaxeZ = boxMax.z;
            var sphereC = sphere.center;
            var sphereCeX = sphereC.x;
            var sphereCeY = sphereC.y;
            var sphereCeZ = sphereC.z;
            var sphereR = sphere.radius;
            Laya.Vector3.Clamp(sphereC, boxMin, boxMax, _tempV30$1);
            var distance = Laya.Vector3.distanceSquared(sphereC, _tempV30$1);
            if (distance > sphereR * sphereR)
                return ContainmentType.Disjoint;
            if ((((boxMineX + sphereR <= sphereCeX) && (sphereCeX <= boxMaxeX - sphereR)) && ((boxMaxeX - boxMineX > sphereR) &&
                (boxMineY + sphereR <= sphereCeY))) && (((sphereCeY <= boxMaxeY - sphereR) && (boxMaxeY - boxMineY > sphereR)) &&
                (((boxMineZ + sphereR <= sphereCeZ) && (sphereCeZ <= boxMaxeZ - sphereR)) && (boxMaxeZ - boxMineZ > sphereR))))
                return ContainmentType.Contains;
            return ContainmentType.Intersects;
        }
        static sphereContainsPoint(sphere, point) {
            if (Laya.Vector3.distanceSquared(point, sphere.center) <= sphere.radius * sphere.radius)
                return ContainmentType.Contains;
            return ContainmentType.Disjoint;
        }
        static sphereContainsTriangle(sphere, vertex1, vertex2, vertex3) {
            var test1 = CollisionUtils.sphereContainsPoint(sphere, vertex1);
            var test2 = CollisionUtils.sphereContainsPoint(sphere, vertex2);
            var test3 = CollisionUtils.sphereContainsPoint(sphere, vertex3);
            if (test1 == ContainmentType.Contains && test2 == ContainmentType.Contains && test3 == ContainmentType.Contains)
                return ContainmentType.Contains;
            if (CollisionUtils.intersectsSphereAndTriangle(sphere, vertex1, vertex2, vertex3))
                return ContainmentType.Intersects;
            return ContainmentType.Disjoint;
        }
        static sphereContainsBox(sphere, box) {
            var sphereC = sphere.center;
            sphereC.x;
            sphereC.y;
            sphereC.z;
            var sphereR = sphere.radius;
            var boxMin = box.min;
            boxMin.x;
            boxMin.y;
            boxMin.z;
            var boxMax = box.max;
            boxMax.x;
            boxMax.y;
            boxMax.z;
            var _tempV30e = _tempV30$1;
            _tempV30e.x;
            _tempV30e.y;
            _tempV30e.z;
            if (!CollisionUtils.intersectsBoxAndSphere(box, sphere))
                return ContainmentType.Disjoint;
            var radiusSquared = sphereR * sphereR;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            if (Laya.Vector3.scalarLengthSquared(_tempV30$1) > radiusSquared)
                return ContainmentType.Intersects;
            return ContainmentType.Contains;
        }
        static sphereContainsSphere(sphere1, sphere2) {
            var sphere1R = sphere1.radius;
            var sphere2R = sphere2.radius;
            var distance = Laya.Vector3.distance(sphere1.center, sphere2.center);
            if (sphere1R + sphere2R < distance)
                return ContainmentType.Disjoint;
            if (sphere1R - sphere2R < distance)
                return ContainmentType.Intersects;
            return ContainmentType.Contains;
        }
        static closestPointPointTriangle(point, vertex1, vertex2, vertex3, out) {
            Laya.Vector3.subtract(vertex2, vertex1, _tempV30$1);
            Laya.Vector3.subtract(vertex3, vertex1, _tempV31$1);
            Laya.Vector3.subtract(point, vertex1, _tempV32$1);
            Laya.Vector3.subtract(point, vertex2, _tempV33$1);
            Laya.Vector3.subtract(point, vertex3, _tempV34$1);
            var d1 = Laya.Vector3.dot(_tempV30$1, _tempV32$1);
            var d2 = Laya.Vector3.dot(_tempV31$1, _tempV32$1);
            var d3 = Laya.Vector3.dot(_tempV30$1, _tempV33$1);
            var d4 = Laya.Vector3.dot(_tempV31$1, _tempV33$1);
            var d5 = Laya.Vector3.dot(_tempV30$1, _tempV34$1);
            var d6 = Laya.Vector3.dot(_tempV31$1, _tempV34$1);
            if (d1 <= 0 && d2 <= 0) {
                vertex1.cloneTo(out);
                return;
            }
            if (d3 >= 0 && d4 <= d3) {
                vertex2.cloneTo(out);
                return;
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                var v = d1 / (d1 - d3);
                Laya.Vector3.scale(_tempV30$1, v, out);
                Laya.Vector3.add(vertex1, out, out);
                return;
            }
            if (d6 >= 0 && d5 <= d6) {
                vertex3.cloneTo(out);
                return;
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                var w = d2 / (d2 - d6);
                Laya.Vector3.scale(_tempV31$1, w, out);
                Laya.Vector3.add(vertex1, out, out);
                return;
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                var w3 = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                Laya.Vector3.subtract(vertex3, vertex2, out);
                Laya.Vector3.scale(out, w3, out);
                Laya.Vector3.add(vertex2, out, out);
                return;
            }
            var denom = 1 / (va + vb + vc);
            var v2 = vb * denom;
            var w2 = vc * denom;
            Laya.Vector3.scale(_tempV30$1, v2, _tempV35$1);
            Laya.Vector3.scale(_tempV31$1, w2, _tempV36$1);
            Laya.Vector3.add(_tempV35$1, _tempV36$1, out);
            Laya.Vector3.add(vertex1, out, out);
        }
        static closestPointPlanePoint(plane, point, out) {
            var planeN = plane.normal;
            var t = Laya.Vector3.dot(planeN, point) - plane.distance;
            Laya.Vector3.scale(planeN, t, _tempV30$1);
            Laya.Vector3.subtract(point, _tempV30$1, out);
        }
        static closestPointBoxPoint(box, point, out) {
            Laya.Vector3.max(point, box.min, _tempV30$1);
            Laya.Vector3.min(_tempV30$1, box.max, out);
        }
        static closestPointSpherePoint(sphere, point, out) {
            var sphereC = sphere.center;
            Laya.Vector3.subtract(point, sphereC, out);
            Laya.Vector3.normalize(out, out);
            Laya.Vector3.scale(out, sphere.radius, out);
            Laya.Vector3.add(out, sphereC, out);
        }
        static closestPointSphereSphere(sphere1, sphere2, out) {
            var sphere1C = sphere1.center;
            Laya.Vector3.subtract(sphere2.center, sphere1C, out);
            Laya.Vector3.normalize(out, out);
            Laya.Vector3.scale(out, sphere1.radius, out);
            Laya.Vector3.add(out, sphere1C, out);
        }
    }
    const _tempV30$1 = new Laya.Vector3();
    const _tempV31$1 = new Laya.Vector3();
    const _tempV32$1 = new Laya.Vector3();
    const _tempV33$1 = new Laya.Vector3();
    const _tempV34$1 = new Laya.Vector3();
    const _tempV35$1 = new Laya.Vector3();
    const _tempV36$1 = new Laya.Vector3();

    exports.FrustumCorner = void 0;
    (function (FrustumCorner) {
        FrustumCorner[FrustumCorner["FarBottomLeft"] = 0] = "FarBottomLeft";
        FrustumCorner[FrustumCorner["FarTopLeft"] = 1] = "FarTopLeft";
        FrustumCorner[FrustumCorner["FarTopRight"] = 2] = "FarTopRight";
        FrustumCorner[FrustumCorner["FarBottomRight"] = 3] = "FarBottomRight";
        FrustumCorner[FrustumCorner["nearBottomLeft"] = 4] = "nearBottomLeft";
        FrustumCorner[FrustumCorner["nearTopLeft"] = 5] = "nearTopLeft";
        FrustumCorner[FrustumCorner["nearTopRight"] = 6] = "nearTopRight";
        FrustumCorner[FrustumCorner["nearBottomRight"] = 7] = "nearBottomRight";
        FrustumCorner[FrustumCorner["unknown"] = 8] = "unknown";
    })(exports.FrustumCorner || (exports.FrustumCorner = {}));
    class BoundFrustum {
        static getPlanesFromMatrix(m, np, fp, lp, rp, tp, bp) {
            var matrixE = m.elements;
            var m11 = matrixE[0];
            var m12 = matrixE[1];
            var m13 = matrixE[2];
            var m14 = matrixE[3];
            var m21 = matrixE[4];
            var m22 = matrixE[5];
            var m23 = matrixE[6];
            var m24 = matrixE[7];
            var m31 = matrixE[8];
            var m32 = matrixE[9];
            var m33 = matrixE[10];
            var m34 = matrixE[11];
            var m41 = matrixE[12];
            var m42 = matrixE[13];
            var m43 = matrixE[14];
            var m44 = matrixE[15];
            var nearNorE = np.normal;
            nearNorE.x = m13;
            nearNorE.y = m23;
            nearNorE.z = m33;
            np.distance = m43;
            np.normal = nearNorE;
            np.normalize();
            var farNorE = fp.normal;
            farNorE.x = m14 - m13;
            farNorE.y = m24 - m23;
            farNorE.z = m34 - m33;
            fp.distance = m44 - m43;
            fp.normal = farNorE;
            fp.normalize();
            var leftNorE = lp.normal;
            leftNorE.x = m14 + m11;
            leftNorE.y = m24 + m21;
            leftNorE.z = m34 + m31;
            lp.distance = m44 + m41;
            lp.normal = leftNorE;
            lp.normalize();
            var rightNorE = rp.normal;
            rightNorE.x = m14 - m11;
            rightNorE.y = m24 - m21;
            rightNorE.z = m34 - m31;
            rp.distance = m44 - m41;
            rp.normal = rightNorE;
            rp.normalize();
            var topNorE = tp.normal;
            topNorE.x = m14 - m12;
            topNorE.y = m24 - m22;
            topNorE.z = m34 - m32;
            tp.distance = m44 - m42;
            tp.normal = topNorE;
            tp.normalize();
            var bottomNorE = bp.normal;
            bottomNorE.x = m14 + m12;
            bottomNorE.y = m24 + m22;
            bottomNorE.z = m34 + m32;
            bp.distance = m44 + m42;
            bp.normal = bottomNorE;
            bp.normalize();
        }
        constructor(matrix) {
            this._matrix = matrix;
            this.initBoundingPlane();
        }
        initBoundingPlane() {
            this._near = new Plane();
            this._far = new Plane();
            this._left = new Plane();
            this._right = new Plane();
            this._top = new Plane();
            this._bottom = new Plane();
            BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get matrix() {
            return this._matrix;
        }
        set matrix(matrix) {
            matrix.cloneTo(this._matrix);
            BoundFrustum.getPlanesFromMatrix(this._matrix, this._near, this._far, this._left, this._right, this._top, this._bottom);
        }
        get near() {
            return this._near;
        }
        get far() {
            return this._far;
        }
        get left() {
            return this._left;
        }
        get right() {
            return this._right;
        }
        get top() {
            return this._top;
        }
        get bottom() {
            return this._bottom;
        }
        equalsBoundFrustum(other) {
            return this._matrix.equalsOtherMatrix(other.matrix);
        }
        equalsObj(obj) {
            if (obj instanceof BoundFrustum) {
                var bf = obj;
                return this.equalsBoundFrustum(bf);
            }
            return false;
        }
        getPlane(index) {
            switch (index) {
                case 0:
                    return this._near;
                case 1:
                    return this._far;
                case 2:
                    return this._left;
                case 3:
                    return this._right;
                case 4:
                    return this._top;
                case 5:
                    return this._bottom;
                default:
                    return null;
            }
        }
        static get3PlaneInterPoint(p1, p2, p3, out) {
            var p1Nor = p1.normal;
            var p2Nor = p2.normal;
            var p3Nor = p3.normal;
            Laya.Vector3.cross(p2Nor, p3Nor, _tempV30);
            Laya.Vector3.cross(p3Nor, p1Nor, _tempV31);
            Laya.Vector3.cross(p1Nor, p2Nor, _tempV32);
            var a = Laya.Vector3.dot(p1Nor, _tempV30);
            var b = Laya.Vector3.dot(p2Nor, _tempV31);
            var c = Laya.Vector3.dot(p3Nor, _tempV32);
            Laya.Vector3.scale(_tempV30, -p1.distance / a, _tempV33);
            Laya.Vector3.scale(_tempV31, -p2.distance / b, _tempV34);
            Laya.Vector3.scale(_tempV32, -p3.distance / c, _tempV35);
            Laya.Vector3.add(_tempV33, _tempV34, _tempV36);
            Laya.Vector3.add(_tempV35, _tempV36, out);
        }
        getCorners(corners) {
            BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._right, corners[exports.FrustumCorner.nearBottomRight]);
            BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._right, corners[exports.FrustumCorner.nearTopRight]);
            BoundFrustum.get3PlaneInterPoint(this._near, this._top, this._left, corners[exports.FrustumCorner.nearTopLeft]);
            BoundFrustum.get3PlaneInterPoint(this._near, this._bottom, this._left, corners[exports.FrustumCorner.nearBottomLeft]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._right, corners[exports.FrustumCorner.FarBottomRight]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._right, corners[exports.FrustumCorner.FarTopRight]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._top, this._left, corners[exports.FrustumCorner.FarTopLeft]);
            BoundFrustum.get3PlaneInterPoint(this._far, this._bottom, this._left, corners[exports.FrustumCorner.FarBottomLeft]);
        }
        containsPoint(point) {
            var result = Plane.PlaneIntersectionType_Front;
            var planeResult = Plane.PlaneIntersectionType_Front;
            for (var i = 0; i < 6; i++) {
                switch (i) {
                    case 0:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._near, point);
                        break;
                    case 1:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._far, point);
                        break;
                    case 2:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._left, point);
                        break;
                    case 3:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._right, point);
                        break;
                    case 4:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._top, point);
                        break;
                    case 5:
                        planeResult = CollisionUtils.intersectsPlaneAndPoint(this._bottom, point);
                        break;
                }
                switch (planeResult) {
                    case Plane.PlaneIntersectionType_Back:
                        return ContainmentType.Disjoint;
                    case Plane.PlaneIntersectionType_Intersecting:
                        result = Plane.PlaneIntersectionType_Intersecting;
                        break;
                }
            }
            switch (result) {
                case Plane.PlaneIntersectionType_Intersecting:
                    return ContainmentType.Intersects;
                default:
                    return ContainmentType.Contains;
            }
        }
        intersects(box) {
            var min = box.min;
            var max = box.max;
            var minX = min.x;
            var minY = min.y;
            var minZ = min.z;
            var maxX = max.x;
            var maxY = max.y;
            var maxZ = max.z;
            var nearNormal = this._near.normal;
            if (this._near.distance + (nearNormal.x * (nearNormal.x < 0 ? minX : maxX)) + (nearNormal.y * (nearNormal.y < 0 ? minY : maxY)) + (nearNormal.z * (nearNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var leftNormal = this._left.normal;
            if (this._left.distance + (leftNormal.x * (leftNormal.x < 0 ? minX : maxX)) + (leftNormal.y * (leftNormal.y < 0 ? minY : maxY)) + (leftNormal.z * (leftNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var rightNormal = this._right.normal;
            if (this._right.distance + (rightNormal.x * (rightNormal.x < 0 ? minX : maxX)) + (rightNormal.y * (rightNormal.y < 0 ? minY : maxY)) + (rightNormal.z * (rightNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var bottomNormal = this._bottom.normal;
            if (this._bottom.distance + (bottomNormal.x * (bottomNormal.x < 0 ? minX : maxX)) + (bottomNormal.y * (bottomNormal.y < 0 ? minY : maxY)) + (bottomNormal.z * (bottomNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var topNormal = this._top.normal;
            if (this._top.distance + (topNormal.x * (topNormal.x < 0 ? minX : maxX)) + (topNormal.y * (topNormal.y < 0 ? minY : maxY)) + (topNormal.z * (topNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            var farNormal = this._far.normal;
            if (this._far.distance + (farNormal.x * (farNormal.x < 0 ? minX : maxX)) + (farNormal.y * (farNormal.y < 0 ? minY : maxY)) + (farNormal.z * (farNormal.z < 0 ? minZ : maxZ)) < 0)
                return false;
            return true;
        }
        containsBoundBox(box) {
            var p = _tempV30, n = _tempV31;
            var boxMin = box.min;
            var boxMax = box.max;
            var result = ContainmentType.Contains;
            for (var i = 0; i < 6; i++) {
                var plane = this.getPlane(i);
                var planeNor = plane.normal;
                if (planeNor.x >= 0) {
                    p.x = boxMax.x;
                    n.x = boxMin.x;
                }
                else {
                    p.x = boxMin.x;
                    n.x = boxMax.x;
                }
                if (planeNor.y >= 0) {
                    p.y = boxMax.y;
                    n.y = boxMin.y;
                }
                else {
                    p.y = boxMin.y;
                    n.y = boxMax.y;
                }
                if (planeNor.z >= 0) {
                    p.z = boxMax.z;
                    n.z = boxMin.z;
                }
                else {
                    p.z = boxMin.z;
                    n.z = boxMax.z;
                }
                if (CollisionUtils.intersectsPlaneAndPoint(plane, p) === Plane.PlaneIntersectionType_Back)
                    return ContainmentType.Disjoint;
                if (CollisionUtils.intersectsPlaneAndPoint(plane, n) === Plane.PlaneIntersectionType_Back)
                    result = ContainmentType.Intersects;
            }
            return result;
        }
        containsBoundSphere(sphere) {
            var result = Plane.PlaneIntersectionType_Front;
            var planeResult = Plane.PlaneIntersectionType_Front;
            for (var i = 0; i < 6; i++) {
                switch (i) {
                    case 0:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._near, sphere);
                        break;
                    case 1:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._far, sphere);
                        break;
                    case 2:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._left, sphere);
                        break;
                    case 3:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._right, sphere);
                        break;
                    case 4:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._top, sphere);
                        break;
                    case 5:
                        planeResult = CollisionUtils.intersectsPlaneAndSphere(this._bottom, sphere);
                        break;
                }
                switch (planeResult) {
                    case Plane.PlaneIntersectionType_Back:
                        return ContainmentType.Disjoint;
                    case Plane.PlaneIntersectionType_Intersecting:
                        result = Plane.PlaneIntersectionType_Intersecting;
                        break;
                }
            }
            switch (result) {
                case Plane.PlaneIntersectionType_Intersecting:
                    return ContainmentType.Intersects;
                default:
                    return ContainmentType.Contains;
            }
        }
        cloneTo(dest) {
            dest.matrix = this.matrix;
        }
        clone() {
            let dest = new BoundFrustum(new Laya.Matrix4x4);
            this.cloneTo(dest);
            return dest;
        }
    }
    const _tempV30 = new Laya.Vector3();
    const _tempV31 = new Laya.Vector3();
    const _tempV32 = new Laya.Vector3();
    const _tempV33 = new Laya.Vector3();
    const _tempV34 = new Laya.Vector3();
    const _tempV35 = new Laya.Vector3();
    const _tempV36 = new Laya.Vector3();

    exports.ShadowMode = void 0;
    (function (ShadowMode) {
        ShadowMode[ShadowMode["None"] = 0] = "None";
        ShadowMode[ShadowMode["Hard"] = 1] = "Hard";
        ShadowMode[ShadowMode["SoftLow"] = 2] = "SoftLow";
        ShadowMode[ShadowMode["SoftHigh"] = 3] = "SoftHigh";
    })(exports.ShadowMode || (exports.ShadowMode = {}));

    exports.LightType = void 0;
    (function (LightType) {
        LightType[LightType["Directional"] = 0] = "Directional";
        LightType[LightType["Spot"] = 1] = "Spot";
        LightType[LightType["Point"] = 2] = "Point";
        LightType[LightType["Area"] = 3] = "Area";
    })(exports.LightType || (exports.LightType = {}));
    exports.LightMode = void 0;
    (function (LightMode) {
        LightMode[LightMode["mix"] = 0] = "mix";
        LightMode[LightMode["realTime"] = 1] = "realTime";
        LightMode[LightMode["bakeOnly"] = 2] = "bakeOnly";
    })(exports.LightMode || (exports.LightMode = {}));
    class Light extends Laya.Component {
        get intensity() {
            return this._intensity;
        }
        set intensity(value) {
            this._intensity = value;
        }
        get shadowMode() {
            return this._dataModule.shadowMode;
        }
        set shadowMode(value) {
            this._dataModule.shadowMode = value;
        }
        get shadowDistance() {
            return this._dataModule.shadowDistance;
        }
        set shadowDistance(value) {
            this._dataModule.shadowDistance = value;
        }
        get shadowResolution() {
            return this._dataModule.shadowResolution;
        }
        set shadowResolution(value) {
            this._dataModule.shadowResolution = value;
        }
        get shadowDepthBias() {
            return this._dataModule.shadowDepthBias;
        }
        set shadowDepthBias(value) {
            this._dataModule.shadowDepthBias = value;
        }
        get shadowNormalBias() {
            return this._dataModule.shadowNormalBias;
        }
        set shadowNormalBias(value) {
            this._dataModule.shadowNormalBias = value;
        }
        get shadowStrength() {
            return this._dataModule.shadowStrength;
        }
        set shadowStrength(value) {
            this._dataModule.shadowStrength = value;
        }
        get shadowNearPlane() {
            return this._dataModule.shadowNearPlane;
        }
        set shadowNearPlane(value) {
            this._dataModule.shadowNearPlane = value;
        }
        get lightmapBakedType() {
            return this._lightmapBakedType;
        }
        set lightmapBakedType(value) {
            let premode = this._lightmapBakedType;
            if (this._lightmapBakedType !== value) {
                this._lightmapBakedType = value;
                if (this._enabled) {
                    if (value == exports.LightMode.bakeOnly)
                        this._removeFromScene();
                    else if (premode == exports.LightMode.bakeOnly)
                        this._addToScene();
                }
            }
        }
        get lightWorldMatrix() {
            var position = this.owner.transform.position;
            var quaterian = this.owner.transform.rotation;
            Laya.Matrix4x4.createAffineTransformation(position, quaterian, Laya.Vector3.ONE, this._lightWoldMatrix);
            return this._lightWoldMatrix;
        }
        get lightType() {
            return this._lightType;
        }
        constructor() {
            super();
            this._shadowMode = exports.ShadowMode.None;
            this._isAlternate = false;
            this._lightWoldMatrix = new Laya.Matrix4x4();
            this._creatModuleData();
            this.runInEditor = true;
            this._intensity = 1.0;
            this._intensityColor = new Laya.Vector3();
            this.color = new Laya.Color(1.0, 1.0, 1.0, 1.0);
            this._lightmapBakedType = exports.LightMode.realTime;
            this.shadowResolution = 2048;
            this.shadowDistance = 50.0;
            this.shadowDepthBias = 1.0;
            this.shadowNormalBias = 1.0;
            this.shadowNearPlane = 0.1;
            this.shadowStrength = 1.0;
            this.shadowMode = exports.ShadowMode.None;
        }
        _creatModuleData() {
        }
        _setOwner(node) {
            super._setOwner(node);
            this._dataModule.transform = this.owner.transform;
        }
        _getRenderDataModule() {
            return this._dataModule;
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest.color = this.color.clone();
            dest.intensity = this.intensity;
            dest.lightmapBakedType = this.lightmapBakedType;
        }
        _addToScene() {
            var scene = this.owner.scene;
            var maxLightCount = Laya.Config3D.maxLightCount;
            if (scene._lightCount < maxLightCount) {
                scene._lightCount++;
                this._addToLightQueue();
                this._isAlternate = false;
            }
            else {
                scene._alternateLights.add(this);
                this._isAlternate = true;
                console.warn("LightSprite:light count has large than maxLightCount,the latest added light will be ignore.");
            }
        }
        _removeFromScene() {
            var scene = this.owner._scene;
            if (!scene)
                return;
            if (this._isAlternate) {
                scene._alternateLights.remove(this);
            }
            else {
                scene._lightCount--;
                this._removeFromLightQueue();
                if (scene._alternateLights._length > 0) {
                    var alternateLight = scene._alternateLights.shift();
                    alternateLight._addToLightQueue();
                    alternateLight._isAlternate = false;
                    scene._lightCount++;
                }
            }
        }
        _addToLightQueue() {
        }
        _removeFromLightQueue() {
        }
        _onEnable() {
            (this.lightmapBakedType !== exports.LightMode.bakeOnly) && (this._addToScene());
        }
        _onDisable() {
            (this.lightmapBakedType !== exports.LightMode.bakeOnly) && (this._removeFromScene());
        }
    }

    var FrustumFace;
    (function (FrustumFace) {
        FrustumFace[FrustumFace["Near"] = 0] = "Near";
        FrustumFace[FrustumFace["Far"] = 1] = "Far";
        FrustumFace[FrustumFace["Left"] = 2] = "Left";
        FrustumFace[FrustumFace["Right"] = 3] = "Right";
        FrustumFace[FrustumFace["Bottom"] = 4] = "Bottom";
        FrustumFace[FrustumFace["Top"] = 5] = "Top";
    })(FrustumFace || (FrustumFace = {}));
    exports.ShadowMapFormat = void 0;
    (function (ShadowMapFormat) {
        ShadowMapFormat[ShadowMapFormat["bit16"] = 0] = "bit16";
        ShadowMapFormat[ShadowMapFormat["bit24_8"] = 1] = "bit24_8";
        ShadowMapFormat[ShadowMapFormat["bit32"] = 2] = "bit32";
    })(exports.ShadowMapFormat || (exports.ShadowMapFormat = {}));
    class ShadowUtils {
        static init() {
            ShadowUtils._adjustNearPlane = new Plane(new Laya.Vector3(), 0);
            ShadowUtils._adjustFarPlane = new Plane(new Laya.Vector3(), 0);
        }
        static supportShadow() {
            return Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.RenderTextureFormat_Depth);
        }
        static getTemporaryShadowTexture(witdh, height, shadowFormat) {
            let depthFormat = Laya.RenderTargetFormat.DEPTH_16;
            switch (shadowFormat) {
                case exports.ShadowMapFormat.bit16:
                    depthFormat = Laya.RenderTargetFormat.DEPTH_16;
                    break;
                case exports.ShadowMapFormat.bit24_8:
                    depthFormat = Laya.RenderTargetFormat.DEPTHSTENCIL_24_8;
                    break;
                case exports.ShadowMapFormat.bit32:
                    depthFormat = Laya.RenderTargetFormat.DEPTH_32;
                    break;
            }
            var shadowMap = Laya.RenderTexture.createFromPool(witdh, height, depthFormat, Laya.RenderTargetFormat.None, false, 1);
            shadowMap.compareMode = Laya.TextureCompareMode.LESS;
            shadowMap.filterMode = Laya.FilterMode.Bilinear;
            shadowMap.wrapModeU = Laya.WrapMode.Clamp;
            shadowMap.wrapModeV = Laya.WrapMode.Clamp;
            return shadowMap;
        }
        static getShadowBias(light, shadowProjectionMatrix, shadowResolution, out) {
            var frustumSize;
            if (light._lightType == exports.LightType.Directional) {
                frustumSize = 2.0 / shadowProjectionMatrix.elements[0];
            }
            else if (light._lightType == exports.LightType.Spot) {
                frustumSize = Math.tan(light.spotAngle * 0.5 * Laya.MathUtils3D.Deg2Rad) * light.range;
            }
            else {
                console.warn("ShadowUtils:Only spot and directional shadow casters are supported now.");
                frustumSize = 0.0;
            }
            var texelSize = frustumSize / shadowResolution;
            var depthBias = -light.shadowDepthBias * texelSize;
            var normalBias = -light.shadowNormalBias * texelSize;
            if (light.shadowMode == exports.ShadowMode.SoftHigh) {
                const kernelRadius = 2.5;
                depthBias *= kernelRadius;
                normalBias *= kernelRadius;
            }
            out.setValue(depthBias, normalBias, 0.0, 0.0);
        }
        static getCameraFrustumPlanes(cameraViewProjectMatrix, frustumPlanes) {
            BoundFrustum.getPlanesFromMatrix(cameraViewProjectMatrix, frustumPlanes[FrustumFace.Near], frustumPlanes[FrustumFace.Far], frustumPlanes[FrustumFace.Left], frustumPlanes[FrustumFace.Right], frustumPlanes[FrustumFace.Top], frustumPlanes[FrustumFace.Bottom]);
        }
        static getFarWithRadius(radius, denominator) {
            return Math.sqrt(radius * radius / denominator);
        }
        static getCascadesSplitDistance(twoSplitRatio, fourSplitRatio, cameraNear, shadowFar, fov, aspectRatio, cascadesMode, out) {
            out[0] = cameraNear;
            var range = shadowFar - cameraNear;
            var tFov = Math.tan(fov * 0.5);
            var denominator = 1.0 + tFov * tFov * (aspectRatio * aspectRatio + 1.0);
            switch (cascadesMode) {
                case exports.ShadowCascadesMode.NoCascades:
                    out[1] = ShadowUtils.getFarWithRadius(shadowFar, denominator);
                    break;
                case exports.ShadowCascadesMode.TwoCascades:
                    out[1] = ShadowUtils.getFarWithRadius(cameraNear + range * twoSplitRatio, denominator);
                    out[2] = ShadowUtils.getFarWithRadius(shadowFar, denominator);
                    break;
                case exports.ShadowCascadesMode.FourCascades:
                    out[1] = ShadowUtils.getFarWithRadius(cameraNear + range * fourSplitRatio.x, denominator);
                    out[2] = ShadowUtils.getFarWithRadius(cameraNear + range * fourSplitRatio.y, denominator);
                    out[3] = ShadowUtils.getFarWithRadius(cameraNear + range * fourSplitRatio.z, denominator);
                    out[4] = ShadowUtils.getFarWithRadius(shadowFar, denominator);
                    break;
            }
        }
        static applySliceTransform(shadowSliceData, atlasWidth, atlasHeight, cascadeIndex, outShadowMatrices) {
            var sliceE = _tempMatrix0.elements;
            var oneOverAtlasWidth = 1.0 / atlasWidth;
            var oneOverAtlasHeight = 1.0 / atlasHeight;
            sliceE[0] = shadowSliceData.resolution * oneOverAtlasWidth;
            sliceE[5] = shadowSliceData.resolution * oneOverAtlasHeight;
            sliceE[12] = shadowSliceData.offsetX * oneOverAtlasWidth;
            sliceE[13] = shadowSliceData.offsetY * oneOverAtlasHeight;
            sliceE[1] = sliceE[2] = sliceE[2] = sliceE[4] = sliceE[6] = sliceE[7] = sliceE[8] = sliceE[9] = sliceE[11] = sliceE[14] = 0;
            sliceE[10] = sliceE[15] = 1;
            var offset = cascadeIndex * 16;
            Utils3D._mulMatrixArray(sliceE, outShadowMatrices, offset, outShadowMatrices, offset);
        }
        static getDirectionLightShadowCullPlanes(cameraFrustumPlanes, cascadeIndex, splitDistance, cameraNear, direction, shadowSliceData) {
            var frustumCorners = _frustumCorners;
            var backPlaneFaces = ShadowUtils._backPlaneFaces;
            var planeNeighbors = _frustumPlaneNeighbors;
            var twoPlaneCorners = _frustumTwoPlaneCorners;
            var edgePlanePoint2 = ShadowUtils._edgePlanePoint2;
            var out = shadowSliceData.cullPlanes;
            var near = cameraFrustumPlanes[FrustumFace.Near], far = cameraFrustumPlanes[FrustumFace.Far];
            var left = cameraFrustumPlanes[FrustumFace.Left], right = cameraFrustumPlanes[FrustumFace.Right];
            var bottom = cameraFrustumPlanes[FrustumFace.Bottom], top = cameraFrustumPlanes[FrustumFace.Top];
            var splitNearDistance = splitDistance[cascadeIndex] - cameraNear;
            var splitNear = ShadowUtils._adjustNearPlane;
            var splitFar = ShadowUtils._adjustFarPlane;
            splitNear.normal = near.normal;
            splitFar.normal = far.normal;
            splitNear.distance = near.distance - splitNearDistance;
            splitFar.distance = Math.min(-near.distance + shadowSliceData.sphereCenterZ + shadowSliceData.splitBoundSphere.radius, far.distance);
            BoundFrustum.get3PlaneInterPoint(splitNear, bottom, right, frustumCorners[exports.FrustumCorner.nearBottomRight]);
            BoundFrustum.get3PlaneInterPoint(splitNear, top, right, frustumCorners[exports.FrustumCorner.nearTopRight]);
            BoundFrustum.get3PlaneInterPoint(splitNear, top, left, frustumCorners[exports.FrustumCorner.nearTopLeft]);
            BoundFrustum.get3PlaneInterPoint(splitNear, bottom, left, frustumCorners[exports.FrustumCorner.nearBottomLeft]);
            BoundFrustum.get3PlaneInterPoint(splitFar, bottom, right, frustumCorners[exports.FrustumCorner.FarBottomRight]);
            BoundFrustum.get3PlaneInterPoint(splitFar, top, right, frustumCorners[exports.FrustumCorner.FarTopRight]);
            BoundFrustum.get3PlaneInterPoint(splitFar, top, left, frustumCorners[exports.FrustumCorner.FarTopLeft]);
            BoundFrustum.get3PlaneInterPoint(splitFar, bottom, left, frustumCorners[exports.FrustumCorner.FarBottomLeft]);
            var backIndex = 0;
            for (var i = 0; i < 6; i++) {
                var plane;
                switch (i) {
                    case FrustumFace.Near:
                        plane = splitNear;
                        break;
                    case FrustumFace.Far:
                        plane = splitFar;
                        break;
                    default:
                        plane = cameraFrustumPlanes[i];
                        break;
                }
                if (Laya.Vector3.dot(plane.normal, direction) < 0.0) {
                    plane.cloneTo(out[backIndex]);
                    backPlaneFaces[backIndex] = i;
                    backIndex++;
                }
            }
            var edgeIndex = backIndex;
            for (var i = 0; i < backIndex; i++) {
                var backFace = backPlaneFaces[i];
                var neighborFaces = planeNeighbors[backFace];
                for (var j = 0; j < 4; j++) {
                    var neighborFace = neighborFaces[j];
                    var notBackFace = true;
                    for (var k = 0; k < backIndex; k++)
                        if (neighborFace == backPlaneFaces[k]) {
                            notBackFace = false;
                            break;
                        }
                    if (notBackFace) {
                        var corners = twoPlaneCorners[backFace][neighborFace];
                        var point0 = frustumCorners[corners[0]];
                        var point1 = frustumCorners[corners[1]];
                        Laya.Vector3.add(point0, direction, edgePlanePoint2);
                        Plane.createPlaneBy3P(point0, point1, edgePlanePoint2, out[edgeIndex++]);
                    }
                }
            }
            shadowSliceData.cullPlaneCount = edgeIndex;
        }
        static getBoundSphereByFrustum(near, far, fov, aspectRatio, cameraPos, forward, outBoundSphere) {
            var centerZ;
            var radius;
            var k = Math.sqrt(1.0 + aspectRatio * aspectRatio) * Math.tan(fov / 2.0);
            var k2 = k * k;
            var farSNear = far - near;
            var farANear = far + near;
            if (k2 > farSNear / farANear) {
                centerZ = far;
                radius = far * k;
            }
            else {
                centerZ = 0.5 * farANear * (1 + k2);
                radius = 0.5 * Math.sqrt(farSNear * farSNear + 2.0 * (far * far + near * near) * k2 + farANear * farANear * k2 * k2);
            }
            var center = outBoundSphere.center;
            outBoundSphere.radius = radius;
            Laya.Vector3.scale(forward, centerZ, center);
            Laya.Vector3.add(cameraPos, center, center);
            outBoundSphere.center = center;
            return centerZ;
        }
        static getMaxTileResolutionInAtlas(atlasWidth, atlasHeight, tileCount) {
            var resolution = Math.min(atlasWidth, atlasHeight);
            var currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
            while (currentTileCount < tileCount) {
                resolution = Math.floor(resolution >> 1);
                currentTileCount = Math.floor(atlasWidth / resolution) * Math.floor(atlasHeight / resolution);
            }
            return resolution;
        }
        static getDirectionalLightMatrices(lightUp, lightSide, lightForward, cascadeIndex, nearPlane, shadowResolution, shadowSliceData, shadowMatrices) {
            var boundSphere = shadowSliceData.splitBoundSphere;
            var center = boundSphere.center;
            var radius = boundSphere.radius;
            var halfShadowResolution = shadowResolution / 2;
            var borderRadius = radius * halfShadowResolution / (halfShadowResolution - ShadowUtils.atlasBorderSize);
            var borderDiam = borderRadius * 2.0;
            var sizeUnit = shadowResolution / borderDiam;
            var radiusUnit = borderDiam / shadowResolution;
            var upLen = Math.ceil(Laya.Vector3.dot(center, lightUp) * sizeUnit) * radiusUnit;
            var sideLen = Math.ceil(Laya.Vector3.dot(center, lightSide) * sizeUnit) * radiusUnit;
            var forwardLen = Laya.Vector3.dot(center, lightForward);
            center.x = lightUp.x * upLen + lightSide.x * sideLen + lightForward.x * forwardLen;
            center.y = lightUp.y * upLen + lightSide.y * sideLen + lightForward.y * forwardLen;
            center.z = lightUp.z * upLen + lightSide.z * sideLen + lightForward.z * forwardLen;
            boundSphere.center = center;
            var origin = shadowSliceData.position;
            var viewMatrix = shadowSliceData.viewMatrix;
            var projectMatrix = shadowSliceData.projectionMatrix;
            var viewProjectMatrix = shadowSliceData.viewProjectMatrix;
            shadowSliceData.resolution = shadowResolution;
            shadowSliceData.offsetX = (cascadeIndex % 2) * shadowResolution;
            shadowSliceData.offsetY = Math.floor(cascadeIndex / 2) * shadowResolution;
            Laya.Vector3.scale(lightForward, radius + nearPlane, origin);
            Laya.Vector3.subtract(center, origin, origin);
            Laya.Matrix4x4.createLookAt(origin, center, lightUp, viewMatrix);
            Laya.Matrix4x4.createOrthoOffCenter(-borderRadius, borderRadius, -borderRadius, borderRadius, 0.0, radius * 2.0 + nearPlane, projectMatrix);
            Laya.Matrix4x4.multiply(projectMatrix, viewMatrix, viewProjectMatrix);
            let offsetMat = _shadowMapScaleOffsetMatrix.elements;
            if (Laya.LayaGL.renderEngine._screenInvertY) {
                offsetMat = _shadowMapInvertScaleOffsetMatrix.elements;
            }
            Utils3D._mulMatrixArray(offsetMat, viewProjectMatrix.elements, 0, shadowMatrices, cascadeIndex * 16);
        }
        static prepareShadowReceiverShaderValues(shadowMapWidth, shadowMapHeight, shadowSliceDatas, cascadeCount, shadowMapSize, shadowMatrices, splitBoundSpheres) {
            shadowMapSize.setValue(1.0 / shadowMapWidth, 1.0 / shadowMapHeight, shadowMapWidth, shadowMapHeight);
            if (cascadeCount > 1) {
                const matrixFloatCount = 16;
                for (var i = cascadeCount * matrixFloatCount, n = 4 * matrixFloatCount; i < n; i++)
                    shadowMatrices[i] = 0.0;
                for (var i = 0; i < cascadeCount; i++) {
                    var boundSphere = shadowSliceDatas[i].splitBoundSphere;
                    var center = boundSphere.center;
                    var radius = boundSphere.radius;
                    var offset = i * 4;
                    splitBoundSpheres[offset] = center.x;
                    splitBoundSpheres[offset + 1] = center.y;
                    splitBoundSpheres[offset + 2] = center.z;
                    splitBoundSpheres[offset + 3] = radius * radius;
                }
                const sphereFloatCount = 4;
                for (var i = cascadeCount * sphereFloatCount, n = 4 * sphereFloatCount; i < n; i++)
                    splitBoundSpheres[i] = 0.0;
            }
        }
    }
    ShadowUtils._backPlaneFaces = new Array(5);
    ShadowUtils._edgePlanePoint2 = new Laya.Vector3();
    ShadowUtils.atlasBorderSize = 4.0;
    const _tempMatrix0 = new Laya.Matrix4x4();
    const _shadowMapScaleOffsetMatrix = new Laya.Matrix4x4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.0, 1.0);
    const _shadowMapInvertScaleOffsetMatrix = new Laya.Matrix4x4(0.5, 0.0, 0.0, 0.0, 0.0, -0.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.5, 0.5, 0.0, 1.0);
    const _frustumCorners = [new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3()];
    const _frustumPlaneNeighbors = [
        [FrustumFace.Left, FrustumFace.Right, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Left, FrustumFace.Right, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Top, FrustumFace.Bottom],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Left, FrustumFace.Right],
        [FrustumFace.Near, FrustumFace.Far, FrustumFace.Left, FrustumFace.Right]
    ];
    const _frustumTwoPlaneCorners = [
        [[exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.nearBottomLeft, exports.FrustumCorner.nearTopLeft], [exports.FrustumCorner.nearTopRight, exports.FrustumCorner.nearBottomRight], [exports.FrustumCorner.nearBottomRight, exports.FrustumCorner.nearBottomLeft], [exports.FrustumCorner.nearTopLeft, exports.FrustumCorner.nearTopRight]],
        [[exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.FarTopLeft, exports.FrustumCorner.FarBottomLeft], [exports.FrustumCorner.FarBottomRight, exports.FrustumCorner.FarTopRight], [exports.FrustumCorner.FarBottomLeft, exports.FrustumCorner.FarBottomRight], [exports.FrustumCorner.FarTopRight, exports.FrustumCorner.FarTopLeft]],
        [[exports.FrustumCorner.nearTopLeft, exports.FrustumCorner.nearBottomLeft], [exports.FrustumCorner.FarBottomLeft, exports.FrustumCorner.FarTopLeft], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.nearBottomLeft, exports.FrustumCorner.FarBottomLeft], [exports.FrustumCorner.FarTopLeft, exports.FrustumCorner.nearTopLeft]],
        [[exports.FrustumCorner.nearBottomRight, exports.FrustumCorner.nearTopRight], [exports.FrustumCorner.FarTopRight, exports.FrustumCorner.FarBottomRight], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.FarBottomRight, exports.FrustumCorner.nearBottomRight], [exports.FrustumCorner.nearTopRight, exports.FrustumCorner.FarTopRight]],
        [[exports.FrustumCorner.nearBottomLeft, exports.FrustumCorner.nearBottomRight], [exports.FrustumCorner.FarBottomRight, exports.FrustumCorner.FarBottomLeft], [exports.FrustumCorner.FarBottomLeft, exports.FrustumCorner.nearBottomLeft], [exports.FrustumCorner.nearBottomRight, exports.FrustumCorner.FarBottomRight], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown]],
        [[exports.FrustumCorner.nearTopRight, exports.FrustumCorner.nearTopLeft], [exports.FrustumCorner.FarTopLeft, exports.FrustumCorner.FarTopRight], [exports.FrustumCorner.nearTopLeft, exports.FrustumCorner.FarTopLeft], [exports.FrustumCorner.FarTopRight, exports.FrustumCorner.nearTopRight], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown], [exports.FrustumCorner.unknown, exports.FrustumCorner.unknown]]
    ];

    class ShadowCasterPass {
        static __init__() {
            ShadowCasterPass.SHADOW_BIAS = Laya.Shader3D.propertyNameToID("u_ShadowBias");
            ShadowCasterPass.SHADOW_LIGHT_DIRECTION = Laya.Shader3D.propertyNameToID("u_ShadowLightDirection");
            ShadowCasterPass.SHADOW_SPLIT_SPHERES = Laya.Shader3D.propertyNameToID("u_ShadowSplitSpheres");
            ShadowCasterPass.SHADOW_MATRICES = Laya.Shader3D.propertyNameToID("u_ShadowMatrices");
            ShadowCasterPass.SHADOW_MAP_SIZE = Laya.Shader3D.propertyNameToID("u_ShadowMapSize");
            ShadowCasterPass.SHADOW_MAP = Laya.Shader3D.propertyNameToID("u_ShadowMap");
            ShadowCasterPass.SHADOW_PARAMS = Laya.Shader3D.propertyNameToID("u_ShadowParams");
            ShadowCasterPass.SHADOW_SPOTMAP_SIZE = Laya.Shader3D.propertyNameToID("u_SpotShadowMapSize");
            ShadowCasterPass.SHADOW_SPOTMAP = Laya.Shader3D.propertyNameToID("u_SpotShadowMap");
            ShadowCasterPass.SHADOW_SPOTMATRICES = Laya.Shader3D.propertyNameToID("u_SpotViewProjectMatrix");
            const shadowUniformMap = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("Shadow");
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_LIGHT_DIRECTION, "u_ShadowLightDirection", exports.ShaderDataType.Vector3);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_BIAS, "u_ShadowBias", exports.ShaderDataType.Vector4);
            shadowUniformMap.addShaderUniformArray(ShadowCasterPass.SHADOW_SPLIT_SPHERES, "u_ShadowSplitSpheres", exports.ShaderDataType.Vector4, 4);
            shadowUniformMap.addShaderUniformArray(ShadowCasterPass.SHADOW_MATRICES, "u_ShadowMatrices", exports.ShaderDataType.Matrix4x4, 4);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_MAP_SIZE, "u_ShadowMapSize", exports.ShaderDataType.Vector4);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_MAP, "u_ShadowMap", exports.ShaderDataType.Texture2D);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_PARAMS, "u_ShadowParams", exports.ShaderDataType.Vector4);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPOTMAP_SIZE, "u_SpotShadowMapSize", exports.ShaderDataType.Vector4);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPOTMAP, "u_SpotShadowMap", exports.ShaderDataType.Texture2D);
            shadowUniformMap.addShaderUniform(ShadowCasterPass.SHADOW_SPOTMATRICES, "u_SpotViewProjectMatrix", exports.ShaderDataType.Matrix4x4);
            this.ShadowUniformMap = shadowUniformMap;
        }
        constructor() {
        }
        getDirectLightShadowMap(light) {
            var shadowMapWidth;
            var shadowMapHeight;
            var atlasResolution = light.shadowResolution;
            var cascadesMode = light.shadowCascadesMode;
            var cascadesCount;
            var shadowTileResolution;
            if (cascadesMode == exports.ShadowCascadesMode.NoCascades) {
                shadowTileResolution = atlasResolution;
                shadowMapWidth = atlasResolution;
                shadowMapHeight = atlasResolution;
            }
            else {
                cascadesCount = cascadesMode == exports.ShadowCascadesMode.TwoCascades ? 2 : 4;
                shadowTileResolution = ShadowUtils.getMaxTileResolutionInAtlas(atlasResolution, atlasResolution, cascadesCount);
                shadowMapWidth = shadowTileResolution * 2;
                shadowMapHeight = cascadesMode == exports.ShadowCascadesMode.TwoCascades ? shadowTileResolution : shadowTileResolution * 2;
            }
            this._shadowDirectLightMap && Laya.RenderTexture.recoverToPool(this._shadowDirectLightMap);
            this._shadowDirectLightMap = ShadowUtils.getTemporaryShadowTexture(shadowMapWidth, shadowMapHeight, exports.ShadowMapFormat.bit16);
            return this._shadowDirectLightMap;
        }
        getSpotLightShadowPassData(light) {
            this._shadowSpotLightMap && Laya.RenderTexture.recoverToPool(this._shadowSpotLightMap);
            var shadowResolution = light.shadowResolution;
            var shadowMapWidth = shadowResolution;
            var shadowMapHeight = shadowResolution;
            this._shadowSpotLightMap = ShadowUtils.getTemporaryShadowTexture(shadowMapWidth, shadowMapHeight, exports.ShadowMapFormat.bit16);
            return this._shadowSpotLightMap;
        }
        getPointLightShadowPassData() {
        }
        cleanUp() {
            this._shadowDirectLightMap && Laya.RenderTexture.recoverToPool(this._shadowDirectLightMap);
            this._shadowSpotLightMap && Laya.RenderTexture.recoverToPool(this._shadowSpotLightMap);
            this._shadowDirectLightMap = null;
            this._shadowSpotLightMap = null;
        }
    }

    class DepthPass {
        static __init__() {
            DepthPass.DEPTHPASS = Laya.Shader3D.getDefineByName("DEPTHPASS");
            DepthPass.DEFINE_SHADOW_BIAS = Laya.Shader3D.propertyNameToID("u_ShadowBias");
            DepthPass.DEPTHTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthTexture");
            DepthPass.DEPTHNORMALSTEXTURE = Laya.Shader3D.propertyNameToID("u_CameraDepthNormalsTexture");
            DepthPass.DEPTHZBUFFERPARAMS = Laya.Shader3D.propertyNameToID("u_ZBufferParams");
        }
        constructor() {
        }
        getTarget(camera, depthType, depthTextureFormat) {
            this._viewPort = camera.viewport;
            switch (depthType) {
                case Laya.DepthTextureMode.Depth:
                    camera.depthTexture = this._depthTexture = Laya.RenderTexture.createFromPool(this._viewPort.width, this._viewPort.height, depthTextureFormat, Laya.RenderTargetFormat.None, false, 1);
                    break;
                case Laya.DepthTextureMode.DepthNormals:
                    camera.depthNormalTexture = this._depthNormalsTexture = Laya.RenderTexture.createFromPool(this._viewPort.width, this._viewPort.height, Laya.RenderTargetFormat.R8G8B8A8, depthTextureFormat, false, 1);
                    break;
                case Laya.DepthTextureMode.MotionVectors:
                    break;
                default:
                    throw ("there is UnDefined type of DepthTextureMode");
            }
        }
        _setupDepthModeShaderValue(depthType, camera) {
            switch (depthType) {
                case Laya.DepthTextureMode.Depth:
                    var far = camera.farPlane;
                    var near = camera.nearPlane;
                    this._zBufferParams.setValue(1.0 - far / near, far / near, (near - far) / (near * far), 1 / near);
                    camera._shaderValues.setVector(DepthPass.DEFINE_SHADOW_BIAS, DepthPass.SHADOW_BIAS);
                    camera._shaderValues.setTexture(DepthPass.DEPTHTEXTURE, this._depthTexture);
                    camera._shaderValues.setVector(DepthPass.DEPTHZBUFFERPARAMS, this._zBufferParams);
                    break;
                default:
                    throw ("there is UnDefined type of DepthTextureMode");
            }
        }
        cleanUp() {
            (this._depthTexture instanceof Laya.RenderTexture) && this._depthTexture && Laya.RenderTexture.recoverToPool(this._depthTexture);
            this._depthNormalsTexture && Laya.RenderTexture.recoverToPool(this._depthNormalsTexture);
            this._depthTexture = null;
            this._depthNormalsTexture = null;
        }
    }
    DepthPass.SHADOW_BIAS = new Laya.Vector4();

    class Picker {
        constructor() {
        }
        static calculateCursorRay(point, viewPort, projectionMatrix, viewMatrix, world, out) {
            var x = point.x;
            var y = point.y;
            var nearSource = _tempVector30$2;
            var nerSourceE = nearSource;
            nerSourceE.x = x;
            nerSourceE.y = y;
            nerSourceE.z = viewPort.minDepth;
            var farSource = _tempVector31$3;
            var farSourceE = farSource;
            farSourceE.x = x;
            farSourceE.y = y;
            farSourceE.z = viewPort.maxDepth;
            var nearPoint = out.origin;
            var farPoint = _tempVector32;
            viewPort.unprojectFromWVP(nearSource, projectionMatrix, viewMatrix, world, nearPoint);
            viewPort.unprojectFromWVP(farSource, projectionMatrix, viewMatrix, world, farPoint);
            var outDire = out.direction;
            outDire.x = farPoint.x - nearPoint.x;
            outDire.y = farPoint.y - nearPoint.y;
            outDire.z = farPoint.z - nearPoint.z;
            Laya.Vector3.normalize(out.direction, out.direction);
        }
        static rayIntersectsTriangle(ray, vertex1, vertex2, vertex3) {
            var result;
            var edge1 = _tempVector30$2, edge2 = _tempVector31$3;
            Laya.Vector3.subtract(vertex2, vertex1, edge1);
            Laya.Vector3.subtract(vertex3, vertex1, edge2);
            var directionCrossEdge2 = _tempVector32;
            Laya.Vector3.cross(ray.direction, edge2, directionCrossEdge2);
            var determinant;
            determinant = Laya.Vector3.dot(edge1, directionCrossEdge2);
            if (determinant > -Number.MIN_VALUE && determinant < Number.MIN_VALUE) {
                result = Number.NaN;
                return result;
            }
            var inverseDeterminant = 1.0 / determinant;
            var distanceVector = _tempVector33;
            Laya.Vector3.subtract(ray.origin, vertex1, distanceVector);
            var triangleU;
            triangleU = Laya.Vector3.dot(distanceVector, directionCrossEdge2);
            triangleU *= inverseDeterminant;
            if (triangleU < 0 || triangleU > 1) {
                result = Number.NaN;
                return result;
            }
            var distanceCrossEdge1 = _tempVector34;
            Laya.Vector3.cross(distanceVector, edge1, distanceCrossEdge1);
            var triangleV;
            triangleV = Laya.Vector3.dot(ray.direction, distanceCrossEdge1);
            triangleV *= inverseDeterminant;
            if (triangleV < 0 || triangleU + triangleV > 1) {
                result = Number.NaN;
                return result;
            }
            var rayDistance;
            rayDistance = Laya.Vector3.dot(edge2, distanceCrossEdge1);
            rayDistance *= inverseDeterminant;
            if (rayDistance < 0) {
                result = Number.NaN;
                return result;
            }
            result = rayDistance;
            return result;
        }
        static rayPlaneIntersection(ray, plane) {
            let point = new Laya.Vector3();
            let ddotn = Laya.Vector3.dot(ray.direction.normalize(), plane.normal.normalize());
            if (ddotn == 0) {
                return null;
            }
            let t = (-plane.distance - Laya.Vector3.dot(ray.origin, plane.normal)) / ddotn;
            if (t < 0)
                return null;
            ray.at(t, point);
            return point;
        }
    }
    const _tempVector30$2 = new Laya.Vector3();
    const _tempVector31$3 = new Laya.Vector3();
    const _tempVector32 = new Laya.Vector3();
    const _tempVector33 = new Laya.Vector3();
    const _tempVector34 = new Laya.Vector3();

    class ScreenQuad extends GeometryElement {
        static __init__() {
            ScreenQuad._vertexDeclaration = new Laya.VertexDeclaration(16, [new Laya.VertexElement(0, Laya.VertexElementFormat.Vector4, ScreenQuad.SCREENQUAD_POSITION_UV)]);
            ScreenQuad.instance = new ScreenQuad();
            ScreenQuad.instance.invertY = true;
            ScreenQuad.InvertInstance = new ScreenQuad();
            ScreenQuad.InvertInstance.invertY = false;
        }
        constructor() {
            super(Laya.MeshTopology.TriangleStrip, Laya.DrawType.DrawArray);
            this._bufferState = new Laya.BufferState();
            this._bufferStateInvertUV = new Laya.BufferState();
            this.setDrawArrayParams(0, 4);
            this._vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(16 * 4, Laya.BufferUsage.Static, false);
            this._vertexBuffer.vertexDeclaration = ScreenQuad._vertexDeclaration;
            this._vertexBuffer.setData(ScreenQuad._vertices.buffer);
            this._bufferState.applyState([this._vertexBuffer], null);
            this._vertexBufferInvertUV = Laya3DRender.renderOBJCreate.createVertexBuffer3D(16 * 4, Laya.BufferUsage.Static, false);
            this._vertexBufferInvertUV.vertexDeclaration = ScreenQuad._vertexDeclaration;
            this._vertexBufferInvertUV.setData(ScreenQuad._verticesInvertUV.buffer);
            this._bufferStateInvertUV.applyState([this._vertexBufferInvertUV], null);
            this.invertY = false;
        }
        set invertY(value) {
            value = Laya.LayaGL.renderEngine._screenInvertY ? !value : value;
            this.bufferState = value ? this._bufferStateInvertUV : this._bufferState;
        }
        _updateRenderParams(state) {
        }
        destroy() {
            super.destroy();
            this._bufferState.destroy();
            this._vertexBuffer.destroy();
            this._bufferStateInvertUV.destroy();
            this._vertexBufferInvertUV.destroy();
        }
    }
    ScreenQuad.SCREENQUAD_POSITION_UV = 0;
    ScreenQuad._vertices = new Float32Array([
        1, 1, 1, 1,
        1, -1, 1, 0,
        -1, 1, 0, 1,
        -1, -1, 0, 0
    ]);
    ScreenQuad._verticesInvertUV = new Float32Array([
        1, 1, 1, 0,
        1, -1, 1, 1,
        -1, 1, 0, 0,
        -1, -1, 0, 1
    ]);

    class BlitScreenQuadCMD extends Command {
        static create(source, dest, offsetScale = null, shader = null, shaderData = null, subShader = 0, screenType = BlitScreenQuadCMD._SCREENTYPE_QUAD, commandbuffer = null) {
            var cmd;
            cmd = BlitScreenQuadCMD._pool.length > 0 ? BlitScreenQuadCMD._pool.pop() : new BlitScreenQuadCMD();
            cmd._source = source;
            cmd.dest = dest;
            cmd.offsetScale = offsetScale || BlitScreenQuadCMD._defaultOffsetScale;
            cmd.setshader(shader, subShader, shaderData);
            cmd._commandBuffer = commandbuffer;
            return cmd;
        }
        constructor() {
            super();
            this._source = null;
            this._dest = null;
            this._offsetScale = new Laya.Vector4();
            this._shader = null;
            this._shaderData = null;
            this._internalShaderData = null;
            this._subShader = 0;
            this._blitQuadCMDData = Laya3DRender.Render3DPassFactory.createBlitQuadCMDData();
            this._transform3D = Laya3DRender.Render3DModuleDataFactory.createTransform(null);
            this._renderElement = new RenderElement();
            this._renderElement.setTransform(this._transform3D);
            this._renderElement.setGeometry(ScreenQuad.instance);
            this._blitQuadCMDData.element = this._renderElement._renderElementOBJ;
            this._blitQuadCMDData.element.isRender = true;
        }
        get offsetScale() {
            return this._offsetScale;
        }
        set offsetScale(value) {
            value.cloneTo(this._offsetScale);
            this._blitQuadCMDData.offsetScale = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
            this._blitQuadCMDData.dest = value ? value._renderTarget : null;
        }
        set shaderData(value) {
            if (value) {
                this._shaderData = value;
            }
            else {
                if (!this._internalShaderData)
                    this._internalShaderData = Laya.LayaGL.renderDeviceFactory.createShaderData();
                this._internalShaderData.clearData();
                this._shaderData = this._internalShaderData;
            }
            this._renderElement._renderElementOBJ.materialShaderData = this._shaderData;
        }
        getRenderCMD() {
            return this._blitQuadCMDData;
        }
        setshader(shader, subShader, shaderData) {
            this._shader = shader || Command._screenShader;
            this._subShader = subShader || 0;
            this.shaderData = shaderData;
            this._renderElement.renderSubShader = this._shader.getSubShaderAt(this._subShader);
            this._renderElement._subShaderIndex = subShader;
        }
        run() {
            var source;
            if (!this._source) {
                if (!this._commandBuffer._camera._internalRenderTexture)
                    throw "camera internalRenderTexture is null,please set camera enableBuiltInRenderTexture";
                source = this._commandBuffer._camera._internalRenderTexture;
            }
            else
                source = this._source;
            this._blitQuadCMDData.source = source._texture;
            var dest = this._dest ? this._dest : this._commandBuffer._camera._internalRenderTexture;
            if (dest != this._dest)
                this._blitQuadCMDData.dest = dest._renderTarget;
            if (dest) {
                Laya.Viewport.TEMP.set(0, 0, dest.width, dest.height);
                Laya.Vector4.TEMP.setValue(0, 0, dest.width, dest.height);
                this._blitQuadCMDData.viewport = Laya.Viewport.TEMP;
                this._blitQuadCMDData.scissor = Laya.Vector4.TEMP;
            }
            else {
                let camera = this._commandBuffer._camera;
                let viewport = camera.viewport;
                let vpH = viewport.height;
                let vpY = RenderContext3D.clientHeight - viewport.y - vpH;
                Laya.Viewport.TEMP.set(viewport.x, vpY, viewport.width, vpH);
                Laya.Vector4.TEMP.setValue(viewport.x, vpY, viewport.width, vpH);
                this._blitQuadCMDData.viewport = Laya.Viewport.TEMP;
                this._blitQuadCMDData.scissor = Laya.Vector4.TEMP;
            }
            let invertY = dest ? true : false;
            this._renderElement.setGeometry(invertY ? ScreenQuad.InvertInstance : ScreenQuad.instance);
            Laya.Stat.blitDrawCall++;
        }
        recover() {
            BlitScreenQuadCMD._pool.push(this);
            this._source = null;
            this._dest = null;
            BlitScreenQuadCMD._defaultOffsetScale.cloneTo(this._offsetScale);
            this._shader = null;
            this._shaderData = null;
            super.recover();
        }
        destroy() {
            this._source = null;
            this.dest = null;
            this._offsetScale = null;
            this._shader = null;
            this._shaderData = null;
            if (this._internalShaderData)
                this._internalShaderData.destroy();
            this._internalShaderData = null;
            this._renderElement.destroy();
        }
    }
    BlitScreenQuadCMD._SCREENTYPE_QUAD = 0;
    BlitScreenQuadCMD._SCREENTYPE_TRIANGLE = 1;
    BlitScreenQuadCMD._pool = [];
    BlitScreenQuadCMD._defaultOffsetScale = new Laya.Vector4(0, 0, 1, 1);

    class SetShaderDataCMD extends Command {
        static create(shaderData, nameID, value, shaderDataType, commandBuffer) {
            var cmd;
            cmd = SetShaderDataCMD._pool.length > 0 ? SetShaderDataCMD._pool.pop() : new SetShaderDataCMD();
            cmd._setRenderDataCMD.dest = shaderData;
            cmd._setRenderDataCMD.propertyID = nameID;
            cmd._setRenderDataCMD.dataType = shaderDataType;
            cmd._setRenderDataCMD.value = value;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        constructor() {
            super();
            this._setRenderDataCMD = Laya3DRender.Render3DPassFactory.createSetRenderDataCMD();
        }
        getRenderCMD() {
            return this._setRenderDataCMD;
        }
        recover() {
            SetShaderDataCMD._pool.push(this);
        }
    }
    SetShaderDataCMD.ShaderDataType_define = -2;
    SetShaderDataCMD._pool = [];
    class SetDefineCMD extends Command {
        static create(shaderData, define, addDefine, commandBuffer) {
            var cmd;
            cmd = SetDefineCMD._pool.length > 0 ? SetDefineCMD._pool.pop() : new SetDefineCMD();
            cmd._setRenderDefineCMD.dest = shaderData;
            cmd._setRenderDefineCMD.add = addDefine;
            cmd._setRenderDefineCMD.define = define;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        constructor() {
            super();
            this._setRenderDefineCMD = Laya3DRender.Render3DPassFactory.createSetShaderDefineCMD();
        }
        getRenderCMD() {
            return this._setRenderDefineCMD;
        }
        recover() {
            SetDefineCMD._pool.push(this);
        }
    }
    SetDefineCMD._pool = [];

    class DrawMeshCMD extends Command {
        static create(mesh, matrix, material, subMeshIndex, subShaderIndex, commandBuffer) {
            var cmd;
            cmd = DrawMeshCMD._pool.length > 0 ? DrawMeshCMD._pool.pop() : new DrawMeshCMD();
            cmd._matrix = matrix;
            cmd._transform.worldMatrix = cmd._matrix;
            cmd.material = material;
            cmd.subMeshIndex = subMeshIndex;
            cmd._subShaderIndex = subShaderIndex;
            cmd.mesh = mesh;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        get subMeshIndex() {
            return this._subMeshIndex;
        }
        set subMeshIndex(value) {
            this._subMeshIndex = value;
            this._drawRenderCMDDData.subMeshIndex = value;
        }
        constructor() {
            super();
            this._drawRenderCMDDData = Laya3DRender.Render3DPassFactory.createDrawNodeCMDData();
            this._transform = Laya3DRender.Render3DModuleDataFactory.createTransform(null);
            this._meshRender = new MeshRenderer();
        }
        set material(value) {
            this._material && this._material._removeReference(1);
            this._material = value;
            this._material && this._material._addReference(1);
        }
        get material() {
            return this._material;
        }
        set mesh(value) {
            if (this._mesh == value)
                return;
            this._mesh = value;
            this._meshRender._onMeshChange(this._mesh);
            this._renderElemnts = this._meshRender._renderElements;
            this._renderElemnts.forEach(element => {
                element.material = this._material;
                element.setTransform(this._transform);
                element.renderSubShader = this._material._shader.getSubShaderAt(this._subShaderIndex);
                element._subShaderIndex = this._subShaderIndex;
            });
        }
        getRenderCMD() {
            return this._drawRenderCMDDData;
        }
        run() {
            this._meshRender.sharedMaterial = this.material;
            this._meshRender._baseRenderNode.transform = this._transform;
            this._meshRender.renderUpdate(RenderContext3D._instance);
            this._meshRender.probReflection = RenderContext3D._instance.scene.sceneReflectionProb;
            this._drawRenderCMDDData.destSubShader = this.material.shader.getSubShaderAt(this._subShaderIndex);
            this._drawRenderCMDDData.destShaderData = this.material.shaderData;
            this._drawRenderCMDDData.node = this._meshRender._baseRenderNode;
        }
        recover() {
            DrawMeshCMD._pool.push(this);
            super.recover();
            this._material && (this.material = null);
            this._mesh && (this.mesh = null);
        }
        destroy() {
            super.destroy();
            this._renderElemnts.forEach(element => {
                element.destroy();
            });
            this._material && this._material._removeReference(1);
            this._material = null;
            this._renderElemnts = null;
            this._transform = null;
            this._material = null;
            this._matrix = null;
        }
    }
    DrawMeshCMD._pool = [];

    class DrawRenderCMD extends Command {
        static create(render, material, subMeshIndex, commandBuffer) {
            var cmd;
            cmd = DrawRenderCMD._pool.length > 0 ? DrawRenderCMD._pool.pop() : new DrawRenderCMD();
            cmd.render = render;
            cmd.material = material;
            cmd.subMeshIndex = subMeshIndex;
            cmd._commandBuffer = commandBuffer;
            return cmd;
        }
        get render() {
            return this._render;
        }
        set render(render) {
            this._drawNodeCMDData.node = render._baseRenderNode;
            this._render = render;
        }
        get material() {
            return this._material;
        }
        set material(value) {
            this._material && this._material._removeReference(1);
            if (value) {
                value._addReference(1);
                this._drawNodeCMDData.destShaderData = value.shaderData;
                this._drawNodeCMDData.destSubShader = value.shader.getSubShaderAt(0);
            }
            else {
                this._drawNodeCMDData.destShaderData = null;
                this._drawNodeCMDData.destSubShader = null;
            }
            this._material = value;
        }
        get subMeshIndex() {
            return this._subMeshIndex;
        }
        set subMeshIndex(value) {
            this._subMeshIndex = value;
            this._drawNodeCMDData.subMeshIndex = value;
        }
        constructor() {
            super();
            this._drawNodeCMDData = Laya3DRender.Render3DPassFactory.createDrawNodeCMDData();
        }
        getRenderCMD() {
            return this._drawNodeCMDData;
        }
        run() {
            if (this.render) {
                this.render.renderUpdate(this._context);
                this._prematerial = this.render.sharedMaterials[this.subMeshIndex];
            }
        }
        recover() {
            DrawRenderCMD._pool.push(this);
            super.recover();
            this.material = null;
            this.render.sharedMaterials[this.subMeshIndex] = this._prematerial;
            this._render = null;
            this.subMeshIndex = 0;
        }
        destroy() {
            super.destroy();
            this.material = null;
        }
    }
    DrawRenderCMD._pool = [];

    class SetGlobalShaderDataCMD extends Command {
        static create(nameID, value, shaderDataType, commandBuffer) {
            let context = RenderContext3D._instance;
            let shaderData = context._contextOBJ.globalShaderData;
            if (!shaderData)
                shaderData = context._contextOBJ.globalShaderData = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
            var cmd = SetShaderDataCMD.create(shaderData, nameID, value, shaderDataType, commandBuffer);
            return cmd;
        }
    }

    class MeshInstanceGeometry extends GeometryElement {
        constructor(subMesh) {
            super(subMesh ? subMesh._geometryElementOBj.mode : Laya.MeshTopology.Triangles, Laya.DrawType.DrawElementInstance);
            this._subMesh = subMesh;
            if (subMesh)
                this.indexFormat = subMesh._mesh.indexFormat;
        }
        set subMesh(value) {
            this._subMesh = value;
            if (value)
                this.indexFormat = value._mesh.indexFormat;
            this.mode = value._geometryElementOBj.mode;
        }
        get subMesh() {
            return this._subMesh;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            let byteCount;
            switch (this.indexFormat) {
                case Laya.IndexFormat.UInt32:
                    byteCount = 4;
                    break;
                case Laya.IndexFormat.UInt16:
                    byteCount = 2;
                    break;
                case Laya.IndexFormat.UInt8:
                    byteCount = 1;
                    break;
            }
            this.setDrawElemenParams(this._subMesh.indexCount, this._subMesh._indexStart * byteCount);
        }
    }

    class DrawMeshInstancedCMD extends Command {
        static create(mesh, subMeshIndex, matrixs, material, subShaderIndex, instanceProperty, drawnums, commandBuffer) {
            var cmd;
            if ((matrixs && matrixs.length > DrawMeshInstancedCMD.maxInstanceCount) || drawnums > DrawMeshInstancedCMD.maxInstanceCount) {
                throw "the number of renderings exceeds the maximum number of merges";
            }
            cmd = DrawMeshInstancedCMD._pool.length > 0 ? DrawMeshInstancedCMD._pool.pop() : new DrawMeshInstancedCMD();
            cmd._matrixs = matrixs;
            cmd.material = material;
            cmd._subMeshIndex = subMeshIndex;
            cmd._subShaderIndex = subShaderIndex;
            cmd._commandBuffer = commandBuffer;
            cmd._instanceProperty = instanceProperty;
            cmd._drawnums = drawnums;
            cmd.mesh = mesh;
            matrixs && cmd._updateWorldMatrixBuffer();
            cmd._setInstanceBuffer();
            return cmd;
        }
        constructor() {
            super();
            this._subShaderIndex = 0;
            this._transform = Laya3DRender.Render3DModuleDataFactory.createTransform(null);
            this._instanceRenderElementArray = [];
            this._instanceGeometryArray = [];
            this._instanceWorldMatrixData = new Float32Array(DrawMeshInstancedCMD.maxInstanceCount * 20);
            this._instanceWorldMatrixBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(this._instanceWorldMatrixData.length * 4, Laya.BufferUsage.Dynamic, false);
            this._instanceWorldMatrixBuffer.vertexDeclaration = Laya.VertexMesh.instanceWorldMatrixDeclaration;
            this._instanceWorldMatrixBuffer.instanceBuffer = true;
            this._render = new BaseRender();
            this._render._baseRenderNode.shaderData.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_GPU_INSTANCE);
            this._instanceBufferState = new Laya.BufferState();
            this._drawElementCMDData = Laya3DRender.Render3DPassFactory.createDrawElementCMDData();
        }
        set material(value) {
            this._material && this._material._removeReference(1);
            this._material = value;
            this._material && this._material._addReference(1);
        }
        get bufferState() {
            return this._instanceWorldMatrixBuffer;
        }
        get mesh() {
            return this._mesh;
        }
        set mesh(value) {
            if (this._mesh == value)
                return;
            BaseRender.changeVertexDefine(this._mesh, value, this._render._baseRenderNode.shaderData);
            this._mesh = value;
            if (!this._mesh)
                return;
            let submeshs = this._mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let element = this._instanceRenderElementArray[i] = this._instanceRenderElementArray[i] ? this._instanceRenderElementArray[i] : new RenderElement();
                    let geometry = this._instanceGeometryArray[i] = this._instanceGeometryArray[i] ? this._instanceGeometryArray[i] : new MeshInstanceGeometry(submeshs[i]);
                    element.setGeometry(geometry);
                    element.transform = this._transform;
                    element.material = this._material;
                    element._subShaderIndex = this._subShaderIndex;
                    element.render = this._render;
                    element._renderElementOBJ.owner = this._render._baseRenderNode;
                    geometry.bufferState = this._instanceBufferState;
                    geometry.instanceCount = this._drawnums;
                }
            }
            else {
                let element = this._instanceRenderElementArray[0] = this._instanceRenderElementArray[0] ? this._instanceRenderElementArray[0] : new RenderElement();
                let geometry = this._instanceGeometryArray[0] = this._instanceGeometryArray[0] ? this._instanceGeometryArray[0] : new MeshInstanceGeometry(submeshs[this._subMeshIndex]);
                element.setGeometry(geometry);
                element.transform = this._transform;
                element.material = this._material;
                element.render = this._render;
                geometry.bufferState = this._instanceBufferState;
                geometry.instanceCount = this._drawnums;
                element._renderElementOBJ.owner = this._render._baseRenderNode;
            }
        }
        _setInstanceBuffer() {
            let instanceBufferState = this._instanceBufferState;
            let vertexArray = [];
            let meshVertexBuffer = this._mesh._bufferState._vertexBuffers;
            meshVertexBuffer.forEach(element => {
                vertexArray.push(element);
            });
            vertexArray.push(this._instanceWorldMatrixBuffer);
            let propertyMap = this._instanceProperty._propertyMap;
            for (let i in propertyMap) {
                vertexArray.push(propertyMap[i]._vertexBuffer);
            }
            instanceBufferState.applyState(vertexArray, this._mesh._indexBuffer);
            this._instanceGeometryArray.forEach(element => {
                element.bufferState = instanceBufferState;
            });
        }
        _updateWorldMatrixBuffer() {
            let worldMatrixData = this._instanceWorldMatrixData;
            let count = this._drawnums;
            for (let i = 0; i < count; i++) {
                worldMatrixData.set(this._matrixs[i].elements, i * 20);
            }
            let worldBuffer = this._instanceWorldMatrixBuffer;
            worldBuffer.setData(worldMatrixData.buffer, 0, 0, count * 80);
        }
        setWorldMatrix(worldMatrixArray) {
            if (worldMatrixArray.length < this._drawnums)
                throw "worldMatrixArray length is less then drawnums";
            this._matrixs = worldMatrixArray;
            this._matrixs && this._updateWorldMatrixBuffer();
        }
        setDrawNums(drawNums) {
            if (this._matrixs && this._matrixs.length < drawNums)
                throw "worldMatrixArray length is less then drawnums";
            this._drawnums = drawNums;
            let submeshs = this._mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let geometry = this._instanceGeometryArray[i] ? this._instanceGeometryArray[i] : new MeshInstanceGeometry(submeshs[i]);
                    geometry.instanceCount = this._drawnums;
                }
            }
            else {
                let geometry = this._instanceGeometryArray[0] ? this._instanceGeometryArray[0] : new MeshInstanceGeometry(submeshs[0]);
                geometry.instanceCount = this._drawnums;
            }
            this._matrixs && this._updateWorldMatrixBuffer();
        }
        getRenderCMD() {
            return this._drawElementCMDData;
        }
        renderUpdateElement(renderElement, context) {
            let renderObj = renderElement._renderElementOBJ;
            renderObj.isRender = renderElement._geometry._prepareRender(context);
            renderElement._geometry._updateRenderParams(context);
            return renderObj;
        }
        run() {
            let context = RenderContext3D._instance;
            context._contextOBJ.cameraUpdateMask = Camera._updateMark;
            let propertyMap = this._instanceProperty._propertyMap;
            for (let i in propertyMap) {
                propertyMap[i].updateVertexBufferData(this._drawnums);
            }
            let submeshs = this.mesh._subMeshes;
            if (this._subMeshIndex == -1) {
                let arrayElement = [];
                for (let i = 0, n = submeshs.length; i < n; i++) {
                    let renderElement = this._instanceRenderElementArray[i];
                    let renderObj = this.renderUpdateElement(renderElement, context);
                    arrayElement.push(renderObj);
                }
                this._drawElementCMDData.setRenderelements(arrayElement);
            }
            else {
                let renderElement = this._instanceRenderElementArray[this._subMeshIndex];
                let renderObj = this.renderUpdateElement(renderElement, context);
                this._drawElementCMDData.setRenderelements([renderObj]);
            }
        }
        recover() {
            DrawMeshInstancedCMD._pool.push(this);
            super.recover();
            this._material && this._material._removeReference(1);
            this._material = null;
            this._instanceBufferState.destroy();
            this._instanceBufferState = null;
            delete this._instanceRenderElementArray;
            this._instanceRenderElementArray = [];
            delete this._instanceGeometryArray;
            this._instanceGeometryArray = [];
            this.mesh = null;
        }
        destroy() {
            super.destroy();
            this._material && this._material._removeReference(1);
            this._material = null;
            this._instanceBufferState.destroy();
            this._instanceBufferState = null;
            delete this._instanceRenderElementArray;
            this._instanceRenderElementArray = [];
            delete this._instanceGeometryArray;
            this._instanceGeometryArray = [];
            this.mesh = null;
        }
    }
    DrawMeshInstancedCMD._pool = [];
    DrawMeshInstancedCMD.maxInstanceCount = 1024;

    class SetRTCMD extends Command {
        static create(renderTexture, clearColor, clearDepth, clearStencil, backgroundColor, depth = 1, stencil = 0, commandBuffer) {
            var cmd;
            cmd = SetRTCMD._pool.length > 0 ? SetRTCMD._pool.pop() : new SetRTCMD();
            cmd.renderTexture = renderTexture;
            let clearflag = 0;
            if (clearColor) {
                clearflag |= Laya.RenderClearFlag.Color;
                cmd._setRenderTargetCMD.clearColorValue = backgroundColor;
            }
            if (clearDepth) {
                clearflag |= Laya.RenderClearFlag.Depth;
                cmd._setRenderTargetCMD.clearDepthValue = depth;
            }
            if (clearStencil) {
                clearflag |= Laya.RenderClearFlag.Stencil;
                cmd._setRenderTargetCMD.clearStencilValue = stencil;
            }
            cmd._setRenderTargetCMD.clearFlag = clearflag;
            return cmd;
        }
        get renderTexture() {
            return this._renderTexture;
        }
        set renderTexture(value) {
            this._renderTexture = value;
            this._setRenderTargetCMD.rt = value._renderTarget;
        }
        constructor() {
            super();
            this._renderTexture = null;
            this._setRenderTargetCMD = Laya3DRender.Render3DPassFactory.createSetRenderTargetCMD();
        }
        getRenderCMD() {
            return this._setRenderTargetCMD;
        }
        recover() {
            SetRTCMD._pool.push(this);
            this._renderTexture = null;
        }
    }
    SetRTCMD._pool = [];

    class DrawRenderElementCMD extends Command {
        static create(renderElement) {
            var cmd;
            cmd = DrawRenderElementCMD._pool.length > 0 ? DrawRenderElementCMD._pool.pop() : new DrawRenderElementCMD();
            cmd.renderElement = renderElement;
            return cmd;
        }
        get renderElement() {
            return this._renderElement;
        }
        set renderElement(value) {
            this._renderElement = value;
            this._drawElementCMDData.setRenderelements([this._renderElement._renderElementOBJ]);
        }
        constructor() {
            super();
            this._drawElementCMDData = Laya3DRender.Render3DPassFactory.createDrawElementCMDData();
        }
        recover() {
            super.recover();
            DrawRenderElementCMD._pool.push(this);
        }
        getRenderCMD() {
            return this._drawElementCMDData;
        }
        destroy() {
            this._renderElement = null;
            this._drawElementCMDData = null;
        }
    }
    DrawRenderElementCMD._pool = [];

    class CommandBuffer {
        constructor(name = null, shadowCaster = false) {
            this._shadow = false;
            this._camera = null;
            this._commands = [];
            this._renderCMDs = [];
            this._name = name;
            this._shadow = shadowCaster;
        }
        get name() {
            return this._name;
        }
        get casterShadow() {
            return this._shadow;
        }
        get context() {
            return this._context;
        }
        set context(value) {
            this._context = value;
        }
        _apply(render = false) {
            for (var i = 0, n = this._commands.length; i < n; i++) {
                let cmd = this._commands[i];
                cmd.run && cmd.run();
            }
            render && this.context._contextOBJ.runCMDList(this._renderCMDs);
            Laya.Stat.cmdDrawCall += this._renderCMDs.length;
        }
        _applyOne() {
            if (this._commands.length) {
                var cmd = this._commands.shift();
                cmd.run && cmd.run();
                cmd.getRenderCMD && this.context._contextOBJ.runOneCMD(this._renderCMDs.shift());
                cmd.recover();
            }
            return this._commands.length > 0;
        }
        getCommandsSize() {
            return this._commands.length;
        }
        setShaderDataTexture(shaderData, nameID, source) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, source, exports.ShaderDataType.Texture2D, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalTexture(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Texture2D, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataColor(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Color, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalColor(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Color, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataVector(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Vector4, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalVector(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Vector4, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataVector3(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Vector3, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalVector3(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Vector3, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataVector2(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Vector2, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalVector2(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Vector2, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataNumber(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Float, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalNumber(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Float, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataInt(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Int, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalInt(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Int, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDataMatrix(shaderData, nameID, value) {
            let cmd = SetShaderDataCMD.create(shaderData, nameID, value, exports.ShaderDataType.Matrix4x4, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setShaderDefine(shaderData, define, value) {
            let cmd = SetDefineCMD.create(shaderData, define, value, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setGlobalMatrix(nameID, source) {
            let cmd = SetGlobalShaderDataCMD.create(nameID, source, exports.ShaderDataType.Matrix4x4, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitScreenQuad(source, dest, offsetScale = null, shader = null, shaderData = null, subShader = 0) {
            let cmd = BlitScreenQuadCMD.create(source, dest, offsetScale, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_QUAD, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitScreenQuadByMaterial(source, dest, offsetScale = null, material = null, subShader = 0) {
            var shader;
            var shaderData;
            if (material) {
                shader = material._shader;
                shaderData = material.shaderData;
            }
            let cmd = BlitScreenQuadCMD.create(source, dest, offsetScale, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_QUAD, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        blitScreenTriangle(source, dest, offsetScale = null, shader = null, shaderData = null, subShader = 0) {
            let cmd = BlitScreenQuadCMD.create(source, dest, offsetScale, shader, shaderData, subShader, BlitScreenQuadCMD._SCREENTYPE_TRIANGLE, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        setRenderTarget(renderTexture, clearColor, clearDepth, backgroundColor = Laya.Color.BLACK, depth = 1) {
            let cmd = SetRTCMD.create(renderTexture, clearColor, clearDepth, false, backgroundColor, depth, 0, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawMesh(mesh, matrix, material, submeshIndex, subShaderIndex) {
            let cmd = DrawMeshCMD.create(mesh, matrix, material, submeshIndex, subShaderIndex, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawRender(render, material, subMeshIndex = 0) {
            let cmd = DrawRenderCMD.create(render, material, subMeshIndex, this);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawRenderElement(renderElement) {
            let cmd = DrawRenderElementCMD.create(renderElement);
            this._commands.push(cmd);
            cmd.getRenderCMD && this._renderCMDs.push(cmd.getRenderCMD());
        }
        drawMeshInstance(mesh, subMeshIndex = 0, matrixs, material, subShaderIndex = 0, instanceProperty, drawnums) {
            if (!Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.DrawElement_Instance))
                return null;
            var drawMeshInstancedCMD = DrawMeshInstancedCMD.create(mesh, subMeshIndex, matrixs, material, subShaderIndex, instanceProperty, drawnums, this);
            this._commands.push(drawMeshInstancedCMD);
            drawMeshInstancedCMD.getRenderCMD && this._renderCMDs.push(drawMeshInstancedCMD.getRenderCMD());
            return drawMeshInstancedCMD;
        }
        addCustomCMD(command) {
            command._commandBuffer = this;
            this._commands.push(command);
            command.getRenderCMD && this._renderCMDs.push(command.getRenderCMD());
        }
        clear() {
            for (var i = 0, n = this._commands.length; i < n; i++)
                this._commands[i].recover();
            this._commands.length = 0;
            this._renderCMDs.length = 0;
        }
    }

    exports.CameraClearFlags = void 0;
    (function (CameraClearFlags) {
        CameraClearFlags[CameraClearFlags["SolidColor"] = 0] = "SolidColor";
        CameraClearFlags[CameraClearFlags["Sky"] = 1] = "Sky";
        CameraClearFlags[CameraClearFlags["DepthOnly"] = 2] = "DepthOnly";
        CameraClearFlags[CameraClearFlags["Nothing"] = 3] = "Nothing";
        CameraClearFlags[CameraClearFlags["ColorOnly"] = 4] = "ColorOnly";
    })(exports.CameraClearFlags || (exports.CameraClearFlags = {}));
    exports.CameraEventFlags = void 0;
    (function (CameraEventFlags) {
        CameraEventFlags[CameraEventFlags["BeforeForwardOpaque"] = 0] = "BeforeForwardOpaque";
        CameraEventFlags[CameraEventFlags["BeforeSkyBox"] = 2] = "BeforeSkyBox";
        CameraEventFlags[CameraEventFlags["BeforeTransparent"] = 4] = "BeforeTransparent";
        CameraEventFlags[CameraEventFlags["BeforeImageEffect"] = 6] = "BeforeImageEffect";
        CameraEventFlags[CameraEventFlags["AfterEveryThing"] = 8] = "AfterEveryThing";
    })(exports.CameraEventFlags || (exports.CameraEventFlags = {}));
    class Camera extends BaseCamera {
        static get _updateMark() {
            return RenderContext3D._instance._contextOBJ.cameraUpdateMask;
        }
        static set _updateMark(value) {
            RenderContext3D._instance._contextOBJ.cameraUpdateMask = value;
        }
        static drawRenderTextureByScene(camera, scene, renderTexture) {
            if (!renderTexture)
                return null;
            Scene3D._updateMark++;
            if (!scene.parent)
                scene._update();
            else {
                scene.sceneRenderableManager.renderUpdate();
                scene.skyRenderer.renderUpdate(RenderContext3D._instance);
            }
            scene._prepareSceneToRender();
            scene._setCullCamera(camera);
            let recoverTexture = camera.renderTarget;
            camera.renderTarget = renderTexture;
            let originScene = camera.scene;
            camera._scene = scene;
            camera.render(scene);
            camera.renderTarget = recoverTexture;
            scene.recaculateCullCamera();
            scene._componentDriver.callPostRender();
            camera._aftRenderMainPass();
            camera._scene = originScene;
            return renderTexture;
        }
        static getTexturePixel(texture) {
            let coverFilter = texture.filterMode;
            texture.filterMode = Laya.FilterMode.Point;
            let rtFormat = Laya.RenderTargetFormat.R8G8B8;
            let pixelData;
            let size = texture.width * texture.height;
            switch (texture.format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32A32;
                    pixelData = new Float32Array(size * 4);
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32;
                    pixelData = new Float32Array(size * 3);
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8;
                    pixelData = new Uint8Array(size * 3);
                    break;
                default:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8A8;
                    pixelData = new Uint8Array(size * 4);
                    break;
            }
            let rt = Laya.RenderTexture.createFromPool(texture.width, texture.height, rtFormat, Laya.RenderTargetFormat.None, false, 0, false);
            let cmd = new CommandBuffer();
            cmd.blitScreenQuad(texture, rt);
            cmd.context = RenderContext3D._instance;
            cmd._applyOne();
            texture.filterMode = coverFilter;
            rt.getData(0, 0, texture.width, texture.height, pixelData);
            rt.destroy();
            return pixelData;
        }
        static getTexturePixelAsync(texture) {
            let coverFilter = texture.filterMode;
            texture.filterMode = Laya.FilterMode.Point;
            let rtFormat = Laya.RenderTargetFormat.R8G8B8;
            let pixelData;
            let size = texture.width * texture.height;
            switch (texture.format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32A32;
                    pixelData = new Float32Array(size * 4);
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32;
                    pixelData = new Float32Array(size * 3);
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8;
                    pixelData = new Uint8Array(size * 3);
                    break;
                default:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8A8;
                    pixelData = new Uint8Array(size * 4);
                    break;
            }
            let rt = Laya.RenderTexture.createFromPool(texture.width, texture.height, rtFormat, Laya.RenderTargetFormat.None, false, 0, false);
            let cmd = new CommandBuffer();
            cmd.blitScreenQuad(texture, rt);
            cmd.context = RenderContext3D._instance;
            cmd._applyOne();
            texture.filterMode = coverFilter;
            const pd = rt.getDataAsync(0, 0, texture.width, texture.height, pixelData);
            rt.destroy();
            return pd;
        }
        static drawTextureCubePixelByScene(camera, scene, renderCubeSize, format, cullingMask) {
            let rtFormat = Laya.RenderTargetFormat.R8G8B8;
            let pixelData;
            let size = renderCubeSize * renderCubeSize;
            let bytelength;
            switch (format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32A32;
                    size *= 4;
                    bytelength = 4;
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    rtFormat = Laya.RenderTargetFormat.R32G32B32;
                    size *= 3;
                    bytelength = 4;
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8;
                    size *= 3;
                    bytelength = 1;
                    break;
                case Laya.TextureFormat.R8G8B8A8:
                    rtFormat = Laya.RenderTargetFormat.R8G8B8A8;
                    pixelData = new Uint8Array(size * 4);
                    size *= 4;
                    bytelength = 1;
                    break;
                default:
                    throw new Error("Type is not supported");
            }
            let rt = new Laya.RenderTexture(renderCubeSize, renderCubeSize, rtFormat, Laya.RenderTargetFormat.DEPTH_16, false, 0, false, false);
            camera.fieldOfView = 90;
            camera.cullingMask = cullingMask;
            let pixels = [];
            let quaterionArray = [
                new Laya.Quaternion(0, 1, 0, 0),
                new Laya.Quaternion(0, 0, 0, 1),
                new Laya.Quaternion(0, 0.7071068, 0, 0.7071068),
                new Laya.Quaternion(0, 0.7071068, 0, -0.7071068),
                new Laya.Quaternion(0, 0.7071068, -0.7071068, 0),
                new Laya.Quaternion(0, -0.7071068, -0.7071068, 0),
            ];
            for (var i = 0; i < 6; i++) {
                camera.transform.rotation = quaterionArray[i];
                this.drawRenderTextureByScene(camera, scene, rt);
                if (bytelength == 4)
                    pixelData = new Float32Array(size);
                else
                    pixelData = new Uint8Array(size);
                pixels[i] = rt.getData(0, 0, renderCubeSize, renderCubeSize, pixelData);
            }
            rt.destroy();
            return pixels;
        }
        static drawTextureCubeByScene(camera, position, scene, renderCubeSize, format, cullingMask = 0) {
            camera.transform.position = position;
            let pixels = this.drawTextureCubePixelByScene(camera, scene, renderCubeSize, format, cullingMask);
            switch (format) {
                case Laya.TextureFormat.R32G32B32A32:
                case Laya.TextureFormat.R16G16B16A16:
                    Laya.TextureFormat.R32G32B32A32;
                    break;
                case Laya.TextureFormat.R32G32B32:
                case Laya.TextureFormat.R16G16B16:
                    Laya.TextureFormat.R32G32B32;
                    break;
                case Laya.TextureFormat.R5G6B5:
                case Laya.TextureFormat.R8G8B8:
                    Laya.TextureFormat.R8G8B8;
                    break;
                case Laya.TextureFormat.R8G8B8A8:
                    Laya.TextureFormat.R8G8B8A8;
                    break;
                default:
                    throw new Error("Type is not supported");
            }
            let textureCube = new Laya.TextureCube(renderCubeSize, format, true, false);
            textureCube.setPixelsData(pixels, false, false);
            return textureCube;
        }
        static __init__() {
            Camera.depthPass = new DepthPass();
        }
        set nearPlane(value) {
            super.nearPlane = value;
            this._renderDataModule.nearplane = value;
        }
        get nearPlane() {
            return this._nearPlane;
        }
        set farPlane(value) {
            super.farPlane = value;
            this._renderDataModule.farplane = value;
        }
        get farPlane() {
            return this._farPlane;
        }
        set fieldOfView(value) {
            super.fieldOfView = value;
            this._renderDataModule.fieldOfView = value;
        }
        get fieldOfView() {
            return this._fieldOfView;
        }
        get aspectRatio() {
            if (this._aspectRatio === 0) {
                var vp = this.viewport;
                return vp.width / vp.height;
            }
            return this._aspectRatio;
        }
        set aspectRatio(value) {
            if (value < 0)
                throw new Error("Camera: the aspect ratio has to be a positive real number.");
            this._aspectRatio = value;
            this._renderDataModule.aspectRatio = value;
            this._calculateProjectionMatrix();
        }
        get viewport() {
            if (this._offScreenRenderTexture)
                this._calculationViewport(this._normalizedViewport, this._offScreenRenderTexture.width, this._offScreenRenderTexture.height);
            else
                this._calculationViewport(this._normalizedViewport, this.clientWidth, this.clientHeight);
            return this._viewport;
        }
        set viewport(value) {
            var width;
            var height;
            if (this._offScreenRenderTexture) {
                width = this._offScreenRenderTexture.width;
                height = this._offScreenRenderTexture.height;
            }
            else {
                width = this.clientWidth;
                height = this.clientHeight;
            }
            this._normalizedViewport.x = value.x / width;
            this._normalizedViewport.y = value.y / height;
            this._normalizedViewport.width = value.width / width;
            this._normalizedViewport.height = value.height / height;
            this._calculationViewport(this._normalizedViewport, width, height);
            this._calculateProjectionMatrix();
        }
        get clientWidth() {
            Laya.ILaya.stage.needUpdateCanvasSize();
            if (Laya.Config3D.customResolution)
                return Laya.Config3D.pixelRatio * Laya.Config3D._resoluWidth | 0;
            else
                return RenderContext3D.clientWidth * Laya.Config3D.pixelRatio | 0;
        }
        get clientHeight() {
            Laya.ILaya.stage.needUpdateCanvasSize();
            if (Laya.Config3D.customResolution)
                return Laya.Config3D.pixelRatio * Laya.Config3D._resoluHeight | 0;
            else
                return RenderContext3D.clientHeight * Laya.Config3D.pixelRatio | 0;
        }
        set msaa(value) {
            Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.MSAA) ? this._msaa = value : this._msaa = false;
        }
        get msaa() {
            return this._msaa && Laya.Stat.enablemsaa;
        }
        set fxaa(value) {
            this._fxaa = value;
        }
        get fxaa() {
            return this._fxaa;
        }
        get normalizedViewport() {
            return this._normalizedViewport;
        }
        set normalizedViewport(value) {
            var width;
            var height;
            if (this._offScreenRenderTexture) {
                width = this._offScreenRenderTexture.width;
                height = this._offScreenRenderTexture.height;
            }
            else {
                width = this.clientWidth;
                height = this.clientHeight;
            }
            if (this._normalizedViewport !== value)
                value.cloneTo(this._normalizedViewport);
            this._calculationViewport(value, width, height);
            this._calculateProjectionMatrix();
        }
        get viewMatrix() {
            if (this._updateViewMatrix) {
                var scale = this.transform.getWorldLossyScale();
                var scaleX = scale.x;
                var scaleY = scale.y;
                var scaleZ = scale.z;
                var viewMatE = this._viewMatrix.elements;
                this.transform.worldMatrix.cloneTo(this._viewMatrix);
                viewMatE[0] /= scaleX;
                viewMatE[1] /= scaleX;
                viewMatE[2] /= scaleX;
                viewMatE[4] /= scaleY;
                viewMatE[5] /= scaleY;
                viewMatE[6] /= scaleY;
                viewMatE[8] /= scaleZ;
                viewMatE[9] /= scaleZ;
                viewMatE[10] /= scaleZ;
                this._viewMatrix.invert(this._viewMatrix);
                this._updateViewMatrix = false;
                if (this.skyRenderElement._renderElementOBJ)
                    this.skyRenderElement.calculateViewMatrix(this._viewMatrix);
            }
            return this._viewMatrix;
        }
        get projectionMatrix() {
            return this._projectionMatrix;
        }
        set projectionMatrix(value) {
            this._projectionMatrix = value;
            this._useUserProjectionMatrix = true;
        }
        get projectionViewMatrix() {
            Laya.Matrix4x4.multiply(this.projectionMatrix, this.viewMatrix, this._projectionViewMatrix);
            this._renderDataModule.setProjectionViewMatrix(this._projectionViewMatrix);
            return this._projectionViewMatrix;
        }
        get boundFrustum() {
            this._boundFrustum.matrix = this.projectionViewMatrix;
            return this._boundFrustum;
        }
        get renderTarget() {
            return this._offScreenRenderTexture;
        }
        set renderTarget(value) {
            var lastValue = this._offScreenRenderTexture;
            if (lastValue !== value) {
                (lastValue) && (lastValue._isCameraTarget = false);
                (value) && (value._isCameraTarget = true);
                this._offScreenRenderTexture = value;
                this._calculateProjectionMatrix();
            }
        }
        get postProcess() {
            return this._postProcess;
        }
        set postProcess(value) {
            this._postProcess = value;
        }
        get enableHDR() {
            return this._enableHDR;
        }
        set enableHDR(value) {
            if (value && !Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.RenderTextureFormat_R16G16B16A16)) {
                console.warn("Camera:can't enable HDR in this device.");
                return;
            }
            this._enableHDR = value;
        }
        get enableBuiltInRenderTexture() {
            return this._needBuiltInRenderTexture;
        }
        set enableBuiltInRenderTexture(value) {
            this._needBuiltInRenderTexture = value;
        }
        get depthTextureMode() {
            return this._depthTextureMode;
        }
        set depthTextureMode(value) {
            this._depthTextureMode = value;
            if (!Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.RenderTextureFormat_Depth)) {
                this._depthTextureMode &= ~Laya.DepthTextureMode.Depth;
            }
        }
        set opaquePass(value) {
            if (value == this._opaquePass)
                return;
            if (!value) {
                this._shaderValues.setTexture(BaseCamera.OPAQUETEXTURE, Laya.Texture2D.blackTexture);
                this._shaderValues.setVector(BaseCamera.OPAQUETEXTUREPARAMS, Laya.Vector4.ONE);
                this._opaqueTexture && Laya.RenderTexture.recoverToPool(this._opaqueTexture);
                this._opaqueTexture = null;
            }
            this._opaquePass = value;
        }
        get opaquePass() {
            return this._opaquePass;
        }
        get depthTextureFormat() {
            return this._depthTextureFormat;
        }
        set depthTextureFormat(value) {
            this._depthTextureFormat = value;
        }
        set enableBlitDepth(value) {
            if (value == this._canBlitDepth)
                return;
            this._canBlitDepth = value;
            this._cacheDepth = value;
            this._internalRenderTexture && Laya.RenderTexture.recoverToPool(this._internalRenderTexture);
            this._internalRenderTexture = Laya.RenderTexture.createFromPool(this.viewport.width, this.viewport.height, this._getRenderTextureFormat(), this.depthTextureFormat, false, this.msaa ? 4 : 1, this._canBlitDepth, this._needRenderGamma(this._getRenderTextureFormat()));
            if (!value) {
                if (this._cacheDepthTexture)
                    this._cacheDepthTexture._inPool ? 0 : Laya.RenderTexture.recoverToPool(this._cacheDepthTexture);
            }
        }
        get enableBlitDepth() {
            return this._canBlitDepth;
        }
        get canblitDepth() {
            return this._canBlitDepth && this._internalRenderTexture && this._internalRenderTexture.depthStencilFormat != null;
        }
        constructor(aspectRatio = 0, nearPlane = 0.3, farPlane = 1000) {
            super(nearPlane, farPlane);
            this._updateViewMatrix = true;
            this._postProcess = null;
            this._enableHDR = false;
            this._viewportParams = new Laya.Vector4();
            this._projectionParams = new Laya.Vector4();
            this._needBuiltInRenderTexture = false;
            this._msaa = false;
            this._fxaa = false;
            this._offScreenRenderTexture = null;
            this._internalRenderTexture = null;
            this._canBlitDepth = false;
            this._internalCommandBuffer = new CommandBuffer();
            this._depthTextureFormat = Laya.RenderTargetFormat.DEPTH_32;
            this._cameraEventCommandBuffer = {};
            this._shadowCasterCommanBuffer = [];
            this._clusterPlaneCacheFlag = new Laya.Vector2(-1, -1);
            this._screenOffsetScale = new Laya.Vector4();
            this.enableRender = true;
            this.clearFlag = exports.CameraClearFlags.SolidColor;
            this.opaqueTextureSize = 512;
            this._renderDataModule = Laya3DRender.Render3DModuleDataFactory.createCameraModuleData();
            this._Render3DProcess = Laya3DRender.Render3DPassFactory.createRender3DProcess();
            this._renderDataModule.transform = this.transform;
            this._viewMatrix = new Laya.Matrix4x4();
            this._projectionMatrix = new Laya.Matrix4x4();
            this._projectionViewMatrix = new Laya.Matrix4x4();
            this._viewport = new Laya.Viewport(0, 0, 0, 0);
            this._normalizedViewport = new Laya.Viewport(0, 0, 1, 1);
            this._rayViewport = new Laya.Viewport(0, 0, 0, 0);
            this._aspectRatio = aspectRatio;
            this._boundFrustum = new BoundFrustum(new Laya.Matrix4x4());
            this.depthTextureMode = 0;
            this.opaquePass = false;
            this._calculateProjectionMatrix();
            Laya.ILaya.stage.on(Laya.Event.RESIZE, this, this._onScreenSizeChanged);
            this.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            this.opaquePass = false;
            this._internalCommandBuffer.context = RenderContext3D._instance;
            this._renderDataModule.farplane = this.farPlane;
            this._renderDataModule.nearplane = this.nearPlane;
            this._renderDataModule.fieldOfView = this.fieldOfView;
            this._renderDataModule.aspectRatio = this.aspectRatio;
        }
        _calculationViewport(normalizedViewport, width, height) {
            var lx = normalizedViewport.x * width;
            var ly = normalizedViewport.y * height;
            var rx = lx + Math.max(normalizedViewport.width * width, 0);
            var ry = ly + Math.max(normalizedViewport.height * height, 0);
            var ceilLeftX = Math.ceil(lx);
            var ceilLeftY = Math.ceil(ly);
            var floorRightX = Math.floor(rx);
            var floorRightY = Math.floor(ry);
            var pixelLeftX = ceilLeftX - lx >= 0.5 ? Math.floor(lx) : ceilLeftX;
            var pixelLeftY = ceilLeftY - ly >= 0.5 ? Math.floor(ly) : ceilLeftY;
            var pixelRightX = rx - floorRightX >= 0.5 ? Math.ceil(rx) : floorRightX;
            var pixelRightY = ry - floorRightY >= 0.5 ? Math.ceil(ry) : floorRightY;
            this._viewport.x = pixelLeftX;
            this._viewport.y = pixelLeftY;
            this._viewport.width = pixelRightX - pixelLeftX;
            this._viewport.height = pixelRightY - pixelLeftY;
        }
        _calculateProjectionMatrix() {
            if (!this._useUserProjectionMatrix) {
                if (this._orthographic) {
                    var halfHeight = this.orthographicVerticalSize * 0.5;
                    var halfWidth = halfHeight * this.aspectRatio;
                    Laya.Matrix4x4.createOrthoOffCenter(-halfWidth, halfWidth, -halfHeight, halfHeight, this.nearPlane, this.farPlane, this._projectionMatrix);
                }
                else {
                    Laya.Matrix4x4.createPerspective(3.1416 * this.fieldOfView / 180.0, this.aspectRatio, this.nearPlane, this.farPlane, this._projectionMatrix);
                }
                if (this.skyRenderElement._renderElementOBJ)
                    this.skyRenderElement.caluclateProjectionMatrix(this._projectionMatrix, this.aspectRatio, this.nearPlane, this.farPlane, this.fieldOfView, this.orthographic);
            }
        }
        _isLayerVisible(layer) {
            return (Math.pow(2, layer) & this.cullingMask) != 0;
        }
        _onTransformChanged(flag) {
            flag &= Transform3D.TRANSFORM_WORLDMATRIX;
            (flag) && (this._updateViewMatrix = true);
        }
        clone() {
            let camera = super.clone();
            camera.clearFlag = this.clearFlag;
            this.clearColor.cloneTo(camera.clearColor);
            camera.clearColor = camera.clearColor;
            camera.viewport = this.viewport;
            this.normalizedViewport.cloneTo(camera.normalizedViewport);
            camera.enableHDR = this.enableHDR;
            camera.farPlane = this.farPlane;
            camera.nearPlane = this.nearPlane;
            camera.fieldOfView = this.fieldOfView;
            camera.orthographic = this.orthographic;
            camera.orthographicVerticalSize = this.orthographicVerticalSize;
            camera.opaquePass = this.opaquePass;
            camera._cameraEventCommandBuffer = this._cameraEventCommandBuffer;
            camera.opaquePass = this.opaquePass;
            return camera;
        }
        _getCanvasWidth() {
            if (this._offScreenRenderTexture)
                return this._offScreenRenderTexture.width;
            else
                return this.clientWidth;
        }
        _getCanvasHeight() {
            if (this._offScreenRenderTexture)
                return this._offScreenRenderTexture.height;
            else
                return this.clientHeight;
        }
        _getRenderTexture() {
            return this._internalRenderTexture || this._offScreenRenderTexture;
        }
        _needRenderGamma(rt) {
            switch (rt) {
                case Laya.RenderTargetFormat.R8G8B8:
                case Laya.RenderTargetFormat.R8G8B8A8:
                    return true;
                default:
                    return false;
            }
        }
        _needInternalRenderTexture() {
            let needInternalRT = this.enableBuiltInRenderTexture;
            if (this.renderTarget) {
                if (this.msaa) {
                    needInternalRT = needInternalRT || !(this.renderTarget.samples > 1);
                }
                if (this.enableHDR) {
                    switch (this.renderTarget.format) {
                        case Laya.TextureFormat.R16G16B16A16:
                        case Laya.TextureFormat.R16G16B16:
                        case Laya.TextureFormat.R32G32B32A32:
                        case Laya.TextureFormat.R32G32B32:
                            break;
                        default:
                            needInternalRT = true;
                            break;
                    }
                }
                if (this.postProcess && this.postProcess.enable && this.postProcess.effects.length > 0) {
                    needInternalRT = true;
                }
                if (this.normalizedViewport.width != 1 || this.normalizedViewport.height != 1 || this.normalizedViewport.x != 0 || this.normalizedViewport.y != 0) {
                    needInternalRT = true;
                }
            }
            return needInternalRT;
        }
        _getRenderTextureFormat() {
            if (this._enableHDR)
                return Laya.RenderTargetFormat.R16G16B16A16;
            else
                return Laya.RenderTargetFormat.R8G8B8A8;
        }
        _updateCameraRenderData(context) {
            this._prepareCameraToRender();
            this._applyViewProject(this.viewMatrix, this._projectionMatrix, context.invertY);
            this._contextApply(context);
        }
        _prepareCameraToRender() {
            super._prepareCameraToRender();
            var vp = this.viewport;
            this._viewportParams.setValue(vp.x, vp.y, vp.width, vp.height);
            let invertY = Laya.LayaGL.renderEngine._screenInvertY ? !RenderContext3D._instance.invertY : RenderContext3D._instance.invertY;
            this._projectionParams.setValue(this._nearPlane, this._farPlane, invertY ? -1 : 1, 1 / this.farPlane);
            this._shaderValues.setVector(BaseCamera.VIEWPORT, this._viewportParams);
            this._shaderValues.setVector(BaseCamera.PROJECTION_PARAMS, this._projectionParams);
        }
        _contextApply(context) {
            context.viewMatrix = this.viewMatrix;
            context.projectionMatrix = this.projectionMatrix;
            context.projectionViewMatrix = this.projectionViewMatrix;
        }
        _applyViewProject(viewMat, proMat, invertY) {
            var projectView;
            if (invertY) {
                Laya.Matrix4x4.multiply(BaseCamera._invertYScaleMatrix, proMat, BaseCamera._invertYProjectionMatrix);
                Laya.Matrix4x4.multiply(BaseCamera._invertYProjectionMatrix, viewMat, BaseCamera._invertYProjectionViewMatrix);
                proMat = BaseCamera._invertYProjectionMatrix;
                projectView = BaseCamera._invertYProjectionViewMatrix;
            }
            else {
                Laya.Matrix4x4.multiply(proMat, viewMat, this._projectionViewMatrix);
                this._renderDataModule.setProjectionViewMatrix(this._projectionViewMatrix);
                projectView = this._projectionViewMatrix;
            }
            this._shaderValues.setMatrix4x4(BaseCamera.VIEWMATRIX, viewMat);
            this._shaderValues.setMatrix4x4(BaseCamera.PROJECTMATRIX, proMat);
            this._shaderValues.setMatrix4x4(BaseCamera.VIEWPROJECTMATRIX, projectView);
        }
        _updateClusterPlaneXY() {
            var fieldOfView = this.fieldOfView;
            var aspectRatio = this.aspectRatio;
            if (this._clusterPlaneCacheFlag.x !== fieldOfView || this._clusterPlaneCacheFlag.y !== aspectRatio) {
                var clusterCount = Laya.Config3D.lightClusterCount;
                var xSlixe = clusterCount.x, ySlice = clusterCount.y;
                var xCount = xSlixe + 1, yCount = ySlice + 1;
                var xPlanes = this._clusterXPlanes, yPlanes = this._clusterYPlanes;
                if (!xPlanes) {
                    xPlanes = this._clusterXPlanes = new Array(xCount);
                    yPlanes = this._clusterYPlanes = new Array(yCount);
                    for (var i = 0; i < xCount; i++)
                        xPlanes[i] = new Laya.Vector3();
                    for (var i = 0; i < yCount; i++)
                        yPlanes[i] = new Laya.Vector3();
                }
                var halfY = Math.tan((this.fieldOfView / 2) * Math.PI / 180);
                var halfX = this.aspectRatio * halfY;
                var yLengthPerCluster = 2 * halfY / ySlice;
                var xLengthPerCluster = 2 * halfX / xSlixe;
                for (var i = 0; i < xCount; i++) {
                    var angle = -halfX + xLengthPerCluster * i;
                    var bigHypot = Math.sqrt(1 + angle * angle);
                    var normX = 1 / bigHypot;
                    var xPlane = xPlanes[i];
                    xPlane.setValue(normX, 0, -angle * normX);
                }
                for (var i = 0; i < yCount; i++) {
                    var angle = halfY - yLengthPerCluster * i;
                    var bigHypot = Math.sqrt(1 + angle * angle);
                    var normY = -1 / bigHypot;
                    var yPlane = yPlanes[i];
                    yPlane.setValue(0, normY, -angle * normY);
                }
                this._clusterPlaneCacheFlag.x = fieldOfView;
                this._clusterPlaneCacheFlag.y = aspectRatio;
            }
        }
        _addCasterShadowCommandBuffer(commandBuffer) {
            if (this._shadowCasterCommanBuffer.indexOf(commandBuffer) < 0)
                this._shadowCasterCommanBuffer.push(commandBuffer);
        }
        _removeCasterShadowCommandBuffer(commandBuffer) {
            var index = this._shadowCasterCommanBuffer.indexOf(commandBuffer);
            if (index != -1)
                this._shadowCasterCommanBuffer.splice(index, 1);
        }
        _preRenderMainPass(context, scene, needInternalRT, viewport) {
            context.camera = this;
            context.cameraShaderValue = this._shaderValues;
            Camera._updateMark++;
            if (needInternalRT && !this._offScreenRenderTexture && (this.clearFlag == exports.CameraClearFlags.DepthOnly || this.clearFlag == exports.CameraClearFlags.Nothing)) {
                if (Laya.RenderTexture.bindCanvasRender) {
                    if (Laya.RenderTexture.bindCanvasRender != this._internalRenderTexture) {
                        this._internalCommandBuffer.clear();
                        this._internalCommandBuffer.blitScreenQuad(Laya.RenderTexture.bindCanvasRender, this._internalRenderTexture);
                        this._internalCommandBuffer._applyOne();
                    }
                }
                else {
                    if (this._enableHDR) {
                        var grabTexture = Laya.RenderTexture.createFromPool(viewport.width, viewport.height, Laya.RenderTargetFormat.R8G8B8, Laya.RenderTargetFormat.DEPTH_16, false, 1);
                        grabTexture.filterMode = Laya.FilterMode.Bilinear;
                        this._renderEngine.copySubFrameBuffertoTex(grabTexture._texture, 0, 0, 0, viewport.x, RenderContext3D.clientHeight - (viewport.y + viewport.height), viewport.width, viewport.height);
                        this._internalCommandBuffer.clear();
                        this._internalCommandBuffer.blitScreenQuad(grabTexture, this._internalRenderTexture);
                        this._internalCommandBuffer._apply(true);
                        Laya.RenderTexture.recoverToPool(grabTexture);
                    }
                }
            }
        }
        get depthTexture() {
            return this._depthTexture;
        }
        set depthTexture(value) {
            this._depthTexture = value;
        }
        get depthNormalTexture() {
            return this._depthNormalsTexture;
        }
        set depthNormalTexture(value) {
            this._depthNormalsTexture = value;
        }
        _aftRenderMainPass() {
            if (this._cacheDepth && this._internalRenderTexture) {
                if (this._cacheDepthTexture)
                    this._cacheDepthTexture._inPool ? 0 : Laya.RenderTexture.recoverToPool(this._cacheDepthTexture);
                this._cacheDepthTexture = this._internalRenderTexture;
            }
            else {
                this._internalRenderTexture && Laya.RenderTexture.recoverToPool(this._internalRenderTexture);
            }
        }
        _createOpaqueTexture() {
            if (!this._opaqueTexture) {
                let tex = this._getRenderTexture();
                let size = this.opaqueTextureSize;
                this._opaqueTexture = Laya.RenderTexture.createFromPool(size, size, tex.colorFormat, Laya.RenderTargetFormat.None, true, 1, false, true);
                this._opaqueTexture.filterMode = Laya.FilterMode.Bilinear;
                this._opaqueTexture.wrapModeU = Laya.WrapMode.Clamp;
                this._opaqueTexture.wrapModeV = Laya.WrapMode.Clamp;
                this._shaderValues.setTexture(BaseCamera.OPAQUETEXTURE, this._opaqueTexture);
                let opaqueTexParams = new Laya.Vector4();
                opaqueTexParams.x = this._opaqueTexture.width;
                opaqueTexParams.y = this._opaqueTexture.height;
                opaqueTexParams.z = this._opaqueTexture.maxMipmapLevel;
                this._shaderValues.setVector(BaseCamera.OPAQUETEXTUREPARAMS, opaqueTexParams);
            }
        }
        render(scene) {
            let context = RenderContext3D._instance;
            context.scene = scene;
            context.camera = this;
            scene._setCullCamera(this);
            this._Render3DProcess.render3DManager = scene.sceneRenderableManager._sceneManagerOBJ;
            let viewport = this.viewport;
            let needInternalRT = this._needInternalRenderTexture();
            if (needInternalRT) {
                let multiSampler = this.msaa ? 4 : 1;
                let frameFormat = this._getRenderTextureFormat();
                let depthFormat = this.depthTextureFormat;
                let gamma = this._needRenderGamma(frameFormat);
                let internalRT = Laya.RenderTexture.createFromPool(viewport.width, viewport.height, frameFormat, depthFormat, false, multiSampler, this.canblitDepth, gamma);
                internalRT.filterMode = Laya.FilterMode.Bilinear;
                this._internalRenderTexture = internalRT;
            }
            else {
                this._internalRenderTexture = null;
            }
            if (this.opaquePass && !this._opaqueTexture) {
                this._createOpaqueTexture();
            }
            context.invertY = false;
            let renderRT = this._getRenderTexture();
            if (renderRT) {
                context.invertY = renderRT._isCameraTarget ? !Laya.LayaGL.renderEngine._screenInvertY : false;
            }
            this._prepareCameraToRender();
            this._applyViewProject(this.viewMatrix, this.projectionMatrix, context.invertY);
            this._contextApply(context);
            if (this.clearFlag == exports.CameraClearFlags.Sky) {
                scene.skyRenderer.setRenderElement(this.skyRenderElement);
                this.skyRenderElement.renderpre(context);
            }
            scene._componentDriver.callPreRender();
            this._preRenderMainPass(context, scene, needInternalRT, viewport);
            let multiLight = Laya.Config3D._multiLighting;
            if (multiLight) {
                Cluster.instance.update(this, scene);
            }
            var time = performance.now();
            this._Render3DProcess.fowardRender(context._contextOBJ, this);
            Laya.Stat.renderPassStatArray[Laya.RenderPassStatisticsInfo.T_CameraRender] += (performance.now() - time);
            scene._componentDriver.callPostRender();
        }
        viewportPointToRay(point, out) {
            _tempVector20.setValue(point.x * Laya.ILaya.stage.clientScaleX * Laya.Config3D.pixelRatio, point.y * Laya.ILaya.stage.clientScaleY * Laya.Config3D.pixelRatio);
            this._rayViewport.x = this.viewport.x;
            this._rayViewport.y = this.viewport.y;
            this._rayViewport.width = this.viewport.width;
            this._rayViewport.height = this.viewport.height;
            Picker.calculateCursorRay(_tempVector20, this._rayViewport, this._projectionMatrix, this.viewMatrix, null, out);
        }
        normalizedViewportPointToRay(point, out) {
            var vp = this.normalizedViewport;
            _tempVector20.x = point.x * Laya.Config3D.pixelRatio * vp.width;
            _tempVector20.y = point.y * Laya.Config3D.pixelRatio * vp.height;
            Picker.calculateCursorRay(_tempVector20, this.viewport, this._projectionMatrix, this.viewMatrix, null, out);
        }
        worldToViewportPoint(position, out) {
            Laya.Matrix4x4.multiply(this._projectionMatrix, this._viewMatrix, this._projectionViewMatrix);
            this.viewport.project(position, this._projectionViewMatrix, out);
            var r = Laya.Config3D.pixelRatio;
            let _wr = (out.x - this.viewport.x) / r;
            let _hr = (out.y - this.viewport.y) / r;
            out.x = _wr + this.viewport.x;
            out.y = _hr + this.viewport.y;
            out.x = (out.x / Laya.ILaya.stage.clientScaleX) | 0;
            out.y = (out.y / Laya.ILaya.stage.clientScaleY) | 0;
        }
        worldToNormalizedViewportPoint(position, out) {
            this.worldToViewportPoint(position, out);
            out.x = out.x / Laya.ILaya.stage.width;
            out.y = out.y / Laya.ILaya.stage.height;
        }
        convertScreenCoordToOrthographicCoord(source, out) {
            if (this._orthographic) {
                var clientWidth = this.clientWidth;
                var clientHeight = this.clientHeight;
                var ratioX = this.orthographicVerticalSize * this.aspectRatio / clientWidth;
                var ratioY = this.orthographicVerticalSize / clientHeight;
                out.x = (-clientWidth / 2 + source.x * Laya.ILaya.stage.clientScaleX) * ratioX;
                out.y = (clientHeight / 2 - source.y * Laya.ILaya.stage.clientScaleY) * ratioY;
                out.z = (this.nearPlane - this.farPlane) * (source.z + 1) / 2 - this.nearPlane;
                Laya.Vector3.transformCoordinate(out, this.transform.worldMatrix, out);
                return true;
            }
            else {
                return false;
            }
        }
        destroy(destroyChild = true) {
            this._shaderValues.destroy();
            this._internalRenderTexture && (!this._internalRenderTexture._inPool) && Laya.RenderTexture.recoverToPool(this._internalRenderTexture);
            this._offScreenRenderTexture = null;
            if (this._opaqueTexture) {
                Laya.RenderTexture.recoverToPool(this._opaqueTexture);
            }
            this._Render3DProcess.destroy();
            this.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onTransformChanged);
            Laya.ILaya.stage.off(Laya.Event.RESIZE, this, this._onScreenSizeChanged);
            this._cameraEventCommandBuffer = {};
            if (RenderContext3D._instance.camera == this) {
                RenderContext3D._instance.cameraShaderValue = null;
                RenderContext3D._instance.camera = null;
            }
            super.destroy(destroyChild);
        }
        addCommandBuffer(event, commandBuffer) {
            var commandBufferArray = this._cameraEventCommandBuffer[event];
            if (!commandBufferArray)
                commandBufferArray = this._cameraEventCommandBuffer[event] = [];
            if (commandBufferArray.indexOf(commandBuffer) < 0)
                commandBufferArray.push(commandBuffer);
            commandBuffer._camera = this;
            if (commandBuffer.casterShadow) {
                this._addCasterShadowCommandBuffer(commandBuffer);
            }
        }
        removeCommandBuffer(event, commandBuffer) {
            var commandBufferArray = this._cameraEventCommandBuffer[event];
            if (commandBufferArray) {
                var index = commandBufferArray.indexOf(commandBuffer);
                if (index != -1)
                    commandBufferArray.splice(index, 1);
                commandBuffer.casterShadow && this._removeCasterShadowCommandBuffer(commandBuffer);
            }
            else
                throw "Camera:unknown event.";
        }
        removeCommandBuffers(event) {
            if (this._cameraEventCommandBuffer[event])
                this._cameraEventCommandBuffer[event].length = 0;
        }
    }
    Camera._context3DViewPortCatch = new Laya.Viewport(0, 0, 0, 0);
    Camera._contextScissorPortCatch = new Laya.Vector4(0, 0, 0, 0);
    const _tempVector20 = new Laya.Vector2();

    class BlitFrameBufferCMD {
        static __init__() {
            BlitFrameBufferCMD.shaderdata = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
        }
        static create(source, dest, viewport, offsetScale = null, shader = null, shaderData = null, subShader = 0) {
            var cmd;
            cmd = BlitFrameBufferCMD._pool.length > 0 ? BlitFrameBufferCMD._pool.pop() : new BlitFrameBufferCMD();
            cmd._source = source;
            cmd._dest = dest;
            cmd._offsetScale = offsetScale;
            cmd.setshader(shader, subShader, shaderData);
            cmd._source && cmd._texture_size.setValue(source.width, source.height, 1.0 / source.width, 1.0 / source.height);
            cmd._viewPort = viewport;
            return cmd;
        }
        constructor() {
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._texture_size = null;
            this._shader = null;
            this._shaderData = null;
            this._subShader = 0;
            this._viewPort = null;
            this._transform3D = Laya3DRender.Render3DModuleDataFactory.createTransform(null);
            this._renderElement = new RenderElement();
            this._renderElement.setTransform(this._transform3D);
            this._renderElement.setGeometry(ScreenQuad.instance);
            this._renderElement._renderElementOBJ.isRender = true;
            this._texture_size = new Laya.Vector4();
        }
        set shaderData(value) {
            this._shaderData = value || BlitFrameBufferCMD.shaderdata;
            this._renderElement._renderElementOBJ.materialShaderData = this._shaderData;
        }
        setshader(shader, subShader, shaderData) {
            this._shader = shader || Command._screenShader;
            this._subShader = subShader || 0;
            this.shaderData = shaderData;
            this._renderElement.renderSubShader = this._shader.getSubShaderAt(this._subShader);
        }
        run() {
            if (!this._source || !this._viewPort)
                return;
            var source = this._source;
            var dest = this._dest;
            var shaderData = this._shaderData;
            let context = RenderContext3D._instance;
            var viewport = this._viewPort;
            let vph = RenderContext3D.clientHeight - viewport.y - viewport.height;
            if (Laya.LayaGL.renderEngine._screenInvertY) {
                context.changeViewport(viewport.x, viewport.y, viewport.width, viewport.height);
                context.changeScissor(viewport.x, viewport.y, viewport.width, viewport.height);
            }
            else {
                context.changeViewport(viewport.x, vph, viewport.width, viewport.height);
                context.changeScissor(viewport.x, vph, viewport.width, viewport.height);
            }
            shaderData.setTexture(Command.SCREENTEXTURE_ID, source);
            shaderData.setVector(Command.SCREENTEXTUREOFFSETSCALE_ID, this._offsetScale || BlitFrameBufferCMD._defaultOffsetScale);
            source && (shaderData.setVector(Command.MAINTEXTURE_TEXELSIZE_ID, this._texture_size));
            if (dest) {
                shaderData.removeDefine(RenderContext3D.GammaCorrect);
            }
            else {
                shaderData.addDefine(RenderContext3D.GammaCorrect);
            }
            this._renderElement.setGeometry(ScreenQuad.InvertInstance);
            context.destTarget = dest;
            context._contextOBJ.cameraUpdateMask = Camera._updateMark;
            context.drawRenderElement(this._renderElement._renderElementOBJ);
            Laya.Stat.blitDrawCall++;
        }
        recover() {
            BlitFrameBufferCMD._pool.push(this);
            this._source = null;
            this._dest = null;
            this._offsetScale = null;
            this._shader = null;
            this._shaderData = null;
            this._viewPort = null;
        }
    }
    BlitFrameBufferCMD._pool = [];
    BlitFrameBufferCMD._defaultOffsetScale = new Laya.Vector4(0, 0, 1, 1);

    class SceneRenderManager {
        constructor() {
            this._sceneManagerOBJ = Laya3DRender.Render3DPassFactory.createSceneRenderManager();
        }
        get list() {
            return this._sceneManagerOBJ.list;
        }
        set list(value) {
            this._sceneManagerOBJ.list = value;
        }
        addRenderObject(object) {
            this._sceneManagerOBJ.addRenderObject(object);
        }
        removeRenderObject(object) {
            this._sceneManagerOBJ.removeRenderObject(object);
        }
        removeMotionObject(object) {
            this._sceneManagerOBJ.removeMotionObject(object);
        }
        updateMotionObjects() {
            this._sceneManagerOBJ.updateMotionObjects();
        }
        renderUpdate() {
            var context = RenderContext3D._instance;
            let lists = this._sceneManagerOBJ.list.elements;
            for (let i = 0, n = this.list.length; i < n; i++) {
                lists[i].renderUpdate(context);
            }
        }
        addMotionObject(object) {
            this._sceneManagerOBJ.addMotionObject(object);
        }
        destroy() {
            this._sceneManagerOBJ.destroy();
        }
    }

    class UI3DManager {
        constructor() {
            this._UI3Dlist = new Laya.FastSinglelist();
        }
        add(value) {
            this._UI3Dlist.add(value);
        }
        remove(value) {
            this._UI3Dlist.remove(value);
        }
        update() {
            let elements = this._UI3Dlist.elements;
            for (var i = 0, n = this._UI3Dlist.length; i < n; i++) {
                elements[i]._submitRT();
            }
        }
        rayCast(ray) {
            let rayOri = ray.origin;
            this._UI3Dlist.clean();
            this._UI3Dlist.elements.sort((a, b) => {
                return a._getCameraDistance(rayOri) - b._getCameraDistance(rayOri);
            });
            let elements = this._UI3Dlist.elements;
            for (var i = 0, n = this._UI3Dlist.length; i < n; i++) {
                let hit = elements[i]._checkUIPos(ray);
                if (hit) {
                    return hit;
                }
            }
            return null;
        }
        destory() {
            this._UI3Dlist.destroy();
        }
    }

    exports.FogMode = void 0;
    (function (FogMode) {
        FogMode[FogMode["Linear"] = 0] = "Linear";
        FogMode[FogMode["EXP"] = 1] = "EXP";
        FogMode[FogMode["EXP2"] = 2] = "EXP2";
    })(exports.FogMode || (exports.FogMode = {}));
    class Scene3D extends Laya.Sprite {
        static get _updateMark() {
            return RenderContext3D._instance._contextOBJ.cameraUpdateMask;
        }
        static set _updateMark(value) {
            RenderContext3D._instance._contextOBJ.cameraUpdateMask = value;
        }
        static regManager(type, cla) {
            Scene3D.componentManagerMap.set(type, cla);
        }
        static shaderValueInit() {
            Scene3DShaderDeclaration.SHADERDEFINE_FOG = Laya.Shader3D.getDefineByName("FOG");
            Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR = Laya.Shader3D.getDefineByName("FOG_LINEAR");
            Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP = Laya.Shader3D.getDefineByName("FOG_EXP");
            Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2 = Laya.Shader3D.getDefineByName("FOG_EXP2");
            Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT = Laya.Shader3D.getDefineByName("DIRECTIONLIGHT");
            Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT = Laya.Shader3D.getDefineByName("POINTLIGHT");
            Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT = Laya.Shader3D.getDefineByName("SPOTLIGHT");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW = Laya.Shader3D.getDefineByName("SHADOW");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_CASCADE = Laya.Shader3D.getDefineByName("SHADOW_CASCADE");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_LOW = Laya.Shader3D.getDefineByName("SHADOW_SOFT_SHADOW_LOW");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SOFT_SHADOW_HIGH = Laya.Shader3D.getDefineByName("SHADOW_SOFT_SHADOW_HIGH");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT = Laya.Shader3D.getDefineByName("SHADOW_SPOT");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_LOW = Laya.Shader3D.getDefineByName("SHADOW_SPOT_SOFT_SHADOW_LOW");
            Scene3DShaderDeclaration.SHADERDEFINE_SHADOW_SPOT_SOFT_SHADOW_HIGH = Laya.Shader3D.getDefineByName("SHADOW_SPOT_SOFT_SHADOW_HIGH");
            Scene3D.FOGCOLOR = Laya.Shader3D.propertyNameToID("u_FogColor");
            Scene3D.FOGPARAMS = Laya.Shader3D.propertyNameToID("u_FogParams");
            Scene3D.DIRECTIONLIGHTCOUNT = Laya.Shader3D.propertyNameToID("u_DirationLightCount");
            Scene3D.LIGHTBUFFER = Laya.Shader3D.propertyNameToID("u_LightBuffer");
            Scene3D.CLUSTERBUFFER = Laya.Shader3D.propertyNameToID("u_LightClusterBuffer");
            Scene3D.TIME = Laya.Shader3D.propertyNameToID("u_Time");
            Scene3D.GIRotate = Laya.Shader3D.propertyNameToID("u_GIRotate");
            let sceneUniformMap = Scene3D.sceneUniformMap = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("Scene3D");
            sceneUniformMap.addShaderUniform(Scene3D.TIME, "u_Time", exports.ShaderDataType.Float);
            sceneUniformMap.addShaderUniform(Scene3D.FOGPARAMS, "u_FogParams", exports.ShaderDataType.Vector4);
            sceneUniformMap.addShaderUniform(Scene3D.FOGCOLOR, "u_FogColor", exports.ShaderDataType.Color);
            sceneUniformMap.addShaderUniform(Scene3D.LIGHTBUFFER, "u_LightBuffer", exports.ShaderDataType.Texture2D);
            sceneUniformMap.addShaderUniform(Scene3D.CLUSTERBUFFER, "u_LightClusterBuffer", exports.ShaderDataType.Texture2D);
            sceneUniformMap.addShaderUniform(Scene3D.GIRotate, "u_GIRotate", exports.ShaderDataType.Float);
            sceneUniformMap.addShaderUniform(Scene3D.DIRECTIONLIGHTCOUNT, "u_DirationLightCount", exports.ShaderDataType.Int);
            ReflectionProbe.init();
            VolumetricGI.init();
        }
        static legacyLightingValueInit() {
            Scene3D.LIGHTDIRECTION = Laya.Shader3D.propertyNameToID("u_DirLightDirection");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.LIGHTDIRECTION, "u_DirLightDirection", exports.ShaderDataType.Vector3);
            Scene3D.LIGHTDIRCOLOR = Laya.Shader3D.propertyNameToID("u_DirLightColor");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.LIGHTDIRCOLOR, "u_DirLightColor", exports.ShaderDataType.Vector3);
            Scene3D.LIGHTMODE = Laya.Shader3D.propertyNameToID("u_DirLightMode");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.LIGHTMODE, "u_DirLightMode", exports.ShaderDataType.Int);
            Scene3D.POINTLIGHTPOS = Laya.Shader3D.propertyNameToID("u_PointLightPos");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTPOS, "u_PointLightPos", exports.ShaderDataType.Vector3);
            Scene3D.POINTLIGHTRANGE = Laya.Shader3D.propertyNameToID("u_PointLightRange");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTRANGE, "u_PointLightRange", exports.ShaderDataType.Float);
            Scene3D.POINTLIGHTCOLOR = Laya.Shader3D.propertyNameToID("u_PointLightColor");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTCOLOR, "u_PointLightColor", exports.ShaderDataType.Vector3);
            Scene3D.POINTLIGHTMODE = Laya.Shader3D.propertyNameToID("u_PointLightMode");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.POINTLIGHTMODE, "u_PointLightMode", exports.ShaderDataType.Int);
            Scene3D.SPOTLIGHTPOS = Laya.Shader3D.propertyNameToID("u_SpotLightPos");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTPOS, "u_SpotLightPos", exports.ShaderDataType.Vector3);
            Scene3D.SPOTLIGHTDIRECTION = Laya.Shader3D.propertyNameToID("u_SpotLightDirection");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTDIRECTION, "u_SpotLightDirection", exports.ShaderDataType.Vector3);
            Scene3D.SPOTLIGHTSPOTANGLE = Laya.Shader3D.propertyNameToID("u_SpotLightSpot");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTSPOTANGLE, "u_SpotLightSpot", exports.ShaderDataType.Float);
            Scene3D.SPOTLIGHTRANGE = Laya.Shader3D.propertyNameToID("u_SpotLightRange");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTRANGE, "u_SpotLightRange", exports.ShaderDataType.Float);
            Scene3D.SPOTLIGHTCOLOR = Laya.Shader3D.propertyNameToID("u_SpotLightColor");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTCOLOR, "u_SpotLightColor", exports.ShaderDataType.Vector3);
            Scene3D.SPOTLIGHTMODE = Laya.Shader3D.propertyNameToID("u_SpotLightMode");
            Scene3D.sceneUniformMap.addShaderUniform(Scene3D.SPOTLIGHTMODE, "u_SpotLightMode", exports.ShaderDataType.Int);
        }
        static __init__() {
            var multiLighting = Laya.Config3D._multiLighting;
            if (multiLighting) {
                const width = 4;
                var maxLightCount = Laya.Config3D.maxLightCount;
                var clusterSlices = Laya.Config3D.lightClusterCount;
                Cluster.instance = new Cluster(clusterSlices.x, clusterSlices.y, clusterSlices.z, Math.min(Laya.Config3D.maxLightCount, Laya.Config3D._maxAreaLightCountPerClusterAverage));
                Scene3D._lightTexture = Utils3D._createFloatTextureBuffer(width, maxLightCount);
                Scene3D._lightTexture.lock = true;
                Scene3D._lightPixles = new Float32Array(maxLightCount * width * 4);
            }
            Scene3D.shaderValueInit();
            var configShaderValue = Laya.Shader3D._configDefineValues;
            if (!Laya.Config3D._multiLighting) {
                (configShaderValue.add(Laya.Shader3D.SHADERDEFINE_LEGACYSINGALLIGHTING));
                Scene3D.legacyLightingValueInit();
            }
            Scene3D._shadowCasterPass = new ShadowCasterPass();
            if (Laya.Config._uniformBlock)
                configShaderValue.add(Laya.Shader3D.SHADERDEFINE_ENUNIFORMBLOCK);
            let supportFloatTex = Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.TextureFormat_R32G32B32A32);
            if (supportFloatTex) {
                configShaderValue.add(Laya.Shader3D.SHADERDEFINE_FLOATTEXTURE);
            }
            let supportFloatLinearFiltering = Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Texture_FloatLinearFiltering);
            if (supportFloatLinearFiltering) {
                configShaderValue.add(Laya.Shader3D.SHADERDEFINE_FLOATTEXTURE_FIL_LINEAR);
            }
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url).then((res) => {
                if (complete) {
                    let ret;
                    if (res) {
                        let scene = res.create();
                        if (scene instanceof Laya.Scene)
                            ret = scene._scene3D;
                        else
                            ret = scene;
                    }
                    complete.runWith([ret]);
                }
            });
        }
        get scene2D() {
            return this._scene2D;
        }
        get sceneRenderableManager() {
            return this._sceneRenderManager;
        }
        set sceneRenderableManager(manager) {
            manager.list = this._sceneRenderManager.list;
            this._sceneRenderManager = manager;
        }
        get enableFog() {
            return this._enableFog;
        }
        set enableFog(value) {
            if (this._enableFog !== value) {
                this._enableFog = value;
                if (value) {
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG);
                }
                else
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG);
            }
        }
        get fogMode() {
            return this._fogMode;
        }
        set fogMode(value) {
            this._fogMode = value;
            switch (value) {
                case exports.FogMode.Linear:
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2);
                    break;
                case exports.FogMode.EXP:
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2);
                    break;
                case exports.FogMode.EXP2:
                    this._shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP2);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_LINEAR);
                    this._shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_FOG_EXP);
                    break;
            }
        }
        get fogColor() {
            return this._shaderValues.getColor(Scene3D.FOGCOLOR);
        }
        set fogColor(value) {
            this._shaderValues.setColor(Scene3D.FOGCOLOR, value);
        }
        get fogStart() {
            return this._fogParams.x;
        }
        set fogStart(value) {
            this._fogParams.x = value;
            this.fogParams = this._fogParams;
        }
        get fogEnd() {
            return this._fogParams.y;
        }
        set fogEnd(value) {
            this._fogParams.y = value;
            this.fogParams = this._fogParams;
        }
        get fogDensity() {
            return this._fogParams.z;
        }
        set fogDensity(value) {
            this._fogParams.z = value;
            this.fogParams = this._fogParams;
        }
        get fogParams() {
            return this._shaderValues.getVector(Scene3D.FOGPARAMS);
        }
        set fogParams(value) {
            this._shaderValues.setVector(Scene3D.FOGPARAMS, value);
        }
        get GIRotate() {
            return this._shaderValues.getNumber(Scene3D.GIRotate);
        }
        set GIRotate(value) {
            this._shaderValues.setNumber(Scene3D.GIRotate, value);
        }
        get ambientMode() {
            return this._sceneReflectionProb.ambientMode;
        }
        set ambientMode(value) {
            this._sceneReflectionProb.ambientMode = value;
        }
        get sceneReflectionProb() {
            return this._sceneReflectionProb;
        }
        set sceneReflectionProb(value) {
            this._sceneReflectionProb = value;
        }
        get ambientColor() {
            return this._sceneReflectionProb.ambientColor;
        }
        set ambientColor(value) {
            this._sceneReflectionProb.ambientColor = value;
        }
        get ambientIntensity() {
            return this._sceneReflectionProb.ambientIntensity;
        }
        set ambientIntensity(value) {
            this._sceneReflectionProb.ambientIntensity = value;
        }
        get reflectionIntensity() {
            return this._sceneReflectionProb.reflectionIntensity;
        }
        set reflectionIntensity(value) {
            this._sceneReflectionProb.reflectionIntensity = value;
        }
        get ambientSH() {
            return this._sceneReflectionProb.ambientSH;
        }
        set ambientSH(value) {
            this._sceneReflectionProb.ambientSH = value;
        }
        get iblTex() {
            return this._sceneReflectionProb.iblTex;
        }
        set iblTex(value) {
            this._sceneReflectionProb.iblTex = value;
        }
        get iblTexRGBD() {
            return this._sceneReflectionProb.iblTexRGBD;
        }
        set iblTexRGBD(value) {
            this._sceneReflectionProb.iblTexRGBD = value;
        }
        get skyRenderer() {
            return this._skyRenderer;
        }
        get physicsSimulation() {
            return this._physicsManager;
        }
        get timer() {
            return this._timer;
        }
        set timer(value) {
            this._timer = value;
        }
        get lightmaps() {
            return this._lightmaps.slice();
        }
        set lightmaps(value) {
            var maps = this._lightmaps;
            if (maps) {
                for (var i = 0, n = maps.length; i < n; i++) {
                    var map = maps[i];
                    map.lightmapColor && map.lightmapColor._removeReference();
                    map.lightmapDirection && map.lightmapDirection._removeReference();
                }
            }
            if (value) {
                var count = value.length;
                maps.length = count;
                for (i = 0; i < count; i++) {
                    var map = value[i];
                    map.lightmapColor && map.lightmapColor._addReference();
                    map.lightmapDirection && map.lightmapDirection._addReference();
                    maps[i] = map;
                }
            }
            else {
                maps.length = 0;
            }
            this._sceneModuleData.lightmapDirtyFlag = Scene3D._updateMark;
        }
        get shadowMapFrequency() {
            return this._ShadowMapupdateFrequency;
        }
        set shadowMapFrequency(value) {
            this._ShadowMapupdateFrequency = value;
        }
        constructor() {
            super();
            this._reflectionsSource = 0;
            this._reflectionsResolution = "256";
            this._reflectionsIblSamples = 128;
            this._lightCount = 0;
            this._pointLights = new LightQueue();
            this._spotLights = new LightQueue();
            this._directionLights = new LightQueue();
            this._alternateLights = new AlternateLightQueue();
            this._lightmaps = [];
            this._skyRenderer = new SkyRenderer();
            this._time = 0;
            this._physicsStepTime = 0;
            this._sunColor = new Laya.Color(1.0, 1.0, 1.0);
            this._sundir = new Laya.Vector3();
            this._collsionTestList = [];
            this._key = new Laya.SubmitKey();
            this._cameraPool = [];
            this._UI3DManager = new UI3DManager();
            this.currentCreationLayer = Math.pow(2, 0);
            this.enableLight = true;
            this._ShadowMapupdateFrequency = 1;
            this.componentElementMap = new Map();
            this._componentElementDatasMap = {};
            this._nodeType = 1;
            this._componentDriver = new Laya.ComponentDriver();
            this._timer = Laya.ILaya.timer;
            this._sceneModuleData = Laya3DRender.Render3DModuleDataFactory.createSceneModuleData();
            if (Laya.LayaEnv.isConch && window.conchConfig.getGraphicsAPI() != 2) {
                this._nativeObj = new window.conchSubmitScene3D(this.renderSubmit.bind(this));
            }
            if (Laya.ILaya.Laya3D.enablePhysics)
                this._physicsManager = Laya.ILaya.Laya3D.PhysicsCreateUtil.createPhysicsManger(Scene3D.physicsSettings);
            this._shaderValues = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
            this._shaderValues.addDefines(Laya.Shader3D._configDefineValues);
            this._fogParams = new Laya.Vector4(300, 1000, 0.01, 0);
            this.enableFog = false;
            this.fogStart = 300;
            this.fogEnd = 1000;
            this.fogDensity = 0.01;
            this.fogColor = new Laya.Color(0.7, 0.7, 0.7);
            this.fogMode = exports.FogMode.Linear;
            this.GIRotate = 0;
            this._scene = this;
            this._sceneRenderManager = new SceneRenderManager();
            if (Laya.Config3D.debugFrustumCulling) ;
            this._volumeManager = new VolumeManager();
            this._UI3DManager = new UI3DManager();
            this.sceneReflectionProb = this._volumeManager.reflectionProbeManager.sceneReflectionProbe;
            this._sceneReflectionProb.reflectionIntensity = 1.0;
            this.ambientColor = new Laya.Color(0.212, 0.227, 0.259);
            Scene3D.componentManagerMap.forEach((val, key) => {
                this.componentElementMap.set(key, new val());
            });
        }
        get componentElementDatasMap() {
            return this._componentElementDatasMap;
        }
        set componentElementDatasMap(value) {
            this._componentElementDatasMap = value;
            this.componentElementMap.forEach((value, key) => {
                value.Init(this._componentElementDatasMap[key]);
            });
        }
        _update() {
            var delta = this.timer.delta / 1000;
            this._time += delta;
            this._shaderValues.setNumber(Scene3D.TIME, this._time);
            if (Laya.LayaEnv.isPlaying) {
                this._physicsStepTime += delta;
                if (this._physicsStepTime > Scene3D.physicsSettings.fixedTimeStep) {
                    let physicsManager = this._physicsManager;
                    if (Laya.ILaya.Laya3D.enablePhysics && Laya.Stat.enablePhysicsUpdate) {
                        physicsManager.update(this._physicsStepTime);
                    }
                    this._physicsStepTime = 0;
                }
            }
            this._componentDriver.callStart();
            this._componentDriver.callUpdate();
            this._componentDriver.callLateUpdate();
            this._componentDriver.callDestroy();
            if (this._volumeManager.needreCaculateAllRenderObjects())
                this._volumeManager.reCaculateAllRenderObjects(this._sceneRenderManager.list);
            else
                this._volumeManager.handleMotionlist();
            this.componentElementMap.forEach((value) => {
                value.update(delta);
            });
            this._sceneRenderManager.renderUpdate();
            this.skyRenderer.renderUpdate(RenderContext3D._instance);
            if (!this._renderByEditor)
                this._UI3DManager.update();
        }
        _binarySearchIndexInCameraPool(camera) {
            var start = 0;
            var end = this._cameraPool.length - 1;
            var mid;
            while (start <= end) {
                mid = Math.floor((start + end) / 2);
                var midValue = this._cameraPool[mid]._renderingOrder;
                if (midValue == camera._renderingOrder)
                    return mid;
                else if (midValue > camera._renderingOrder)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        _getGroup() {
            return this._group;
        }
        _setGroup(value) {
            this._group = value;
        }
        _onActive() {
            super._onActive();
            Laya.ILaya.stage._scene3Ds.push(this);
        }
        _onInActive() {
            super._onInActive();
            var scenes = Laya.ILaya.stage._scene3Ds;
            scenes.splice(scenes.indexOf(this), 1);
        }
        _prepareSceneToRender() {
            var shaderValues = this._shaderValues;
            var multiLighting = Laya.Config3D._multiLighting && Laya.Stat.enableMulLight;
            if (multiLighting) {
                var ligTex = Scene3D._lightTexture;
                var ligPix = Scene3D._lightPixles;
                const pixelWidth = ligTex.width;
                const floatWidth = pixelWidth * 4;
                var curCount = 0;
                var dirCount = Laya.Stat.enableLight ? this._directionLights._length : 0;
                var dirElements = this._directionLights._elements;
                if (dirCount > 0) {
                    var sunLightIndex = this._directionLights.getBrightestLight();
                    this._mainDirectionLight = dirElements[sunLightIndex];
                    this._directionLights.normalLightOrdering(sunLightIndex);
                    for (var i = 0; i < dirCount; i++, curCount++) {
                        var dirLight = dirElements[i];
                        var dir = dirLight.direction;
                        var intCor = dirLight._intensityColor;
                        var off = floatWidth * curCount;
                        intCor.x = Laya.Color.gammaToLinearSpace(dirLight.color.r);
                        intCor.y = Laya.Color.gammaToLinearSpace(dirLight.color.g);
                        intCor.z = Laya.Color.gammaToLinearSpace(dirLight.color.b);
                        Laya.Vector3.scale(intCor, dirLight._intensity, intCor);
                        dirLight.owner.transform.worldMatrix.getForward(dir);
                        Laya.Vector3.normalize(dir, dir);
                        ligPix[off] = intCor.x;
                        ligPix[off + 1] = intCor.y;
                        ligPix[off + 2] = intCor.z;
                        ligPix[off + 3] = dirLight._lightmapBakedType;
                        ligPix[off + 4] = dir.x;
                        ligPix[off + 5] = dir.y;
                        ligPix[off + 6] = dir.z;
                        if (i == 0) {
                            this._sunColor = dirLight.color;
                            this._sundir = dir;
                        }
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                    this._mainDirectionLight = null;
                }
                var poiCount = Laya.Stat.enableLight ? this._pointLights._length : 0;
                if (poiCount > 0) {
                    var poiElements = this._pointLights._elements;
                    var mainPointLightIndex = this._pointLights.getBrightestLight();
                    this._mainPointLight = poiElements[mainPointLightIndex];
                    this._pointLights.normalLightOrdering(mainPointLightIndex);
                    for (var i = 0; i < poiCount; i++, curCount++) {
                        var poiLight = poiElements[i];
                        var pos = poiLight.owner.transform.position;
                        var intCor = poiLight._intensityColor;
                        var off = floatWidth * curCount;
                        intCor.x = Laya.Color.gammaToLinearSpace(poiLight.color.r);
                        intCor.y = Laya.Color.gammaToLinearSpace(poiLight.color.g);
                        intCor.z = Laya.Color.gammaToLinearSpace(poiLight.color.b);
                        Laya.Vector3.scale(intCor, poiLight._intensity, intCor);
                        ligPix[off] = intCor.x;
                        ligPix[off + 1] = intCor.y;
                        ligPix[off + 2] = intCor.z;
                        ligPix[off + 3] = poiLight.range;
                        ligPix[off + 4] = pos.x;
                        ligPix[off + 5] = pos.y;
                        ligPix[off + 6] = pos.z;
                        ligPix[off + 7] = poiLight._lightmapBakedType;
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                    this._mainPointLight = null;
                }
                var spoCount = Laya.Stat.enableLight ? this._spotLights._length : 0;
                if (spoCount > 0) {
                    var spoElements = this._spotLights._elements;
                    var mainSpotLightIndex = this._spotLights.getBrightestLight();
                    this._mainSpotLight = spoElements[mainSpotLightIndex];
                    this._spotLights.normalLightOrdering(mainSpotLightIndex);
                    for (var i = 0; i < spoCount; i++, curCount++) {
                        var spoLight = spoElements[i];
                        var dir = spoLight.direction;
                        var pos = spoLight.owner.transform.position;
                        var intCor = spoLight._intensityColor;
                        var off = floatWidth * curCount;
                        intCor.x = Laya.Color.gammaToLinearSpace(spoLight.color.r);
                        intCor.y = Laya.Color.gammaToLinearSpace(spoLight.color.g);
                        intCor.z = Laya.Color.gammaToLinearSpace(spoLight.color.b);
                        Laya.Vector3.scale(intCor, spoLight._intensity, intCor);
                        spoLight.owner.transform.worldMatrix.getForward(dir);
                        Laya.Vector3.normalize(dir, dir);
                        ligPix[off] = intCor.x;
                        ligPix[off + 1] = intCor.y;
                        ligPix[off + 2] = intCor.z;
                        ligPix[off + 3] = spoLight.range;
                        ligPix[off + 4] = pos.x;
                        ligPix[off + 5] = pos.y;
                        ligPix[off + 6] = pos.z;
                        ligPix[off + 7] = spoLight.spotAngle * Math.PI / 180;
                        ligPix[off + 8] = dir.x;
                        ligPix[off + 9] = dir.y;
                        ligPix[off + 10] = dir.z;
                        ligPix[off + 11] = spoLight._lightmapBakedType;
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                    this._mainSpotLight = null;
                }
                (curCount > 0) && (ligTex.setSubPixelsData(0, 0, pixelWidth, curCount, ligPix, 0, false, false, false));
                shaderValues.setTexture(Scene3D.LIGHTBUFFER, ligTex);
                shaderValues.setInt(Scene3D.DIRECTIONLIGHTCOUNT, this._directionLights._length);
                shaderValues.setTexture(Scene3D.CLUSTERBUFFER, Cluster.instance._clusterTexture);
            }
            else {
                if (!Scene3D.LIGHTDIRECTION)
                    Scene3D.legacyLightingValueInit();
                if (this._directionLights._length > 0 && Laya.Stat.enableLight) {
                    var dirLight = this._directionLights._elements[0];
                    this._mainDirectionLight = dirLight;
                    dirLight._intensityColor.x = Laya.Color.gammaToLinearSpace(dirLight.color.r);
                    dirLight._intensityColor.y = Laya.Color.gammaToLinearSpace(dirLight.color.g);
                    dirLight._intensityColor.z = Laya.Color.gammaToLinearSpace(dirLight.color.b);
                    Laya.Vector3.scale(dirLight._intensityColor, dirLight._intensity, dirLight._intensityColor);
                    dirLight.owner.transform.worldMatrix.getForward(dirLight.direction);
                    Laya.Vector3.normalize(dirLight.direction, dirLight.direction);
                    shaderValues.setVector3(Scene3D.LIGHTDIRCOLOR, dirLight._intensityColor);
                    shaderValues.setVector3(Scene3D.LIGHTDIRECTION, dirLight.direction);
                    shaderValues.setInt(Scene3D.LIGHTMODE, dirLight._lightmapBakedType);
                    if (i == 0) {
                        this._sunColor = dirLight.color;
                        this._sundir = dirLight.direction;
                    }
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_DIRECTIONLIGHT);
                }
                if (this._pointLights._length > 0 && Laya.Stat.enableLight) {
                    var poiLight = this._pointLights._elements[0];
                    this._mainPointLight = poiLight;
                    poiLight._intensityColor.x = Laya.Color.gammaToLinearSpace(poiLight.color.r);
                    poiLight._intensityColor.y = Laya.Color.gammaToLinearSpace(poiLight.color.g);
                    poiLight._intensityColor.z = Laya.Color.gammaToLinearSpace(poiLight.color.b);
                    Laya.Vector3.scale(poiLight._intensityColor, poiLight._intensity, poiLight._intensityColor);
                    shaderValues.setVector3(Scene3D.POINTLIGHTCOLOR, poiLight._intensityColor);
                    shaderValues.setVector3(Scene3D.POINTLIGHTPOS, poiLight.owner.transform.position);
                    shaderValues.setNumber(Scene3D.POINTLIGHTRANGE, poiLight.range);
                    shaderValues.setInt(Scene3D.POINTLIGHTMODE, poiLight._lightmapBakedType);
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_POINTLIGHT);
                }
                if (this._spotLights._length > 0 && Laya.Stat.enableLight) {
                    var spotLight = this._spotLights._elements[0];
                    this._mainSpotLight = spotLight;
                    spotLight._intensityColor.x = Laya.Color.gammaToLinearSpace(spotLight.color.r);
                    spotLight._intensityColor.y = Laya.Color.gammaToLinearSpace(spotLight.color.g);
                    spotLight._intensityColor.z = Laya.Color.gammaToLinearSpace(spotLight.color.b);
                    Laya.Vector3.scale(spotLight._intensityColor, spotLight._intensity, spotLight._intensityColor);
                    shaderValues.setVector3(Scene3D.SPOTLIGHTCOLOR, spotLight._intensityColor);
                    shaderValues.setVector3(Scene3D.SPOTLIGHTPOS, spotLight.owner.transform.position);
                    spotLight.owner.transform.worldMatrix.getForward(spotLight.direction);
                    Laya.Vector3.normalize(spotLight.direction, spotLight.direction);
                    shaderValues.setVector3(Scene3D.SPOTLIGHTDIRECTION, spotLight.direction);
                    shaderValues.setNumber(Scene3D.SPOTLIGHTRANGE, spotLight.range);
                    shaderValues.setNumber(Scene3D.SPOTLIGHTSPOTANGLE, spotLight.spotAngle * Math.PI / 180);
                    shaderValues.setInt(Scene3D.SPOTLIGHTMODE, spotLight._lightmapBakedType);
                    shaderValues.addDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
                else {
                    shaderValues.removeDefine(Scene3DShaderDeclaration.SHADERDEFINE_SPOTLIGHT);
                }
            }
        }
        get cullInfoCamera() {
            return this._cullInfoCamera;
        }
        _setCullCamera(camera) {
            this._cullInfoCamera = camera;
            if (camera) {
                this.skyRenderer.setRenderElement(camera.skyRenderElement);
            }
            else {
                this.skyRenderer.setRenderElement(null);
            }
        }
        recaculateCullCamera() {
            this._setCullCamera(this._cameraPool[0]);
            this._cameraPool.forEach(element => {
                if (this.cullInfoCamera.maxlocalYDistance < element.maxlocalYDistance) {
                    this._setCullCamera(element);
                }
            });
        }
        _addCamera(camera) {
            var index = this._binarySearchIndexInCameraPool(camera);
            var order = camera._renderingOrder;
            var count = this._cameraPool.length;
            while (index < count && this._cameraPool[index]._renderingOrder <= order)
                index++;
            this._cameraPool.splice(index, 0, camera);
        }
        _removeCamera(camera) {
            this._cameraPool.splice(this._cameraPool.indexOf(camera), 1);
        }
        _addRenderObject(render) {
            this._sceneRenderManager.addRenderObject(render);
            render._inRenderList = true;
            render._addReflectionProbeUpdate();
        }
        _removeRenderObject(render) {
            render._inRenderList = false;
            this._sceneRenderManager.removeRenderObject(render);
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._nativeObj = null;
            this._skyRenderer.destroy();
            this._skyRenderer = null;
            this._directionLights = null;
            this._pointLights = null;
            this._spotLights = null;
            this._alternateLights = null;
            (RenderContext3D._instance.scene == this) && (RenderContext3D._instance.scene = null);
            this._shaderValues.destroy();
            this._shaderValues = null;
            this.sceneRenderableManager.destroy();
            this._sceneRenderManager = null;
            this._cameraPool = null;
            this._physicsManager && this._physicsManager.destroy();
            var maps = this._lightmaps;
            if (maps) {
                for (var i = 0, n = maps.length; i < n; i++) {
                    var map = maps[i];
                    map.lightmapColor && map.lightmapColor._removeReference();
                    map.lightmapDirection && map.lightmapDirection._removeReference();
                }
            }
            this._lightmaps = null;
            this._volumeManager.destroy();
            this._componentDriver.callDestroy();
        }
        getComponentElementManager(type) {
            return this.componentElementMap.get(type);
        }
        render(ctx) {
            return;
        }
        renderSubmit() {
            if (this._children.length <= 0)
                return;
            if (this._renderByEditor)
                return;
            this._prepareSceneToRender();
            var i, n;
            Scene3D._updateMark++;
            for (i = 0, n = this._cameraPool.length, n - 1; i < n; i++) {
                var camera = this._cameraPool[i];
                if (camera.enableRender && camera.activeInHierarchy) {
                    if (camera.renderTarget) {
                        camera.enableBuiltInRenderTexture || (camera.enableBuiltInRenderTexture = false);
                    }
                    else {
                        camera.enableBuiltInRenderTexture || (camera.enableBuiltInRenderTexture = true);
                    }
                    camera.render(this);
                    if (!camera._offScreenRenderTexture) {
                        this.blitMainCanvans(camera._internalRenderTexture, camera.normalizedViewport, camera);
                    }
                    camera._aftRenderMainPass();
                }
            }
            Laya.Context.set2DRenderConfig();
            Laya.RenderTexture.clearPool();
        }
        blitMainCanvans(source, normalizeViewPort, camera) {
            if (!source)
                return;
            Scene3D.mainCavansViewPort.x = RenderContext3D.clientWidth * normalizeViewPort.x | 0;
            Scene3D.mainCavansViewPort.y = RenderContext3D.clientHeight * normalizeViewPort.y | 0;
            Scene3D.mainCavansViewPort.width = RenderContext3D.clientWidth * normalizeViewPort.width | 0;
            Scene3D.mainCavansViewPort.height = RenderContext3D.clientHeight * normalizeViewPort.height | 0;
            source.filterMode = Laya.FilterMode.Bilinear;
            if (camera.fxaa)
                BlitFrameBufferCMD.shaderdata.addDefine(BaseCamera.SHADERDEFINE_FXAA);
            var cmd = BlitFrameBufferCMD.create(source, null, Scene3D.mainCavansViewPort, null, null, BlitFrameBufferCMD.shaderdata);
            cmd.run();
            cmd.recover();
            Laya.RenderTexture2D._clear = false;
            BlitFrameBufferCMD.shaderdata.removeDefine(BaseCamera.SHADERDEFINE_FXAA);
        }
        reUse(context, pos) {
            return 0;
        }
        setGlobalShaderValue(name, type, value) {
            var shaderOffset = Laya.Shader3D.propertyNameToID(name);
            this._shaderValues.setShaderData(shaderOffset, type, value);
        }
        get fogRange() {
            return this._fogParams.y - this.fogParams.x;
        }
        set fogRange(value) {
            this._fogParams.y = value + this.fogParams.x;
            this.fogParams = this._fogParams;
        }
        setlightmaps(value) {
            var maps = this._lightmaps;
            for (var i = 0, n = maps.length; i < n; i++)
                maps[i].lightmapColor._removeReference();
            if (value) {
                var count = value.length;
                maps.length = count;
                for (i = 0; i < count; i++) {
                    var lightMap = value[i];
                    lightMap._addReference();
                    (maps[i]) || (maps[i] = new Lightmap());
                    maps[i].lightmapColor = lightMap;
                }
            }
            else {
                throw new Error("Scene3D: value value can't be null.");
            }
        }
        getlightmaps() {
            var lightmapColors = new Array(this._lightmaps.length);
            for (var i = 0; i < this._lightmaps.length; i++) {
                lightmapColors[i] = this._lightmaps[i].lightmapColor;
            }
            return lightmapColors;
        }
    }
    Scene3D.physicsSettings = new PhysicsSettings();
    Scene3D.mainCavansViewPort = new Laya.Viewport(0, 0, 1, 1);
    Scene3D.componentManagerMap = new Map();

    class SubMeshInstanceBatch extends GeometryElement {
        static __init__() {
            SubMeshInstanceBatch.instance = new SubMeshInstanceBatch();
        }
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElementInstance);
            this.instanceWorldMatrixData = new Float32Array(SubMeshInstanceBatch.maxInstanceCount * 20);
            this.instanceSimpleAnimatorData = new Float32Array(SubMeshInstanceBatch.maxInstanceCount * 4);
            this.indexFormat = Laya.IndexFormat.UInt16;
            this.instanceWorldMatrixBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(this.instanceWorldMatrixData.length * 4, Laya.BufferUsage.Dynamic, false);
            this.instanceWorldMatrixBuffer.vertexDeclaration = Laya.VertexMesh.instanceWorldMatrixDeclaration;
            this.instanceWorldMatrixBuffer.instanceBuffer = true;
            this.instanceSimpleAnimatorBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(this.instanceSimpleAnimatorData.length * 4, Laya.BufferUsage.Dynamic, false);
            this.instanceSimpleAnimatorBuffer.vertexDeclaration = Laya.VertexMesh.instanceSimpleAnimatorDeclaration;
            this.instanceSimpleAnimatorBuffer.instanceBuffer = true;
        }
        _updateRenderParams(state) {
        }
    }
    SubMeshInstanceBatch.maxInstanceCount = 1024;

    class InstanceRenderElement extends RenderElement {
        static create() {
            let elemet = InstanceRenderElement._pool.length > 0 ? InstanceRenderElement._pool.pop() : new InstanceRenderElement();
            elemet._isInPool = false;
            elemet.clear();
            return elemet;
        }
        constructor() {
            super();
            this._InvertFront = false;
            this.setGeometry(new MeshInstanceGeometry(null));
            this._instanceBatchElementList = new Laya.FastSinglelist();
            this._isUpdataData = true;
            this._invertFrontFace = false;
        }
        getInvertFront() {
            return this._invertFrontFace;
        }
        set InvertFront(value) {
            this._InvertFront = value;
        }
        _createRenderElementOBJ() {
        }
        compileShader(context) {
            this._subShader._passes;
        }
        _renderUpdatePre(context) {
        }
        updateInstanceData(mesh) {
        }
        clear() {
            this._instanceBatchElementList.length = 0;
        }
        recover() {
        }
    }
    InstanceRenderElement.maxInstanceCount = 1024;
    InstanceRenderElement._pool = [];

    class SubMesh extends GeometryElement {
        get indexCount() {
            return this._indexCount;
        }
        constructor(mesh) {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this.indexFormat = mesh.indexFormat;
            if (mesh.indexFormat === Laya.IndexFormat.UInt32 && !Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Element_Index_Uint32)) {
                console.warn("SubMesh:this device do not support IndexFormat.UInt32.");
                return;
            }
            this._mesh = mesh;
            this._boneIndicesList = [];
            this._subIndexBufferStart = [];
            this._subIndexBufferCount = [];
            this.bufferState = mesh._bufferState;
        }
        _setIndexRange(indexStart, indexCount, indexFormat = Laya.IndexFormat.UInt16) {
            this._indexStart = indexStart;
            this._indexCount = indexCount;
            if (this._indexBuffer.canRead) {
                if (indexFormat == Laya.IndexFormat.UInt16) {
                    this._indices = new Uint16Array(this._indexBuffer.getData().buffer, indexStart * 2, indexCount);
                }
                else {
                    this._indices = new Uint32Array(this._indexBuffer.getData().buffer, indexStart * 4, indexCount);
                }
            }
        }
        _getType() {
            return SubMesh._type;
        }
        _prepareRender(state) {
            this._mesh._uploadVerticesData();
            return true;
        }
        _updateRenderParams(state) {
            var mesh = this._mesh;
            var byteCount;
            switch (mesh._indexFormat) {
                case Laya.IndexFormat.UInt32:
                    byteCount = 4;
                    break;
                case Laya.IndexFormat.UInt16:
                    byteCount = 2;
                    break;
                case Laya.IndexFormat.UInt8:
                    byteCount = 1;
                    break;
            }
            this.clearRenderParams();
            if (this._boneIndicesList && this._boneIndicesList.length > 1) {
                for (var i = 0, n = this._boneIndicesList.length; i < n; i++) {
                    this.setDrawElemenParams(this._subIndexBufferCount[i], this._subIndexBufferStart[i] * byteCount);
                }
            }
            else {
                this.setDrawElemenParams(this._indexCount, this._indexStart * byteCount);
            }
        }
        getIndices() {
            if (this._mesh._isReadable)
                return this._indices.slice();
            else
                throw new Laya.NotReadableError();
        }
        setIndices(indices) {
            this._indexBuffer.setData(indices, this._indexStart, 0, this._indexCount);
        }
        destroy() {
            if (this._destroyed)
                return;
            super.destroy();
            this._indexBuffer = null;
            this._vertexBuffer = null;
            this._mesh = null;
            this._boneIndicesList = null;
            this._subIndexBufferStart = null;
            this._subIndexBufferCount = null;
        }
    }
    SubMesh._type = GeometryElement._typeCounter++;

    exports.EPhysicsCapable = void 0;
    (function (EPhysicsCapable) {
        EPhysicsCapable[EPhysicsCapable["Physics_Gravity"] = 0] = "Physics_Gravity";
        EPhysicsCapable[EPhysicsCapable["Physics_StaticCollider"] = 1] = "Physics_StaticCollider";
        EPhysicsCapable[EPhysicsCapable["Physics_DynamicCollider"] = 2] = "Physics_DynamicCollider";
        EPhysicsCapable[EPhysicsCapable["Physics_CharacterCollider"] = 3] = "Physics_CharacterCollider";
        EPhysicsCapable[EPhysicsCapable["Physics_BoxColliderShape"] = 4] = "Physics_BoxColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_SphereColliderShape"] = 5] = "Physics_SphereColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_CapsuleColliderShape"] = 6] = "Physics_CapsuleColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_CylinderColliderShape"] = 7] = "Physics_CylinderColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_ConeColliderShape"] = 8] = "Physics_ConeColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_MeshColliderShape"] = 9] = "Physics_MeshColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_CompoundColliderShape"] = 10] = "Physics_CompoundColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_CreateCorveMesh"] = 11] = "Physics_CreateCorveMesh";
        EPhysicsCapable[EPhysicsCapable["physics_heightFieldColliderShape"] = 12] = "physics_heightFieldColliderShape";
        EPhysicsCapable[EPhysicsCapable["Physics_Joint"] = 13] = "Physics_Joint";
        EPhysicsCapable[EPhysicsCapable["Physics_FixedJoint"] = 14] = "Physics_FixedJoint";
        EPhysicsCapable[EPhysicsCapable["Physics_SpringJoint"] = 15] = "Physics_SpringJoint";
        EPhysicsCapable[EPhysicsCapable["Physics_HingeJoint"] = 16] = "Physics_HingeJoint";
        EPhysicsCapable[EPhysicsCapable["Physics_D6Joint"] = 17] = "Physics_D6Joint";
    })(exports.EPhysicsCapable || (exports.EPhysicsCapable = {}));

    class skinnedMatrixCache {
        constructor(subMeshIndex, batchIndex, batchBoneIndex) {
            this.subMeshIndex = subMeshIndex;
            this.batchIndex = batchIndex;
            this.batchBoneIndex = batchBoneIndex;
        }
    }
    class Mesh extends Laya.Resource {
        static load(url, complete) {
            Laya.ILaya.loader.load(url, complete, null, Laya.Loader.MESH);
        }
        get inverseAbsoluteBindPoses() {
            return this._inverseBindPoses;
        }
        get vertexCount() {
            return this._vertexCount;
        }
        get indexCount() {
            return this._indexBuffer.indexCount;
        }
        get subMeshCount() {
            return this._subMeshes.length;
        }
        get bounds() {
            return this._bounds;
        }
        set bounds(value) {
            if (this._bounds !== value)
                value.cloneTo(this._bounds);
        }
        get indexFormat() {
            return this._indexFormat;
        }
        set indexFormat(value) {
            this._indexFormat = value;
            this._subMeshes.forEach(element => {
                element.indexFormat = value;
            });
        }
        constructor(isReadable = true) {
            super();
            this._minVerticesUpdate = -1;
            this._maxVerticesUpdate = -1;
            this._needUpdateBounds = true;
            this._bufferState = new Laya.BufferState();
            this._instanceBufferStateType = 0;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._skinnedMatrixCaches = [];
            this._vertexCount = 0;
            this._indexFormat = Laya.IndexFormat.UInt16;
            this._bounds = new Bounds(new Laya.Vector3(), new Laya.Vector3());
            this._isReadable = isReadable;
            this._subMeshes = [];
            this.destroyedImmediately = Laya.Config.destroyResourceImmediatelyDefault;
        }
        _getPositionElement(vertexBuffer) {
            var vertexElements = vertexBuffer.vertexDeclaration._vertexElements;
            for (var i = 0, n = vertexElements.length; i < n; i++) {
                var vertexElement = vertexElements[i];
                if (vertexElement._elementFormat === Laya.VertexElementFormat.Vector3 && vertexElement._elementUsage === Laya.VertexMesh.MESH_POSITION0)
                    return vertexElement;
            }
            return null;
        }
        _getVerticeElementData(data, elementUsage) {
            data.length = this._vertexCount;
            var verDec = this._vertexBuffer.vertexDeclaration;
            var element = verDec.getVertexElementByUsage(elementUsage);
            if (element) {
                var uint8Vertices = this._vertexBuffer.getUint8Data();
                var floatVertices = this._vertexBuffer.getFloat32Data();
                var uint8VerStr = verDec.vertexStride;
                var floatVerStr = uint8VerStr / 4;
                var uint8EleOffset = element._offset;
                var floatEleOffset = uint8EleOffset / 4;
                switch (elementUsage) {
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Vector2(floatVertices[offset], floatVertices[offset + 1]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_POSITION0:
                    case Laya.VertexMesh.MESH_NORMAL0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Vector3(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                    case Laya.VertexMesh.MESH_BLENDWEIGHT0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Vector4(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2], floatVertices[offset + 3]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_COLOR0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = floatVerStr * i + floatEleOffset;
                            data[i] = new Laya.Color(floatVertices[offset], floatVertices[offset + 1], floatVertices[offset + 2], floatVertices[offset + 3]);
                        }
                        break;
                    case Laya.VertexMesh.MESH_BLENDINDICES0:
                        for (var i = 0; i < this._vertexCount; i++) {
                            var offset = uint8VerStr * i + uint8EleOffset;
                            data[i] = new Laya.Vector4(uint8Vertices[offset], uint8Vertices[offset + 1], uint8Vertices[offset + 2], uint8Vertices[offset + 3]);
                        }
                        break;
                    default:
                        throw "Mesh:Unknown elementUsage.";
                }
            }
        }
        _setVerticeElementData(data, elementUsage) {
            var verDec = this._vertexBuffer.vertexDeclaration;
            var element = verDec.getVertexElementByUsage(elementUsage);
            if (element) {
                var uint8Vertices = this._vertexBuffer.getUint8Data();
                var floatVertices = this._vertexBuffer.getFloat32Data();
                var uint8VerStr = verDec.vertexStride;
                var float8VerStr = uint8VerStr / 4;
                var uint8EleOffset = element._offset;
                var floatEleOffset = uint8EleOffset / 4;
                switch (elementUsage) {
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var vec2 = data[i];
                            floatVertices[offset] = vec2.x;
                            floatVertices[offset + 1] = vec2.y;
                        }
                        break;
                    case Laya.VertexMesh.MESH_POSITION0:
                    case Laya.VertexMesh.MESH_NORMAL0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var vec3 = data[i];
                            floatVertices[offset] = vec3.x;
                            floatVertices[offset + 1] = vec3.y;
                            floatVertices[offset + 2] = vec3.z;
                        }
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                    case Laya.VertexMesh.MESH_BLENDWEIGHT0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var vec4 = data[i];
                            floatVertices[offset] = vec4.x;
                            floatVertices[offset + 1] = vec4.y;
                            floatVertices[offset + 2] = vec4.z;
                            floatVertices[offset + 3] = vec4.w;
                        }
                        break;
                    case Laya.VertexMesh.MESH_COLOR0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = float8VerStr * i + floatEleOffset;
                            var cor = data[i];
                            floatVertices[offset] = cor.r;
                            floatVertices[offset + 1] = cor.g;
                            floatVertices[offset + 2] = cor.b;
                            floatVertices[offset + 3] = cor.a;
                        }
                        break;
                    case Laya.VertexMesh.MESH_BLENDINDICES0:
                        for (var i = 0, n = data.length; i < n; i++) {
                            var offset = uint8VerStr * i + uint8EleOffset;
                            var vec4 = data[i];
                            uint8Vertices[offset] = vec4.x;
                            uint8Vertices[offset + 1] = vec4.y;
                            uint8Vertices[offset + 2] = vec4.z;
                            uint8Vertices[offset + 3] = vec4.w;
                        }
                        break;
                    default:
                        throw "Mesh:Unknown elementUsage.";
                }
                this._minVerticesUpdate = 0;
                this._maxVerticesUpdate = Number.MAX_SAFE_INTEGER;
                this._vertexBuffer.setData(floatVertices.buffer, 0, 0, floatVertices.byteLength);
            }
            else {
                console.warn("Mesh: the mesh don't have  this VertexElement.");
            }
        }
        _disposeResource() {
            for (var i = 0, n = this._subMeshes.length; i < n; i++)
                this._subMeshes[i].destroy();
            this._vertexBuffer && this._vertexBuffer.destroy();
            this._indexBuffer && this._indexBuffer.destroy();
            this._bufferState.destroy();
            this._instanceBufferState && this._instanceBufferState.destroy();
            this._instanceWorldVertexBuffer && this._instanceWorldVertexBuffer.destroy();
            this._instanceSimpleAniVertexBuffer && this._instanceSimpleAniVertexBuffer.destroy();
            this._instanceLightMapVertexBuffer && this._instanceLightMapVertexBuffer.destroy();
            this.instanceLightMapScaleOffsetData && (this.instanceLightMapScaleOffsetData = null);
            this._setCPUMemory(0);
            this._setGPUMemory(0);
            this._bufferState = null;
            this._instanceBufferState = null;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            this._subMeshes = null;
            this._btTriangleMesh = null;
            this._indexBuffer = null;
            this._boneNames = null;
            this._inverseBindPoses = null;
            this.morphTargetData && (this.morphTargetData.destroy());
            this.__convexMesh && this.__convexMesh.destroy();
        }
        _setSubMeshes(subMeshes) {
            this._subMeshes = subMeshes;
            for (var i = 0, n = subMeshes.length; i < n; i++)
                subMeshes[i]._indexInMesh = i;
        }
        _setBuffer(vertexBuffer, indexBuffer) {
            var bufferState = this._bufferState;
            bufferState.applyState([vertexBuffer], indexBuffer);
        }
        _setInstanceBuffer() {
            if (this._instanceBufferState)
                return;
            var instanceBufferState = this._instanceBufferState = new Laya.BufferState();
            var instanceBufferStateType = this._instanceBufferStateType;
            let vertexArray = [];
            vertexArray.push(this._vertexBuffer);
            let instanceBuffer3D = this._instanceWorldVertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(InstanceRenderElement.maxInstanceCount * 16 * 4, Laya.BufferUsage.Dynamic, false);
            instanceBuffer3D.vertexDeclaration = Laya.VertexMesh.instanceWorldMatrixDeclaration;
            instanceBuffer3D.instanceBuffer = true;
            vertexArray.push(instanceBuffer3D);
            switch (instanceBufferStateType) {
                case Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR:
                    let instanceSimpleAnimatorBuffer = this._instanceSimpleAniVertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(InstanceRenderElement.maxInstanceCount * 4 * 4, Laya.BufferUsage.Dynamic, false);
                    instanceSimpleAnimatorBuffer.vertexDeclaration = Laya.VertexMesh.instanceSimpleAnimatorDeclaration;
                    instanceSimpleAnimatorBuffer.instanceBuffer = true;
                    vertexArray.push(instanceSimpleAnimatorBuffer);
                    break;
                case Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL:
                    if (this.getVertexDeclaration().getVertexElementByUsage(Laya.VertexMesh.MESH_TEXTURECOORDINATE1)) {
                        let instanceLightMapVertexBuffer = this._instanceLightMapVertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(InstanceRenderElement.maxInstanceCount * 4 * 4, Laya.BufferUsage.Dynamic, false);
                        instanceLightMapVertexBuffer.vertexDeclaration = Laya.VertexMesh.instanceLightMapScaleOffsetDeclaration;
                        instanceLightMapVertexBuffer.instanceBuffer = true;
                        this.instanceLightMapScaleOffsetData = new Float32Array(InstanceRenderElement.maxInstanceCount * 4);
                        vertexArray.push(instanceLightMapVertexBuffer);
                    }
                    break;
            }
            instanceBufferState.applyState(vertexArray, this._indexBuffer);
        }
        _uploadVerticesData() {
            var min = this._minVerticesUpdate;
            var max = this._maxVerticesUpdate;
            if (min !== -1 && max !== -1) {
                var offset = min;
                this._vertexBuffer.setData(this._vertexBuffer.getUint8Data().buffer, offset, offset, max - min);
                this._minVerticesUpdate = -1;
                this._maxVerticesUpdate = -1;
            }
        }
        getSubMesh(index) {
            return this._subMeshes[index];
        }
        getPositions(positions) {
            if (this._isReadable)
                this._getVerticeElementData(positions, Laya.VertexMesh.MESH_POSITION0);
            else
                throw new Laya.NotReadableError();
        }
        setPositions(positions) {
            if (this._isReadable) {
                this._setVerticeElementData(positions, Laya.VertexMesh.MESH_POSITION0);
                this._needUpdateBounds = true;
            }
            else {
                throw new Laya.NotReadableError();
            }
        }
        getColors(colors) {
            if (this._isReadable)
                this._getVerticeElementData(colors, Laya.VertexMesh.MESH_COLOR0);
            else
                throw new Laya.NotReadableError();
        }
        setColors(colors) {
            if (this._isReadable)
                this._setVerticeElementData(colors, Laya.VertexMesh.MESH_COLOR0);
            else
                throw new Laya.NotReadableError();
        }
        getUVs(uvs, channel = 0) {
            if (this._isReadable) {
                switch (channel) {
                    case 0:
                        this._getVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE0);
                        break;
                    case 1:
                        this._getVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE1);
                        break;
                    default:
                        throw "Mesh:Invalid channel.";
                }
            }
            else {
                throw new Laya.NotReadableError();
            }
        }
        setUVs(uvs, channel = 0) {
            if (this._isReadable) {
                switch (channel) {
                    case 0:
                        this._setVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE0);
                        break;
                    case 1:
                        this._setVerticeElementData(uvs, Laya.VertexMesh.MESH_TEXTURECOORDINATE1);
                        break;
                    default:
                        throw "Mesh:Invalid channel.";
                }
            }
            else {
                throw new Laya.NotReadableError();
            }
        }
        getNormals(normals) {
            if (this._isReadable)
                this._getVerticeElementData(normals, Laya.VertexMesh.MESH_NORMAL0);
            else
                throw new Laya.NotReadableError();
        }
        setNormals(normals) {
            if (this._isReadable)
                this._setVerticeElementData(normals, Laya.VertexMesh.MESH_NORMAL0);
            else
                throw new Laya.NotReadableError();
        }
        getTangents(tangents) {
            if (this._isReadable)
                this._getVerticeElementData(tangents, Laya.VertexMesh.MESH_TANGENT0);
            else
                throw new Laya.NotReadableError();
        }
        setTangents(tangents) {
            if (this._isReadable)
                this._setVerticeElementData(tangents, Laya.VertexMesh.MESH_TANGENT0);
            else
                throw new Laya.NotReadableError();
        }
        getBoneWeights(boneWeights) {
            if (this._isReadable)
                this._getVerticeElementData(boneWeights, Laya.VertexMesh.MESH_BLENDWEIGHT0);
            else
                throw new Laya.NotReadableError();
        }
        setBoneWeights(boneWeights) {
            if (this._isReadable)
                this._setVerticeElementData(boneWeights, Laya.VertexMesh.MESH_BLENDWEIGHT0);
            else
                throw new Laya.NotReadableError();
        }
        getBoneIndices(boneIndices) {
            if (this._isReadable)
                this._getVerticeElementData(boneIndices, Laya.VertexMesh.MESH_BLENDINDICES0);
            else
                throw new Laya.NotReadableError();
        }
        setBoneIndices(boneIndices) {
            if (this._isReadable)
                this._setVerticeElementData(boneIndices, Laya.VertexMesh.MESH_BLENDINDICES0);
            else
                throw new Laya.NotReadableError();
        }
        markAsUnreadbale() {
            this._uploadVerticesData();
            this._vertexBuffer.markAsUnreadbale();
            this._isReadable = false;
        }
        getVertexDeclaration() {
            return this._vertexBuffer.vertexDeclaration;
        }
        getVertices() {
            if (this._isReadable)
                return this._vertexBuffer.getUint8Data().buffer.slice(0);
            else
                throw new Laya.NotReadableError();
        }
        setVertices(vertices) {
            this._vertexBuffer.setData(vertices);
            this._needUpdateBounds = true;
        }
        getIndices() {
            if (this._isReadable)
                return this._indexBuffer.getData().slice();
            else
                throw new Laya.NotReadableError();
        }
        setIndices(indices) {
            var format;
            if (indices instanceof Uint32Array)
                format = Laya.IndexFormat.UInt32;
            else if (indices instanceof Uint16Array)
                format = Laya.IndexFormat.UInt16;
            else if (indices instanceof Uint8Array)
                format = Laya.IndexFormat.UInt8;
            var indexBuffer = this._indexBuffer;
            if (this._indexFormat !== format || indexBuffer.indexCount !== indices.length) {
                indexBuffer.destroy();
                this._indexBuffer = indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(format, indices.length, Laya.BufferUsage.Static, this._isReadable);
            }
            indexBuffer.setData(indices);
            this.indexFormat = format;
        }
        calculateBounds() {
            if (this._isReadable) {
                if (this._needUpdateBounds) {
                    var min = _tempVector30$1;
                    var max = _tempVector31$2;
                    min.x = min.y = min.z = Number.MAX_VALUE;
                    max.x = max.y = max.z = -Number.MAX_VALUE;
                    var vertexBuffer = this._vertexBuffer;
                    var positionElement = this._getPositionElement(vertexBuffer);
                    var verticesData = vertexBuffer.getFloat32Data();
                    var floatCount = vertexBuffer.vertexDeclaration.vertexStride / 4;
                    var posOffset = positionElement._offset / 4;
                    for (var j = 0, m = verticesData.length; j < m; j += floatCount) {
                        var ofset = j + posOffset;
                        var pX = verticesData[ofset];
                        var pY = verticesData[ofset + 1];
                        var pZ = verticesData[ofset + 2];
                        min.x = Math.min(min.x, pX);
                        min.y = Math.min(min.y, pY);
                        min.z = Math.min(min.z, pZ);
                        max.x = Math.max(max.x, pX);
                        max.y = Math.max(max.y, pY);
                        max.z = Math.max(max.z, pZ);
                    }
                    this._bounds.setMin(min);
                    this._bounds.setMax(max);
                    this._needUpdateBounds = false;
                }
            }
            else {
                throw new Laya.NotReadableError();
            }
        }
        getCorveMesh() {
            if (this._convexMesh == null) {
                return null;
            }
            let util = Laya.ILaya.Laya3D._PhysicsCreateUtil;
            if (this.__convexMesh == null && util && util.getPhysicsCapable(exports.EPhysicsCapable.Physics_CreateCorveMesh)) {
                this.__convexMesh = util.createCorveMesh(this);
            }
            return this.__convexMesh;
        }
        cloneTo(destObject) {
            var vb = this._vertexBuffer;
            var destVB = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vb._byteLength, vb.bufferUsage, vb.canRead);
            destVB.vertexDeclaration = vb.vertexDeclaration;
            destVB.setData(vb.getUint8Data().slice().buffer);
            destObject._vertexBuffer = destVB;
            destObject._vertexCount = this._vertexCount;
            var ib = this._indexBuffer;
            var destIB = Laya3DRender.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, ib.indexCount, ib.bufferUsage, ib.canRead);
            destIB.setData(ib.getData().slice());
            destObject._indexBuffer = destIB;
            destObject._setBuffer(destObject._vertexBuffer, destIB);
            destObject._instanceBufferStateType = this._instanceBufferStateType;
            destObject._setCPUMemory(this.cpuMemory);
            destObject._setGPUMemory(this.gpuMemory);
            var i;
            var boneNames = this._boneNames;
            if (boneNames) {
                var destBoneNames = destObject._boneNames = [];
                for (i = 0; i < boneNames.length; i++)
                    destBoneNames[i] = boneNames[i];
            }
            var inverseBindPoses = this._inverseBindPoses;
            if (inverseBindPoses) {
                var destInverseBindPoses = destObject._inverseBindPoses = [];
                for (i = 0; i < inverseBindPoses.length; i++)
                    destInverseBindPoses[i] = inverseBindPoses[i];
            }
            if (this._inverseBindPosesBuffer) {
                let length = this._inverseBindPosesBuffer.byteLength;
                destObject._inverseBindPosesBuffer = new ArrayBuffer(length);
                new Uint8Array(destObject._inverseBindPosesBuffer).set(new Uint8Array(this._inverseBindPosesBuffer));
            }
            var cacheLength = this._skinnedMatrixCaches.length;
            destObject._skinnedMatrixCaches.length = cacheLength;
            for (i = 0; i < cacheLength; i++) {
                var skinnedCache = this._skinnedMatrixCaches[i];
                if (skinnedCache)
                    destObject._skinnedMatrixCaches[i] = new skinnedMatrixCache(skinnedCache.subMeshIndex, skinnedCache.batchIndex, skinnedCache.batchBoneIndex);
            }
            for (i = 0; i < this.subMeshCount; i++) {
                var subMesh = this._subMeshes[i];
                var subIndexBufferStart = subMesh._subIndexBufferStart;
                var subIndexBufferCount = subMesh._subIndexBufferCount;
                var boneIndicesList = subMesh._boneIndicesList;
                var destSubmesh = new SubMesh(destObject);
                destSubmesh._subIndexBufferStart.length = subIndexBufferStart.length;
                destSubmesh._subIndexBufferCount.length = subIndexBufferCount.length;
                destSubmesh._boneIndicesList.length = boneIndicesList.length;
                for (var j = 0; j < subIndexBufferStart.length; j++)
                    destSubmesh._subIndexBufferStart[j] = subIndexBufferStart[j];
                for (j = 0; j < subIndexBufferCount.length; j++)
                    destSubmesh._subIndexBufferCount[j] = subIndexBufferCount[j];
                for (j = 0; j < boneIndicesList.length; j++)
                    destSubmesh._boneIndicesList[j] = new Uint16Array(boneIndicesList[j]);
                destSubmesh._indexBuffer = destIB;
                destSubmesh._indexStart = subMesh._indexStart;
                destSubmesh._indexCount = subMesh._indexCount;
                destSubmesh._indices = new Uint16Array(destIB.getData().buffer, subMesh._indexStart * 2, subMesh._indexCount);
                var vertexBuffer = destObject._vertexBuffer;
                destSubmesh._vertexBuffer = vertexBuffer;
                destObject._subMeshes.push(destSubmesh);
            }
            destObject._setSubMeshes(destObject._subMeshes);
            if (this.morphTargetData) {
                destObject.morphTargetData = this.morphTargetData.clone();
            }
        }
        clone() {
            var dest = new Mesh();
            this.cloneTo(dest);
            return dest;
        }
    }
    Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL = 0;
    Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR = 1;
    const _tempVector30$1 = new Laya.Vector3();
    const _tempVector31$2 = new Laya.Vector3();

    class PrimitiveMesh {
        static __init__() {
        }
        static _createMesh(vertexDeclaration, vertices, indices) {
            var mesh = new Mesh();
            var subMesh = new SubMesh(mesh);
            var vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vertices.length * 4, Laya.BufferUsage.Static, true);
            vertexBuffer.vertexDeclaration = vertexDeclaration;
            vertexBuffer.setData(vertices.buffer);
            mesh._vertexBuffer = vertexBuffer;
            mesh._vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;
            var indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, indices.length, Laya.BufferUsage.Static, true);
            indexBuffer.setData(indices);
            mesh._indexBuffer = indexBuffer;
            mesh._setBuffer(vertexBuffer, indexBuffer);
            subMesh._vertexBuffer = vertexBuffer;
            subMesh._indexBuffer = indexBuffer;
            subMesh._setIndexRange(0, indexBuffer.indexCount);
            var subIndexBufferStart = subMesh._subIndexBufferStart;
            var subIndexBufferCount = subMesh._subIndexBufferCount;
            var boneIndicesList = subMesh._boneIndicesList;
            subIndexBufferStart.length = 1;
            subIndexBufferCount.length = 1;
            boneIndicesList.length = 1;
            subIndexBufferStart[0] = 0;
            subIndexBufferCount[0] = indexBuffer.indexCount;
            var subMeshes = [];
            subMeshes.push(subMesh);
            mesh._setSubMeshes(subMeshes);
            mesh.calculateBounds();
            var memorySize = vertexBuffer._byteLength + indexBuffer._byteLength;
            mesh._setCPUMemory(memorySize);
            mesh._setGPUMemory(memorySize);
            return mesh;
        }
        static createBox(long = 1, height = 1, width = 1) {
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var halfLong = long / 2;
            var halfHeight = height / 2;
            var halfWidth = width / 2;
            var vertices = new Float32Array([
                -halfLong, halfHeight, -halfWidth, 0, 1, 0, 0, 0, halfLong, halfHeight, -halfWidth, 0, 1, 0, 1, 0, halfLong, halfHeight, halfWidth, 0, 1, 0, 1, 1, -halfLong, halfHeight, halfWidth, 0, 1, 0, 0, 1,
                -halfLong, -halfHeight, -halfWidth, 0, -1, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 0, -1, 0, 1, 1, halfLong, -halfHeight, halfWidth, 0, -1, 0, 1, 0, -halfLong, -halfHeight, halfWidth, 0, -1, 0, 0, 0,
                -halfLong, halfHeight, -halfWidth, -1, 0, 0, 0, 0, -halfLong, halfHeight, halfWidth, -1, 0, 0, 1, 0, -halfLong, -halfHeight, halfWidth, -1, 0, 0, 1, 1, -halfLong, -halfHeight, -halfWidth, -1, 0, 0, 0, 1,
                halfLong, halfHeight, -halfWidth, 1, 0, 0, 1, 0, halfLong, halfHeight, halfWidth, 1, 0, 0, 0, 0, halfLong, -halfHeight, halfWidth, 1, 0, 0, 0, 1, halfLong, -halfHeight, -halfWidth, 1, 0, 0, 1, 1,
                -halfLong, halfHeight, halfWidth, 0, 0, 1, 0, 0, halfLong, halfHeight, halfWidth, 0, 0, 1, 1, 0, halfLong, -halfHeight, halfWidth, 0, 0, 1, 1, 1, -halfLong, -halfHeight, halfWidth, 0, 0, 1, 0, 1,
                -halfLong, halfHeight, -halfWidth, 0, 0, -1, 1, 0, halfLong, halfHeight, -halfWidth, 0, 0, -1, 0, 0, halfLong, -halfHeight, -halfWidth, 0, 0, -1, 0, 1, -halfLong, -halfHeight, -halfWidth, 0, 0, -1, 1, 1
            ]);
            var indices = new Uint16Array([
                0, 1, 2, 2, 3, 0,
                4, 7, 6, 6, 5, 4,
                8, 9, 10, 10, 11, 8,
                12, 15, 14, 14, 13, 12,
                16, 17, 18, 18, 19, 16,
                20, 23, 22, 22, 21, 20
            ]);
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createCapsule(radius = 0.5, height = 2, stacks = 16, slices = 32) {
            var vertexCount = (stacks + 1) * (slices + 1) * 2 + (slices + 1) * 2;
            var indexCount = (3 * stacks * (slices + 1)) * 2 * 2 + 2 * slices * 3;
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var indices = new Uint16Array(indexCount);
            var stackAngle = (Math.PI / 2.0) / stacks;
            var sliceAngle = (Math.PI * 2.0) / slices;
            var hcHeight = height / 2 - radius;
            var posX = 0;
            var posY = 0;
            var posZ = 0;
            var vc = 0;
            var ic = 0;
            var verticeCount = 0;
            var stack, slice;
            for (stack = 0; stack <= stacks; stack++) {
                for (slice = 0; slice <= slices; slice++) {
                    posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI);
                    posY = radius * Math.sin(stack * stackAngle);
                    posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI);
                    vertices[vc++] = posX;
                    vertices[vc++] = posY + hcHeight;
                    vertices[vc++] = posZ;
                    vertices[vc++] = posX;
                    vertices[vc++] = posY;
                    vertices[vc++] = posZ;
                    vertices[vc++] = 1 - slice / slices;
                    vertices[vc++] = (1 - stack / stacks) * ((Math.PI * radius / 2) / (height + Math.PI * radius));
                    if (stack < stacks) {
                        indices[ic++] = (stack * (slices + 1)) + slice + (slices + 1);
                        indices[ic++] = (stack * (slices + 1)) + slice;
                        indices[ic++] = (stack * (slices + 1)) + slice + 1;
                        indices[ic++] = (stack * (slices + 1)) + slice + (slices);
                        indices[ic++] = (stack * (slices + 1)) + slice;
                        indices[ic++] = (stack * (slices + 1)) + slice + (slices + 1);
                    }
                }
            }
            verticeCount += (stacks + 1) * (slices + 1);
            for (stack = 0; stack <= stacks; stack++) {
                for (slice = 0; slice <= slices; slice++) {
                    posX = radius * Math.cos(stack * stackAngle) * Math.cos(slice * sliceAngle + Math.PI);
                    posY = radius * Math.sin(-stack * stackAngle);
                    posZ = radius * Math.cos(stack * stackAngle) * Math.sin(slice * sliceAngle + Math.PI);
                    vertices[vc++] = posX;
                    vertices[vc++] = posY - hcHeight;
                    vertices[vc++] = posZ;
                    vertices[vc++] = posX;
                    vertices[vc++] = posY;
                    vertices[vc++] = posZ;
                    vertices[vc++] = 1 - slice / slices;
                    vertices[vc++] = ((stack / stacks) * (Math.PI * radius / 2) + (height + Math.PI * radius / 2)) / (height + Math.PI * radius);
                    if (stack < stacks) {
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice;
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices + 1);
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + 1;
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice;
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices);
                        indices[ic++] = verticeCount + (stack * (slices + 1)) + slice + (slices + 1);
                    }
                }
            }
            verticeCount += (stacks + 1) * (slices + 1);
            for (slice = 0; slice <= slices; slice++) {
                posX = radius * Math.cos(slice * sliceAngle + Math.PI);
                posY = hcHeight;
                posZ = radius * Math.sin(slice * sliceAngle + Math.PI);
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = posY;
                vertices[vc + (slices + 1) * 8 - 1] = -posY;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 0;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = 1 - slice * 1 / slices;
                vertices[vc + (slices + 1) * 8 - 1] = 1 - slice * 1 / slices;
                vertices[vc++] = (Math.PI * radius / 2) / (height + Math.PI * radius);
                vertices[vc + (slices + 1) * 8 - 1] = (Math.PI * radius / 2 + height) / (height + Math.PI * radius);
            }
            for (slice = 0; slice < slices; slice++) {
                indices[ic++] = slice + verticeCount + (slices + 1);
                indices[ic++] = slice + verticeCount + 1;
                indices[ic++] = slice + verticeCount;
                indices[ic++] = slice + verticeCount + (slices + 1);
                indices[ic++] = slice + verticeCount + (slices + 1) + 1;
                indices[ic++] = slice + verticeCount + 1;
            }
            verticeCount += 2 * (slices + 1);
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createCone(radius = 0.5, height = 1, slices = 32) {
            var vertexCount = (slices + 1 + 1) + (slices + 1) * 2;
            var indexCount = 6 * slices + 3 * slices;
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var indices = new Uint16Array(indexCount);
            var sliceAngle = (Math.PI * 2.0) / slices;
            var halfHeight = height / 2;
            var curAngle = 0;
            var verticeCount = 0;
            var posX = 0;
            var posY = 0;
            var posZ = 0;
            var normal = new Laya.Vector3();
            var downV3 = new Laya.Vector3(0, -1, 0);
            var upPoint = new Laya.Vector3(0, halfHeight, 0);
            var downPoint = new Laya.Vector3();
            var v3 = new Laya.Vector3();
            var q4 = new Laya.Quaternion();
            var rotateAxis = new Laya.Vector3();
            var rotateRadius;
            var vc = 0;
            var ic = 0;
            for (var rv = 0; rv <= slices; rv++) {
                curAngle = rv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = posY;
                vertices[vc + (slices + 1) * 8 - 1] = -posY;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                normal.x = posX;
                normal.y = 0;
                normal.z = posZ;
                downPoint.x = posX;
                downPoint.y = -posY;
                downPoint.z = posZ;
                Laya.Vector3.subtract(downPoint, upPoint, v3);
                Laya.Vector3.normalize(v3, v3);
                rotateRadius = Math.acos(Laya.Vector3.dot(downV3, v3));
                Laya.Vector3.cross(downV3, v3, rotateAxis);
                Laya.Vector3.normalize(rotateAxis, rotateAxis);
                Laya.Quaternion.createFromAxisAngle(rotateAxis, rotateRadius, q4);
                Laya.Vector3.normalize(normal, normal);
                Laya.Vector3.transformQuat(normal, q4, normal);
                Laya.Vector3.normalize(normal, normal);
                vertices[vc++] = normal.x;
                vertices[vc + (slices + 1) * 8 - 1] = normal.x;
                vertices[vc++] = normal.y;
                vertices[vc + (slices + 1) * 8 - 1] = normal.y;
                vertices[vc++] = normal.z;
                vertices[vc + (slices + 1) * 8 - 1] = normal.z;
                vertices[vc++] = 1 - rv * 1 / slices;
                vertices[vc + (slices + 1) * 8 - 1] = 1 - rv * 1 / slices;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 1;
            }
            vc += (slices + 1) * 8;
            for (var ri = 0; ri < slices; ri++) {
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + 1;
                indices[ic++] = ri + verticeCount;
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + (slices + 1) + 1;
                indices[ic++] = ri + verticeCount + 1;
            }
            verticeCount += 2 * (slices + 1);
            for (var bv = 0; bv <= slices; bv++) {
                if (bv === 0) {
                    vertices[vc++] = 0;
                    vertices[vc++] = -halfHeight;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0;
                    vertices[vc++] = -1;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0.5;
                    vertices[vc++] = 0.5;
                }
                curAngle = bv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = -halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = posX;
                vertices[vc++] = posY;
                vertices[vc++] = posZ;
                vertices[vc++] = 0;
                vertices[vc++] = -1;
                vertices[vc++] = 0;
                vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
            }
            for (var bi = 0; bi < slices; bi++) {
                indices[ic++] = 0 + verticeCount;
                indices[ic++] = bi + 2 + verticeCount;
                indices[ic++] = bi + 1 + verticeCount;
            }
            verticeCount += slices + 1 + 1;
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createCylinder(radius = 0.5, height = 2, slices = 32) {
            var vertexCount = (slices + 1 + 1) + (slices + 1) * 2 + (slices + 1 + 1);
            var indexCount = 3 * slices + 6 * slices + 3 * slices;
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var indices = new Uint16Array(indexCount);
            var sliceAngle = (Math.PI * 2.0) / slices;
            var halfHeight = height / 2;
            var curAngle = 0;
            var verticeCount = 0;
            var posX = 0;
            var posY = 0;
            var posZ = 0;
            var vc = 0;
            var ic = 0;
            for (var tv = 0; tv <= slices; tv++) {
                if (tv === 0) {
                    vertices[vc++] = 0;
                    vertices[vc++] = halfHeight;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0;
                    vertices[vc++] = 1;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0.5;
                    vertices[vc++] = 0.5;
                }
                curAngle = tv * sliceAngle;
                posX = Math.cos(curAngle) * radius;
                posY = halfHeight;
                posZ = Math.sin(curAngle) * radius;
                vertices[vc++] = posX;
                vertices[vc++] = posY;
                vertices[vc++] = posZ;
                vertices[vc++] = 0;
                vertices[vc++] = 1;
                vertices[vc++] = 0;
                vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
            }
            for (var ti = 0; ti < slices; ti++) {
                indices[ic++] = 0;
                indices[ic++] = ti + 1;
                indices[ic++] = ti + 2;
            }
            verticeCount += slices + 1 + 1;
            for (var rv = 0; rv <= slices; rv++) {
                curAngle = rv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = posY;
                vertices[vc + (slices + 1) * 8 - 1] = -posY;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = posX;
                vertices[vc + (slices + 1) * 8 - 1] = posX;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 0;
                vertices[vc++] = posZ;
                vertices[vc + (slices + 1) * 8 - 1] = posZ;
                vertices[vc++] = 1 - rv * 1 / slices;
                vertices[vc + (slices + 1) * 8 - 1] = 1 - rv * 1 / slices;
                vertices[vc++] = 0;
                vertices[vc + (slices + 1) * 8 - 1] = 1;
            }
            vc += (slices + 1) * 8;
            for (var ri = 0; ri < slices; ri++) {
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + 1;
                indices[ic++] = ri + verticeCount;
                indices[ic++] = ri + verticeCount + (slices + 1);
                indices[ic++] = ri + verticeCount + (slices + 1) + 1;
                indices[ic++] = ri + verticeCount + 1;
            }
            verticeCount += 2 * (slices + 1);
            for (var bv = 0; bv <= slices; bv++) {
                if (bv === 0) {
                    vertices[vc++] = 0;
                    vertices[vc++] = -halfHeight;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0;
                    vertices[vc++] = -1;
                    vertices[vc++] = 0;
                    vertices[vc++] = 0.5;
                    vertices[vc++] = 0.5;
                }
                curAngle = bv * sliceAngle;
                posX = Math.cos(curAngle + Math.PI) * radius;
                posY = -halfHeight;
                posZ = Math.sin(curAngle + Math.PI) * radius;
                vertices[vc++] = posX;
                vertices[vc++] = posY;
                vertices[vc++] = posZ;
                vertices[vc++] = 0;
                vertices[vc++] = -1;
                vertices[vc++] = 0;
                vertices[vc++] = 0.5 + Math.cos(curAngle) * 0.5;
                vertices[vc++] = 0.5 + Math.sin(curAngle) * 0.5;
            }
            for (var bi = 0; bi < slices; bi++) {
                indices[ic++] = 0 + verticeCount;
                indices[ic++] = bi + 2 + verticeCount;
                indices[ic++] = bi + 1 + verticeCount;
            }
            verticeCount += slices + 1 + 1;
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createPlane(long = 10, width = 10, stacks = 10, slices = 10) {
            var vertexCount = (stacks + 1) * (slices + 1);
            var indexCount = stacks * slices * 2 * 3;
            var indices = new Uint16Array(indexCount);
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var halfLong = long / 2;
            var halfWidth = width / 2;
            var stacksLong = long / stacks;
            var slicesWidth = width / slices;
            var verticeCount = 0;
            for (var i = 0; i <= slices; i++) {
                for (var j = 0; j <= stacks; j++) {
                    vertices[verticeCount++] = j * stacksLong - halfLong;
                    vertices[verticeCount++] = 0;
                    vertices[verticeCount++] = i * slicesWidth - halfWidth;
                    vertices[verticeCount++] = 0;
                    vertices[verticeCount++] = 1;
                    vertices[verticeCount++] = 0;
                    vertices[verticeCount++] = j * 1 / stacks;
                    vertices[verticeCount++] = i * 1 / slices;
                }
            }
            var indiceIndex = 0;
            for (i = 0; i < slices; i++) {
                for (j = 0; j < stacks; j++) {
                    indices[indiceIndex++] = (i + 1) * (stacks + 1) + j;
                    indices[indiceIndex++] = i * (stacks + 1) + j;
                    indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                    indices[indiceIndex++] = i * (stacks + 1) + j;
                    indices[indiceIndex++] = i * (stacks + 1) + j + 1;
                    indices[indiceIndex++] = (i + 1) * (stacks + 1) + j + 1;
                }
            }
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createQuad(long = 1, width = 1) {
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var halfLong = long / 2;
            var halfWidth = width / 2;
            var vertices = new Float32Array([-halfLong, halfWidth, 0, 0, 0, 1, 0, 0, halfLong, halfWidth, 0, 0, 0, 1, 1, 0, -halfLong, -halfWidth, 0, 0, 0, 1, 0, 1, halfLong, -halfWidth, 0, 0, 0, 1, 1, 1]);
            var indices = new Uint16Array([0, 1, 2, 3, 2, 1]);
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
        static createSphere(radius = 0.5, stacks = 32, slices = 32) {
            var vertexCount = (stacks + 1) * (slices + 1);
            var indexCount = (3 * stacks * (slices + 1)) * 2;
            var indices = new Uint16Array(indexCount);
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var vertexFloatStride = vertexDeclaration.vertexStride / 4;
            var vertices = new Float32Array(vertexCount * vertexFloatStride);
            var stackAngle = Math.PI / stacks;
            var sliceAngle = (Math.PI * 2.0) / slices;
            var vertexIndex = 0;
            vertexCount = 0;
            indexCount = 0;
            for (var stack = 0; stack < (stacks + 1); stack++) {
                var r = Math.sin(stack * stackAngle);
                var y = Math.cos(stack * stackAngle);
                for (var slice = 0; slice < (slices + 1); slice++) {
                    var x = r * Math.sin(slice * sliceAngle + Math.PI * 1 / 2);
                    var z = r * Math.cos(slice * sliceAngle + Math.PI * 1 / 2);
                    vertices[vertexCount + 0] = x * radius;
                    vertices[vertexCount + 1] = y * radius;
                    vertices[vertexCount + 2] = z * radius;
                    vertices[vertexCount + 3] = x;
                    vertices[vertexCount + 4] = y;
                    vertices[vertexCount + 5] = z;
                    vertices[vertexCount + 6] = slice / slices;
                    vertices[vertexCount + 7] = stack / stacks;
                    vertexCount += vertexFloatStride;
                    if (stack != (stacks - 1)) {
                        indices[indexCount++] = vertexIndex + (slices + 1);
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + 1;
                        indices[indexCount++] = vertexIndex + (slices);
                        indices[indexCount++] = vertexIndex;
                        indices[indexCount++] = vertexIndex + (slices + 1);
                        vertexIndex++;
                    }
                }
            }
            return PrimitiveMesh._createMesh(vertexDeclaration, vertices, indices);
        }
    }

    var UtilsGLSL = "#if !defined(Utils_lib)\n#define Utils_lib\n#endif\n";

    var OutputTransformGLSL = "#if !defined(OutputTransform_lib)\n#define OutputTransform_lib\nvec3 gammaCorrect(in vec3 color,float gammaValue){return pow(color,vec3(gammaValue));}vec4 gammaCorrect(in vec4 color){float gammaValue=1.0/2.2;return vec4(gammaCorrect(color.rgb,gammaValue),color.a);}vec4 outputTransform(in vec4 color){\n#ifdef GAMMACORRECT\nreturn gammaCorrect(color);\n#else\nreturn color;\n#endif\n}\n#endif\n";

    var BakedBoneMatrixSamplerGLSL = "#if !defined(BakeBoneAnimSampler_lib)\n#define BakeBoneAnimSampler_lib\nmat4 loadBakedMatMatrix(float FramePos,float boneIndices,float offset){vec2 uv;float PixelPos=FramePos+boneIndices*4.0;float halfOffset=offset*0.5;float uvoffset=PixelPos/u_SimpleAnimatorTextureSize;uv.y=floor(uvoffset)*offset+halfOffset;uv.x=mod(float(PixelPos),u_SimpleAnimatorTextureSize)*offset+halfOffset;vec4 mat0row=texture2D(u_SimpleAnimatorTexture,uv);uv.x+=offset;vec4 mat1row=texture2D(u_SimpleAnimatorTexture,uv);uv.x+=offset;vec4 mat2row=texture2D(u_SimpleAnimatorTexture,uv);uv.x+=offset;vec4 mat3row=texture2D(u_SimpleAnimatorTexture,uv);mat4 m=mat4(mat0row.x,mat0row.y,mat0row.z,mat0row.w,mat1row.x,mat1row.y,mat1row.z,mat1row.w,mat2row.x,mat2row.y,mat2row.z,mat2row.w,mat3row.x,mat3row.y,mat3row.z,mat3row.w);return m;}\n#endif\n";

    var MorphTargetGLSL = "#if !defined(MorphTarget_lib)\n#define MorphTarget_lib\n#ifdef GRAPHICS_API_GLES3\nuniform sampler2DArray u_MorphTargetsTex;uniform vec4 u_MorphParams;uniform vec4 u_MorphAttrOffset;\n#define Morph_TexWidth u_MorphParams.x\n#define Morph_TexHeight u_MorphParams.y\n#define Morph_AttributeNum u_MorphParams.z\n#define Morph_TargetNum u_MorphParams.w\n#define Morph_PositionOffset u_MorphAttrOffset.x\n#define Morph_NormalOffset u_MorphAttrOffset.y\n#define Morph_TangentOffset u_MorphAttrOffset.z\nuniform vec4 u_MorphActiveTargets[MORPH_MAX_COUNT];uniform int u_MorphTargetActiveCount;\n#define MORPH_ACTIVE_COUNT u_MorphTargetActiveCount\nvec4 sampleMorphTargets(in int vertexID,in float targetID){int v=vertexID/int(Morph_TexWidth);int u=vertexID-v*int(Morph_TexWidth);vec3 uvw=vec3((float(u)+0.5)/Morph_TexWidth,(float(v)+0.5)/Morph_TexHeight,targetID);return texture(u_MorphTargetsTex,uvw);}vec3 positionMorph(in vec3 position){int vertexID=gl_VertexID*int(Morph_AttributeNum)+int(Morph_PositionOffset);for(int i=0;i<MORPH_ACTIVE_COUNT;i++){float index=u_MorphActiveTargets[i].x;float weight=u_MorphActiveTargets[i].y;position+=sampleMorphTargets(vertexID,index).xyz*weight;}return position;}vec3 normalMorph(in vec3 normal){int vertexID=gl_VertexID*int(Morph_AttributeNum)+int(Morph_NormalOffset);for(int i=0;i<MORPH_ACTIVE_COUNT;i++){float index=u_MorphActiveTargets[i].x;float weight=u_MorphActiveTargets[i].y;normal+=sampleMorphTargets(vertexID,index).xyz*weight;}return normal;}vec4 tangentMorph(in vec4 tangent){int vertexID=gl_VertexID*int(Morph_AttributeNum)+int(Morph_TangentOffset);for(int i=0;i<MORPH_ACTIVE_COUNT;i++){float index=u_MorphActiveTargets[i].x;float weight=u_MorphActiveTargets[i].y;vec4 sampleTangent=sampleMorphTargets(vertexID,index);tangent.xyz+=sampleTangent.xyz*weight*tangent.w*sampleTangent.w;}return tangent;}\n#endif\n#endif\n";

    var VertexGLSL = "#if !defined(VertexCommon_lib)\n#define VertexCommon_lib\n#ifdef MORPHTARGETS\n#include \"MorphTarget.glsl\";\n#endif\nstruct Vertex{vec3 positionOS;vec3 normalOS;\n#ifdef TANGENT\nvec4 tangentOS;\n#endif\n#ifdef UV\nvec2 texCoord0;\n#endif\n#ifdef UV1\nvec2 texCoord1;\n#endif\n#ifdef COLOR\nvec4 vertexColor;\n#endif\n#ifdef LIGHTMAP\nvec4 lightmapScaleOffset;\n#endif LIGHTMAP\n};vec4 getVertexPosition(){vec4 position=a_Position;\n#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_POSITION\n#ifdef GRAPHICS_API_GLES3\nposition.xyz=positionMorph(position.xyz);\n#endif\n#endif\n#endif\nreturn position;}vec3 getVertexNormal(){vec3 normal=a_Normal.xyz;\n#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_NORMAL\n#ifdef GRAPHICS_API_GLES3\nnormal.xyz=normalMorph(normal);\n#endif\n#endif\n#endif\nreturn normal;}\n#ifdef TANGENT\nvec4 getVertexTangent(){vec4 tangent=a_Tangent0;\n#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TANGENT\n#ifdef GRAPHICS_API_GLES3\ntangent=tangentMorph(tangent);\n#endif\n#endif\n#endif\nreturn tangent;}\n#endif\n#ifdef LIGHTMAP\n#ifndef GPU_INSTANCE\nuniform vec4 u_LightmapScaleOffset;\n#endif\nvec4 getLightmapScaleOffset(){\n#ifdef GPU_INSTANCE\nreturn a_LightmapScaleOffset;\n#else\nreturn u_LightmapScaleOffset;\n#endif\n}\n#endif\nvoid getVertexParams(inout Vertex vertex){vertex.positionOS=getVertexPosition().xyz;vertex.normalOS=getVertexNormal();\n#ifdef TANGENT\nvertex.tangentOS=getVertexTangent();\n#endif\n#ifdef UV\nvertex.texCoord0=a_Texcoord0;\n#endif\n#ifdef UV1\nvertex.texCoord1=a_Texcoord1;\n#endif\n#ifdef COLOR\nvertex.vertexColor=vec4(pow(a_Color.rgb,vec3(2.2)),a_Color.a);\n#endif\n#ifdef LIGHTMAP\nvertex.lightmapScaleOffset=getLightmapScaleOffset();\n#endif LIGHTMAP\n}\n#endif\n";

    var ShadingCommonGLSL = "#if !defined(ShadingCommon_lib)\n#define ShadingCommon_lib\nvarying vec3 v_PositionWS;varying vec3 v_NormalWS;varying vec3 v_TangentWS;varying vec3 v_BiNormalWS;\n#ifdef UV\nvarying vec2 v_Texcoord0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nvarying vec2 v_Texcoord1;\n#endif\n#endif\n#ifdef COLOR\nvarying vec4 v_VertexColor;\n#endif\nstruct PixelParams{vec3 positionWS;vec3 normalWS;vec3 tangentWS;vec3 biNormalWS;mat3 TBN;\n#ifdef UV\nvec2 uv0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nvec2 uv1;\n#endif\n#endif\n#ifdef COLOR\nvec4 vertexColor;\n#endif\n};\n#endif\n";

    var ShadingVertexGLSL = "#if !defined(ShadingVertex_lib)\n#define ShadingVertex_lib\n#include \"ShadingCommon.glsl\";\nvoid sharePixelParams(const in PixelParams params){v_PositionWS=params.positionWS;v_NormalWS=params.normalWS;v_TangentWS=params.tangentWS;v_BiNormalWS=params.biNormalWS;\n#ifdef UV\nv_Texcoord0=params.uv0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nv_Texcoord1=params.uv1;\n#endif LIGHTMAP\n#endif\n#ifdef COLOR\nv_VertexColor=params.vertexColor;\n#endif\n}void shadingPixelParams(inout PixelParams params,in Vertex vertex){mat4 worldMat=getWorldMatrix();vec4 pos=(worldMat*vec4(vertex.positionOS,1.0));params.positionWS=pos.xyz/pos.w;mat3 normalMat=transpose(inverse(mat3(worldMat)));params.normalWS=normalize((normalMat*vertex.normalOS).xyz);\n#ifdef TANGENT\nparams.tangentWS=normalize((normalMat*vertex.tangentOS.xyz).xyz);params.tangentWS*=WorldInvertFront;params.biNormalWS=normalize(cross(params.normalWS,params.tangentWS)*sign(vertex.tangentOS.w));\n#else\nparams.tangentWS=vec3(1.0,0.0,0.0);params.tangentWS*=WorldInvertFront;params.biNormalWS=normalize(cross(params.normalWS,params.tangentWS));\n#endif\n#ifdef UV\nparams.uv0=vertex.texCoord0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nparams.uv1=tranformLightMapUV(vertex.texCoord1,vertex.lightmapScaleOffset);\n#endif LIGHTMAP\n#endif\n#ifdef COLOR\nparams.vertexColor=vertex.vertexColor;\n#endif\n}\n#endif\n";

    var ShadingFragGLSL = "#if !defined(ShadingFrag_lib)\n#define ShadingFrag_lib\n#include \"ShadingCommon.glsl\";\n#define _InvertNormal (float(gl_FrontFacing) * 2.0 - 1.0);\nvoid getPixelParams(inout PixelParams params){params.positionWS=v_PositionWS;float invertN=_InvertNormal;params.normalWS=normalize(v_NormalWS*invertN);params.tangentWS=normalize(v_TangentWS*invertN);params.biNormalWS=normalize(v_BiNormalWS*invertN);params.TBN=mat3(params.tangentWS,params.biNormalWS,params.normalWS);\n#ifdef UV\nparams.uv0=v_Texcoord0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nparams.uv1=v_Texcoord1;\n#endif\n#endif\n#ifdef COLOR\nparams.vertexColor=v_VertexColor;\n#endif\n}\n#endif\n";

    var SceneGLSL = "#if !defined(SceneCommon_lib)\n#define SceneCommon_lib\n#ifdef ENUNIFORMBLOCK\nuniform Scene3D{float u_Time;vec4 u_FogParams;vec4 u_FogColor;float u_GIRotate;int u_DirationLightCount;};\n#else\nuniform float u_Time;uniform vec4 u_FogParams;uniform vec4 u_FogColor;uniform float u_GIRotate;uniform mediump int u_DirationLightCount;\n#endif\n#endif\n";

    var CameraGLSL = "#if !defined(CameraCommon_lib)\n#define CameraCommon_lib\n#ifdef ENUNIFORMBLOCK\nuniform BaseCamera{vec3 u_CameraPos;mat4 u_View;mat4 u_Projection;mat4 u_ViewProjection;vec3 u_CameraDirection;vec3 u_CameraUp;vec4 u_Viewport;vec4 u_ProjectionParams;vec4 u_OpaqueTextureParams;vec4 u_ZBufferParams;};\n#else\nuniform vec3 u_CameraPos;uniform mat4 u_View;uniform mat4 u_Projection;uniform mat4 u_ViewProjection;uniform vec3 u_CameraDirection;uniform vec3 u_CameraUp;uniform vec4 u_Viewport;uniform vec4 u_ProjectionParams;uniform vec4 u_OpaqueTextureParams;uniform vec4 u_ZBufferParams;\n#endif\nuniform sampler2D u_CameraDepthTexture;uniform sampler2D u_CameraDepthNormalsTexture;uniform sampler2D u_CameraOpaqueTexture;vec4 getPositionCS(in vec3 positionWS){return u_ViewProjection*vec4(positionWS,1.0);}vec3 getViewDirection(in vec3 positionWS){return normalize(u_CameraPos-positionWS);}vec4 remapPositionZ(vec4 position){\n#ifdef BLITSCREEN_INVERTY\nposition.y=-position.y;\n#endif\n#ifdef REMAP_Z\nposition.z=position.z*2.0-position.w;\n#endif\nreturn position;}\n#endif\n";

    var SkyCommon = "#if !defined(SkyCommon_lib)\n#define SkyCommon_lib\nuniform vec3 u_SunLight_direction;uniform vec4 u_SunLight_color;uniform mat4 u_SkyViewMat;uniform mat4 u_SkyProjectionMat;uniform mat4 u_SkyProjectionViewMat;vec4 remapSkyPositionZ(in vec4 position){position.z=position.w;\n#ifdef BLITSCREEN_INVERTY\nposition.y=-position.y;\n#endif\nreturn position;}const float c_deg2ang=3.141593/180.0;vec4 rotateAroundYInDegrees(vec4 vertex,float deg){float angle=deg*c_deg2ang;float sina=sin(angle);float cosa=cos(angle);mat2 m=mat2(cosa,-sina,sina,cosa);return vec4(m*vertex.xz,vertex.yw).xzyw;}\n#endif\n";

    var Sprite3DCommonGLSL = "#if !defined(Sprite3DCommon_lib)\n#define Sprite3DCommon_lib\nuniform mat4 u_WorldMat;uniform vec4 u_WorldInvertFront;\n#ifdef GPU_INSTANCE\n#define WorldInvertFront a_WorldInvertFront.x\n#define NodeCustomData0 a_WorldInvertFront.y\n#define NodeCustomData1 a_WorldInvertFront.z\n#define NodeCustomData2 a_WorldInvertFront.w\n#else\n#define WorldInvertFront u_WorldInvertFront.x\n#define NodeCustomData0 u_WorldInvertFront.y\n#define NodeCustomData1 u_WorldInvertFront.z\n#define NodeCustomData2 u_WorldInvertFront.w\n#endif\nvec2 tranformLightMapUV(in vec2 texcoord,in vec4 tilingOffset){vec2 lightMapUV=vec2(texcoord.x,1.0-texcoord.y)*tilingOffset.xy+tilingOffset.zw;lightMapUV.y=1.0-lightMapUV.y;return lightMapUV;}vec2 transformUV(in vec2 texcoord,in vec4 tilingOffset){vec2 uv=texcoord*tilingOffset.xy+tilingOffset.zw*vec2(1.0,-1.0)+vec2(0.0,1.0-tilingOffset.y);return uv;}\n#endif\n";

    var Sprite3DVertexGLSL = "#if !defined(Sprite3DVertex_lib)\n#define Sprite3DVertex_lib\n#include \"Sprite3DCommon.glsl\";\n#ifdef BONE\nuniform mat4 u_Bones[24];\n#ifdef SIMPLEBONE\nuniform vec4 u_SimpleAnimatorParams;uniform sampler2D u_SimpleAnimatorTexture;uniform float u_SimpleAnimatorTextureSize;\n#include \"BakedBoneMatrixSampler.glsl\";\n#endif\n#endif\nmat4 getWorldMatrix(){\n#ifdef GPU_INSTANCE\nmat4 worldMat=a_WorldMat;\n#else\nmat4 worldMat=u_WorldMat;\n#endif\n#ifdef BONE\n#ifdef SIMPLEBONE\n#ifdef GPU_INSTANCE\nfloat currentPixelPos=a_SimpleTextureParams.x+a_SimpleTextureParams.y;\n#else\nfloat currentPixelPos=u_SimpleAnimatorParams.x+u_SimpleAnimatorParams.y;\n#endif\nfloat offset=1.0/u_SimpleAnimatorTextureSize;mat4 skinTrans=loadBakedMatMatrix(currentPixelPos,a_BoneIndices.x,offset)*a_BoneWeights.x;skinTrans+=loadBakedMatMatrix(currentPixelPos,a_BoneIndices.y,offset)*a_BoneWeights.y;skinTrans+=loadBakedMatMatrix(currentPixelPos,a_BoneIndices.z,offset)*a_BoneWeights.z;skinTrans+=loadBakedMatMatrix(currentPixelPos,a_BoneIndices.w,offset)*a_BoneWeights.w;worldMat=worldMat*skinTrans;\n#else\nivec4 boneIndex=ivec4(a_BoneIndices);mat4 skinTrans=u_Bones[boneIndex.x]*a_BoneWeights.x;skinTrans+=u_Bones[boneIndex.y]*a_BoneWeights.y;skinTrans+=u_Bones[boneIndex.z]*a_BoneWeights.z;skinTrans+=u_Bones[boneIndex.w]*a_BoneWeights.w;worldMat=worldMat*skinTrans;\n#endif\n#endif\nreturn worldMat;}vec2 getSimpleBoneCustomData(){vec2 custom;\n#ifdef BONE\n#ifdef SIMPLEBONE\n#ifdef GPU_INSTANCE\ncustom=a_SimpleTextureParams.zw;\n#else\ncustom=u_SimpleAnimatorParams.zw;\n#endif\n#endif\n#endif\nreturn custom;}\n#endif\n";

    var Sprite3DFragGLSL = "#if !defined(Sprite3DFrag_lib)\n#define Sprite3DFrag_lib\n#include \"Sprite3DCommon.glsl\";\n#endif\n";

    var DepthVertexGLSL = "#if !defined(DepthVertex_lib)\n#define DepthVertex_lib\n#include \"Math.glsl\";\n#include \"Scene.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DVertex.glsl\";\n#include \"VertexCommon.glsl\";\n#if defined(SHADOW) || defined(SHADOW_SPOT)\n#ifndef DEPTHPASS\n#include \"ShadowCommon.glsl\"\nvec3 applyShadowBias(vec3 positionWS,vec3 normalWS,vec3 lightDirection){float invNdotL=1.0-clamp(dot(-lightDirection,normalWS),0.0,1.0);float scale=invNdotL*u_ShadowBias.y;positionWS+=-lightDirection*u_ShadowBias.xxx;positionWS+=normalWS*vec3(scale);return positionWS;}\n#endif\n#endif\n#ifdef DEPTHPASS\n#include \"Camera.glsl\";\n#endif\nvec4 DepthPositionCS(in vec3 positionWS,in vec3 normalWS){\n#ifdef DEPTHPASS\nvec4 positionCS=u_ViewProjection*vec4(positionWS,1.0);\n#endif\n#ifdef SHADOW\n#ifndef DEPTHPASS\npositionWS=applyShadowBias(positionWS,normalWS,u_ShadowLightDirection);vec4 positionCS=u_ViewProjection*vec4(positionWS,1.0);positionCS.z=max(positionCS.z,0.0);\n#endif\n#endif\n#ifdef SHADOW_SPOT\n#ifndef DEPTHPASS\nvec4 positionCS=u_ViewProjection*vec4(positionWS,1.0);positionCS.z=positionCS.z-u_ShadowBias.x/positionCS.w;positionCS.z=max(positionCS.z,0.0);\n#endif\n#endif\nreturn positionCS;}\n#endif\n";

    var DepthFragGLSL = "#if !defined(DepthFrag_lib)\n#define DepthFrag_lib\nvec4 getDepthColor(){return vec4(0.0);}\n#endif\n";

    var DepthNormalUtilGLSL = "#define SAMPLE_DEPTH_TEXTURE(textureName, coord2) (texture2D(textureName, coord2).r)\nvec2 EncodeViewNormalStereo(vec3 n){n.z=abs(n.z);float kScale=1.7777;vec2 enc;enc=n.xy/(n.z+1.0);enc/=kScale;enc=enc*0.5+0.5;return enc;}vec3 DecodeViewNormalStereo(vec4 enc4){float kScale=1.7777;vec3 nn=enc4.xyz*vec3(2.0*kScale,2.0*kScale,0.0)+vec3(-kScale,-kScale,1.0);float g=2.0/dot(nn.xyz,nn.xyz);vec3 n;n.xy=g*nn.xy;n.z=g-1.0;return n;}vec2 EncodeFloatRG(float v){vec2 kEncodeMul=vec2(1.0,255.0);float kEncodeBit=1.0/255.0;vec2 enc=kEncodeMul*v;enc=fract(enc);enc.x-=enc.y*kEncodeBit;return enc;}float DecodeFloatRG(vec2 enc){vec2 kDecodeDot=vec2(1.0,1.0/255.0);return dot(enc,kDecodeDot);}vec4 EncodeDepthNormal(float depth,vec3 normals){vec4 encode;encode.xy=EncodeViewNormalStereo(normals);encode.zw=EncodeFloatRG(depth);return encode;}void DecodeDepthNormal(vec4 enc,out float depth,out vec3 normal){depth=DecodeFloatRG(enc.zw);normal=DecodeViewNormalStereo(enc);}vec4 depthNormalsFragment(vec4 depthNormal){return EncodeDepthNormal(depthNormal.w,depthNormal.xyz);}float Linear01Depth(float z,vec4 zbufferParams){return 1.0/(zbufferParams.x*z+zbufferParams.y);}float LinearEyeDepth(float z,vec4 zbufferParams){return 1.0/(zbufferParams.z*z+zbufferParams.w);}";

    var DepthNormalFragGLSL = "#if !defined(DepthNormalFrag_lib)\n#define DepthNormalFrag_lib\n#include \"DepthNormalUtil.glsl\";\nvec4 encodeDepthNormal(const in vec4 positionCS,const in vec3 normalWS){float depth=(positionCS.z*2.0-positionCS.w)*u_ProjectionParams.w;vec3 normalVS=mat3(u_View)*normalWS;return EncodeDepthNormal(depth,normalVS);}\n#endif\n";

    var ShadowCommonGLSL = "#if !defined(ShadowCommon_lib)\n#define ShadowCommon_lib\n#ifndef GRAPHICS_API_GLES3\n#define NO_NATIVE_SHADOWMAP\n#endif\n#if defined(NO_NATIVE_SHADOWMAP)\n#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2D textureName\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) (texture2D(textureName, coord3.xy).r < coord3.z ? 0.0 : 1.0)\n#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2D shadowMap\n#else\n#define TEXTURE2D_SHADOW(textureName) uniform mediump sampler2DShadow textureName\n#define SAMPLE_TEXTURE2D_SHADOW(textureName, coord3) textureLod(textureName, coord3, 0.0)\n#define TEXTURE2D_SHADOW_PARAM(shadowMap) mediump sampler2DShadow shadowMap\n#endif\n#if defined(SHADOW) || defined(SHADOW_SPOT)\n#ifdef ENUNIFORMBLOCK\nuniform Shadow{vec3 u_ShadowLightDirection;vec4 u_ShadowBias;vec4 u_ShadowSplitSpheres[4];mat4 u_ShadowMatrices[4];vec4 u_ShadowMapSize;vec4 u_ShadowParams;vec4 u_SpotShadowMapSize;mat4 u_SpotViewProjectMatrix;};TEXTURE2D_SHADOW(u_ShadowMap);TEXTURE2D_SHADOW(u_SpotShadowMap);\n#else\nuniform vec3 u_ShadowLightDirection;uniform vec4 u_ShadowBias;uniform vec4 u_ShadowSplitSpheres[4];uniform mat4 u_ShadowMatrices[4];uniform vec4 u_ShadowMapSize;uniform vec4 u_ShadowParams;uniform vec4 u_SpotShadowMapSize;uniform mat4 u_SpotViewProjectMatrix;TEXTURE2D_SHADOW(u_ShadowMap);TEXTURE2D_SHADOW(u_SpotShadowMap);\n#endif\n#endif\n#endif\n";

    var ShadowSampleTentGLSL = "float sampleShadowGetIRTriangleTexelArea(float triangleHeight){return triangleHeight-0.5;}void sampleShadowGetTexelAreasTent3x3(float offset,out vec4 computedArea,out vec4 computedAreaUncut){float a=offset+0.5;float offsetSquaredHalved=a*a*0.5;computedAreaUncut.x=computedArea.x=offsetSquaredHalved-offset;computedAreaUncut.w=computedArea.w=offsetSquaredHalved;computedAreaUncut.y=sampleShadowGetIRTriangleTexelArea(1.5-offset);float clampedOffsetLeft=min(offset,0.0);float areaOfSmallLeftTriangle=clampedOffsetLeft*clampedOffsetLeft;computedArea.y=computedAreaUncut.y-areaOfSmallLeftTriangle;computedAreaUncut.z=sampleShadowGetIRTriangleTexelArea(1.5+offset);float clampedOffsetRight=max(offset,0.0);float areaOfSmallRightTriangle=clampedOffsetRight*clampedOffsetRight;computedArea.z=computedAreaUncut.z-areaOfSmallRightTriangle;}void sampleShadowGetTexelWeightsTent5x5(float offset,out vec3 texelsWeightsA,out vec3 texelsWeightsB){vec4 areaFrom3texelTriangle;vec4 areaUncutFrom3texelTriangle;sampleShadowGetTexelAreasTent3x3(offset,areaFrom3texelTriangle,areaUncutFrom3texelTriangle);texelsWeightsA.x=0.16*(areaFrom3texelTriangle.x);texelsWeightsA.y=0.16*(areaUncutFrom3texelTriangle.y);texelsWeightsA.z=0.16*(areaFrom3texelTriangle.y+1.0);texelsWeightsB.x=0.16*(areaFrom3texelTriangle.z+1.0);texelsWeightsB.y=0.16*(areaUncutFrom3texelTriangle.z);texelsWeightsB.z=0.16*(areaFrom3texelTriangle.w);}void sampleShadowComputeSamplesTent5x5(vec4 shadowMapTextureTexelSize,vec2 coord,out float fetchesWeights[9],out vec2 fetchesUV[9]){vec2 tentCenterInTexelSpace=coord.xy*shadowMapTextureTexelSize.zw;vec2 centerOfFetchesInTexelSpace=floor(tentCenterInTexelSpace+0.5);vec2 offsetFromTentCenterToCenterOfFetches=tentCenterInTexelSpace-centerOfFetchesInTexelSpace;vec3 texelsWeightsUA,texelsWeightsUB;vec3 texelsWeightsVA,texelsWeightsVB;sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.x,texelsWeightsUA,texelsWeightsUB);sampleShadowGetTexelWeightsTent5x5(offsetFromTentCenterToCenterOfFetches.y,texelsWeightsVA,texelsWeightsVB);vec3 fetchesWeightsU=vec3(texelsWeightsUA.xz,texelsWeightsUB.y)+vec3(texelsWeightsUA.y,texelsWeightsUB.xz);vec3 fetchesWeightsV=vec3(texelsWeightsVA.xz,texelsWeightsVB.y)+vec3(texelsWeightsVA.y,texelsWeightsVB.xz);vec3 fetchesOffsetsU=vec3(texelsWeightsUA.y,texelsWeightsUB.xz)/fetchesWeightsU.xyz+vec3(-2.5,-0.5,1.5);vec3 fetchesOffsetsV=vec3(texelsWeightsVA.y,texelsWeightsVB.xz)/fetchesWeightsV.xyz+vec3(-2.5,-0.5,1.5);fetchesOffsetsU*=shadowMapTextureTexelSize.xxx;fetchesOffsetsV*=shadowMapTextureTexelSize.yyy;vec2 bilinearFetchOrigin=centerOfFetchesInTexelSpace*shadowMapTextureTexelSize.xy;fetchesUV[0]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.x);fetchesUV[1]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.x);fetchesUV[2]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.x);fetchesUV[3]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.y);fetchesUV[4]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.y);fetchesUV[5]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.y);fetchesUV[6]=bilinearFetchOrigin+vec2(fetchesOffsetsU.x,fetchesOffsetsV.z);fetchesUV[7]=bilinearFetchOrigin+vec2(fetchesOffsetsU.y,fetchesOffsetsV.z);fetchesUV[8]=bilinearFetchOrigin+vec2(fetchesOffsetsU.z,fetchesOffsetsV.z);fetchesWeights[0]=fetchesWeightsU.x*fetchesWeightsV.x;fetchesWeights[1]=fetchesWeightsU.y*fetchesWeightsV.x;fetchesWeights[2]=fetchesWeightsU.z*fetchesWeightsV.x;fetchesWeights[3]=fetchesWeightsU.x*fetchesWeightsV.y;fetchesWeights[4]=fetchesWeightsU.y*fetchesWeightsV.y;fetchesWeights[5]=fetchesWeightsU.z*fetchesWeightsV.y;fetchesWeights[6]=fetchesWeightsU.x*fetchesWeightsV.z;fetchesWeights[7]=fetchesWeightsU.y*fetchesWeightsV.z;fetchesWeights[8]=fetchesWeightsU.z*fetchesWeightsV.z;}";

    var ShadowSamplerGLSL = "\n#if !defined(ShadowSampler_lib)\n#define ShadowSampler_lib\n#ifdef RECEIVESHADOW\n#include \"ShadowSampleTent.glsl\";\n#include \"ShadowCommon.glsl\"\n#define ShadowStrength u_ShadowParams.x\n#define SpotShadowStrength u_ShadowParams.y\n#ifdef SHADOW\n#define CALCULATE_SHADOWS\nvarying vec4 v_ShadowCoord;\n#endif\n#ifdef SHADOW_SPOT\n#define CALCULATE_SPOTSHADOWS\nvarying vec4 v_SpotShadowCoord;\n#endif\nfloat sampleShdowMapFiltered4(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowMapSize){float attenuation;vec4 attenuation4;vec2 offset=shadowMapSize.xy/2.0;vec3 shadowCoord0=shadowCoord+vec3(-offset,0.0);vec3 shadowCoord1=shadowCoord+vec3(offset.x,-offset.y,0.0);vec3 shadowCoord2=shadowCoord+vec3(-offset.x,offset.y,0.0);vec3 shadowCoord3=shadowCoord+vec3(offset,0.0);attenuation4.x=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord0);attenuation4.y=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord1);attenuation4.z=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord2);attenuation4.w=SAMPLE_TEXTURE2D_SHADOW(shadowMap,shadowCoord3);attenuation=dot(attenuation4,vec4(0.25));return attenuation;}float sampleShdowMapFiltered9(TEXTURE2D_SHADOW_PARAM(shadowMap),vec3 shadowCoord,vec4 shadowmapSize){float attenuation;float fetchesWeights[9];vec2 fetchesUV[9];sampleShadowComputeSamplesTent5x5(shadowmapSize,shadowCoord.xy,fetchesWeights,fetchesUV);attenuation=fetchesWeights[0]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[0].xy,shadowCoord.z));attenuation+=fetchesWeights[1]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[1].xy,shadowCoord.z));attenuation+=fetchesWeights[2]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[2].xy,shadowCoord.z));attenuation+=fetchesWeights[3]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[3].xy,shadowCoord.z));attenuation+=fetchesWeights[4]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[4].xy,shadowCoord.z));attenuation+=fetchesWeights[5]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[5].xy,shadowCoord.z));attenuation+=fetchesWeights[6]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[6].xy,shadowCoord.z));attenuation+=fetchesWeights[7]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[7].xy,shadowCoord.z));attenuation+=fetchesWeights[8]*SAMPLE_TEXTURE2D_SHADOW(shadowMap,vec3(fetchesUV[8].xy,shadowCoord.z));return attenuation;}\n#endif\n#if defined(CALCULATE_SHADOWS)\n#ifdef SHADOW_CASCADE\nmediump int computeCascadeIndex(in vec3 positionWS){vec3 fromCenter0=positionWS-u_ShadowSplitSpheres[0].xyz;vec3 fromCenter1=positionWS-u_ShadowSplitSpheres[1].xyz;vec3 fromCenter2=positionWS-u_ShadowSplitSpheres[2].xyz;vec3 fromCenter3=positionWS-u_ShadowSplitSpheres[3].xyz;mediump vec4 comparison=vec4(dot(fromCenter0,fromCenter0)<u_ShadowSplitSpheres[0].w,dot(fromCenter1,fromCenter1)<u_ShadowSplitSpheres[1].w,dot(fromCenter2,fromCenter2)<u_ShadowSplitSpheres[2].w,dot(fromCenter3,fromCenter3)<u_ShadowSplitSpheres[3].w);comparison.yzw=clamp(comparison.yzw-comparison.xyz,0.0,1.0);mediump vec4 indexCoefficient=vec4(4.0,3.0,2.0,1.0);mediump int index=4-int(dot(comparison,indexCoefficient));return index;}\n#endif\nvec4 getShadowCoord(in vec3 positionWS){\n#ifdef SHADOW_CASCADE\nmediump int cascadeIndex=computeCascadeIndex(positionWS);\n#ifdef GRAPHICS_API_GLES3\nmat4 shadowMat=u_ShadowMatrices[cascadeIndex];\n#else\nmat4 shadowMat;if(cascadeIndex==0){shadowMat=u_ShadowMatrices[0];}else if(cascadeIndex==1){shadowMat=u_ShadowMatrices[1];}else if(cascadeIndex==2){shadowMat=u_ShadowMatrices[2];}else{shadowMat=u_ShadowMatrices[3];}\n#endif\nreturn shadowMat*vec4(positionWS,1.0);\n#else\nreturn u_ShadowMatrices[0]*vec4(positionWS,1.0);\n#endif\n}float sampleShadowmap(in vec4 shadowCoord){float attenuation=1.0;vec3 coord=shadowCoord.xyz/shadowCoord.w;vec4 shadowmapSize=u_ShadowMapSize;{\n#if defined(SHADOW_SOFT_SHADOW_HIGH)\nattenuation=sampleShdowMapFiltered9(u_ShadowMap,coord,shadowmapSize);\n#elif defined(SHADOW_SOFT_SHADOW_LOW)\nattenuation=sampleShdowMapFiltered4(u_ShadowMap,coord,shadowmapSize);\n#else\nattenuation=SAMPLE_TEXTURE2D_SHADOW(u_ShadowMap,coord);\n#endif\nattenuation=mix(1.0,attenuation,ShadowStrength);}if(coord.z>0.0&&coord.z<1.0)return attenuation;return 1.0;}\n#endif\n#if defined(CALCULATE_SPOTSHADOWS)\nvec4 getSpotShadowCoord(in vec3 positionWS){vec4 coordinate=u_SpotViewProjectMatrix*vec4(positionWS,1.0);return coordinate;}float sampleSpotShadowmap(vec4 shadowCoord){float attenuation=1.0;vec3 coord=shadowCoord.xyz/shadowCoord.w;coord.xy=coord.xy*0.5+0.5;vec4 shadowmapSize=u_SpotShadowMapSize;\n#if defined(SHADOW_SPOT_SOFT_SHADOW_HIGH)\nattenuation=sampleShdowMapFiltered9(u_SpotShadowMap,coord,shadowmapSize);\n#elif defined(SHADOW_SPOT_SOFT_SHADOW_LOW)\nattenuation=sampleShdowMapFiltered4(u_SpotShadowMap,coord,shadowmapSize);\n#else\nattenuation=SAMPLE_TEXTURE2D_SHADOW(u_SpotShadowMap,coord);\n#endif\nattenuation=mix(1.0,attenuation,SpotShadowStrength);if(coord.z>0.0&&coord.z<1.0)return attenuation;return 1.0;}\n#endif\n#endif\n";

    var SceneFogGLSL = "#if !defined(SceneFog_lib)\n#define SceneFog_lib\n#ifdef FOG\nvarying float v_fogFactor;float getFogFactor(){return v_fogFactor;}vec3 scenUnlitFog(in vec3 color){float lerpFact=getFogFactor();\n#ifdef ADDTIVEFOG\nlerpFact=clamp(lerpFact,0.0,1.0);return mix(vec3(0.0),color,lerpFact);\n#else\nlerpFact=clamp(lerpFact,0.0,1.0);return mix(u_FogColor.rgb,color,lerpFact);\n#endif\n}vec3 sceneLitFog(in vec3 color){float lerpFact=getFogFactor();lerpFact=clamp(lerpFact,0.0,1.0);return mix(u_FogColor.rgb,color,lerpFact);}\n#endif\n#endif\n";

    var SceneFogInputGLSL = "#if !defined(SceneFog_lib)\n#define SceneFog_lib\n#ifdef FOG\nvarying float v_fogFactor;void FogHandle(in float fact){float lerpFact=0.0;\n#ifdef FOG_EXP\nlerpFact=fact*(u_FogParams.z/log(2.0));lerpFact=exp2(-lerpFact);\n#elif defined(FOG_EXP2)\nlerpFact=fact*(u_FogParams.z/sqrt(log(2.0)));lerpFact=exp2(-lerpFact);\n#else\nlerpFact=(-1.0*fact/(u_FogParams.y-u_FogParams.x)+u_FogParams.y/(u_FogParams.y-u_FogParams.x));\n#endif\nv_fogFactor=lerpFact;}\n#endif\n#endif\n";

    var LightingGLSL = "#if !defined(Lighting_lib)\n#define Lighting_lib\n#include \"ShadowSampler.glsl\";\nstruct Light{vec3 color;vec3 dir;float attenuation;};struct DirectionLight{vec3 color;vec3 direction;float attenuation;int lightMode;};struct PointLight{vec3 color;vec3 position;float range;float attenuation;int lightMode;};struct SpotLight{vec3 color;vec3 position;float range;vec3 direction;float spot;float attenuation;int lightMode;};\n#define LightMode_Mix 0\n#define LightMode_RealTime 1\nint getAttenuationByMode(float lightMapMode){\n#ifdef LIGHTMAP\nreturn int(lightMapMode);\n#else\n#ifdef VOLUMETRICGI\nreturn int(lightMapMode);\n#endif\n#endif\nreturn LightMode_RealTime;}\n#if defined(DIRECTIONLIGHT) || defined(POINTLIGHT) || defined(SPOTLIGHT)\n#define LIGHTING\nfloat attenuation(in vec3 L,in float invLightRadius){float fRatio=clamp(length(L)*invLightRadius,0.0,1.0);fRatio*=fRatio;return 1.0/(1.0+25.0*fRatio)*clamp(4.0*(1.0-fRatio),0.0,1.0);}Light getLight(in DirectionLight directionLight){Light light;light.color=directionLight.color;light.dir=directionLight.direction;light.attenuation=directionLight.attenuation;return light;}Light getLight(in PointLight pointLight,in vec3 normalWS,in vec3 positionWS){vec3 lightDirection=positionWS-pointLight.position;float rangeAttenuate=attenuation(lightDirection,1.0/pointLight.range);Light light;light.color=pointLight.color*rangeAttenuate;light.dir=normalize(lightDirection);light.attenuation=pointLight.attenuation;return light;}Light getLight(in SpotLight spotLight,in vec3 normalWS,in vec3 positionWS){vec3 lightDirection=positionWS-spotLight.position;vec3 normalizeLightDir=normalize(lightDirection);vec2 cosAngles=cos(vec2(spotLight.spot,spotLight.spot*0.5)*0.5);float dirAttenuate=dot(spotLight.direction,normalizeLightDir);dirAttenuate*=smoothstep(cosAngles.x,cosAngles.y,dirAttenuate);float rangeAttenuate=attenuation(lightDirection,1.0/spotLight.range);Light light;light.color=spotLight.color*rangeAttenuate*dirAttenuate;light.dir=normalizeLightDir;light.attenuation=spotLight.attenuation;return light;}\n#ifdef LEGACYSINGLELIGHTING\n#define CalculateLightCount 1\n#define DirectionCount 1\n#ifdef DIRECTIONLIGHT\nuniform vec3 u_DirLightColor;uniform vec3 u_DirLightDirection;uniform int u_DirLightMode;\n#endif\n#ifdef POINTLIGHT\nuniform vec3 u_PointLightColor;uniform vec3 u_PointLightPos;uniform float u_PointLightRange;uniform int u_PointLightMode;\n#endif\n#ifdef SPOTLIGHT\nuniform vec3 u_SpotLightPos;uniform vec3 u_SpotLightColor;uniform vec3 u_SpotLightDirection;uniform float u_SpotLightRange;uniform float u_SpotLightSpot;uniform int u_SpotLightMode;\n#endif\n#else\n#define CalculateLightCount MAX_LIGHT_COUNT\n#define DirectionCount u_DirationLightCount\nuniform sampler2D u_LightBuffer;\n#if defined(POINTLIGHT) || defined(SPOTLIGHT)\nconst int c_ClusterBufferWidth=CLUSTER_X_COUNT*CLUSTER_Y_COUNT;int c_ClusterBufferHeight=CLUSTER_Z_COUNT*(1+int(ceil(float(MAX_LIGHT_COUNT_PER_CLUSTER)/4.0)));const int c_ClusterBufferFloatWidth=c_ClusterBufferWidth*4;uniform sampler2D u_LightClusterBuffer;int getLightIndex(in int offset,in int index){int totalOffset=offset+index;int row=totalOffset/c_ClusterBufferFloatWidth;int lastRowFloat=totalOffset-row*c_ClusterBufferFloatWidth;int col=lastRowFloat/4;vec2 uv=vec2((float(col)+0.5)/float(c_ClusterBufferWidth),(float(row)+0.5)/float(c_ClusterBufferHeight));vec4 texPixel=texture2D(u_LightClusterBuffer,uv);int pixelComponent=lastRowFloat-col*4;\n#ifdef GRAPHICS_API_GLES3\nreturn int(texPixel[pixelComponent]);\n#else\nif(pixelComponent==0)return int(texPixel.x);else if(pixelComponent==1)return int(texPixel.y);else if(pixelComponent==2)return int(texPixel.z);else return int(texPixel.w);\n#endif\n}\n#endif\n#endif\n#ifdef DIRECTIONLIGHT\nDirectionLight getDirectionLight(in int index,in vec3 positionWS){DirectionLight light;\n#ifdef LEGACYSINGLELIGHTING\nlight.color=u_DirLightColor;light.direction=u_DirLightDirection;light.attenuation=1.0;light.lightMode=getAttenuationByMode(float(u_DirLightMode));\n#else\nfloat v=(float(index)+0.5)/float(CalculateLightCount);vec4 p1=texture2D(u_LightBuffer,vec2(0.125,v));vec4 p2=texture2D(u_LightBuffer,vec2(0.375,v));light.color=p1.rgb;light.direction=p2.rgb;light.attenuation=1.0;light.lightMode=getAttenuationByMode(p1.a);\n#endif\n#if defined(CALCULATE_SHADOWS)\nif(index==0){vec4 shadowCoord=getShadowCoord(positionWS);float shadowAttenuation=sampleShadowmap(shadowCoord);light.attenuation=shadowAttenuation;}\n#endif\nreturn light;}\n#endif\n#if defined(POINTLIGHT) || defined(SPOTLIGHT)\nivec4 getClusterInfo(mat4 viewMatrix,vec4 viewport,vec3 positionWS,vec4 fragCoord,vec4 projectParams){\n#ifdef LEGACYSINGLELIGHTING\nreturn ivec4(1,1,0,0);\n#else\nvec3 viewPos=vec3(viewMatrix*vec4(positionWS,1.0));int clusterXIndex=int(floor(fragCoord.x/(float(viewport.z)/float(CLUSTER_X_COUNT))));int clusterYIndex=int(floor((viewport.w*(projectParams.z<0.0 ? 0.0 : 1.0)-fragCoord.y*projectParams.z)/(float(viewport.w)/float(CLUSTER_Y_COUNT))));float zSliceParam=float(CLUSTER_Z_COUNT)/log2(projectParams.y/projectParams.x);int clusterZIndex=int(floor(log2(-viewPos.z)*zSliceParam-log2(projectParams.x)*zSliceParam));vec2 uv=vec2((float(clusterXIndex+clusterYIndex*CLUSTER_X_COUNT)+0.5)/float(c_ClusterBufferWidth),(float(clusterZIndex)+0.5)/float(c_ClusterBufferHeight));vec4 clusterPixel=texture2D(u_LightClusterBuffer,uv);return ivec4(clusterPixel);\n#endif\n}\n#endif\n#ifdef POINTLIGHT\nPointLight getPointLight(in int index,in ivec4 clusterInfo,in vec3 positionWS){PointLight light;\n#ifdef LEGACYSINGLELIGHTING\nlight.color=u_PointLightColor;light.position=u_PointLightPos;light.range=u_PointLightRange;light.attenuation=1.0;light.lightMode=getAttenuationByMode(float(u_PointLightMode));\n#else\nint indexOffset=clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w;int pointIndex=getLightIndex(indexOffset,index);float v=(float(pointIndex)+0.5)/float(CalculateLightCount);vec4 p1=texture2D(u_LightBuffer,vec2(0.125,v));vec4 p2=texture2D(u_LightBuffer,vec2(0.375,v));light.color=p1.rgb;light.range=p1.a;light.position=p2.rgb;light.attenuation=1.0;light.lightMode=getAttenuationByMode(p2.a);\n#endif\nreturn light;}\n#endif\n#ifdef SPOTLIGHT\nSpotLight getSpotLight(in int index,in ivec4 clusterInfo,in vec3 positionWS){SpotLight light;\n#ifdef LEGACYSINGLELIGHTING\nlight.color=u_SpotLightColor;light.position=u_SpotLightPos;light.range=u_SpotLightRange;light.direction=u_SpotLightDirection;light.spot=u_SpotLightSpot;light.attenuation=1.0;light.lightMode=getAttenuationByMode(float(u_SpotLightMode));\n#else\nint indexOffset=clusterInfo.z*c_ClusterBufferFloatWidth+clusterInfo.w;int spotIndex=getLightIndex(indexOffset,index+clusterInfo.x);float v=(float(spotIndex)+0.5)/float(CalculateLightCount);vec4 p1=texture2D(u_LightBuffer,vec2(0.125,v));vec4 p2=texture2D(u_LightBuffer,vec2(0.375,v));vec4 p3=texture2D(u_LightBuffer,vec2(0.625,v));light.color=p1.rgb;light.range=p1.a;light.position=p2.rgb;light.spot=p2.a;light.direction=p3.rgb;light.attenuation=1.0;light.lightMode=getAttenuationByMode(p3.a);\n#endif\n#if defined(CALCULATE_SPOTSHADOWS)\nif(index==0){vec4 shadowCoord=getSpotShadowCoord(positionWS);float shadowAttenuation=sampleSpotShadowmap(shadowCoord);light.attenuation=shadowAttenuation;}\n#endif\nreturn light;}\n#endif\n#endif\n#endif\n";

    var GlobalIlluminationGLSL = "#if !defined(globalIllumination_lib)\n#define globalIllumination_lib\n#ifdef ENUNIFORMBLOCK\nuniform ReflectionProbe{vec4 u_AmbientColor;vec3 u_IblSH[9];float u_IBLRoughnessLevel;float u_AmbientIntensity;float u_ReflectionIntensity;};uniform samplerCube u_IBLTex;\n#else\nuniform vec4 u_AmbientColor;uniform vec3 u_IblSH[9];uniform samplerCube u_IBLTex;uniform float u_IBLRoughnessLevel;uniform float u_AmbientIntensity;uniform float u_ReflectionIntensity;\n#endif\n#ifdef VOLUMETRICGI\n#include \"VolumetricGI.glsl\";\n#endif\nvec3 rotateByYAixs(in vec3 normal){float co=cos(u_GIRotate);float si=sin(u_GIRotate);float x=normal.x*co-normal.z*si;float z=normal.x*si+normal.z*co;return vec3(x,normal.y,z);}vec4 rotateByYAixs(in vec4 normal){float co=cos(u_GIRotate);float si=sin(u_GIRotate);float x=normal.x*co-normal.z*si;float z=normal.x*si+normal.z*co;return vec4(x,normal.y,z,normal.w);}\n#ifdef GI_IBL\nvec3 diffuseIrradiance(in vec3 normalWS){vec3 n=normalWS*vec3(-1.0,1.0,1.0);n=rotateByYAixs(n);return max(u_IblSH[0]+u_IblSH[1]*n.y+u_IblSH[2]*n.z+u_IblSH[3]*n.x+u_IblSH[4]*(n.y*n.x)+u_IblSH[5]*(n.y*n.z)+u_IblSH[6]*(3.0*n.z*n.z-1.0)+u_IblSH[7]*(n.z*n.x)+u_IblSH[8]*(n.x*n.x-n.y*n.y),0.0)*u_AmbientIntensity;}vec3 diffuseIrradiance(in vec3 normalWS,in vec3 positionWS,in vec3 viewDir){\n#ifdef VOLUMETRICGI\nvec3 surfaceBias=VolumetricGISurfaceBias(normalWS,viewDir);return VolumetricGIVolumeIrradiance(positionWS,surfaceBias,normalWS)*u_AmbientIntensity;\n#else\nreturn diffuseIrradiance(normalWS);\n#endif\n}vec3 specularRadiance(in vec3 r,in float perceptualRoughness){float lod=u_IBLRoughnessLevel*perceptualRoughness*(2.0-perceptualRoughness);vec3 reflectDir=r*vec3(-1.0,1.0,1.0);reflectDir=rotateByYAixs(reflectDir);\n#ifdef LOD_TEXTURE_SAMPLE\nvec4 reflectSampler=textureCubeLodEXT(u_IBLTex,reflectDir,lod);\n#else\nvec4 reflectSampler=textureLod(u_IBLTex,reflectDir,lod);\n#endif\n#ifdef IBL_RGBD\nreturn decodeRGBD(reflectSampler)*u_ReflectionIntensity;\n#else\nreturn reflectSampler.rgb*u_ReflectionIntensity;\n#endif\n}\n#endif\n#ifdef GI_LEGACYIBL\nuniform vec4 u_AmbientSHAr;uniform vec4 u_AmbientSHAg;uniform vec4 u_AmbientSHAb;uniform vec4 u_AmbientSHBr;uniform vec4 u_AmbientSHBg;uniform vec4 u_AmbientSHBb;uniform vec4 u_AmbientSHC;\n#define LAYA_SPECCUBE_LOD_STEPS 6.0\nuniform samplerCube u_ReflectTexture;uniform vec4 u_ReflectCubeHDRParams;vec3 shEvalLinearL0L1(in vec4 normal){vec3 x;x.r=dot(u_AmbientSHAr,normal);x.g=dot(u_AmbientSHAg,normal);x.b=dot(u_AmbientSHAb,normal);return x;}vec3 shEvalLinearL2(in vec4 normal){vec3 x1,x2;vec4 vB=normal.xyzz*normal.yzzx;x1.r=dot(u_AmbientSHBr,vB);x1.g=dot(u_AmbientSHBg,vB);x1.b=dot(u_AmbientSHBb,vB);float vC=normal.x*normal.x-normal.y*normal.y;x2=u_AmbientSHC.rgb*vC;return x1+x2;}vec3 diffuseIrradiance(in vec3 normalWS){vec4 normal=vec4(-normalWS.x,normalWS.yz,1.0);normal=rotateByYAixs(normal);vec3 ambientContrib=shEvalLinearL0L1(normal);ambientContrib+=shEvalLinearL2(normal);vec3 ambient=max(vec3(0.0),ambientContrib);return ambient*u_AmbientIntensity;}vec3 diffuseIrradiance(in vec3 normalWS,in vec3 positionWS,in vec3 viewDir){\n#ifdef VOLUMETRICGI\nvec3 surfaceBias=VolumetricGISurfaceBias(normalWS,viewDir);return VolumetricGIVolumeIrradiance(positionWS,surfaceBias,normalWS)*u_AmbientIntensity;\n#else\nreturn diffuseIrradiance(normalWS);\n#endif\n}vec3 specularRadiance(in vec3 r,in float perceptualRoughness){float roughness=perceptualRoughness*(1.7-0.7*perceptualRoughness);r*=vec3(-1.0,1.0,1.0);r=rotateByYAixs(r);float lod=roughness*LAYA_SPECCUBE_LOD_STEPS;vec4 rgbm=textureCubeLodEXT(u_ReflectTexture,r,lod);float range=u_ReflectCubeHDRParams.x;vec3 color=decodeRGBM(rgbm,range);color=gammaToLinear(color);return color*u_ReflectionIntensity;}\n#endif\n#ifndef GI_IBL\n#ifndef GI_LEGACYIBL\nvec3 diffuseIrradiance(in vec3 normalWS){return u_AmbientColor.rgb*u_AmbientIntensity;}vec3 diffuseIrradiance(in vec3 normalWS,in vec3 positionWS,in vec3 viewDir){return diffuseIrradiance(normalWS);}vec3 specularRadiance(in vec3 r,in float perceptualRoughness){return u_AmbientColor.rgb*u_ReflectionIntensity;}\n#endif\n#endif\n#ifdef LIGHTMAP\n#ifdef UV1\n#define USELIGHTMAP\n#endif\nuniform sampler2D u_LightMap;\n#ifdef LIGHTMAP_DIRECTIONAL\nuniform sampler2D u_LightMapDirection;vec3 DecodeDirectionalLightmap(in vec2 lightmapUV,in vec3 bakeColor,in vec3 normalWS){vec4 dirLightmap=texture2D(u_LightMapDirection,lightmapUV);vec3 lightdir=normalize(dirLightmap.xyz-vec3(0.5));float halfLambert=clamp(dot(normalWS,lightdir),0.0,1.0)*0.5+0.5;return bakeColor*halfLambert/max(dirLightmap.w,0.001);}\n#endif\nvec3 getBakedLightmapColor(in vec2 lightmapUV,in vec3 normalWS){vec4 lightmapSampler=texture2D(u_LightMap,lightmapUV);lightmapSampler.rgb=decodeRGBM(lightmapSampler,5.0);lightmapSampler=gammaToLinear(lightmapSampler);\n#ifdef LIGHTMAP_DIRECTIONAL\nlightmapSampler.rgb=DecodeDirectionalLightmap(lightmapUV,lightmapSampler.rgb,normalWS);\n#endif\nreturn lightmapSampler.rgb;}\n#endif\n#ifdef SPECCUBE_BOX_PROJECTION\nuniform vec3 u_SpecCubeProbePosition;uniform vec3 u_SpecCubeBoxMax;uniform vec3 u_SpecCubeBoxMin;vec3 getBoxProjectionReflectedVector(vec3 r,vec3 positionWS){vec3 boxCenter=u_SpecCubeProbePosition;vec3 boxMin=u_SpecCubeBoxMin;vec3 boxMax=u_SpecCubeBoxMax;vec3 nr=normalize(r);vec3 rbmax=boxMax-positionWS;vec3 rbmin=boxMin-positionWS;vec3 select=step(vec3(0.0),r);vec3 rbminmax=mix(rbmin,rbmax,select)/nr;float scalar=vecmin(rbminmax);vec3 boxr=nr*scalar+positionWS-boxCenter;return boxr;}\n#endif\n#endif\n";

    var OctGLSL = "#if !defined(Oct_lib)\n#define Oct_lib\nfloat signNotZero(in float k){return k>=0.0 ? 1.0 :-1.0;}vec2 signNotZero(in vec2 v){return vec2(signNotZero(v.x),signNotZero(v.y));}vec2 octEncode(in vec3 v){float l1norm=abs(v.x)+abs(v.y)+abs(v.z);vec2 result=v.xy*(1.0/l1norm);if(v.z<0.0){result=(1.0-abs(result.yx))*signNotZero(result.xy);}return result;}vec3 finalDecode(float x,float y){vec3 v=vec3(x,y,1.0-abs(x)-abs(y));if(v.z<0.0){v.xy=(1.0-abs(v.yx))*signNotZero(v.xy);}return normalize(v);}vec2 textureCoordFromDirection(in vec3 dir,vec4 outSize,vec4 gridSize){vec2 uv=(octEncode(normalize(dir)))*0.5+0.5;uv=uv*(outSize.xy-vec2(2.0,2.0))*outSize.zw+outSize.zw;uv=gridSize.xy*(1.0/gridSize.zw)+uv*(1.0/gridSize.zw);return uv;}\n#endif\n";

    var GridHelpersGLSL = "#if !defined(GridHelpers_lib)\n#define GridHelpers_lib\nint imod(int x,int y){\n#ifdef GRAPHICS_API_GLES3\nreturn x % y;\n#else\nreturn x-(x/y)*y;\n#endif\n}int gridCoordToProbeIndex(in ivec3 probeCoords,const in ivec3 probeCounts){return probeCoords.x+probeCoords.y*probeCounts.x+probeCoords.z*probeCounts.x*probeCounts.y;}ivec3 probeIndexToGridcoord(in int probeIndex,const in ivec3 probeCounts){ivec3 iPos;iPos.x=imod(probeIndex,probeCounts.x);iPos.y=imod(probeIndex,(probeCounts.x*probeCounts.y))/probeCounts.x;iPos.z=probeIndex/(probeCounts.x*probeCounts.y);return iPos;}vec3 gridCoordToPosition(in ivec3 coord,const in vec3 probeStep,const in vec3 probeStartPosition){return(vec3(coord)+0.5)*probeStep+probeStartPosition;}ivec3 baseGridCoord(in vec3 position,in vec3 probeStep,in vec3 probeStartPosition,in ivec3 probeCounts){probeStartPosition+=0.5*probeStep;return ivec3(clamp(vec3((position-probeStartPosition)/probeStep),vec3(0,0,0),vec3(probeCounts)-vec3(1,1,1)));}\n#endif\n";

    var VolumetricGIGLSL = "\n#if !defined(VolumetricGI_lib)\n#define VolumetricGI_lib\n#include \"Oct.glsl\";\n#include \"GridHelpers.glsl\";\n#ifdef ENUNIFORMBLOCK\nuniform VolumetricGIProbe{vec3 u_VolGIProbeCounts;vec3 u_VolGIProbeStep;vec3 u_VolGIProbeStartPosition;vec4 u_VolGIProbeParams;};uniform sampler2D u_ProbeIrradiance;uniform sampler2D u_ProbeDistance;\n#else\nuniform vec3 u_VolGIProbeCounts;uniform vec3 u_VolGIProbeStep;uniform vec3 u_VolGIProbeStartPosition;uniform vec4 u_VolGIProbeParams;uniform sampler2D u_ProbeIrradiance;uniform sampler2D u_ProbeDistance;\n#endif\nstruct VolumetricGI{vec3 probeCounts;vec3 probeStep;vec3 probeStartPosition;vec4 probeParams;};vec2 porbeGridCoordToTextureGridCoord(in ivec3 porbeGridCoord,in ivec3 probeCounts,in vec2 textureGridSize){int probeIndex=gridCoordToProbeIndex(porbeGridCoord,probeCounts);ivec2 index;index.x=imod(probeIndex,(probeCounts.x*probeCounts.y));index.y=probeIndex/(probeCounts.x*probeCounts.y);vec2 textureGridCoord=vec2(index);textureGridCoord.y=textureGridCoord.y;return textureGridCoord;}vec3 VolumetricGISurfaceBias(in vec3 surfaceNormal,in vec3 cameraDirection){return surfaceNormal*u_VolGIProbeParams.z+cameraDirection*u_VolGIProbeParams.w;}vec3 VolumetricGIVolumeIrradiance(in vec3 worldPosition,in vec3 surfaceBias,in vec3 direction){ivec3 porbeCounts=ivec3(u_VolGIProbeCounts);vec3 probeStep=u_VolGIProbeStep;vec3 probeStartPosition=u_VolGIProbeStartPosition;vec2 volumeCounts=vec2(porbeCounts.x*porbeCounts.y,porbeCounts.z);vec4 irradianceTexels=vec4(u_VolGIProbeParams.x,u_VolGIProbeParams.x,1.0/u_VolGIProbeParams.x,1.0/u_VolGIProbeParams.x);vec4 distanceTexels=vec4(u_VolGIProbeParams.y,u_VolGIProbeParams.y,1.0/u_VolGIProbeParams.y,1.0/u_VolGIProbeParams.y);ivec3 maxGridCoord=porbeCounts-ivec3(1);vec3 irradiance=vec3(0.0);float accumulatedWeights=0.0;vec3 biasedWorldPosition=worldPosition+surfaceBias;ivec3 baseProbeCoords=baseGridCoord(biasedWorldPosition,probeStep,probeStartPosition,porbeCounts);vec3 baseProbeWorldPosition=gridCoordToPosition(baseProbeCoords,probeStep,probeStartPosition);vec3 gridSpaceDistance=biasedWorldPosition-baseProbeWorldPosition;vec3 alpha=clamp(gridSpaceDistance/probeStep,vec3(0.0),vec3(1.0));for(int probeIndex=0;probeIndex<8;probeIndex++){ivec3 adjacentProbeOffset=ivec3(imod(probeIndex,2),imod((probeIndex/2),2),imod((probeIndex/4),2));ivec3 adjacentProbeCoords=ivec3(clamp(vec3(baseProbeCoords+adjacentProbeOffset),vec3(0),vec3(maxGridCoord)));vec3 adjacentProbeWorldPosition=gridCoordToPosition(adjacentProbeCoords,probeStep,probeStartPosition);vec3 worldPosToAdjProbe=normalize(adjacentProbeWorldPosition-worldPosition);vec3 biasedPosToAdjProbe=normalize(adjacentProbeWorldPosition-biasedWorldPosition);float biasedPosToAdjProbeDist=distance(adjacentProbeWorldPosition,biasedWorldPosition);vec3 trilinear=max(vec3(0.001),mix(1.0-alpha,alpha,vec3(adjacentProbeOffset)));float trilinearWeight=trilinear.x*trilinear.y*trilinear.z;float weight=1.0;float warpShading=(dot(worldPosToAdjProbe,direction)+1.0)*0.5;weight*=(warpShading*warpShading)*0.2;vec2 textureGridCoord=porbeGridCoordToTextureGridCoord(adjacentProbeCoords,porbeCounts,volumeCounts);vec2 probeTextureUV=textureCoordFromDirection(-biasedPosToAdjProbe,distanceTexels,vec4(textureGridCoord,volumeCounts));vec3 filteredDistance=texture2D(u_ProbeDistance,probeTextureUV).xyz;float variance=abs(filteredDistance.x*filteredDistance.x-filteredDistance.y);float chebyshevWeight=1.0;if(biasedPosToAdjProbeDist>filteredDistance.x){float v=biasedPosToAdjProbeDist-filteredDistance.x;chebyshevWeight=variance/(variance+(v*v));chebyshevWeight=max(chebyshevWeight*chebyshevWeight*chebyshevWeight,0.0);}if(filteredDistance.z<1.0){chebyshevWeight=1.0;}weight*=max(0.05,chebyshevWeight);weight=max(0.000001,weight);const float crushThreshold=0.2;if(weight<crushThreshold){weight*=(weight*weight)*(1.0/(crushThreshold*crushThreshold));}weight*=trilinearWeight;probeTextureUV=textureCoordFromDirection(direction,irradianceTexels,vec4(textureGridCoord,volumeCounts));vec3 probeIrradiance=linearToGamma(texture2D(u_ProbeIrradiance,probeTextureUV).rgb);irradiance+=(probeIrradiance*weight);accumulatedWeights+=weight;}if(accumulatedWeights==0.0){return vec3(0.0);}irradiance*=(1.0/accumulatedWeights);irradiance=gammaToLinear(irradiance);return irradiance;}\n#endif\n";

    var BlinnPhongLightingGLSL = "#if !defined(BlinnPhongLighting_lib)\n#define BlinnPhongLighting_lib\n#include \"Lighting.glsl\";\n#include \"globalIllumination.glsl\";\nstruct PixelInfo{vec3 positionWS;vec3 vertexNormalWS;vec3 normalWS;vec3 viewDir;\n#ifdef LIGHTMAP\n#ifdef UV1\nvec2 lightmapUV;\n#endif\n#endif\n};struct Surface{vec3 diffuseColor;vec3 specularColor;float shininess;vec3 gloss;vec3 normalTS;float alpha;float alphaClip;};vec3 BlinnPhongLighting(in Surface surface,in Light light,in PixelInfo pixel){vec3 l=normalize(-light.dir);vec3 v=pixel.viewDir;vec3 normalWS=pixel.normalWS;vec3 diffuseColor=surface.diffuseColor;float shininess=surface.shininess;vec3 specularColor=surface.specularColor;vec3 gloss=surface.gloss;float ndl=max(0.0,dot(normalWS,l));vec3 lightDiffuse=light.color*diffuseColor*ndl;mediump vec3 h=normalize(v+l);lowp float ndh=max(0.0,dot(h,normalWS));float specularIntensity=pow(ndh,shininess*128.0);vec3 lightSpecular=light.color*specularColor*specularIntensity*gloss;return lightDiffuse+lightSpecular;}vec3 BlinnPhongGI(const in Surface surface,const in PixelInfo info){vec3 indirect=vec3(0.0);\n#ifdef LIGHTMAP\n#ifdef UV1\nvec2 lightmapUV=info.lightmapUV;vec3 bakedColor=getBakedLightmapColor(lightmapUV,info.normalWS);indirect=bakedColor*surface.diffuseColor;\n#endif\n#else\nvec3 n=info.normalWS;indirect=diffuseIrradiance(n)*surface.diffuseColor;\n#endif\nreturn indirect;}\n#endif\n";

    var PBRLightingGLSL = "#if !defined(PBRLighting_lib)\n#define PBRLighting_lib\n#include \"Lighting.glsl\";\n#if !defined(GL_FRAGMENT_PRECISION_HIGH)\n#define MIN_PERCEPTUAL_ROUGHNESS 0.089\n#define MIN_ROUGHNESS 0.007921\n#else\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#define MIN_ROUGHNESS 0.002025\n#endif\n#define MIN_N_DOT_V 1e-4\n#include \"BRDF.glsl\";\nstruct PixelInfo{vec3 positionWS;vec3 vertexNormalWS;vec3 normalWS;vec3 tangentWS;vec3 biNormalWS;vec3 viewDir;float NoV;vec3 dfg;vec3 energyCompensation;\n#ifdef IRIDESCENCE\nvec3 iridescenceFresnel;\n#endif\n#ifdef CLEARCOAT\nvec3 clearCoatNormal;float clearCoatNoV;\n#endif\n#ifdef SHEEN\nfloat sheenScaling;float sheenDfg;\n#endif\n#ifdef ANISOTROPIC\nvec3 anisotropicT;vec3 anisotropicB;float ToV;float BoV;float at;float ab;\n#endif\n#ifdef THICKNESS\nvec4 worldScale;\n#endif\n#ifdef LIGHTMAP\n#ifdef UV1\nvec2 lightmapUV;\n#endif\n#endif\n};struct Surface{vec3 diffuseColor;float alpha;vec3 f0;vec3 f90;float roughness;float perceptualRoughness;float occlusion;\n#ifdef EMISSION\nvec3 emissionColor;\n#endif\nvec3 normalTS;float ior;\n#ifdef CLEARCOAT\nfloat clearCoat;float clearCoatRoughness;float clearCoatPerceptualRoughness;\n#ifdef CLEARCOAT_NORMAL\nvec3 clearCoatNormalTS;\n#endif\n#endif\n#ifdef ANISOTROPIC\nfloat anisotropy;vec2 anisotropyDirection;\n#endif\n#ifdef IRIDESCENCE\nfloat iridescence;float iridescenceIor;float iridescenceThickness;\n#endif\n#ifdef SHEEN\nvec3 sheenColor;float sheenRoughness;float sheenPerceptualRoughness;\n#endif\n#ifdef TRANSMISSION\nfloat transmission;\n#endif\n#ifdef THICKNESS\nfloat thickness;vec3 attenuationColor;float attenuationDistance;\n#endif\n};struct LightParams{vec3 l;vec3 h;float NoL;float NoH;float LoH;float VoH;\n#ifdef CLEARCOAT\nfloat clearCoatNoH;float clearCoatNoL;\n#endif\n#ifdef ANISOTROPIC\nfloat ToL;float BoL;\n#endif\n};void initLightParams(inout LightParams params,const in PixelInfo pixel,const in Light light){vec3 v=pixel.viewDir;vec3 n=pixel.normalWS;vec3 l=normalize(-light.dir);params.l=l;vec3 h=SafeNormalize(v+l);params.h=h;params.NoL=saturate(dot(n,l));params.NoH=saturate(dot(n,h));params.LoH=saturate(dot(l,h));params.VoH=saturate(dot(v,h));\n#ifdef CLEARCOAT\nparams.clearCoatNoL=saturate(dot(pixel.clearCoatNormal,l));params.clearCoatNoH=saturate(dot(pixel.clearCoatNormal,h));\n#endif\n#ifdef ANISOTROPIC\nvec3 t=pixel.anisotropicT;vec3 b=pixel.anisotropicB;params.ToL=dot(t,l);params.BoL=dot(b,l);\n#endif\n}vec3 prefilteredDFG_LUT(float roughness,float NoV){vec2 samplePoint=clamp(vec2(NoV,roughness),vec2(0.0,0.0),vec2(1.0,1.0));samplePoint.y=1.0-samplePoint.y;\n#if defined(FLOATTEXTURE) && defined(FLOATTEXTURE_FIL_LINEAR)\nreturn(texture2D(u_IBLDFG,samplePoint)).rgb;\n#else\nreturn decodeRGBD(texture2D(u_IBLDFG,samplePoint));\n#endif\n}vec2 EnvBRDFApproxLazarov(float roughness,float NoV){vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);vec4 r=roughness*c0+c1;float a004=min(r.x*r.x,exp2(-9.28*NoV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return AB;}float dielectricSpecularToF0(float specular){return 0.08*specular;}float dielectricF0ToIor(float f0){return 2.0/(1.0-sqrt(min(f0,0.99)))-1.0;}float dielectricIorToF0(float ior){return pow2((ior-1.0)/(ior+1.0));}vec3 computeF0(vec3 f0,vec3 baseColor,float metallic){return mix(f0,baseColor,metallic);}vec3 computeF90(vec3 f0){return vec3(saturate(dot(f0,vec3(50.0*0.33))));}vec3 computeDiffuse(vec3 baseColor,float metallic){return(1.0-metallic)*baseColor;}float specularAA(float roughness,in vec3 normalWS){\n#if !defined(GRAPHICS_API_GLES3) && !defined(GL_OES_standard_derivatives)\nreturn roughness;\n#else\nvec3 du=dFdx(normalWS);vec3 dv=dFdy(normalWS);float specularAAVariance=0.15;float specularAAThreshold=0.04;float variance=specularAAVariance*(dot(du,du)+dot(dv,dv));float kernelRoughness=min(2.0*variance,specularAAThreshold);float squareRoughness=saturate(roughness*roughness+kernelRoughness);return sqrt(squareRoughness);\n#endif\n}vec3 diffuseLobe(in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){return surface.diffuseColor*Fd_Lambert();}vec3 specularLobe(const in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){float roughness=surface.roughness;float D=distribution(roughness,lightParams.NoH,lightParams.h,pixel.normalWS);float V=visibility(roughness,pixel.NoV,lightParams.NoL);vec3 F=fresnel(surface.f0,surface.f90,lightParams.LoH);return(D*V)*F;}\n#ifdef IRIDESCENCE\nvec3 iridescenceDiffuseLobe(in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){vec3 f0=surface.f0;vec3 f90=vec3(1.0);vec3 iridescenceFresnel=pixel.iridescenceFresnel;float iridescence=surface.iridescence;float VoH=lightParams.VoH;return surface.diffuseColor*Fd_IridescenceLambert(f0,f90,iridescenceFresnel,iridescence,VoH);}vec3 iridescenceSpecularLobe(const in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){float roughness=surface.roughness;float D=distribution(roughness,lightParams.NoH,lightParams.h,pixel.normalWS);float V=visibility(roughness,pixel.NoV,lightParams.NoL);float iridescenceFactor=surface.iridescence;vec3 iridescenceFresnel=pixel.iridescenceFresnel;vec3 F=mix(fresnel(surface.f0,lightParams.LoH),iridescenceFresnel,vec3(iridescenceFactor));return(D*V)*F;}\n#endif\n#ifdef CLEARCOAT\nfloat clearCoatLobe(const in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){float roughness=surface.clearCoatRoughness;float clearCoat=surface.clearCoat;vec3 n=pixel.clearCoatNormal;vec3 h=lightParams.h;float LoH=lightParams.LoH;float clearCoatNoH=lightParams.clearCoatNoH;float D=distribution(roughness,clearCoatNoH,h,n);float V=V_kelemen(LoH);return D*V;}\n#endif\n#ifdef SHEEN\nvec3 sheenLobe(const in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){float roughness=surface.sheenRoughness;float NoV=pixel.NoV;float NoH=lightParams.NoH;float NoL=lightParams.NoL;float D=D_Charlie(roughness,NoH);float V=V_Neubelt(NoV,NoL);return D*V*surface.sheenColor;}\n#endif\n#ifdef ANISOTROPIC\nvec3 anisotropyLobe(const in Surface surface,const in PixelInfo pixel,const in LightParams lightParams){float anisotropy=surface.anisotropy;float at=pixel.at;float ab=pixel.ab;vec3 anisotropicT=pixel.anisotropicT;vec3 anisotropicB=pixel.anisotropicB;float NoV=pixel.NoV;float ToV=pixel.ToV;float BoV=pixel.BoV;vec3 h=lightParams.h;float NoL=lightParams.NoL;float NoH=lightParams.NoH;float VoH=lightParams.VoH;float ToL=lightParams.ToL;float BoL=lightParams.BoL;float V=V_SmithGGXCorrelated_Anisotropic(at,ab,ToV,BoV,ToL,BoL,NoV,NoL);float D=D_GGX_Anisotropic(NoH,h,anisotropicT,anisotropicB,at,ab);vec3 F=fresnel(surface.f0,surface.f90,lightParams.LoH);return V*D*F;}\n#endif\nvec3 PBRLighting(const in Surface surface,const in PixelInfo pixel,const in Light light){LightParams lightParams;initLightParams(lightParams,pixel,light);float NoL=lightParams.NoL;\n#ifdef IRIDESCENCE\nvec3 Fd=iridescenceDiffuseLobe(surface,pixel,lightParams);vec3 Fr=iridescenceSpecularLobe(surface,pixel,lightParams);\n#elif defined(ANISOTROPIC)\nvec3 Fd=diffuseLobe(surface,pixel,lightParams);vec3 Fr=anisotropyLobe(surface,pixel,lightParams);\n#else\nvec3 Fd=diffuseLobe(surface,pixel,lightParams);vec3 Fr=specularLobe(surface,pixel,lightParams);\n#endif\n#ifdef TRANSMISSION\nFd*=1.0-surface.transmission;\n#endif\nvec3 shading=(Fd+Fr*pixel.energyCompensation);\n#ifdef SHEEN\nvec3 fSheen=sheenLobe(surface,pixel,lightParams);shading*=pixel.sheenScaling;shading+=fSheen;\n#endif\n#ifdef CLEARCOAT\nfloat clearCoatNoL=lightParams.clearCoatNoL;float LoH=lightParams.LoH;float FccClearCoat=F_Schlick(0.04,1.0,LoH)*surface.clearCoat;float attenuation=1.0-FccClearCoat;shading*=attenuation*NoL;float clearcoat=clearCoatLobe(surface,pixel,lightParams)*FccClearCoat;shading+=clearcoat*clearCoatNoL;NoL=1.0;\n#endif\nreturn shading*light.color*NoL;}\n#include \"PBRGI.glsl\";\n#endif\n";

    var BlitVS = "#define SHADER_NAME BlitVS\nvarying vec2 v_Texcoord0;void main(){gl_Position=vec4(u_OffsetScale.x*2.0-1.0+(a_PositionTexcoord.x+1.0)*u_OffsetScale.z,(1.0-((u_OffsetScale.y*2.0-1.0+(-a_PositionTexcoord.y+1.0)*u_OffsetScale.w)+1.0)/2.0)*2.0-1.0,0.0,1.0);v_Texcoord0=a_PositionTexcoord.zw;}";

    var BlitFS = "#define SHADER_NAME BlitFS\n#include \"Color.glsl\";\n#include \"FastApproximateAntiAliasing.glsl\";\nvarying vec2 v_Texcoord0;void main(){\n#ifdef FXAA\ngl_FragColor=FXAAMain(u_MainTex,v_Texcoord0,u_MainTex_TexelSize.zw);\n#else\nvec4 mainColor=texture2D(u_MainTex,v_Texcoord0);\n#ifdef Gamma_u_MainTex\nmainColor=gammaToLinear(mainColor);\n#endif\ngl_FragColor=mainColor;\n#endif\ngl_FragColor=outputTransform(gl_FragColor);}";

    var FXAA = "#if !defined(FXAA_lib)\n#define FXAA_lib\n#ifdef FXAA\n#define EDGE_THRESHOLD_MIN 0.0312\n#define EDGE_THRESHOLD_MAX 0.125\n#define QUALITY(q) ((q) < 5 ? 1.0 : ((q) > 5 ? ((q) < 10 ? 2.0 : ((q) < 11 ? 4.0 : 8.0)) : 1.5))\n#define ITERATIONS 12\n#define SUBPIXEL_QUALITY 0.75\nfloat rgb2luma(in vec3 rgb){return dot(rgb,vec3(0.299,0.587,0.114));}vec3 textureOffsetbyScreenSize(in sampler2D mainTex,in vec2 uv,in vec2 offset,in vec2 inverseScreenSize){vec2 sampleruv=uv+inverseScreenSize*offset;return texture2D(mainTex,sampleruv).rgb;}vec4 FXAAMain(in sampler2D mainTex,in vec2 texuv,in vec2 inverseScreenSize){vec4 mainColor=texture2D(mainTex,texuv);vec3 colorCenter=mainColor.rgb;float lumaCenter=rgb2luma(colorCenter);float lumaDown=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(0,-1),inverseScreenSize));float lumaUp=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(0,1),inverseScreenSize));float lumaLeft=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(-1,0),inverseScreenSize));float lumaRight=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(1,0),inverseScreenSize));float lumaMin=min(lumaCenter,min(min(lumaDown,lumaUp),min(lumaLeft,lumaRight)));float lumaMax=max(lumaCenter,max(max(lumaDown,lumaUp),max(lumaLeft,lumaRight)));float lumaRange=lumaMax-lumaMin;if(lumaRange<max(EDGE_THRESHOLD_MIN,lumaMax*EDGE_THRESHOLD_MAX)){return mainColor;}float lumaDownLeft=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(-1,-1),inverseScreenSize));float lumaUpRight=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(1,1),inverseScreenSize));float lumaUpLeft=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(-1,1),inverseScreenSize));float lumaDownRight=rgb2luma(textureOffsetbyScreenSize(mainTex,texuv,vec2(1,-1),inverseScreenSize));float lumaDownUp=lumaDown+lumaUp;float lumaLeftRight=lumaLeft+lumaRight;float lumaLeftCorners=lumaDownLeft+lumaUpLeft;float lumaDownCorners=lumaDownLeft+lumaDownRight;float lumaRightCorners=lumaDownRight+lumaUpRight;float lumaUpCorners=lumaUpRight+lumaUpLeft;float edgeHorizontal=abs(-2.0*lumaLeft+lumaLeftCorners)+abs(-2.0*lumaCenter+lumaDownUp)*2.0+abs(-2.0*lumaRight+lumaRightCorners);float edgeVertical=abs(-2.0*lumaUp+lumaUpCorners)+abs(-2.0*lumaCenter+lumaLeftRight)*2.0+abs(-2.0*lumaDown+lumaDownCorners);bool isHorizontal=(edgeHorizontal>=edgeVertical);float stepLength=isHorizontal ? inverseScreenSize.y : inverseScreenSize.x;float luma1=isHorizontal ? lumaDown : lumaLeft;float luma2=isHorizontal ? lumaUp : lumaRight;float gradient1=luma1-lumaCenter;float gradient2=luma2-lumaCenter;bool is1Steepest=abs(gradient1)>=abs(gradient2);float gradientScaled=0.25*max(abs(gradient1),abs(gradient2));float lumaLocalAverage=0.0;if(is1Steepest){stepLength=-stepLength;lumaLocalAverage=0.5*(luma1+lumaCenter);}else{lumaLocalAverage=0.5*(luma2+lumaCenter);}vec2 currentUv=texuv;if(isHorizontal){currentUv.y+=stepLength*0.5;}else{currentUv.x+=stepLength*0.5;}vec2 offset=isHorizontal ? vec2(inverseScreenSize.x,0.0): vec2(0.0,inverseScreenSize.y);vec2 uv1=currentUv-offset*QUALITY(0);vec2 uv2=currentUv+offset*QUALITY(0);float lumaEnd1=rgb2luma(textureOffsetbyScreenSize(mainTex,uv1,vec2(0.0,0.0),inverseScreenSize));float lumaEnd2=rgb2luma(textureOffsetbyScreenSize(mainTex,uv2,vec2(0.0,0.0),inverseScreenSize));lumaEnd1-=lumaLocalAverage;lumaEnd2-=lumaLocalAverage;bool reached1=abs(lumaEnd1)>=gradientScaled;bool reached2=abs(lumaEnd2)>=gradientScaled;bool reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(1);}if(!reached2){uv2+=offset*QUALITY(1);}if(!reachedBoth){for(int i=2;i<ITERATIONS;i++){if(!reached1){lumaEnd1=rgb2luma(textureOffsetbyScreenSize(mainTex,uv1,vec2(0.0,0.0),inverseScreenSize));lumaEnd1=lumaEnd1-lumaLocalAverage;}if(!reached2){lumaEnd2=rgb2luma(textureOffsetbyScreenSize(mainTex,uv2,vec2(0.0,0.0),inverseScreenSize));lumaEnd2=lumaEnd2-lumaLocalAverage;}reached1=abs(lumaEnd1)>=gradientScaled;reached2=abs(lumaEnd2)>=gradientScaled;reachedBoth=reached1&&reached2;if(!reached1){uv1-=offset*QUALITY(i);}if(!reached2){uv2+=offset*QUALITY(i);}if(reachedBoth){break;}}}float distance1=isHorizontal ?(texuv.x-uv1.x):(texuv.y-uv1.y);float distance2=isHorizontal ?(uv2.x-texuv.x):(uv2.y-texuv.y);bool isDirection1=distance1<distance2;float distanceFinal=min(distance1,distance2);float edgeThickness=(distance1+distance2);bool isLumaCenterSmaller=lumaCenter<lumaLocalAverage;bool correctVariation1=(lumaEnd1<0.0)!=isLumaCenterSmaller;bool correctVariation2=(lumaEnd2<0.0)!=isLumaCenterSmaller;bool correctVariation=isDirection1 ? correctVariation1 : correctVariation2;float pixelOffset=-distanceFinal/edgeThickness+0.5;float finalOffset=correctVariation ? pixelOffset : 0.0;float lumaAverage=(1.0/12.0)*(2.0*(lumaDownUp+lumaLeftRight)+lumaLeftCorners+lumaRightCorners);float subPixelOffset1=clamp(abs(lumaAverage-lumaCenter)/lumaRange,0.0,1.0);float subPixelOffset2=(-2.0*subPixelOffset1+3.0)*subPixelOffset1*subPixelOffset1;float subPixelOffsetFinal=subPixelOffset2*subPixelOffset2*SUBPIXEL_QUALITY;finalOffset=max(finalOffset,subPixelOffsetFinal);vec2 finalUv=texuv;if(isHorizontal){finalUv.y+=finalOffset*stepLength;}else{finalUv.x+=finalOffset*stepLength;}return texture2D(mainTex,finalUv);}\n#endif\n#endif\n";

    class BlitScreenShaderInit {
        static init() {
            Laya.Shader3D.addInclude("FastApproximateAntiAliasing.glsl", FXAA);
            let attributeMap = {
                "a_PositionTexcoord": [Laya.VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_OffsetScale": exports.ShaderDataType.Vector4,
                "u_MainTex": exports.ShaderDataType.Texture2D,
                "u_MainTex_TexelSize": exports.ShaderDataType.Vector4,
            };
            let shader = Laya.Shader3D.add("BlitScreen");
            shader.shaderType = Laya.ShaderFeatureType.PostProcess;
            let subShader = new Laya.SubShader(attributeMap, uniformMap);
            shader.addSubShader(subShader);
            let blitPass = subShader.addShaderPass(BlitVS, BlitFS);
            blitPass.statefirst = true;
            let blitState = blitPass.renderState;
            blitState.depthTest = RenderState.DEPTHTEST_ALWAYS;
            blitState.depthWrite = false;
            blitState.cull = RenderState.CULL_NONE;
            blitState.blend = RenderState.BLEND_DISABLE;
            let transparentShader = Laya.Shader3D.add("BlitScreen_Transparnet");
            shader.shaderType = Laya.ShaderFeatureType.PostProcess;
            let transparentSubShader = new Laya.SubShader(attributeMap, uniformMap);
            transparentShader.addSubShader(transparentSubShader);
            let blitPassTrans = transparentSubShader.addShaderPass(BlitVS, BlitFS);
            blitPass.statefirst = true;
            blitState = blitPassTrans.renderState;
            blitState.depthTest = RenderState.DEPTHTEST_ALWAYS;
            blitState.depthWrite = false;
            blitState.cull = RenderState.CULL_NONE;
            blitState.blend = RenderState.BLEND_ENABLE_ALL;
            blitState.srcBlend = RenderState.BLENDPARAM_SRC_ALPHA;
            blitState.dstBlend = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
        }
    }

    var UnlitVS = "\n#define SHADER_NAME UnlitVS\n#include \"Math.glsl\";\n#include \"Scene.glsl\";\n#include \"SceneFogInput.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DVertex.glsl\";\n#include \"VertexCommon.glsl\";\n#ifdef UV\nvarying vec2 v_Texcoord0;\n#endif\n#ifdef COLOR\nvarying vec4 v_VertexColor;\n#endif\nvoid main(){Vertex vertex;getVertexParams(vertex);\n#ifdef UV\nv_Texcoord0=transformUV(vertex.texCoord0,u_TilingOffset);\n#endif\n#ifdef COLOR\nv_VertexColor=vertex.vertexColor;\n#endif\nmat4 worldMat=getWorldMatrix();vec4 pos=(worldMat*vec4(vertex.positionOS,1.0));vec3 positionWS=pos.xyz/pos.w;gl_Position=getPositionCS(positionWS);gl_Position=remapPositionZ(gl_Position);\n#ifdef FOG\nFogHandle(gl_Position.z);\n#endif\n}";

    var UnlitFS = "\n#define SHADER_NAME UNLITFS\n#include \"Color.glsl\";\n#include \"Scene.glsl\";\n#include \"SceneFog.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DFrag.glsl\";\n#ifdef UV\nvarying vec2 v_Texcoord0;\n#endif\n#ifdef COLOR\nvarying vec4 v_VertexColor;\n#endif\nvoid main(){vec3 color=u_AlbedoColor.rgb;float alpha=u_AlbedoColor.a;\n#ifdef COLOR\n#ifdef ENABLEVERTEXCOLOR\nvec4 vertexColor=v_VertexColor;color*=vertexColor.rgb;alpha*=vertexColor.a;\n#endif\n#endif\n#ifdef UV\nvec2 uv=v_Texcoord0;\n#ifdef ALBEDOTEXTURE\nvec4 albedoSampler=texture2D(u_AlbedoTexture,uv);\n#ifdef Gamma_u_AlbedoTexture\nalbedoSampler=gammaToLinear(albedoSampler);\n#endif\ncolor*=albedoSampler.rgb;alpha*=albedoSampler.a;\n#endif\n#endif\n#ifdef ALPHATEST\nif(alpha<u_AlphaTestValue)discard;\n#endif\n#ifdef FOG\ncolor=scenUnlitFog(color);\n#endif\ngl_FragColor=vec4(color,alpha);gl_FragColor=outputTransform(gl_FragColor);}";

    var PBRDepthVS = "#define SHADER_NAME DepthVS\n#include \"DepthVertex.glsl\";\nvoid main(){Vertex vertex;getVertexParams(vertex);mat4 worldMat=getWorldMatrix();vec4 pos=(worldMat*vec4(vertex.positionOS,1.0));vec3 positionWS=pos.xyz/pos.w;mat4 normalMat=transpose(inverse(worldMat));vec3 normalWS=normalize((normalMat*vec4(vertex.normalOS,0.0)).xyz);vec4 positionCS=DepthPositionCS(positionWS,normalWS);gl_Position=remapPositionZ(positionCS);}";

    var PBRDepthFS = "#define SHADER_NAME DepthFS\n#include \"DepthFrag.glsl\";\nvoid main(){gl_FragColor=getDepthColor();}";

    class UnlitShaderInit {
        static init() {
            let uniformMap = {
                "UnlitBlock": {
                    "u_AlbedoColor": exports.ShaderDataType.Color,
                    "u_TilingOffset": exports.ShaderDataType.Vector4,
                },
                "u_AlbedoTexture": exports.ShaderDataType.Texture2D,
                "u_AlphaTestValue": exports.ShaderDataType.Float,
            };
            let defaultValue = {
                "u_AlbedoColor": Laya.Color.WHITE,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
                "u_AlphaTestValue": 0.5
            };
            let shader = Laya.Shader3D.add("Unlit", true, false);
            shader.shaderType = Laya.ShaderFeatureType.D3;
            let subShader = new Laya.SubShader(Laya.SubShader.DefaultAttributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(UnlitVS, UnlitFS);
            subShader.addShaderPass(PBRDepthVS, PBRDepthFS, "ShadowCaster");
        }
    }

    var BlinnPhongCommonGLSL = "#if !defined(BlinnPhongCommon_lib)\n#define BlinnPhongCommon_lib\nvarying vec3 v_PositionWS;varying vec3 v_NormalWS;varying vec3 v_TangentWS;varying vec3 v_BiNormalWS;\n#ifdef UV\nvarying vec2 v_Texcoord0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nvarying vec2 v_Texcoord1;\n#endif\n#endif\n#ifdef COLOR\nvarying vec4 v_VertexColor;\n#endif\nstruct PixelParams{vec3 positionWS;vec3 normalWS;vec3 tangentWS;vec3 biNormalWS;mat3 TBN;\n#ifdef UV\nvec2 uv0;\n#endif\n#ifdef UV1\n#ifdef LIGHTMAP\nvec2 uv1;\n#endif\n#endif\n#ifdef COLOR\nvec4 vertexColor;\n#endif\n};\n#endif\n";

    var BlinnPhongVertexGLSL = "#if !defined(BlinnPhongVertex_lib)\n#define BlinnPhongVertex_lib\n#include \"ShadingVertex.glsl\";\nvoid initPixelParams(inout PixelParams params,in Vertex vertex){shadingPixelParams(params,vertex);sharePixelParams(params);}\n#endif\n";

    var BlinnPhongFragGLSL = "#if !defined(BlinnPhongFrag_lib)\n#define BlinnPhongFrag_lib\n#include \"BlinnPhongLighting.glsl\";\n#include \"ShadingFrag.glsl\";\nvoid getPixelInfo(inout PixelInfo info,const in PixelParams pixel,const in Surface surface){info.positionWS=pixel.positionWS;info.vertexNormalWS=pixel.normalWS;\n#ifdef TANGENT\ninfo.normalWS=normalize(pixel.TBN*surface.normalTS);\n#else\ninfo.normalWS=pixel.normalWS;\n#endif\ninfo.viewDir=normalize(u_CameraPos-info.positionWS);\n#ifdef LIGHTMAP\n#ifdef UV1\ninfo.lightmapUV=pixel.uv1;\n#endif\n#endif\n}vec3 BlinnPhongLighting(const in Surface surface,const in PixelParams pixel){PixelInfo info;getPixelInfo(info,pixel,surface);vec3 positionWS=info.positionWS;vec3 normalWS=info.normalWS;vec3 v=info.viewDir;vec3 lightColor=vec3(0.0,0.0,0.0);\n#ifdef DIRECTIONLIGHT\nfor(int i=0;i<CalculateLightCount;i++){if(i>=DirectionCount)break;DirectionLight directionLight=getDirectionLight(i,positionWS);if(directionLight.lightMode!=LightMode_Mix){Light light=getLight(directionLight);lightColor+=BlinnPhongLighting(surface,light,info)*light.attenuation;}}\n#endif\n#if defined(POINTLIGHT) || defined(SPOTLIGHT)\nivec4 clusterInfo=getClusterInfo(u_View,u_Viewport,positionWS,gl_FragCoord,u_ProjectionParams);\n#endif\n#ifdef POINTLIGHT\nfor(int i=0;i<CalculateLightCount;i++){\n#ifdef BREAK_TEXTURE_SAMPLE\nif(i>=clusterInfo.x)break;\n#endif\nPointLight pointLight=getPointLight(i,clusterInfo,positionWS);if(pointLight.lightMode!=LightMode_Mix){Light light=getLight(pointLight,normalWS,positionWS);\n#ifndef BREAK_TEXTURE_SAMPLE\nif(i<clusterInfo.x)\n#endif\nlightColor+=BlinnPhongLighting(surface,light,info)*light.attenuation;}}\n#endif\n#ifdef SPOTLIGHT\nfor(int i=0;i<CalculateLightCount;i++){\n#ifdef BREAK_TEXTURE_SAMPLE\nif(i>=clusterInfo.y)break;\n#endif\nSpotLight spotLight=getSpotLight(i,clusterInfo,positionWS);if(spotLight.lightMode!=LightMode_Mix){Light light=getLight(spotLight,normalWS,positionWS);\n#ifndef BREAK_TEXTURE_SAMPLE\nif(i<clusterInfo.y)\n#endif\nlightColor+=BlinnPhongLighting(surface,light,info)*light.attenuation;}}\n#endif\nvec3 giColor=BlinnPhongGI(surface,info);return lightColor+giColor;}\n#endif\n";

    var BlinnPhongVS = "#define SHADER_NAME BlinnPhongVS\n#include \"Math.glsl\";\n#include \"Scene.glsl\";\n#include \"SceneFogInput.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DVertex.glsl\";\n#include \"VertexCommon.glsl\";\n#include \"BlinnPhongVertex.glsl\";\nvoid main(){Vertex vertex;getVertexParams(vertex);PixelParams pixel;initPixelParams(pixel,vertex);gl_Position=getPositionCS(pixel.positionWS);gl_Position=remapPositionZ(gl_Position);\n#ifdef FOG\nFogHandle(gl_Position.z);\n#endif\n}";

    var BlinnPhongFS = "#define SHADER_NAME BlinnPhongFS\n#include \"Color.glsl\";\n#include \"Scene.glsl\";\n#include \"SceneFog.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DFrag.glsl\";\n#include \"BlinnPhongFrag.glsl\";\nvoid getBinnPhongSurfaceParams(inout Surface surface,in PixelParams pixel){\n#ifdef UV\nvec2 uv=transformUV(pixel.uv0,u_TilingOffset);\n#else\nvec2 uv=vec2(0.0);\n#endif\nsurface.diffuseColor=u_DiffuseColor.rgb;surface.alpha=u_DiffuseColor.a;\n#ifdef COLOR\n#ifdef ENABLEVERTEXCOLOR\nsurface.diffuseColor*=pixel.vertexColor.xyz;surface.alpha*=pixel.vertexColor.a;\n#endif\n#endif\n#ifdef DIFFUSEMAP\nvec4 diffuseSampler=texture2D(u_DiffuseTexture,uv);\n#ifdef Gamma_u_DiffuseTexture\ndiffuseSampler=gammaToLinear(diffuseSampler);\n#endif\nsurface.diffuseColor*=u_DiffuseColor.rgb*diffuseSampler.rgb*u_AlbedoIntensity;surface.alpha*=diffuseSampler.a;\n#endif\nsurface.diffuseColor*=u_AlbedoIntensity;surface.normalTS=vec3(0.0,0.0,1.0);\n#ifdef NORMALMAP\nvec3 normalSampler=texture2D(u_NormalTexture,uv).rgb;normalSampler=normalize(normalSampler*2.0-1.0);normalSampler.y*=-1.0;surface.normalTS=normalSampler;\n#endif\n#ifdef SPECULARMAP\nvec4 specularSampler=texture2D(u_SpecularTexture,uv);\n#ifdef Gamma_u_SpecularTexture\nspecularSampler=gammaToLinear(specularSampler);\n#endif\nsurface.gloss=specularSampler.rgb;\n#else\n#ifdef DIFFUSEMAP\nsurface.gloss=vec3(diffuseSampler.a);\n#else\nsurface.gloss=vec3(1.0,1.0,1.0);\n#endif\n#endif\nsurface.specularColor=u_MaterialSpecular.rgb;surface.shininess=u_Shininess;}void main(){PixelParams pixel;getPixelParams(pixel);Surface surface;getBinnPhongSurfaceParams(surface,pixel);\n#ifdef ALPHATEST\nif(surface.alpha<u_AlphaTestValue){discard;}\n#endif\nvec3 surfaceColor=vec3(0.0);surfaceColor=BlinnPhongLighting(surface,pixel);\n#ifdef FOG\nsurfaceColor=sceneLitFog(surfaceColor);\n#endif\ngl_FragColor=vec4(surfaceColor,surface.alpha);gl_FragColor=outputTransform(gl_FragColor);}";

    var DepthNormalVS$1 = "#define SHADER_NAME BlinnPhongDephtNormalVS\n#include \"Math.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DVertex.glsl\";\n#include \"VertexCommon.glsl\";\n#include \"BlinnPhongVertex.glsl\";\nvarying vec4 v_PositionCS;void main(){Vertex vertex;getVertexParams(vertex);PixelParams pixel;initPixelParams(pixel,vertex);vec4 positionCS=getPositionCS(pixel.positionWS);v_PositionCS=positionCS;gl_Position=positionCS;gl_Position=remapPositionZ(gl_Position);}";

    var DepthNormalFS$1 = "#define SHADER_NAME BlinnPhongDephtNormalFS\n#include \"Color.glsl\";\n#include \"Scene.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DFrag.glsl\";\n#include \"ShadingFrag.glsl\";\n#include \"DepthNormalFrag.glsl\";\nvarying vec4 v_PositionCS;void main(){PixelParams pixel;getPixelParams(pixel);vec3 normalWS=pixel.normalWS;\n#ifdef NORMALMAP\n#ifdef UV\nvec2 uv=transformUV(pixel.uv0,u_TilingOffset);vec3 normalSampler=texture2D(u_NormalTexture,uv).rgb;normalSampler=normalize(normalSampler*2.0-1.0);normalSampler.y*=-1.0;vec3 normalTS=normalSampler;normalWS=normalize(pixel.TBN*normalTS);\n#endif\n#endif\nvec4 positionCS=v_PositionCS;vec4 dephtNormal=encodeDepthNormal(positionCS,normalWS);gl_FragColor=dephtNormal;}";

    class BlinnPhongShaderInit {
        static init() {
            Laya.Shader3D.addInclude("BlinnPhongCommon.glsl", BlinnPhongCommonGLSL);
            Laya.Shader3D.addInclude("BlinnPhongVertex.glsl", BlinnPhongVertexGLSL);
            Laya.Shader3D.addInclude("BlinnPhongFrag.glsl", BlinnPhongFragGLSL);
            let uniformMap = {
                "u_AlphaTestValue": exports.ShaderDataType.Float,
                "u_TilingOffset": exports.ShaderDataType.Vector4,
                "u_DiffuseColor": exports.ShaderDataType.Color,
                "u_DiffuseTexture": exports.ShaderDataType.Texture2D,
                "u_AlbedoIntensity": exports.ShaderDataType.Float,
                "u_MaterialSpecular": exports.ShaderDataType.Color,
                "u_SpecularTexture": exports.ShaderDataType.Texture2D,
                "u_Shininess": exports.ShaderDataType.Float,
                "u_NormalTexture": exports.ShaderDataType.Texture2D,
            };
            let defaultValue = {
                "u_AlbedoIntensity": 1.0,
                "u_DiffuseColor": Laya.Color.WHITE,
                "u_MaterialSpecular": Laya.Color.WHITE,
                "u_Shininess": 0.078125,
                "u_AlphaTestValue": 0.5,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
            };
            let shader = Laya.Shader3D.add("BLINNPHONG", true, true);
            shader.shaderType = Laya.ShaderFeatureType.D3;
            let subShader = new Laya.SubShader(Laya.SubShader.DefaultAttributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(BlinnPhongVS, BlinnPhongFS);
            subShader.addShaderPass(PBRDepthVS, PBRDepthFS, "ShadowCaster");
            subShader.addShaderPass(DepthNormalVS$1, DepthNormalFS$1, "DepthNormal");
        }
    }

    var PBRStandardVS = "#define SHADER_NAME PBRStandardVS\n#include \"Math.glsl\";\n#include \"Scene.glsl\";\n#include \"SceneFogInput.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DVertex.glsl\";\n#include \"VertexCommon.glsl\";\n#include \"PBRVertex.glsl\";\n#if defined(DETAILTEXTURE) || defined(DETAILNORMAL)\nvarying vec2 v_DetailUV;\n#endif\nvoid main(){Vertex vertex;getVertexParams(vertex);PixelParams pixel;initPixelParams(pixel,vertex);\n#if defined(DETAILTEXTURE) || defined(DETAILNORMAL)\n#ifdef UV\nv_DetailUV=transformUV(vertex.texCoord0,u_DetailTillingOffset);\n#else\nv_DetailUV=vec2(0.0);\n#endif\n#endif\ngl_Position=getPositionCS(pixel.positionWS);gl_Position=remapPositionZ(gl_Position);\n#ifdef FOG\nFogHandle(gl_Position.z);\n#endif\n}";

    var PBRStandardFS = "#define SHADER_NAME PBRStandardFS\n#include \"Color.glsl\";\n#include \"Scene.glsl\";\n#include \"SceneFog.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DFrag.glsl\";\n#include \"PBRMetallicFrag.glsl\";\n#if defined(DETAILTEXTURE) || defined(DETAILNORMAL)\nvarying vec2 v_DetailUV;\n#define ColorSpaceDouble vec3(4.59479380, 4.59479380, 4.59479380);\nvec3 BlendNormals(vec3 n1,vec3 n2){return normalize(vec3(n1.xy+n2.xy,n1.z*n2.z));}\n#endif\nvoid initSurfaceInputs(inout SurfaceInputs inputs,const in PixelParams pixel){\n#ifdef UV\nvec2 uv=transformUV(pixel.uv0,u_TilingOffset);\n#else\nvec2 uv=vec2(0.0);\n#endif\ninputs.diffuseColor=u_AlbedoColor.rgb;inputs.alpha=u_AlbedoColor.a;\n#ifdef COLOR\n#ifdef ENABLEVERTEXCOLOR\ninputs.diffuseColor*=pixel.vertexColor.xyz;inputs.alpha*=pixel.vertexColor.a;\n#endif\n#endif\ninputs.alphaTest=u_AlphaTestValue;\n#ifdef ALBEDOTEXTURE\nvec4 albedoSampler=texture2D(u_AlbedoTexture,uv);\n#ifdef Gamma_u_AlbedoTexture\nalbedoSampler=gammaToLinear(albedoSampler);\n#endif\ninputs.diffuseColor*=albedoSampler.rgb;inputs.alpha*=albedoSampler.a;\n#endif\n#ifdef DETAILTEXTURE\nvec3 detailSampler=texture2D(u_DetailAlbedoTexture,v_DetailUV).rgb;\n#ifdef Gamma_u_DetailAlbedoTexture\ndetailSampler=gammaToLinear(detailSampler);\n#endif\ndetailSampler*=ColorSpaceDouble;inputs.diffuseColor*=detailSampler;\n#endif\ninputs.normalTS=vec3(0.0,0.0,1.0);\n#ifdef NORMALTEXTURE\nvec3 normalSampler=texture2D(u_NormalTexture,uv).rgb;normalSampler=normalize(normalSampler*2.0-1.0);normalSampler.y*=-1.0;inputs.normalTS=normalScale(normalSampler,u_NormalScale);\n#endif\n#ifdef DETAILNORMAL\nvec3 detailnormalSampler=texture2D(u_DetailNormalTexture,v_DetailUV).rgb;detailnormalSampler=normalize(detailnormalSampler*2.0-1.0);detailnormalSampler.y*=-1.0;detailnormalSampler=normalScale(detailnormalSampler,u_DetailNormalScale);inputs.normalTS=BlendNormals(inputs.normalTS,detailnormalSampler);\n#endif\ninputs.metallic=u_Metallic;inputs.smoothness=u_Smoothness;\n#ifdef METALLICGLOSSTEXTURE\nvec4 metallicSampler=texture2D(u_MetallicGlossTexture,uv);\n#ifdef Gamma_u_MetallicGlossTexture\nmetallicSampler=gammaToLinear(metallicSampler);\n#endif\ninputs.metallic=metallicSampler.x;\n#ifdef SMOOTHNESSSOURCE_ALBEDOTEXTURE_ALPHA\n#ifdef ALBEDOTEXTURE\ninputs.smoothness=(albedoSampler.a*u_Smoothness);\n#endif\n#else\ninputs.smoothness=(metallicSampler.a*u_Smoothness);\n#endif\n#endif\ninputs.occlusion=1.0;\n#ifdef OCCLUSIONTEXTURE\nvec4 occlusionSampler=texture2D(u_OcclusionTexture,uv);\n#ifdef Gamma_u_OcclusionTexture\nocclusionSampler=gammaToLinear(occlusionSampler);\n#endif\nfloat occlusion=occlusionSampler.g;inputs.occlusion=(1.0-u_OcclusionStrength)+occlusion*u_OcclusionStrength;\n#endif\ninputs.emissionColor=vec3(0.0);\n#ifdef EMISSION\ninputs.emissionColor=u_EmissionColor.rgb*u_EmissionIntensity;\n#ifdef EMISSIONTEXTURE\nvec4 emissionSampler=texture2D(u_EmissionTexture,uv);\n#ifdef Gamma_u_EmissionTexture\nemissionSampler=gammaToLinear(emissionSampler);\n#endif\ninputs.emissionColor*=emissionSampler.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\ninputs.clearCoat=u_ClearCoatFactor;inputs.clearCoatRoughness=u_ClearCoatRoughness;\n#ifdef CLEARCOATMAP\nvec4 clearCoatSampler=texture2D(u_ClearCoatTexture,uv);inputs.clearCoat*=clearCoatSampler.r;\n#endif\n#ifdef CLEARCOAT_ROUGHNESSMAP\nvec4 clearcoatSampleRoughness=texture2D(u_ClearCoatRoughnessTexture,uv);inputs.clearCoatRoughness*=clearcoatSampleRoughness.g;\n#endif\n#ifdef CLEARCOAT_NORMAL\nvec3 clearCoatNormalSampler=texture2D(u_ClearCoatNormalTexture,uv).rgb;clearCoatNormalSampler=normalize(clearCoatNormalSampler*2.0-1.0);clearCoatNormalSampler.y*=-1.0;inputs.clearCoatNormalTS=clearCoatNormalSampler;\n#endif\n#endif\n#ifdef ANISOTROPIC\ninputs.anisotropy=u_AnisotropyStrength;vec2 direction=vec2(1.0,0.0);\n#ifdef ANISOTROPYMAP\nvec3 anisotropySampler=texture2D(u_AnisotropyTexture,uv).rgb;inputs.anisotropy*=anisotropySampler.b;direction=anisotropySampler.xy*2.0-1.0;\n#endif\nvec2 anisotropyRotation=vec2(cos(u_AnisotropyRotation),sin(u_AnisotropyRotation));mat2 rotationMatrix=mat2(anisotropyRotation.x,anisotropyRotation.y,-anisotropyRotation.y,anisotropyRotation.x);inputs.anisotropyDirection=rotationMatrix*direction;\n#endif\n}void main(){PixelParams pixel;getPixelParams(pixel);SurfaceInputs inputs;initSurfaceInputs(inputs,pixel);vec4 surfaceColor=PBR_Metallic_Flow(inputs,pixel);\n#ifdef FOG\nsurfaceColor.rgb=sceneLitFog(surfaceColor.rgb);\n#endif\ngl_FragColor=surfaceColor;gl_FragColor=outputTransform(gl_FragColor);}";

    var DepthNormalVS = "#define SHADER_NAME PBRStandardDepthNormalVS\n#include \"Math.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DVertex.glsl\";\n#include \"VertexCommon.glsl\";\n#include \"PBRVertex.glsl\";\nvarying vec4 v_PositionCS;void main(){Vertex vertex;getVertexParams(vertex);PixelParams pixel;initPixelParams(pixel,vertex);sharePixelParams(pixel);vec4 positionCS=getPositionCS(pixel.positionWS);v_PositionCS=positionCS;gl_Position=positionCS;gl_Position=remapPositionZ(gl_Position);}";

    var DepthNormalFS = "#define SHADER_NAME PBRStandardDepthNormalFS\n#include \"Color.glsl\";\n#include \"Scene.glsl\";\n#include \"Camera.glsl\";\n#include \"Sprite3DFrag.glsl\";\n#include \"ShadingFrag.glsl\";\n#include \"DepthNormalFrag.glsl\";\nvarying vec4 v_PositionCS;void main(){PixelParams pixel;getPixelParams(pixel);vec3 normalWS=pixel.normalWS;\n#ifdef NORMALTEXTURE\n#ifdef UV\nvec2 uv=transformUV(pixel.uv0,u_TilingOffset);vec3 normalSampler=texture2D(u_NormalTexture,uv).rgb;normalSampler=normalize(normalSampler*2.0-1.0);normalSampler.y*=-1.0;vec3 normalTS=normalScale(normalSampler,u_NormalScale);normalWS=normalize(pixel.TBN*normalTS);\n#endif\n#endif\nvec4 positionCS=v_PositionCS;vec4 dephtNormal=encodeDepthNormal(positionCS,normalWS);gl_FragColor=dephtNormal;}";

    class PBRStandardShaderInit {
        static init() {
            let uniformMap = {
                "u_AlbedoColor": exports.ShaderDataType.Color,
                "u_TilingOffset": exports.ShaderDataType.Vector4,
                "u_NormalScale": exports.ShaderDataType.Float,
                "u_Metallic": exports.ShaderDataType.Float,
                "u_Smoothness": exports.ShaderDataType.Float,
                "u_OcclusionStrength": exports.ShaderDataType.Float,
                "u_AlphaTestValue": exports.ShaderDataType.Float,
                "u_EmissionColor": exports.ShaderDataType.Color,
                "u_EmissionIntensity": exports.ShaderDataType.Float,
                "u_AlbedoTexture": exports.ShaderDataType.Texture2D,
                "u_NormalTexture": exports.ShaderDataType.Texture2D,
                "u_OcclusionTexture": exports.ShaderDataType.Texture2D,
                "u_EmissionTexture": exports.ShaderDataType.Texture2D,
                "u_MetallicGlossTexture": exports.ShaderDataType.Texture2D,
                "u_AnisotropyStrength": exports.ShaderDataType.Float,
                "u_AnisotropyTexture": exports.ShaderDataType.Texture2D,
                "u_AnisotropyRotation": exports.ShaderDataType.Float,
                "u_ClearCoatFactor": exports.ShaderDataType.Float,
                "u_ClearCoatTexture": exports.ShaderDataType.Texture2D,
                "u_ClearCoatRoughness": exports.ShaderDataType.Float,
                "u_ClearCoatRoughnessTexture": exports.ShaderDataType.Texture2D,
                "u_ClearCoatNormalTexture": exports.ShaderDataType.Texture2D,
                "u_DetailAlbedoTexture": exports.ShaderDataType.Texture2D,
                "u_DetailNormalTexture": exports.ShaderDataType.Texture2D,
                "u_DetailNormalScale": exports.ShaderDataType.Float,
                "u_DetailTillingOffset": exports.ShaderDataType.Vector4
            };
            let defaultValue = {
                "u_AlbedoColor": Laya.Color.WHITE,
                "u_TilingOffset": new Laya.Vector4(1, 1, 0, 0),
                "u_DetailTillingOffset": new Laya.Vector4(1, 1, 0, 0),
                "u_NormalScale": 1,
                "u_DetailNormalScale": 1,
                "u_Metallic": 0,
                "u_Smoothness": 0.5,
                "u_OcclusionStrength": 1,
                "u_EmissionColor": Laya.Color.WHITE,
                "u_EmissionIntensity": 1,
                "u_AlphaTestValue": 0.5,
                "u_AnisotropyStrength": 0,
                "u_AnisotropyRotation": 0,
                "u_ClearCoatFactor": 0,
                "u_ClearCoatRoughness": 0,
            };
            let shader = Laya.Shader3D.add("PBR", true, true);
            shader.shaderType = Laya.ShaderFeatureType.D3;
            shader._surportVolumetricGI = true;
            let subShader = new Laya.SubShader(Laya.SubShader.DefaultAttributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            subShader.addShaderPass(PBRStandardVS, PBRStandardFS);
            subShader.addShaderPass(PBRDepthVS, PBRDepthFS, "ShadowCaster");
            subShader.addShaderPass(DepthNormalVS, DepthNormalFS, "DepthNormal");
        }
    }

    var SkyboxVS = "#define SHADER_NAME SkyBoxVS\n#include \"SkyCommon.glsl\";\nvarying vec3 v_Texcoord;void main(){v_Texcoord=vec3(-a_Position.x,a_Position.yz);vec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);gl_Position=u_SkyProjectionViewMat*position;gl_Position=remapSkyPositionZ(gl_Position);}";

    var SkyboxFS = "#define SHADER_NAME SkyBoxFS\n#include \"Color.glsl\";\nvarying vec3 v_Texcoord;const vec4 c_ColorSpace=vec4(4.59479380,4.59479380,4.59479380,2.0);void main(){vec3 uv=v_Texcoord;vec4 cubeSampler=textureCube(u_CubeTexture,uv);\n#ifdef Gamma_u_CubeTexture\ncubeSampler=gammaToLinear(cubeSampler);\n#endif\nvec3 color=cubeSampler.rgb*u_TintColor.rgb*pow(u_Exposure,2.2)*c_ColorSpace.rgb;gl_FragColor=vec4(color,1.0);gl_FragColor=outputTransform(gl_FragColor);}";

    class SkyBoxShaderInit {
        static init() {
            let attributeMap = {
                "a_Position": [Laya.VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_TintColor": exports.ShaderDataType.Color,
                "u_Exposure": exports.ShaderDataType.Float,
                "u_Rotation": exports.ShaderDataType.Float,
                "u_CubeTexture": exports.ShaderDataType.TextureCube
            };
            let defaultValue = {
                "u_TintColor": new Laya.Color(0.5, 0.5, 0.5, 0.5),
                "u_Exposure": 1,
                "u_Rotation": 0
            };
            let shader = Laya.Shader3D.add("SkyBox");
            shader.shaderType = Laya.ShaderFeatureType.Sky;
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(SkyboxVS, SkyboxFS);
            pass.renderState.depthTest = RenderState.DEPTHTEST_LEQUAL;
            pass.renderState.cull = Laya.CullMode.Back;
            pass.renderState.depthWrite = false;
            pass.renderState.stencilWrite = false;
            pass.statefirst = true;
        }
    }

    var SkyProceduralVS = "#define SHADER_NAME SkyProceduralVS\n#include \"SkyCommon.glsl\";\n#define OUTER_RADIUS 1.025\n#define RAYLEIGH (mix(0.0, 0.0025, pow(u_AtmosphereThickness,2.5)))\n#define MIE 0.0010\n#define SUN_BRIGHTNESS 20.0\n#define MAX_SCATTER 50.0\nconst float SKY_GROUND_THRESHOLD=0.02;const float outerRadius=OUTER_RADIUS;const float outerRadius2=OUTER_RADIUS*OUTER_RADIUS;const float innerRadius=1.0;const float innerRadius2=1.0;const float cameraHeight=0.0001;const float HDSundiskIntensityFactor=15.0;const float simpleSundiskIntensityFactor=27.0;const float sunScale=400.0*SUN_BRIGHTNESS;const float kmESun=MIE*SUN_BRIGHTNESS;const float km4PI=MIE*4.0*3.14159265;const float scale=1.0/(OUTER_RADIUS-1.0);const float scaleDepth=0.25;const float scaleOverScaleDepth=(1.0/(OUTER_RADIUS-1.0))/0.25;const float samples=2.0;const vec3 c_DefaultScatteringWavelength=vec3(0.65,0.57,0.475);const vec3 c_VariableRangeForScatteringWavelength=vec3(0.15,0.15,0.15);varying vec3 v_GroundColor;varying vec3 v_SkyColor;\n#ifdef SUN_HIGH_QUALITY\nvarying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\nvarying vec3 v_RayDir;\n#else\nvarying float v_SkyGroundFactor;\n#endif\n#if defined(SUN_HIGH_QUALITY)||defined(SUN_SIMPLE)\nvarying vec3 v_SunColor;\n#endif\nfloat getRayleighPhase(vec3 light,vec3 ray){float eyeCos=dot(light,ray);return 0.75+0.75*eyeCos*eyeCos;}float scaleAngle(float inCos){float x=1.0-inCos;return 0.25*exp(-0.00287+x*(0.459+x*(3.83+x*(-6.80+x*5.25))));}void main(){gl_Position=u_SkyProjectionViewMat*a_Position;vec3 skyTintInGammaSpace=pow(u_SkyTint.xyz,vec3(0.45));vec3 scatteringWavelength=mix(c_DefaultScatteringWavelength-c_VariableRangeForScatteringWavelength,c_DefaultScatteringWavelength+c_VariableRangeForScatteringWavelength,vec3(1.0)-skyTintInGammaSpace);vec3 invWavelength=1.0/pow(scatteringWavelength,vec3(4.0));float krESun=RAYLEIGH*SUN_BRIGHTNESS;float kr4PI=RAYLEIGH*4.0*3.14159265;vec3 cameraPos=vec3(0.0,innerRadius+cameraHeight,0.0);vec3 eyeRay=normalize(a_Position.xyz);float far=0.0;vec3 cIn,cOut;if(eyeRay.y>=0.0){far=sqrt(outerRadius2+innerRadius2*eyeRay.y*eyeRay.y-innerRadius2)-innerRadius*eyeRay.y;float height=innerRadius+cameraHeight;float depth=exp(scaleOverScaleDepth*-cameraHeight);float startAngle=dot(eyeRay,cameraPos)/height;float startOffset=depth*scaleAngle(startAngle);float sampleLength=far/samples;float scaledLength=sampleLength*scale;vec3 sampleRay=eyeRay*sampleLength;vec3 samplePoint=cameraPos+sampleRay*0.5;vec3 frontColor=vec3(0.0);{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float lightAngle=dot(-u_SunLight_direction,samplePoint)/height;float cameraAngle=dot(eyeRay,samplePoint)/height;float scatter=(startOffset+depth*(scaleAngle(lightAngle)-scaleAngle(cameraAngle)));vec3 attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float lightAngle=dot(-u_SunLight_direction,samplePoint)/height;float cameraAngle=dot(eyeRay,samplePoint)/height;float scatter=(startOffset+depth*(scaleAngle(lightAngle)-scaleAngle(cameraAngle)));vec3 attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}cIn=frontColor*(invWavelength*krESun);cOut=frontColor*kmESun;}else{far=(-cameraHeight)/(min(-0.001,eyeRay.y));vec3 pos=cameraPos+far*eyeRay;float depth=exp((-cameraHeight)*(1.0/scaleDepth));float cameraAngle=dot(-eyeRay,pos);float lightAngle=dot(-u_SunLight_direction,pos);float cameraScale=scaleAngle(cameraAngle);float lightScale=scaleAngle(lightAngle);float cameraOffset=depth*cameraScale;float temp=lightScale+cameraScale;float sampleLength=far/samples;float scaledLength=sampleLength*scale;vec3 sampleRay=eyeRay*sampleLength;vec3 samplePoint=cameraPos+sampleRay*0.5;vec3 frontColor=vec3(0.0,0.0,0.0);vec3 attenuate;{float height=length(samplePoint);float depth=exp(scaleOverScaleDepth*(innerRadius-height));float scatter=depth*temp-cameraOffset;attenuate=exp(-clamp(scatter,0.0,MAX_SCATTER)*(invWavelength*kr4PI+km4PI));frontColor+=attenuate*(depth*scaledLength);samplePoint+=sampleRay;}cIn=frontColor*(invWavelength*krESun+kmESun);cOut=clamp(attenuate,0.0,1.0);}\n#ifdef SUN_HIGH_QUALITY\nv_Vertex=-a_Position.xyz;\n#elif defined(SUN_SIMPLE)\nv_RayDir=-eyeRay;\n#else\nv_SkyGroundFactor=-eyeRay.y/SKY_GROUND_THRESHOLD;\n#endif\nv_GroundColor=u_Exposure*(cIn+u_GroundTint.xyz*cOut);v_SkyColor=u_Exposure*(cIn*getRayleighPhase(-u_SunLight_direction,-eyeRay));float lightColorIntensity=clamp(length(u_SunLight_color.xyz),0.25,1.0);\n#ifdef SUN_HIGH_QUALITY\nv_SunColor=HDSundiskIntensityFactor*clamp(cOut,0.0,1.0)*u_SunLight_color.xyz/lightColorIntensity;\n#elif defined(SUN_SIMPLE)\nv_SunColor=simpleSundiskIntensityFactor*clamp(cOut*sunScale,0.0,1.0)*u_SunLight_color.xyz/lightColorIntensity;\n#endif\ngl_Position=remapSkyPositionZ(gl_Position);}";

    var SkyProceduralFS = "#define SHADER_NAME SkyProceduralFS\n#include \"Color.glsl\";\nconst float MIE_G=-0.990;const float MIE_G2=0.9801;const float SKY_GROUND_THRESHOLD=0.02;uniform vec3 u_SunLight_direction;varying vec3 v_GroundColor;varying vec3 v_SkyColor;\n#ifdef SUN_HIGH_QUALITY\nvarying vec3 v_Vertex;\n#elif defined(SUN_SIMPLE)\nvarying vec3 v_RayDir;\n#else\nvarying float v_SkyGroundFactor;\n#endif\n#if defined(SUN_HIGH_QUALITY) || defined(SUN_SIMPLE)\nvarying vec3 v_SunColor;\n#endif\nfloat getMiePhase(float eyeCos,float eyeCos2){float temp=1.0+MIE_G2-2.0*MIE_G*eyeCos;temp=pow(temp,pow(u_SunSize,0.65)*10.0);temp=max(temp,1.0e-4);temp=1.5*((1.0-MIE_G2)/(2.0+MIE_G2))*(1.0+eyeCos2)/temp;return temp;}float calcSunAttenuation(vec3 lightPos,vec3 ray){\n#ifdef SUN_HIGH_QUALITY\nfloat focusedEyeCos=pow(clamp(dot(lightPos,ray),0.0,1.0),u_SunSizeConvergence);return getMiePhase(-focusedEyeCos,focusedEyeCos*focusedEyeCos);\n#else\nvec3 delta=lightPos-ray;float dist=length(delta);float spot=1.0-smoothstep(0.0,u_SunSize,dist);return spot*spot;\n#endif\n}void main(){vec3 col=vec3(0.0,0.0,0.0);\n#ifdef SUN_HIGH_QUALITY\nvec3 ray=normalize(v_Vertex);float y=ray.y/SKY_GROUND_THRESHOLD;\n#elif defined(SUN_SIMPLE)\nvec3 ray=v_RayDir;float y=ray.y/SKY_GROUND_THRESHOLD;\n#else\nfloat y=v_SkyGroundFactor;\n#endif\ncol=mix(v_SkyColor,v_GroundColor,clamp(y,0.0,1.0));\n#if defined(SUN_HIGH_QUALITY) || defined(SUN_SIMPLE)\nif(y<0.0)col+=v_SunColor*calcSunAttenuation(-u_SunLight_direction,-ray);\n#endif\ngl_FragColor=vec4(col,1.0);gl_FragColor=outputTransform(gl_FragColor);}";

    class SkyProceduralShaderInit {
        static init() {
            let attributeMap = {
                "a_Position": [Laya.VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                "u_SunSize": exports.ShaderDataType.Float,
                "u_SunSizeConvergence": exports.ShaderDataType.Float,
                "u_AtmosphereThickness": exports.ShaderDataType.Float,
                "u_SkyTint": exports.ShaderDataType.Color,
                "u_GroundTint": exports.ShaderDataType.Color,
                "u_Exposure": exports.ShaderDataType.Float,
            };
            let defaultValue = {
                "u_SunSize": 0.04,
                "u_SunSizeConvergence": 5,
                "u_AtmosphereThickness": 1.0,
                "u_SkyTint": new Laya.Color(0.5, 0.5, 0.5, 1.0),
                "u_GroundTint": new Laya.Color(0.369, 0.349, 0.341, 1.0),
                "u_Exposure": 1.3,
            };
            let shader = Laya.Shader3D.add("SkyProcedural");
            shader.shaderType = Laya.ShaderFeatureType.Sky;
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(SkyProceduralVS, SkyProceduralFS);
            pass.renderState.depthTest = RenderState.DEPTHTEST_LEQUAL;
            pass.renderState.cull = Laya.CullMode.Back;
            pass.renderState.depthWrite = false;
            pass.renderState.stencilWrite = false;
            pass.statefirst = true;
        }
    }

    var SkyPanoramicVS = "#define SHADER_NAME SkyPanoramicVS\n#include \"SkyCommon.glsl\";\nvarying vec3 v_Texcoord;varying vec2 v_Image180ScaleAndCutoff;varying vec4 v_Layout3DScaleAndOffset;void main(){vec4 position=rotateAroundYInDegrees(a_Position,u_Rotation);v_Texcoord=vec3(-a_Position.x,-a_Position.y,a_Position.z);v_Image180ScaleAndCutoff=vec2(1.0,1.0);v_Layout3DScaleAndOffset=vec4(0,0,1,1);gl_Position=u_SkyProjectionViewMat*position;gl_Position=remapSkyPositionZ(gl_Position);}";

    var SkyPanoramicFS = "#define SHADER_NAME SkyPanoramicVS\n#include \"Color.glsl\";\nvarying vec3 v_Texcoord;varying vec2 v_Image180ScaleAndCutoff;varying vec4 v_Layout3DScaleAndOffset;const vec4 c_ColorSpace=vec4(4.59479380,4.59479380,4.59479380,2.0);vec2 ToRadialCoords(vec3 coords){vec3 normalizedCoords=normalize(coords);float latitude=acos(normalizedCoords.y);float longitude=atan(normalizedCoords.z,normalizedCoords.x);vec2 sphereCoords=vec2(longitude,latitude)*vec2(0.5/PI,1.0/PI);return vec2(0.5,1.0)-sphereCoords;}void main(){vec2 tc=ToRadialCoords(v_Texcoord);if(tc.x>v_Image180ScaleAndCutoff.y)gl_FragColor=vec4(0,0,0,1);tc.x=mod(tc.x*v_Image180ScaleAndCutoff.x,1.0);tc=(tc+v_Layout3DScaleAndOffset.xy)*v_Layout3DScaleAndOffset.zw;mediump vec4 tex=texture2D(u_Texture,tc);\n#ifdef Gamma_u_Texture\ntex=gammaToLinear(tex);\n#endif\nmediump vec3 c=tex.xyz;c=c*u_TintColor.rgb*c_ColorSpace.rgb;c*=pow(u_Exposure,2.2);gl_FragColor=vec4(c,1.0);gl_FragColor=outputTransform(gl_FragColor);}";

    class SkyPanoramicShaderInit {
        static init() {
            let attributeMap = {
                "a_Position": [Laya.VertexMesh.MESH_POSITION0, exports.ShaderDataType.Vector4]
            };
            let uniformMap = {
                'u_TintColor': exports.ShaderDataType.Color,
                'u_Rotation': exports.ShaderDataType.Float,
                'u_Texture': exports.ShaderDataType.Texture2D,
                'u_Exposure': exports.ShaderDataType.Float,
            };
            let defaultValue = {
                'u_TintColor': new Laya.Color(0.5, 0.5, 0.5, 1.0),
                'u_Exposure': 1.3,
                'u_Rotation': 0,
                'u_Texture': Laya.Texture2D.grayTexture,
            };
            let shader = Laya.Shader3D.add("SkyPanoramic");
            shader.shaderType = Laya.ShaderFeatureType.Sky;
            let subShader = new Laya.SubShader(attributeMap, uniformMap, defaultValue);
            shader.addSubShader(subShader);
            let pass = subShader.addShaderPass(SkyPanoramicVS, SkyPanoramicFS);
            pass.renderState.depthTest = RenderState.DEPTHTEST_LEQUAL;
            pass.renderState.cull = Laya.CullMode.Back;
            pass.renderState.depthWrite = false;
            pass.renderState.stencilWrite = false;
            pass.statefirst = true;
        }
    }

    class ShaderInit3D {
        static __init__() {
            Laya.Shader3D.addInclude("Utils.glsl", UtilsGLSL);
            Laya.Shader3D.addInclude("BakedBoneMatrixSampler.glsl", BakedBoneMatrixSamplerGLSL);
            Laya.Shader3D.addInclude("MorphTarget.glsl", MorphTargetGLSL);
            Laya.Shader3D.addInclude("VertexCommon.glsl", VertexGLSL);
            Laya.Shader3D.addInclude("ShadingCommon.glsl", ShadingCommonGLSL);
            Laya.Shader3D.addInclude("ShadingVertex.glsl", ShadingVertexGLSL);
            Laya.Shader3D.addInclude("ShadingFrag.glsl", ShadingFragGLSL);
            Laya.Shader3D.addInclude("OutputTransform.glsl", OutputTransformGLSL);
            Laya.Shader3D.addInclude("Scene.glsl", SceneGLSL);
            Laya.Shader3D.addInclude("Camera.glsl", CameraGLSL);
            Laya.Shader3D.addInclude("SkyCommon.glsl", SkyCommon);
            Laya.Shader3D.addInclude("Sprite3DCommon.glsl", Sprite3DCommonGLSL);
            Laya.Shader3D.addInclude("Sprite3DVertex.glsl", Sprite3DVertexGLSL);
            Laya.Shader3D.addInclude("Sprite3DFrag.glsl", Sprite3DFragGLSL);
            Laya.Shader3D.addInclude("DepthVertex.glsl", DepthVertexGLSL);
            Laya.Shader3D.addInclude("DepthFrag.glsl", DepthFragGLSL);
            Laya.Shader3D.addInclude("DepthNormalUtil.glsl", DepthNormalUtilGLSL);
            Laya.Shader3D.addInclude("DepthNormalFrag.glsl", DepthNormalFragGLSL);
            Laya.Shader3D.addInclude("SceneFog.glsl", SceneFogGLSL);
            Laya.Shader3D.addInclude("SceneFogInput.glsl", SceneFogInputGLSL);
            Laya.Shader3D.addInclude("ShadowCommon.glsl", ShadowCommonGLSL);
            Laya.Shader3D.addInclude("ShadowSampleTent.glsl", ShadowSampleTentGLSL);
            Laya.Shader3D.addInclude("ShadowSampler.glsl", ShadowSamplerGLSL);
            Laya.Shader3D.addInclude("Lighting.glsl", LightingGLSL);
            Laya.Shader3D.addInclude("globalIllumination.glsl", GlobalIlluminationGLSL);
            Laya.Shader3D.addInclude("Oct.glsl", OctGLSL);
            Laya.Shader3D.addInclude("GridHelpers.glsl", GridHelpersGLSL);
            Laya.Shader3D.addInclude("VolumetricGI.glsl", VolumetricGIGLSL);
            Laya.Shader3D.addInclude("BlinnPhongLighting.glsl", BlinnPhongLightingGLSL);
            Laya.Shader3D.addInclude("PBRLighting.glsl", PBRLightingGLSL);
            PBRShaderLib.init();
            BlitScreenShaderInit.init();
            UnlitShaderInit.init();
            PBRStandardShaderInit.init();
            BlinnPhongShaderInit.init();
            SkyBoxShaderInit.init();
            SkyProceduralShaderInit.init();
            SkyPanoramicShaderInit.init();
            Laya.Shader3D.SHADERDEFINE_LEGACYSINGALLIGHTING = Laya.Shader3D.getDefineByName("LEGACYSINGLELIGHTING");
            Laya.Shader3D.SHADERDEFINE_ENUNIFORMBLOCK = Laya.Shader3D.getDefineByName("ENUNIFORMBLOCK");
            Laya.Shader3D.SHADERDEFINE_FLOATTEXTURE = Laya.Shader3D.getDefineByName("FLOATTEXTURE");
            Laya.Shader3D.SHADERDEFINE_FLOATTEXTURE_FIL_LINEAR = Laya.Shader3D.getDefineByName("FLOATTEXTURE_FIL_LINEAR");
            Laya.Shader3D.SHADERDEFINE_BLITSCREEN_INVERTY = Laya.Shader3D.getDefineByName("BLITSCREEN_INVERTY");
            Laya.Shader3D.SHADERDEFINE_REMAP_POSITIONZ = Laya.Shader3D.getDefineByName("REMAP_Z");
            Laya.Shader3D.SHADERDEFINE_LOD_TEXTURE_SAMPLE = Laya.Shader3D.getDefineByName("LOD_TEXTURE_SAMPLE");
        }
    }

    class SkinnedMeshSprite3DShaderDeclaration {
    }

    class SkinRenderElement extends RenderElement {
        setSkinData(value) {
            this._renderElementOBJ.skinnedData = value;
        }
        constructor() {
            super();
        }
        _createRenderElementOBJ() {
            this._renderElementOBJ = Laya3DRender.Render3DPassFactory.createSkinRenderElement();
        }
        _render(context) {
        }
    }

    class SkinnedMeshRenderer extends MeshRenderer {
        static __init__() {
            SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE = Laya.Shader3D.getDefineByName("BONE");
            SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_SIMPLEBONE = Laya.Shader3D.getDefineByName("SIMPLEBONE");
            const commandUniform = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("SkinSprite3D");
            SkinnedMeshRenderer.BONES = Laya.Shader3D.propertyNameToID("u_Bones");
            commandUniform.addShaderUniform(SkinnedMeshRenderer.BONES, "u_Bones", exports.ShaderDataType.Buffer);
        }
        get _bones() {
            return this.__bones;
        }
        set _bones(value) {
            this.__bones = value;
            this._isISkinRenderNode() && this._ownerSkinRenderNode.setBones(value);
        }
        get localBounds() {
            return this._localBounds;
        }
        set localBounds(value) {
            this._localBounds = value;
            this.geometryBounds = this._localBounds;
        }
        get rootBone() {
            return this._cacheRootBone;
        }
        set rootBone(value) {
            if (this._cacheRootBone != value) {
                if (this._cacheRootBone)
                    this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                else
                    this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                if (value) {
                    value.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                    this._baseRenderNode.transform = value.transform;
                }
                else {
                    this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange);
                    this._baseRenderNode.transform = this.owner.transform;
                }
                this._cacheRootBone = value;
                this._onWorldMatNeedChange(Transform3D.TRANSFORM_WORLDPOSITION | Transform3D.TRANSFORM_WORLDQUATERNION | Transform3D.TRANSFORM_WORLDSCALE);
                let count = this._renderElements.length;
                for (var i = 0; i < count; i++) {
                    var renderElement = this._renderElements[i];
                    renderElement.setTransform(value.transform);
                }
                this._isISkinRenderNode() && this._ownerSkinRenderNode.setRootBoneTransfom(this._cacheRootBone);
            }
            this._baseRenderNode.transform = this.rootBone ? this.rootBone.transform : this.owner.transform;
        }
        get bones() {
            return this._bones;
        }
        set bones(value) {
            this._bones = value;
        }
        constructor() {
            super();
            this.__bones = [];
            this._worldParams = new Laya.Vector4();
            this.localBounds = new Bounds(Laya.Vector3.ZERO, Laya.Vector3.ZERO);
            this._baseRenderNode.shaderData.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE);
            this._baseRenderNode.renderNodeType = exports.BaseRenderType.SkinnedMeshRender;
        }
        _createBaseRenderNode() {
            this._ownerSkinRenderNode = Laya3DRender.Render3DModuleDataFactory.createSkinRenderNode();
            return this._ownerSkinRenderNode;
        }
        _getcommonUniformMap() {
            return ["Sprite3D", "SkinSprite3D"];
        }
        _needRender(boundFrustum, context) {
            if (!Laya.Stat.enableSkin)
                return false;
            return super._needRender(boundFrustum, context);
        }
        _createRenderElement() {
            let renderelement = new SkinRenderElement();
            return renderelement;
        }
        _isISkinRenderNode() {
            return this._ownerSkinRenderNode.setCacheMesh;
        }
        _onSkinMeshChange(mesh) {
            if (mesh && this._mesh != mesh) {
                this._changeVertexDefine(mesh);
                this._changeMorphData(mesh);
                this._mesh = mesh;
                this._isISkinRenderNode() && this._ownerSkinRenderNode.setCacheMesh(mesh);
                var count = mesh.subMeshCount;
                this._renderElements.length = count;
                let materials = this.sharedMaterials;
                materials.length = count;
                for (var i = 0; i < count; i++) {
                    let renderElement = this._renderElements[i];
                    if (!renderElement) {
                        renderElement = this._renderElements[i] = this._createRenderElement();
                        if (this._cacheRootBone) {
                            renderElement.setTransform(this._cacheRootBone.transform);
                        }
                        else {
                            renderElement.setTransform(this.owner._transform);
                        }
                        renderElement.render = this;
                    }
                    materials[i] = materials[i] || BlinnPhongMaterial.defaultMaterial;
                    renderElement.setGeometry(mesh.getSubMesh(i));
                }
                this.sharedMaterials = materials;
                this.boundsChange = true;
            }
            else if (!mesh) {
                this._renderElements.length = 0;
                this._mesh = null;
                this._changeVertexDefine(null);
                this._changeMorphData(null);
                this.boundsChange = false;
            }
            this._meshChange = true;
        }
        _onMeshChange(value) {
            this._onSkinMeshChange(value);
            this._setRenderElements();
            if (!value)
                return;
            this._cacheMesh = value;
            var subMeshCount = value.subMeshCount;
            this._skinnedData = [];
            for (var i = 0; i < subMeshCount; i++) {
                var subBoneIndices = value.getSubMesh(i)._boneIndicesList;
                var subCount = subBoneIndices.length;
                var subData = this._skinnedData[i] = [];
                for (var j = 0; j < subCount; j++)
                    subData[j] = new Float32Array(subBoneIndices[j].length * 16);
                this._renderElements[i].setSkinData(subData);
            }
            this._isISkinRenderNode() && this._ownerSkinRenderNode.setSkinnedData(this._skinnedData);
        }
        _setBelongScene(scene) {
            super._setBelongScene(scene);
            this._isISkinRenderNode() && this._ownerSkinRenderNode.setOwnerTransform(this.owner);
        }
        _setUnBelongScene() {
            super._setUnBelongScene();
        }
        _statAdd() {
            Laya.Stat.renderNode++;
            Laya.Stat.skinRenderNode++;
        }
        _statRemove() {
            Laya.Stat.renderNode--;
            Laya.Stat.skinRenderNode--;
        }
        renderUpdate(context) {
            super.renderUpdate(context);
            this._isISkinRenderNode() && this._ownerSkinRenderNode.computeSkinnedData();
        }
        _cloneTo(dest) {
            let getCommomParent = (rootNode, rootCheckNode) => {
                let nodeArray = [];
                let node = rootNode;
                while (!!node) {
                    if (node instanceof Sprite3D)
                        nodeArray.push(node);
                    node = node.parent;
                }
                let checkNode = rootCheckNode;
                while (!!checkNode && nodeArray.indexOf(checkNode) == -1) {
                    checkNode = checkNode.parent;
                }
                return checkNode;
            };
            let cloneHierachFun = (rootNode, rootCheckNode, destNode) => {
                let rootparent = getCommomParent(rootNode, rootCheckNode);
                if (!rootparent)
                    return null;
                let path = [];
                Utils3D._getHierarchyPath(rootparent, rootNode, path);
                let pathcheck = [];
                Utils3D._getHierarchyPath(rootparent, rootCheckNode, pathcheck);
                let destParent = Utils3D._getParentNodeByHierarchyPath(destNode, path);
                if (!destParent)
                    return null;
                return Utils3D._getNodeByHierarchyPath(destParent, pathcheck);
            };
            var rootBone = this.rootBone;
            if (rootBone) {
                let node = cloneHierachFun(this.owner, this.rootBone, dest.owner);
                if (node)
                    dest.rootBone = node;
                else
                    dest.rootBone = rootBone;
            }
            var bones = this.bones;
            var destBone = dest.bones;
            let n = destBone.length = bones.length;
            for (var i = 0; i < n; i++) {
                let ceckNode = bones[i];
                destBone[i] = cloneHierachFun(this.owner, ceckNode, dest.owner);
            }
            dest.bones = dest.bones;
            var lbb = this.localBounds;
            (lbb) && (lbb.cloneTo(dest.localBounds));
            (dest.localBounds) && (dest.localBounds = dest.localBounds);
            super._cloneTo(dest);
        }
        _onDestroy() {
            if (this._cacheRootBone)
                (!this._cacheRootBone._destroyed) && (this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange));
            else
                (this.owner && !this.owner._destroyed) && (this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange));
            super._onDestroy();
        }
    }

    class SimpleSkinnedMeshRenderer extends SkinnedMeshRenderer {
        get simpleAnimatorTexture() {
            return this._simpleAnimatorTexture;
        }
        set simpleAnimatorTexture(value) {
            this._simpleAnimatorTexture = value;
            this._simpleAnimatorTextureSize = value.width;
            this._baseRenderNode.shaderData.setTexture(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE, value);
            this._baseRenderNode.shaderData.setNumber(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURESIZE, this._simpleAnimatorTextureSize);
        }
        get simpleAnimatorOffset() {
            return this._simpleAnimatorOffset;
        }
        set simpleAnimatorOffset(value) {
            value.cloneTo(this._simpleAnimatorOffset);
        }
        _isISkinRenderNode() {
            return null;
        }
        constructor() {
            super();
            this._simpleAnimatorParams = new Laya.Vector4();
            this._simpleAnimatorOffset = new Laya.Vector2();
            this._baseRenderNode.shaderData.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_SIMPLEBONE);
            this._baseRenderNode.shaderData.addDefine(SkinnedMeshSprite3DShaderDeclaration.SHADERDEFINE_BONE);
            this._baseRenderNode.renderNodeType = exports.BaseRenderType.SimpleSkinRender;
            this._baseRenderNode.shaderData.setVector(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORPARAMS, new Laya.Vector4());
        }
        _createBaseRenderNode() {
            this._ownerSimpleRenderNode = Laya3DRender.Render3DModuleDataFactory.createSimpleSkinRenderNode();
            return this._ownerSimpleRenderNode;
        }
        _getcommonUniformMap() {
            return ["Sprite3D", "SimpleSkinnedMesh"];
        }
        _computeSkinnedData() {
            this._computeAnimatorParamsData();
        }
        renderUpdate(context) {
            super.renderUpdate(context);
            this._computeSkinnedData();
        }
        _createRenderElement() {
            let renderelement = new SubMeshRenderElement();
            return renderelement;
        }
        _computeAnimatorParamsData() {
            if (this._cacheMesh) {
                this._simpleAnimatorParams.x = this._simpleAnimatorOffset.x;
                this._simpleAnimatorParams.y = Math.round(this._simpleAnimatorOffset.y) * this._bonesNums * 4;
                this._ownerSimpleRenderNode.setSimpleAnimatorParams(this._simpleAnimatorParams);
            }
        }
        setCustomData(value1, value2 = 0) {
            this._simpleAnimatorParams.z = value1;
            this._simpleAnimatorParams.w = value2;
            this._ownerSimpleRenderNode.setSimpleAnimatorParams(this._simpleAnimatorParams);
        }
        _onMeshChange(value) {
            this._onSkinMeshChange(value);
            if (!value)
                return;
            this._cacheMesh = value;
            this._setRenderElements();
        }
        _cloneTo(dest) {
            dest.simpleAnimatorOffset = this.simpleAnimatorOffset;
            dest.simpleAnimatorTexture = this.simpleAnimatorTexture;
            dest._bonesNums = this._bonesNums;
            super._cloneTo(dest);
        }
        _onDestroy() {
            if (this._cacheRootBone)
                (!this._cacheRootBone._destroyed) && (this._cacheRootBone.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._onWorldMatNeedChange));
            this._simpleAnimatorTexture = null;
            super._onDestroy();
        }
    }

    class SimpleSkinnedMeshSprite3D extends RenderableSprite3D {
        static __init__() {
            SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE = Laya.Shader3D.propertyNameToID("u_SimpleAnimatorTexture");
            SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORPARAMS = Laya.Shader3D.propertyNameToID("u_SimpleAnimatorParams");
            SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURESIZE = Laya.Shader3D.propertyNameToID("u_SimpleAnimatorTextureSize");
            const commandUniform = Laya.LayaGL.renderDeviceFactory.createGlobalUniformMap("SimpleSkinnedMesh");
            commandUniform.addShaderUniform(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURE, "u_SimpleAnimatorTexture", exports.ShaderDataType.Texture2D);
            commandUniform.addShaderUniform(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORPARAMS, "u_SimpleAnimatorParams", exports.ShaderDataType.Vector4);
            commandUniform.addShaderUniform(SimpleSkinnedMeshSprite3D.SIMPLE_SIMPLEANIMATORTEXTURESIZE, "u_SimpleAnimatorTextureSize", exports.ShaderDataType.Float);
        }
        get meshFilter() {
            return this._meshFilter;
        }
        get simpleSkinnedMeshRenderer() {
            return this._render;
        }
        constructor(mesh = null, name = null) {
            super(name);
            this._meshFilter = this.addComponent(MeshFilter);
            this._render = this.addComponent(SimpleSkinnedMeshRenderer);
            (mesh) && (this._meshFilter.sharedMesh = mesh);
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._meshFilter.destroy();
        }
    }
    SimpleSkinnedMeshSprite3D._tempArray0 = [];

    class SkyPanoramicMaterial extends Laya.Material {
        static __init__() {
            SkyPanoramicMaterial.TINTCOLOR = Laya.Shader3D.propertyNameToID("u_TintColor");
            SkyPanoramicMaterial.EXPOSURE = Laya.Shader3D.propertyNameToID("u_Exposure");
            SkyPanoramicMaterial.ROTATION = Laya.Shader3D.propertyNameToID("u_Rotation");
            SkyPanoramicMaterial.TEXTURE = Laya.Shader3D.propertyNameToID("u_Texture");
            SkyPanoramicMaterial.TEXTURE_HDR_PARAMS = Laya.Shader3D.propertyNameToID("u_Texture_HDR_params");
        }
        get tintColor() {
            return this.getColorByIndex(SkyPanoramicMaterial.TINTCOLOR);
        }
        set tintColor(value) {
            this.setColorByIndex(SkyPanoramicMaterial.TINTCOLOR, value);
        }
        get exposure() {
            return this.getFloatByIndex(SkyPanoramicMaterial.EXPOSURE);
        }
        set exposure(value) {
            this.setFloatByIndex(SkyPanoramicMaterial.EXPOSURE, value);
        }
        get rotation() {
            return this.getFloatByIndex(SkyPanoramicMaterial.ROTATION);
        }
        set rotation(value) {
            this.setFloatByIndex(SkyPanoramicMaterial.ROTATION, value);
        }
        get panoramicTexture() {
            return this.getTextureByIndex(SkyPanoramicMaterial.TEXTURE);
        }
        set panoramicTexture(value) {
            this.setTextureByIndex(SkyPanoramicMaterial.TEXTURE, value);
        }
        constructor() {
            super();
            this._textureHDRParams = new Laya.Vector4(1.0, 0.0, 0.0, 1.0);
            this.setShaderName("SkyPanoramic");
            this.setColorByIndex(SkyPanoramicMaterial.TINTCOLOR, new Laya.Color(0.5, 0.5, 0.5, 0.5));
            this.setFloatByIndex(SkyPanoramicMaterial.ROTATION, 0.0);
            this.setVector4ByIndex(SkyPanoramicMaterial.TEXTURE_HDR_PARAMS, this._textureHDRParams);
            this.exposure = 1.3;
        }
    }

    class PixelLineMaterial extends Laya.Material {
        static __initDefine__() {
            PixelLineMaterial.COLOR = Laya.Shader3D.propertyNameToID("u_Color");
        }
        get color() {
            return this._shaderValues.getVector(PixelLineMaterial.COLOR);
        }
        set color(value) {
            this._shaderValues.setVector(PixelLineMaterial.COLOR, value);
        }
        constructor() {
            super();
            this.setShaderName("LineShader");
            this._shaderValues.setVector(PixelLineMaterial.COLOR, new Laya.Vector4(1.0, 1.0, 1.0, 1.0));
        }
        clone() {
            var dest = new PixelLineMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }

    exports.EPhysicsStatisticsInfo = void 0;
    (function (EPhysicsStatisticsInfo) {
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["C_PhysicsEventCount"] = 0] = "C_PhysicsEventCount";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["FrameClearCount"] = 1] = "FrameClearCount";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["C_PhysicaDynamicRigidBody"] = 2] = "C_PhysicaDynamicRigidBody";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["C_PhysicaStaticRigidBody"] = 3] = "C_PhysicaStaticRigidBody";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["C_PhysicaKinematicRigidBody"] = 4] = "C_PhysicaKinematicRigidBody";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["C_PhysicaCharacterController"] = 5] = "C_PhysicaCharacterController";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["C_PhysicsJoint"] = 6] = "C_PhysicsJoint";
        EPhysicsStatisticsInfo[EPhysicsStatisticsInfo["Count"] = 7] = "Count";
    })(exports.EPhysicsStatisticsInfo || (exports.EPhysicsStatisticsInfo = {}));

    class Physics3DStatInfo {
        static initStatisticsInfo() {
            for (let i = 0; i < exports.EPhysicsStatisticsInfo.Count; i++) {
                this._PhysicsStatisticsInfo.set(i, 0);
            }
            if (Physics3DStatInfo.enableStatistics && Physics3DStatInfo.autoFrameClear) {
                Laya.ILaya.timer.frameLoop(1, null, Physics3DStatInfo.clearStatisticsInfo);
            }
        }
        static addStatisticsInfo(info, value) {
            Physics3DStatInfo.enableStatistics && (Physics3DStatInfo._PhysicsStatisticsInfo.set(info, Physics3DStatInfo._PhysicsStatisticsInfo.get(info) + value));
        }
        static getStatisticsInfo(info) {
            let value = 0;
            if (Physics3DStatInfo.enableStatistics) {
                value = Physics3DStatInfo._PhysicsStatisticsInfo.get(info);
            }
            return value;
        }
        static clearStatisticsInfo() {
            if (Physics3DStatInfo.enableStatistics) {
                for (let i = 0; i < exports.EPhysicsStatisticsInfo.FrameClearCount; i++) {
                    Physics3DStatInfo._PhysicsStatisticsInfo.set(i, 0);
                }
            }
        }
        static stopAndClearAllStatisticsInfo() {
            for (let i = 0; i < exports.EPhysicsStatisticsInfo.Count; i++) {
                this._PhysicsStatisticsInfo.set(i, 0);
            }
            if (Physics3DStatInfo.enableStatistics && Physics3DStatInfo.autoFrameClear) {
                Laya.ILaya.timer.clear(null, Physics3DStatInfo.clearStatisticsInfo);
            }
        }
    }
    Physics3DStatInfo._PhysicsStatisticsInfo = new Map();
    Physics3DStatInfo.enableStatistics = false;
    Physics3DStatInfo.autoFrameClear = false;

    class PostProcessRenderContext {
        constructor() {
            this.source = null;
            this.indirectTarget = null;
            this.destination = null;
            this.camera = null;
            this.compositeShaderData = null;
            this.command = null;
            this.deferredReleaseTextures = [];
        }
        createRTByContextReleaseTexture(width, height, colorFormat, depthFormat, mipmap = false, multiSamples = 1, depthTexture = false, sRGB = false) {
            let n = this.deferredReleaseTextures.length;
            for (let index = 0; index < n; index++) {
                let rt = this.deferredReleaseTextures[index];
                if (rt.width == width && rt.height == height && rt.colorFormat == colorFormat && rt.depthStencilFormat == depthFormat && rt._generateMipmap == mipmap && rt.multiSamples == multiSamples && rt.generateDepthTexture == depthTexture && rt._gammaSpace == sRGB) {
                    rt._inPool = false;
                    let end = this.deferredReleaseTextures[n - 1];
                    this.deferredReleaseTextures[index] = end;
                    this.deferredReleaseTextures.length -= 1;
                    return rt;
                }
            }
            return null;
        }
    }

    class PostProcess {
        static __init__() {
            PostProcess.SHADERDEFINE_BLOOM_LOW = Laya.Shader3D.getDefineByName("BLOOM_LOW");
            PostProcess.SHADERDEFINE_BLOOM = Laya.Shader3D.getDefineByName("BLOOM");
            PostProcess.SHADERDEFINE_FINALPASS = Laya.Shader3D.getDefineByName("FINALPASS");
            PostProcess.SHADERVALUE_MAINTEX = Laya.Shader3D.propertyNameToID("u_MainTex");
            PostProcess.SHADERVALUE_BLOOMTEX = Laya.Shader3D.propertyNameToID("u_BloomTex");
            PostProcess.SHADERVALUE_AUTOEXPOSURETEX = Laya.Shader3D.propertyNameToID("u_AutoExposureTex");
            PostProcess.SHADERVALUE_BLOOM_DIRTTEX = Laya.Shader3D.propertyNameToID("u_Bloom_DirtTex");
            PostProcess.SHADERVALUE_BLOOMTEX_TEXELSIZE = Laya.Shader3D.propertyNameToID("u_BloomTex_TexelSize");
            PostProcess.SHADERVALUE_BLOOM_DIRTTILEOFFSET = Laya.Shader3D.propertyNameToID("u_Bloom_DirtTileOffset");
            PostProcess.SHADERVALUE_BLOOM_SETTINGS = Laya.Shader3D.propertyNameToID("u_Bloom_Settings");
            PostProcess.SHADERVALUE_BLOOM_COLOR = Laya.Shader3D.propertyNameToID("u_Bloom_Color");
        }
        recaculateCameraFlag() {
            this._depthtextureFlag = Laya.DepthTextureMode.None;
            let n = this.effects.length;
            for (let i = 0; i < n; i++) {
                this._depthtextureFlag |= this.effects[i].getCameraDepthTextureModeFlag();
            }
        }
        constructor() {
            this._compositeShader = Laya.Shader3D.find("PostProcessComposite");
            this._compositeShaderData = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
            this._effects = [];
            this._enable = true;
            this._enableColorGrad = false;
            this._context = new PostProcessRenderContext();
            this._context.compositeShaderData = this._compositeShaderData;
            this._context.command = new CommandBuffer();
            this._depthtextureFlag = 0;
        }
        get enable() {
            return this._enable;
        }
        set enable(value) {
            this._enable = value;
        }
        set commandContext(oriContext) {
            this._context.command._context = oriContext;
        }
        get effects() {
            return this._effects;
        }
        set effects(value) {
            this.clearEffect();
            for (var i = 0, n = value.length; i < n; i++) {
                if (value[i])
                    this.addEffect(value[i]);
            }
        }
        get cameraDepthTextureMode() {
            return this._depthtextureFlag;
        }
        _init(camera) {
            this._context.camera = camera;
            this._context.command._camera = camera;
        }
        _render(camera) {
            this._init(camera);
            let context = this._context;
            var camera = context.camera;
            var viewport = camera.viewport;
            var internalRT = camera._needInternalRenderTexture();
            var cameraTarget = !internalRT ? Laya.RenderTexture.createFromPool(camera._offScreenRenderTexture.width, camera._offScreenRenderTexture.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true) : camera._internalRenderTexture;
            var screenTexture = Laya.RenderTexture.createFromPool(cameraTarget.width, cameraTarget.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true);
            var Indirect = [Laya.RenderTexture.createFromPool(cameraTarget.width, cameraTarget.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true), Laya.RenderTexture.createFromPool(cameraTarget.width, cameraTarget.height, camera._getRenderTextureFormat(), Laya.RenderTargetFormat.None, false, 1, false, true)];
            context.command.clear();
            context.source = screenTexture;
            context.indirectTarget = screenTexture;
            context.destination = this._effects.length == 2 ? Indirect[0] : cameraTarget;
            context.compositeShaderData.clearDefine();
            if (internalRT) {
                context.command.blitScreenTriangle(camera._internalRenderTexture, screenTexture);
            }
            else {
                context.command.blitScreenTriangle(camera._offScreenRenderTexture, screenTexture);
            }
            context.compositeShaderData.setTexture(PostProcess.SHADERVALUE_AUTOEXPOSURETEX, Laya.Texture2D.whiteTexture);
            if (this._enableColorGrad) {
                this._ColorGradEffect._buildLUT();
            }
            for (var i = 0, n = this._effects.length; i < n; i++) {
                if (this._effects[i].active) {
                    this._effects[i].render(context);
                    if (i == n - 2) {
                        context.indirectTarget = context.destination;
                        context.destination = cameraTarget;
                    }
                    else {
                        context.indirectTarget = context.destination;
                        context.destination = Indirect[(i + 1) % 2];
                    }
                }
                else if (i == n - 1) {
                    context.command.blitScreenTriangle(context.indirectTarget, cameraTarget);
                }
            }
            this._compositeShaderData.addDefine(PostProcess.SHADERDEFINE_FINALPASS);
            if (camera._offScreenRenderTexture) {
                if (internalRT) {
                    context.destination = camera._offScreenRenderTexture;
                    var canvasWidth = camera._getCanvasWidth(), canvasHeight = camera._getCanvasHeight();
                    if (Laya.LayaGL.renderEngine._screenInvertY) {
                        camera._screenOffsetScale.setValue(viewport.x / canvasWidth, viewport.y / canvasHeight, viewport.width / canvasWidth, viewport.height / canvasHeight);
                    }
                    else {
                        camera._screenOffsetScale.setValue(viewport.x / canvasWidth, 1.0 - viewport.y / canvasHeight, viewport.width / canvasWidth, -viewport.height / canvasHeight);
                    }
                    context.command.blitScreenTriangle(cameraTarget, camera._offScreenRenderTexture, camera._screenOffsetScale, null, this._compositeShaderData, 0);
                }
            }
            if (internalRT)
                Laya.RenderTexture.recoverToPool(cameraTarget);
            Laya.RenderTexture.recoverToPool(screenTexture);
            Laya.RenderTexture.recoverToPool(Indirect[0]);
            Laya.RenderTexture.recoverToPool(Indirect[1]);
            var tempRenderTextures = context.deferredReleaseTextures;
            for (i = 0, n = tempRenderTextures.length; i < n; i++)
                Laya.RenderTexture.recoverToPool(tempRenderTextures[i]);
            tempRenderTextures.length = 0;
        }
        addEffect(effect) {
            if (effect.singleton && this.getEffect(effect.constructor)) {
                console.error("无法增加已经存在的Effect");
                return;
            }
            if (!this._enableColorGrad || effect instanceof Laya.ColorGradEffect) {
                this._effects.push(effect);
            }
            else {
                this._effects.splice(this._effects.length - 1, 0, effect);
            }
            this.recaculateCameraFlag();
            effect.effectInit(this);
        }
        getEffect(classReg) {
            let size = this._effects.length;
            for (let i = 0; i < size; i++) {
                let element = this._effects[i];
                if (element instanceof classReg) {
                    return element;
                }
            }
            return null;
        }
        removeEffect(effect) {
            var index = this._effects.indexOf(effect);
            if (index !== -1) {
                this._effects.splice(index, 1);
                effect.release(this);
                this.recaculateCameraFlag();
            }
        }
        clearEffect() {
            let i = this.effects.length - 1;
            for (; i >= 0; i--) {
                this.removeEffect(this.effects[i]);
            }
            this._effects.length = 0;
        }
        _applyPostProcessCommandBuffers() {
            this._context.command._apply();
        }
    }

    class Laya3D {
        static get PhysicsCreateUtil() {
            return this._PhysicsCreateUtil;
        }
        static set PhysicsCreateUtil(value) {
            if (value && !Laya3D._PhysicsCreateUtil) {
                Laya3D._PhysicsCreateUtil = value;
                Laya3D._enablePhysics = true;
            }
        }
        static get enablePhysics() {
            return Laya3D._enablePhysics;
        }
        static _changeWebGLSize(width, height) {
            RenderContext3D.clientWidth = width;
            RenderContext3D.clientHeight = height;
        }
        static __init__() {
            Laya.Config3D._multiLighting = Laya.Config3D.enableMultiLight && Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.TextureFormat_R32G32B32A32);
            if (Laya.Config3D.maxLightCount > 2048) {
                Laya.Config3D.maxLightCount = 2048;
                console.warn("Config3D: maxLightCount must less equal 2048.");
            }
            let lcc = Laya.Config3D.lightClusterCount;
            if (lcc.x > 128 || lcc.y > 128 || lcc.z > 128) {
                lcc.setValue(Math.min(lcc.x, 128), Math.min(lcc.y, 128), Math.min(lcc.z, 128));
                console.warn("Config3D: lightClusterCount X and Y、Z must less equal 128.");
            }
            let maxAreaLightCountWithZ = Math.floor(2048 / Laya.Config3D.lightClusterCount.z - 1) * 4;
            if (maxAreaLightCountWithZ < Laya.Config3D.maxLightCount)
                console.warn("Config3D: if the area light(PointLight、SpotLight) count is large than " + maxAreaLightCountWithZ + ",maybe the far away culster will ingonre some light.");
            Laya.Config3D._maxAreaLightCountPerClusterAverage = Math.min(maxAreaLightCountWithZ, Laya.Config3D.maxLightCount);
            Laya.ILaya.Scene3D = Scene3D;
            Laya.ILaya.Laya3D = Laya3D;
            VertexPositionTexture.__init__();
            PixelLineVertex.__init__();
            SubMeshInstanceBatch.__init__();
            ShaderInit3D.__init__();
            PBRMaterial.__init__();
            PBRStandardMaterial.__init__();
            SkyPanoramicMaterial.__init__();
            PrimitiveMesh.__init__();
            Sprite3D.__init__();
            RenderableSprite3D.__init__();
            MeshSprite3D.__init__();
            SkinnedMeshRenderer.__init__();
            DepthPass.__init__();
            SimpleSkinnedMeshSprite3D.__init__();
            PostProcess.__init__();
            Scene3D.__init__();
            ShadowCasterPass.__init__();
            BaseCamera.__init__();
            BaseRender.__init__();
            MeshRenderer.__init__();
            SkyRenderer.__init__();
            Camera.__init__();
            ShadowUtils.init();
            RenderContext3D.__init__();
            BlinnPhongMaterial.__initDefine__();
            SkyProceduralMaterial.__initDefine__();
            UnlitMaterial.__initDefine__();
            SkyBoxMaterial.__initDefine__();
            Command.__init__();
            BlitFrameBufferCMD.__init__();
            BlinnPhongMaterial.defaultMaterial = new BlinnPhongMaterial();
            BlinnPhongMaterial.defaultMaterial.lock = true;
            UnlitMaterial.defaultMaterial = new UnlitMaterial();
            UnlitMaterial.defaultMaterial.lock = true;
            let pixelLineMaterial = new UnlitMaterial();
            pixelLineMaterial.lock = true;
            pixelLineMaterial.enableVertexColor = true;
            PixelLineMaterial.defaultMaterial = pixelLineMaterial;
            SkyBox.__init__();
            SkyDome.__init__();
            ScreenQuad.__init__();
        }
        static __initPhysics__() {
            if (!Laya3D._PhysicsCreateUtil) {
                Laya3D._enablePhysics = false;
                return Promise.resolve();
            }
            else {
                Laya3D._enablePhysics = true;
                Physics3DStatInfo.initStatisticsInfo();
                if (Laya.PlayerConfig.physics3D)
                    Object.assign(Scene3D.physicsSettings, Laya.PlayerConfig.physics3D);
                return Laya3D._PhysicsCreateUtil.initialize();
            }
        }
    }
    Laya3D._enablePhysics = false;
    window.Laya3D = Laya3D;
    Laya.Laya.addInitCallback(() => Laya3D.__initPhysics__());

    exports.D6MotionType = void 0;
    (function (D6MotionType) {
        D6MotionType[D6MotionType["eX"] = 0] = "eX";
        D6MotionType[D6MotionType["eY"] = 1] = "eY";
        D6MotionType[D6MotionType["eZ"] = 2] = "eZ";
        D6MotionType[D6MotionType["eTWIST"] = 3] = "eTWIST";
        D6MotionType[D6MotionType["eSWING1"] = 4] = "eSWING1";
        D6MotionType[D6MotionType["eSWING2"] = 5] = "eSWING2";
    })(exports.D6MotionType || (exports.D6MotionType = {}));
    exports.D6Axis = void 0;
    (function (D6Axis) {
        D6Axis[D6Axis["eLOCKED"] = 0] = "eLOCKED";
        D6Axis[D6Axis["eLIMITED"] = 1] = "eLIMITED";
        D6Axis[D6Axis["eFREE"] = 2] = "eFREE";
    })(exports.D6Axis || (exports.D6Axis = {}));
    exports.D6Drive = void 0;
    (function (D6Drive) {
        D6Drive[D6Drive["eX"] = 0] = "eX";
        D6Drive[D6Drive["eY"] = 1] = "eY";
        D6Drive[D6Drive["eZ"] = 2] = "eZ";
        D6Drive[D6Drive["eSWING"] = 3] = "eSWING";
        D6Drive[D6Drive["eTWIST"] = 4] = "eTWIST";
        D6Drive[D6Drive["eSLERP"] = 5] = "eSLERP";
    })(exports.D6Drive || (exports.D6Drive = {}));

    exports.ECharacterCapable = void 0;
    (function (ECharacterCapable) {
        ECharacterCapable[ECharacterCapable["Charcater_Gravity"] = 0] = "Charcater_Gravity";
        ECharacterCapable[ECharacterCapable["Charcater_CollisionGroup"] = 1] = "Charcater_CollisionGroup";
        ECharacterCapable[ECharacterCapable["Charcater_WorldPosition"] = 2] = "Charcater_WorldPosition";
        ECharacterCapable[ECharacterCapable["Charcater_Move"] = 3] = "Charcater_Move";
        ECharacterCapable[ECharacterCapable["Charcater_Jump"] = 4] = "Charcater_Jump";
        ECharacterCapable[ECharacterCapable["Charcater_StepOffset"] = 5] = "Charcater_StepOffset";
        ECharacterCapable[ECharacterCapable["Character_UpDirection"] = 6] = "Character_UpDirection";
        ECharacterCapable[ECharacterCapable["Character_FallSpeed"] = 7] = "Character_FallSpeed";
        ECharacterCapable[ECharacterCapable["Character_SlopeLimit"] = 8] = "Character_SlopeLimit";
        ECharacterCapable[ECharacterCapable["Character_PushForce"] = 9] = "Character_PushForce";
        ECharacterCapable[ECharacterCapable["Character_Radius"] = 10] = "Character_Radius";
        ECharacterCapable[ECharacterCapable["Character_Height"] = 11] = "Character_Height";
        ECharacterCapable[ECharacterCapable["Character_offset"] = 12] = "Character_offset";
        ECharacterCapable[ECharacterCapable["Character_Skin"] = 13] = "Character_Skin";
        ECharacterCapable[ECharacterCapable["Character_minDistance"] = 14] = "Character_minDistance";
        ECharacterCapable[ECharacterCapable["Character_EventFilter"] = 15] = "Character_EventFilter";
        ECharacterCapable[ECharacterCapable["Character_SimulateGravity"] = 16] = "Character_SimulateGravity";
    })(exports.ECharacterCapable || (exports.ECharacterCapable = {}));

    exports.EColliderCapable = void 0;
    (function (EColliderCapable) {
        EColliderCapable[EColliderCapable["Collider_CollisionGroup"] = 0] = "Collider_CollisionGroup";
        EColliderCapable[EColliderCapable["Collider_Friction"] = 1] = "Collider_Friction";
        EColliderCapable[EColliderCapable["Collider_RollingFriction"] = 2] = "Collider_RollingFriction";
        EColliderCapable[EColliderCapable["Collider_Restitution"] = 3] = "Collider_Restitution";
        EColliderCapable[EColliderCapable["Collider_AllowTrigger"] = 4] = "Collider_AllowTrigger";
        EColliderCapable[EColliderCapable["Collider_DynamicFriction"] = 5] = "Collider_DynamicFriction";
        EColliderCapable[EColliderCapable["Collider_StaticFriction"] = 6] = "Collider_StaticFriction";
        EColliderCapable[EColliderCapable["Collider_BounceCombine"] = 7] = "Collider_BounceCombine";
        EColliderCapable[EColliderCapable["Collider_FrictionCombine"] = 8] = "Collider_FrictionCombine";
        EColliderCapable[EColliderCapable["Collider_EventFilter"] = 9] = "Collider_EventFilter";
        EColliderCapable[EColliderCapable["Collider_CollisionDetectionMode"] = 10] = "Collider_CollisionDetectionMode";
        EColliderCapable[EColliderCapable["RigidBody_CanKinematic"] = 11] = "RigidBody_CanKinematic";
        EColliderCapable[EColliderCapable["RigidBody_AllowSleep"] = 12] = "RigidBody_AllowSleep";
        EColliderCapable[EColliderCapable["RigidBody_Gravity"] = 13] = "RigidBody_Gravity";
        EColliderCapable[EColliderCapable["RigidBody_LinearDamp"] = 14] = "RigidBody_LinearDamp";
        EColliderCapable[EColliderCapable["RigidBody_AngularDamp"] = 15] = "RigidBody_AngularDamp";
        EColliderCapable[EColliderCapable["RigidBody_LinearVelocity"] = 16] = "RigidBody_LinearVelocity";
        EColliderCapable[EColliderCapable["RigidBody_AngularVelocity"] = 17] = "RigidBody_AngularVelocity";
        EColliderCapable[EColliderCapable["RigidBody_Mass"] = 18] = "RigidBody_Mass";
        EColliderCapable[EColliderCapable["RigidBody_WorldPosition"] = 19] = "RigidBody_WorldPosition";
        EColliderCapable[EColliderCapable["RigidBody_WorldOrientation"] = 20] = "RigidBody_WorldOrientation";
        EColliderCapable[EColliderCapable["RigidBody_InertiaTensor"] = 21] = "RigidBody_InertiaTensor";
        EColliderCapable[EColliderCapable["RigidBody_MassCenter"] = 22] = "RigidBody_MassCenter";
        EColliderCapable[EColliderCapable["RigidBody_MaxAngularVelocity"] = 23] = "RigidBody_MaxAngularVelocity";
        EColliderCapable[EColliderCapable["RigidBody_MaxDepenetrationVelocity"] = 24] = "RigidBody_MaxDepenetrationVelocity";
        EColliderCapable[EColliderCapable["RigidBody_SleepThreshold"] = 25] = "RigidBody_SleepThreshold";
        EColliderCapable[EColliderCapable["RigidBody_SleepAngularVelocity"] = 26] = "RigidBody_SleepAngularVelocity";
        EColliderCapable[EColliderCapable["RigidBody_SolverIterations"] = 27] = "RigidBody_SolverIterations";
        EColliderCapable[EColliderCapable["RigidBody_AllowDetectionMode"] = 28] = "RigidBody_AllowDetectionMode";
        EColliderCapable[EColliderCapable["RigidBody_AllowKinematic"] = 29] = "RigidBody_AllowKinematic";
        EColliderCapable[EColliderCapable["RigidBody_AllowCharacter"] = 30] = "RigidBody_AllowCharacter";
        EColliderCapable[EColliderCapable["RigidBody_LinearFactor"] = 31] = "RigidBody_LinearFactor";
        EColliderCapable[EColliderCapable["RigidBody_AngularFactor"] = 32] = "RigidBody_AngularFactor";
        EColliderCapable[EColliderCapable["RigidBody_ApplyForce"] = 33] = "RigidBody_ApplyForce";
        EColliderCapable[EColliderCapable["RigidBody_ClearForce"] = 34] = "RigidBody_ClearForce";
        EColliderCapable[EColliderCapable["RigidBody_ApplyForceWithOffset"] = 35] = "RigidBody_ApplyForceWithOffset";
        EColliderCapable[EColliderCapable["RigidBody_ApplyTorque"] = 36] = "RigidBody_ApplyTorque";
        EColliderCapable[EColliderCapable["RigidBody_ApplyImpulse"] = 37] = "RigidBody_ApplyImpulse";
        EColliderCapable[EColliderCapable["RigidBody_ApplyTorqueImpulse"] = 38] = "RigidBody_ApplyTorqueImpulse";
    })(exports.EColliderCapable || (exports.EColliderCapable = {}));

    exports.EJointCapable = void 0;
    (function (EJointCapable) {
        EJointCapable[EJointCapable["Joint_Anchor"] = 0] = "Joint_Anchor";
        EJointCapable[EJointCapable["Joint_ConnectAnchor"] = 1] = "Joint_ConnectAnchor";
    })(exports.EJointCapable || (exports.EJointCapable = {}));

    class DrawNodeCMDData {
        get node() {
            return this._node;
        }
        set node(value) {
            this._node = value;
        }
        get destShaderData() {
            return this._destShaderData;
        }
        set destShaderData(value) {
            this._destShaderData = value;
        }
        get destSubShader() {
            return this._destSubShader;
        }
        set destSubShader(value) {
            this._destSubShader = value;
        }
        get subMeshIndex() {
            return this._subMeshIndex;
        }
        set subMeshIndex(value) {
            this._subMeshIndex = value;
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }
    class BlitQuadCMDData {
        get element() {
            return this._element;
        }
        set element(value) {
            this._element = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        get viewport() {
            return this._viewport;
        }
        set viewport(value) {
            this._viewport = value;
        }
        get scissor() {
            return this._scissor;
        }
        set scissor(value) {
            this._scissor = value;
        }
        get source() {
            return this._source;
        }
        set source(value) {
            this._source = value;
        }
        get offsetScale() {
            return this._offsetScale;
        }
        set offsetScale(value) {
            this._offsetScale = value;
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }
    class DrawElementCMDData {
        setRenderelements(value) {
            throw new Laya.NotImplementedError();
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }
    class SetViewportCMD {
        get viewport() {
            return this._viewport;
        }
        set viewport(value) {
            this._viewport = value;
        }
        get scissor() {
            return this._scissor;
        }
        set scissor(value) {
            this._scissor = value;
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }
    class SetRenderTargetCMD {
        get rt() {
            return this._rt;
        }
        set rt(value) {
            this._rt = value;
        }
        get clearFlag() {
            return this._clearFlag;
        }
        set clearFlag(value) {
            this._clearFlag = value;
        }
        get clearDepthValue() {
            return this._clearDepthValue;
        }
        set clearDepthValue(value) {
            this._clearDepthValue = value;
        }
        get clearStencilValue() {
            return this._clearStencilValue;
        }
        set clearStencilValue(value) {
            this._clearStencilValue = value;
        }
        get clearColorValue() {
            return this._clearColorValue;
        }
        set clearColorValue(value) {
            this._clearColorValue = value;
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }

    class IndexBuffer3D {
        get indexType() {
            return this._indexType;
        }
        get indexTypeByteCount() {
            return this._indexTypeByteCount;
        }
        get indexCount() {
            return this._indexCount;
        }
        get canRead() {
            return this._canRead;
        }
        constructor(indexType, indexCount, bufferUsage = Laya.BufferUsage.Static, canRead = false) {
            this._indexType = Laya.IndexFormat.UInt16;
            this._deviceBuffer = Laya.LayaGL.renderDeviceFactory.createIndexBuffer(bufferUsage);
            this._deviceBuffer.indexType = this._indexType = indexType;
            this._deviceBuffer.indexCount = this._indexCount = indexCount;
            this._canRead = canRead;
            this.bufferUsage = bufferUsage;
            switch (indexType) {
                case Laya.IndexFormat.UInt32:
                    this._indexTypeByteCount = 4;
                    break;
                case Laya.IndexFormat.UInt16:
                    this._indexTypeByteCount = 2;
                    break;
                case Laya.IndexFormat.UInt8:
                    this._indexTypeByteCount = 1;
                    break;
                default:
                    throw new Error("unknown index type: " + indexType);
            }
            var byteLength = this._indexTypeByteCount * indexCount;
            this._byteLength = byteLength;
            this._deviceBuffer._setIndexDataLength(byteLength);
            if (canRead) {
                switch (indexType) {
                    case Laya.IndexFormat.UInt32:
                        this._buffer = new Uint32Array(indexCount);
                        break;
                    case Laya.IndexFormat.UInt16:
                        this._buffer = new Uint16Array(indexCount);
                        break;
                    case Laya.IndexFormat.UInt8:
                        this._buffer = new Uint8Array(indexCount);
                        break;
                }
            }
        }
        setData(data, bufferOffset = 0, dataStartIndex = 0, dataCount = 4294967295) {
            var byteCount = this._indexTypeByteCount;
            if (dataStartIndex !== 0 || dataCount !== 4294967295) {
                switch (this._indexType) {
                    case Laya.IndexFormat.UInt32:
                        data = new Uint32Array(data.buffer, dataStartIndex * byteCount, dataCount);
                        break;
                    case Laya.IndexFormat.UInt16:
                        data = new Uint16Array(data.buffer, dataStartIndex * byteCount, dataCount);
                        break;
                    case Laya.IndexFormat.UInt8:
                        data = new Uint8Array(data.buffer, dataStartIndex * byteCount, dataCount);
                        break;
                }
            }
            this._deviceBuffer._setIndexData(data, bufferOffset * byteCount);
            if (this._canRead) {
                if (bufferOffset !== 0 || dataStartIndex !== 0 || dataCount !== 4294967295) {
                    var maxLength = this._buffer.length - bufferOffset;
                    if (dataCount > maxLength)
                        dataCount = maxLength;
                    if (typeof data == typeof this._buffer && data.length == dataCount)
                        this._buffer.set(data, bufferOffset);
                    else
                        for (var i = 0; i < dataCount; i++)
                            this._buffer[bufferOffset + i] = data[i];
                }
                else {
                    this._buffer = data;
                }
            }
        }
        getData() {
            if (this._canRead)
                return this._buffer;
            else
                throw new Laya.NotReadableError();
        }
        destroy() {
            this._deviceBuffer.destroy();
            this._buffer = null;
            this._byteLength = 0;
            this._indexCount = 0;
        }
    }

    class VertexBuffer3D {
        get vertexDeclaration() {
            return this._deviceBuffer.vertexDeclaration;
        }
        set vertexDeclaration(value) {
            this._deviceBuffer.vertexDeclaration = value;
        }
        get instanceBuffer() {
            return this._deviceBuffer.instanceBuffer;
        }
        set instanceBuffer(value) {
            this._deviceBuffer.instanceBuffer = value;
        }
        get canRead() {
            return this._canRead;
        }
        constructor(byteLength, bufferUsage, canRead = false) {
            this._float32Reader = null;
            this._deviceBuffer = Laya.LayaGL.renderDeviceFactory.createVertexBuffer(bufferUsage);
            this._canRead = canRead;
            this._byteLength = byteLength;
            this._deviceBuffer.setDataLength(byteLength);
            this.bufferUsage = bufferUsage;
            if (this._canRead) {
                this._buffer = new Uint8Array(byteLength);
                this._float32Reader = new Float32Array(this._buffer.buffer);
            }
        }
        setData(buffer, bufferOffset = 0, dataStartIndex = 0, dataCount = Number.MAX_SAFE_INTEGER) {
            this._deviceBuffer.setData(buffer, bufferOffset, dataStartIndex, dataCount);
            var needSubData = dataStartIndex !== 0 || dataCount !== Number.MAX_SAFE_INTEGER;
            if (needSubData) {
                var subData = new Uint8Array(buffer, dataStartIndex, dataCount);
                if (this._canRead)
                    this._buffer.set(subData, bufferOffset);
            }
            else {
                if (this._canRead)
                    this._buffer.set(new Uint8Array(buffer), bufferOffset);
            }
        }
        getUint8Data() {
            if (this._canRead)
                return this._buffer;
            else
                throw new Laya.NotReadableError();
        }
        getFloat32Data() {
            if (this._canRead)
                return this._float32Reader;
            else
                throw new Laya.NotReadableError();
        }
        markAsUnreadbale() {
            this._canRead = false;
            this._buffer = null;
            this._float32Reader = null;
        }
        destroy() {
            this._deviceBuffer.destroy();
            this._buffer = null;
            this._float32Reader = null;
            this._byteLength = 0;
        }
    }

    class LengencyRenderEngine3DFactory {
        createVertexBuffer3D(byteLength, bufferUsage, canRead = false) {
            return new VertexBuffer3D(byteLength, bufferUsage, canRead);
        }
        createIndexBuffer3D(indexType, indexCount, bufferUsage = Laya.BufferUsage.Static, canRead = false) {
            return new IndexBuffer3D(indexType, indexCount, bufferUsage, canRead);
        }
    }
    Laya.Laya.addBeforeInitCallback(() => {
        if (!Laya3DRender.renderOBJCreate)
            Laya3DRender.renderOBJCreate = new LengencyRenderEngine3DFactory();
    });

    class CommandUniformMap {
        constructor(stateName) {
        }
        addShaderUniform(propertyID, propertyKey, uniformtype) {
            throw "need override it";
        }
        addShaderUniformArray(propertyID, propertyName, uniformtype, arrayLength) {
            throw "need override it";
        }
    }

    exports.RenderCMDType = void 0;
    (function (RenderCMDType) {
        RenderCMDType[RenderCMDType["DrawNode"] = 0] = "DrawNode";
        RenderCMDType[RenderCMDType["DrawElement"] = 1] = "DrawElement";
        RenderCMDType[RenderCMDType["Blit"] = 2] = "Blit";
        RenderCMDType[RenderCMDType["ChangeData"] = 3] = "ChangeData";
        RenderCMDType[RenderCMDType["ChangeShaderDefine"] = 4] = "ChangeShaderDefine";
        RenderCMDType[RenderCMDType["ChangeViewPort"] = 5] = "ChangeViewPort";
        RenderCMDType[RenderCMDType["ChangeRenderTarget"] = 6] = "ChangeRenderTarget";
    })(exports.RenderCMDType || (exports.RenderCMDType = {}));
    class SetRenderDataCMD {
        get value() {
            return this._value;
        }
        set value(value) {
            this._value = value;
        }
        get dataType() {
            return this._dataType;
        }
        set dataType(value) {
            this._dataType = value;
        }
        get propertyID() {
            return this._propertyID;
        }
        set propertyID(value) {
            this._propertyID = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }
    class SetShaderDefineCMD {
        get define() {
            return this._define;
        }
        set define(value) {
            this._define = value;
        }
        get dest() {
            return this._dest;
        }
        set dest(value) {
            this._dest = value;
        }
        get add() {
            return this._add;
        }
        set add(value) {
            this._add = value;
        }
        apply(context) {
            throw new Laya.NotImplementedError();
        }
    }

    class UniformBufferBlock {
        constructor(cluster, index, size, alignedSize, user) {
            this._destroyed = false;
            this._id = UniformBufferBlock._idCounter++;
            this.cluster = cluster;
            this.index = index;
            this.size = size;
            this._alignedSize = alignedSize;
            this.offset = alignedSize * index;
            this.user = user;
            this.uploadNum = 0;
            this.moved = false;
        }
        needUpload() {
            this.cluster._addUploadBlock(this.index);
            if (!this.moved && this.uploadNum++ > this.cluster.manager.uploadThreshold)
                this.cluster.manager._addOptimizeBufferPos(this.cluster);
        }
        destroy() {
            if (!this._destroyed) {
                this._destroyed = true;
                this.cluster = null;
                this.user = null;
                return true;
            }
            console.warn('UniformBufferBlock: object alreay destroyed!');
            return false;
        }
    }
    UniformBufferBlock._idCounter = 0;

    class UniformBufferCluster {
        constructor(blockSize, blockNum, manager) {
            this._inManagerUpdateArray = false;
            this._sn = 0;
            this._id = 0;
            this._destroyed = false;
            this._blocks = [];
            this._holeNum = 0;
            this._expand = 16;
            this._id = UniformBufferCluster._idCounter++;
            this.manager = manager;
            this._blockSize = blockSize;
            this._blockNum = blockNum;
            this._totalSize = blockSize * blockNum;
            this._needUpload = new Array(blockNum).fill(false);
            this.data = new ArrayBuffer(this._totalSize);
            this._move = new Uint8Array(this._blockSize);
            this.buffer = this.manager.createGPUBuffer(this._totalSize);
            this.manager.statisGPUMemory(this._totalSize);
        }
        get usedNum() {
            return this._blocks.length;
        }
        _expandBuffer() {
            let expandNum = this._blockNum;
            this._blockNum += this._expand;
            if (this._blockNum > this.manager.clusterMaxBlock)
                this._blockNum = this.manager.clusterMaxBlock;
            expandNum = this._blockNum - expandNum;
            if (expandNum < 1)
                return false;
            this._totalSize = this._blockSize * this._blockNum;
            const expandSize = this._blockSize * this._expand;
            this._needUpload = this._needUpload.concat(new Array(expandNum).fill(false));
            const newArrayBuffer = new ArrayBuffer(this._totalSize);
            new Uint8Array(newArrayBuffer).set(new Uint8Array(this.data));
            this.data = newArrayBuffer;
            this.buffer = this.manager.createGPUBuffer(this._totalSize);
            this.manager.statisGPUMemory(expandSize);
            this._blocks.forEach(block => block && block.user.notifyGPUBufferChange('expand'));
            return true;
        }
        _moveBlock(index) {
            const len = this._blocks.length;
            if (index >= len)
                return false;
            const dataView = new Uint8Array(this.data);
            const size = this._blockSize;
            for (let i = index + 1; i < len; i++) {
                const start = i * size;
                const end = start + size;
                const target = start - size;
                dataView.copyWithin(target, start, end);
                this._needUpload[i - 1] = this._needUpload[i];
                this._blocks[i - 1] = this._blocks[i];
                if (this._blocks[i - 1]) {
                    this._blocks[i - 1].index--;
                    this._blocks[i - 1].offset -= size;
                    this._blocks[i - 1].user.notifyGPUBufferChange('moveBlock');
                }
            }
            this._blocks.length--;
            return true;
        }
        _createBufferBlock(index, size, alignedSize, user) {
            return new UniformBufferBlock(this, index, size, alignedSize, user);
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.manager.byteAlign);
            if (alignedSize !== this._blockSize) {
                console.warn('WebGPUBufferCluster: 获取内存块时, 长度错误!');
                return null;
            }
            const index = this._getBlockWithExpand();
            const bb = this._createBufferBlock(index, size, alignedSize, user);
            this._blocks[index] = bb;
            return bb;
        }
        freeBlock(bb) {
            const index = this._blocks.indexOf(bb);
            if (index !== -1) {
                if (index === this._blocks.length - 1)
                    this._blocks.length--;
                else {
                    this._blocks[index] = null;
                    this._holeNum++;
                }
                bb.destroy();
                if (this._holeNum > this.manager.removeHoleThreshold) {
                    this.manager._addRemoveHoleCluster(this);
                    this._holeNum = 0;
                }
                return true;
            }
            return false;
        }
        upload() {
            var _a;
            let count = 0;
            let bytes = 0;
            let next = false;
            let startIndex = -1;
            let endIndex = -1;
            let offset = 0;
            let size = 0;
            for (let i = 0, len = this._blocks.length; i < len; i++) {
                if (this._needUpload[i]) {
                    if (startIndex === -1)
                        startIndex = i;
                    endIndex = i;
                    next = true;
                    this._needUpload[i] = false;
                    (_a = this._blocks[i]) === null || _a === void 0 ? void 0 : _a.user.updateOver();
                }
                else {
                    if (next) {
                        offset = startIndex * this._blockSize;
                        size = (endIndex - startIndex + 1) * this._blockSize;
                        this.manager.writeBuffer(this.buffer, this.data, offset, size);
                        count++;
                        bytes += size;
                        startIndex = -1;
                        endIndex = -1;
                        next = false;
                    }
                }
            }
            if (next) {
                offset = startIndex * this._blockSize;
                size = (endIndex - startIndex + 1) * this._blockSize;
                this.manager.writeBuffer(this.buffer, this.data, offset, size);
                count++;
                bytes += size;
            }
            this.manager.statisUpload(count, bytes);
        }
        _addUploadBlock(index) {
            this._needUpload[index] = true;
            if (!this._inManagerUpdateArray)
                this.manager._addUpdateArray(this);
        }
        optimize() {
            let ret = false;
            for (let i = 0, len = this._blocks.length; i < len; i++) {
                const bb = this._blocks[i];
                if (bb && !bb.moved && bb.uploadNum > this.manager.uploadThreshold && i > 0) {
                    const size = this._blockSize;
                    const dataView = new Uint8Array(this.data);
                    this._move.set(new Uint8Array(this.data, size * i, size));
                    for (let j = i - 1; j >= 0; j--) {
                        const start = j * size;
                        const end = start + size;
                        const target = start + size;
                        dataView.copyWithin(target, start, end);
                        this._needUpload[j + 1] = this._needUpload[j];
                        this._blocks[j + 1] = this._blocks[j];
                        if (this._blocks[j + 1]) {
                            this._blocks[j + 1].index++;
                            this._blocks[j + 1].offset += size;
                            this._blocks[j + 1].user.notifyGPUBufferChange('optimize');
                        }
                    }
                    dataView.set(this._move);
                    bb.index = 0;
                    bb.offset = 0;
                    bb.moved = true;
                    this._blocks[0] = bb;
                    this._blocks[0].user.notifyGPUBufferChange('optimize');
                    ret = true;
                    if (this.manager._enableStat)
                        this.manager._stat.moveNum++;
                }
            }
            return ret;
        }
        removeHole() {
            let ret = false;
            for (let i = this._blocks.length - 1; i > -1; i--) {
                if (!this._blocks[i]) {
                    if (this._moveBlock(i)) {
                        ret = true;
                        if (this.manager._enableStat)
                            this.manager._stat.moveNum++;
                    }
                }
            }
            this._holeNum = 0;
            return ret;
        }
        clear(blockNum) {
            this._blocks.forEach(block => block && block.destroy());
            this._blocks.length = 0;
            if (blockNum != undefined && blockNum > 0 && blockNum !== this._blockNum) {
                this._blockNum = blockNum;
                this._totalSize = this._blockSize * this._blockNum;
                this.buffer = this.manager.createGPUBuffer(this._totalSize);
                this.data = new ArrayBuffer(this._totalSize);
            }
            else {
                this._blockNum = 0;
                this._totalSize = 0;
                this.buffer = null;
                this.data = null;
            }
            this._needUpload.length = this._blockNum;
            this._needUpload.fill(false);
        }
        _getBlockWithExpand() {
            for (let i = this._blocks.length - 1; i > -1; i--) {
                if (!this._blocks[i]) {
                    this._holeNum--;
                    return i;
                }
            }
            if (this._blocks.length < this._blockNum)
                return this._blocks.length;
            else {
                this._expandBuffer();
                return this._blocks.length;
            }
        }
        destroy() {
            var _a;
            if (!this._destroyed) {
                this.clear();
                (_a = this.buffer.destroy) !== null && _a !== void 0 ? _a : this.buffer.destroy();
                this.manager.statisGPUMemory(-this._totalSize);
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferCluster: object alreay destroyed!');
            return false;
        }
    }
    UniformBufferCluster._idCounter = 0;

    function roundUp(n, align) {
        return (((n + align - 1) / align) | 0) * align;
    }
    function roundDown(n, align) {
        const res = (((n + align - 1) / align) | 0) * align;
        return res > n ? res - align : res;
    }
    class UBOStat {
        constructor() {
            this.moveNum = 0;
            this.uploadNum = 0;
            this.uploadByte = 0;
            this.timeCostAvg = 0;
            this.timeCostSum = 0;
            this.timeCostCount = 0;
        }
    }
    class UniformBufferManager {
        constructor(useBigBuffer) {
            this._destroyed = false;
            this._needUpdateClusters = [];
            this._removeHoleArray = [];
            this._optimizeBufferPosArray = [];
            this._useBigBuffer = true;
            this.byteAlign = 256;
            this.clusterMaxBlock = 256;
            this.uploadThreshold = 200;
            this.removeHoleThreshold = 10;
            this._enableStat = true;
            this.aloneBuffers = [];
            this._useBigBuffer = useBigBuffer;
            this._clustersAll = new Map();
            this._clustersCur = new Map();
            this._stat = new UBOStat();
        }
        _createBufferCluster(size, blockNum) {
            return new UniformBufferCluster(size, blockNum, this);
        }
        _addCluster(size, blockNum = 16) {
            const alignedSize = roundUp(size, this.byteAlign);
            const cluster = this._createBufferCluster(alignedSize, blockNum);
            const clusters = this._clustersAll.get(alignedSize);
            if (clusters) {
                clusters.push(cluster);
                cluster._sn = clusters.length - 1;
            }
            else
                this._clustersAll.set(alignedSize, [cluster]);
            this._clustersCur.set(alignedSize, cluster);
            return cluster;
        }
        startFrame() { }
        endFrame() {
            if (this._enableStat) {
                this._stat.moveNum = 0;
                this._stat.uploadNum = 0;
                this._stat.uploadByte = 0;
                this._stat.timeCostCount++;
            }
            if (this._useBigBuffer) {
                if (this._removeHoleArray.length > 0) {
                    for (let i = this._removeHoleArray.length - 1; i > -1; i--)
                        this._removeHoleArray[i].removeHole();
                    this._removeHoleArray.length = 0;
                }
                if (this._optimizeBufferPosArray.length > 0) {
                    for (let i = this._optimizeBufferPosArray.length - 1; i > -1; i--)
                        this._optimizeBufferPosArray[i].optimize();
                    this._optimizeBufferPosArray.length = 0;
                }
            }
        }
        getBufferAlone(size, name) {
            const alignedSize = roundUp(size, this.byteAlign);
            this.statisGPUMemory(alignedSize);
            return this.createGPUBuffer(alignedSize, name);
        }
        removeCluster(size, sn) {
            var _a;
            const alignedSize = roundUp(size, this.byteAlign);
            if (sn < 0) {
                this._clustersAll.delete(alignedSize);
                this._clustersCur.delete(alignedSize);
                return;
            }
            const cluster_sn = (_a = this._clustersCur.get(alignedSize)) === null || _a === void 0 ? void 0 : _a._sn;
            const clusters = this._clustersAll.get(alignedSize);
            if (clusters.length > sn) {
                clusters.splice(sn, 1);
                if (clusters.length === 0) {
                    this._clustersAll.delete(alignedSize);
                    this._clustersCur.delete(alignedSize);
                    return;
                }
                else {
                    for (let i = sn; i < clusters.length; i++)
                        clusters[i]._sn--;
                }
            }
            else
                return;
            if (cluster_sn !== undefined
                && cluster_sn === sn) {
                let usedNumMax = -1, usedNum = -1, index = -1;
                for (let i = clusters.length - 1; i > -1; i--) {
                    usedNum = clusters[i].usedNum;
                    if (usedNum > usedNumMax
                        && usedNum < this.clusterMaxBlock) {
                        index = i;
                        usedNumMax = usedNum;
                    }
                }
                if (index >= 0)
                    this._clustersCur.set(alignedSize, clusters[index]);
                else
                    this._clustersCur.delete(alignedSize);
            }
        }
        getBlock(size, user) {
            const alignedSize = roundUp(size, this.byteAlign);
            let cluster = this._clustersCur.get(alignedSize);
            if (!cluster)
                return this._addCluster(alignedSize).getBlock(size, user);
            if (cluster.usedNum < this.clusterMaxBlock)
                return cluster.getBlock(size, user);
            cluster = null;
            const clusters = this._clustersAll.get(alignedSize);
            let usedNumMax = -1, usedNum = -1, index = -1;
            for (let i = clusters.length - 1; i > 0; i--) {
                usedNum = clusters[i].usedNum;
                if (usedNum > usedNumMax
                    && usedNum < this.clusterMaxBlock) {
                    index = i;
                    usedNumMax = usedNum;
                }
            }
            if (index >= 0) {
                cluster = clusters[index];
                this._clustersCur.set(alignedSize, cluster);
            }
            else
                this._clustersCur.delete(alignedSize);
            if (cluster)
                return cluster.getBlock(size, user);
            return this._addCluster(alignedSize).getBlock(size, user);
        }
        freeBlock(bb) {
            const cluster = bb.cluster;
            if (cluster) {
                if (cluster.freeBlock(bb)) {
                    if (cluster.usedNum === 0)
                        this.removeCluster(cluster._blockSize, cluster._sn);
                    return true;
                }
                return false;
            }
            return false;
        }
        upload() {
            if (this._useBigBuffer) {
                let t;
                if (this._enableStat)
                    t = performance.now();
                let cluster;
                for (let i = this._needUpdateClusters.length - 1; i > -1; i--) {
                    cluster = this._needUpdateClusters[i];
                    cluster.upload();
                    cluster._inManagerUpdateArray = false;
                }
                this._needUpdateClusters.length = 0;
                if (this._enableStat)
                    this.statisTimeCostAvg(performance.now() - t);
            }
        }
        _addUpdateArray(cluster) {
            if (!cluster._inManagerUpdateArray) {
                this._needUpdateClusters.push(cluster);
                cluster._inManagerUpdateArray = true;
            }
        }
        _addRemoveHoleCluster(cluster) {
            if (this._removeHoleArray.indexOf(cluster) === -1)
                this._removeHoleArray.push(cluster);
        }
        _addOptimizeBufferPos(cluster) {
            if (this._optimizeBufferPosArray.indexOf(cluster) === -1)
                this._optimizeBufferPosArray.push(cluster);
        }
        clear() {
            this._clustersAll.forEach(clusters => {
                for (let i = clusters.length - 1; i > -1; i--)
                    clusters[i].clear();
            });
        }
        destroy() {
            if (!this._destroyed) {
                this.clear();
                this._clustersAll.clear();
                this._clustersCur.clear();
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferManager: object alreay destroyed!');
            return false;
        }
        createGPUBuffer(size, name) {
        }
        writeBuffer(buffer, data, offset, size) {
        }
        statisGPUMemory(bytes) {
        }
        statisTimeCostAvg(time) {
            this._stat.timeCostSum += time;
            if (this._stat.timeCostCount > 100) {
                this._stat.timeCostAvg = ((this._stat.timeCostSum / this._stat.timeCostCount) * 10000 | 0) / 10;
                this._stat.timeCostSum = 0;
                this._stat.timeCostCount = 0;
            }
        }
        statisUpload(count, bytes) {
            this._stat.uploadNum += count;
            this._stat.uploadByte += bytes;
        }
    }

    class UniformBufferAlone {
        constructor(size, manager, user) {
            this._destroyed = false;
            this.uploadNum = 0;
            this.data = new ArrayBuffer(size);
            this.buffer = manager.getBufferAlone(size);
            this._manager = manager;
            this._size = size;
            this._alignedSize = roundUp(size, manager.byteAlign);
            this.user = user;
            manager.aloneBuffers.push(this);
        }
        upload() {
            let t;
            if (this._manager._enableStat)
                t = performance.now();
            this.uploadNum++;
            this._manager.writeBuffer(this.buffer, this.data, 0, this._size);
            if (this._manager._enableStat) {
                this._manager.statisUpload(1, this._size);
                this._manager.statisTimeCostAvg(performance.now() - t);
            }
        }
        destroy() {
            if (!this._destroyed) {
                this.data = null;
                if (this.buffer.destroy)
                    this.buffer.destroy();
                this._manager.statisGPUMemory(-this._size);
                this._manager.aloneBuffers.splice(this._manager.aloneBuffers.indexOf(this), 1);
                this._destroyed = true;
                return true;
            }
            console.warn('UniformBufferAlone: object alreay destroyed!');
            return false;
        }
    }

    class UniformBufferUser {
        constructor(name, size, manager, data) {
            this.destroyed = false;
            this.name = name;
            this._strId = '';
            this._items = new Map();
            this._itemNum = 0;
            this.data = data;
            this._size = size;
            this.manager = manager;
            this.needUpload = false;
            if (manager._useBigBuffer) {
                this.bufferBlock = manager.getBlock(size, this);
                this.offset = this.bufferBlock.offset;
            }
            else
                this.bufferAlone = this._createBufferAlone(size, manager);
        }
        _createBufferAlone(size, manager) {
            return new UniformBufferAlone(size, manager, this);
        }
        updateOver() {
            this.needUpload = false;
        }
        notifyGPUBufferChange() {
            const offset = this.bufferBlock.offset - this.offset;
            this.offset = this.bufferBlock.offset;
            this._items.forEach(item => {
                const tac = UniformBufferUser._typeArray(item.type);
                item.view = new tac(this.bufferBlock.cluster.data, item.view.byteOffset + offset, item.size / tac.BYTES_PER_ELEMENT);
            });
            this.clearGPUBufferBind();
            this.needUpload = true;
        }
        clearGPUBufferBind() { }
        addUniform(id, name, type, offset, align, size, elements, count) {
            if (this._items.has(id))
                return;
            this._items.set(id, this._getUniformItem(name, UniformBufferUser._typeArray(type), type, offset, align, size, elements, count));
            if (this._strId.length > 0)
                this._strId += '|';
            this._strId += id;
            this._itemNum++;
        }
        setUniformData(id, data) {
            const item = this._items.get(id);
            if (item) {
                this.needUpload = true;
                if (item.count == 1) {
                    switch (item.type) {
                        case 'int':
                        case 'float':
                            item.view[0] = data;
                            break;
                        case 'vec2':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            break;
                        case 'vec3':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            break;
                        case 'vec4':
                            item.view[0] = data.x;
                            item.view[1] = data.y;
                            item.view[2] = data.z;
                            item.view[3] = data.w;
                            break;
                        case 'mat3':
                            for (let i = 0; i < 3; i++) {
                                item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                                item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                                item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                            }
                            break;
                        case 'mat4':
                            item.view.set(data.elements);
                            break;
                    }
                }
                else {
                    const arraySize = item.count * item.elements;
                    const alignElements = item.size / item.count / item.view.BYTES_PER_ELEMENT;
                    for (let i = 0, j = 0; i < arraySize; i += item.elements, j += alignElements)
                        item.view.set(data.subarray(i, i + item.elements), j);
                }
            }
        }
        setBool(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data ? 1 : 0;
                this.needUpload = true;
            }
        }
        setBoolArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i] ? 1 : 0;
                this.needUpload = true;
            }
        }
        setInt(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setIntArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setFloat(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data;
                this.needUpload = true;
            }
        }
        setFloatArray(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view[i] = data[i];
                this.needUpload = true;
            }
        }
        setVector2(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                this.needUpload = true;
            }
        }
        setVector2Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 2 + 0] = data[i].x;
                    item.view[i * 2 + 1] = data[i].y;
                }
                this.needUpload = true;
            }
        }
        setVector3(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                this.needUpload = true;
            }
        }
        setVector3Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                }
                this.needUpload = true;
            }
        }
        setVector4(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view[0] = data.x;
                item.view[1] = data.y;
                item.view[2] = data.z;
                item.view[3] = data.w;
                this.needUpload = true;
            }
        }
        setVector4Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++) {
                    item.view[i * 4 + 0] = data[i].x;
                    item.view[i * 4 + 1] = data[i].y;
                    item.view[i * 4 + 2] = data[i].z;
                    item.view[i * 4 + 3] = data[i].w;
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0; i < 3; i++) {
                    item.view[i * 4 + 0] = data.elements[i * 3 + 0];
                    item.view[i * 4 + 1] = data.elements[i * 3 + 1];
                    item.view[i * 4 + 2] = data.elements[i * 3 + 2];
                }
                this.needUpload = true;
            }
        }
        setMatrix3x3Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let j = 0, len = Math.min(item.count, data.length); j < len; j++) {
                    for (let i = 0; i < 3; i++) {
                        item.view[j * 16 + i * 4 + 0] = data[j].elements[i * 3 + 0];
                        item.view[j * 16 + i * 4 + 1] = data[j].elements[i * 3 + 1];
                        item.view[j * 16 + i * 4 + 2] = data[j].elements[i * 3 + 2];
                    }
                }
                this.needUpload = true;
            }
        }
        setMatrix4x4(id, data) {
            const item = this._items.get(id);
            if (item) {
                item.view.set(data.elements);
                this.needUpload = true;
            }
        }
        setMatrix4x4Array(id, data) {
            const item = this._items.get(id);
            if (item) {
                for (let i = 0, len = Math.min(item.count, data.length); i < len; i++)
                    item.view.set(data[i].elements, i * 16);
                this.needUpload = true;
            }
        }
        setBuffer(id, data) {
            this.setUniformData(id, data);
        }
        getUniform(id) {
            return this._items.get(id);
        }
        hasUniform(id) {
            return this._items.has(id);
        }
        isMe(strId) {
            return this._strId === strId;
        }
        upload() {
            if (this.needUpload) {
                if (this.manager._useBigBuffer)
                    this.bufferBlock.needUpload();
                else
                    this.bufferAlone.upload();
                this.needUpload = false;
            }
        }
        clear() {
            if (this.manager._useBigBuffer)
                new Uint8Array(this.bufferBlock.cluster.data).fill(0, this.bufferBlock.offset, this.bufferBlock.offset + this.bufferBlock.size);
            else
                new Uint8Array(this.bufferAlone.data).fill(0);
            this._strId = '';
            this._items.clear();
            this._itemNum = 0;
            this.needUpload = false;
        }
        destroy() {
            if (!this.destroyed) {
                if (this.manager._useBigBuffer)
                    this.manager.freeBlock(this.bufferBlock);
                else
                    this.bufferAlone.destroy();
                this.destroyed = true;
                return true;
            }
            console.warn('UniformBufferUser: object alreay destroyed!');
            return false;
        }
        _getUniformItem(name, tac, type, offset, align, size, elements, count) {
            let view;
            if (this.manager._useBigBuffer)
                view = new tac(this.bufferBlock.cluster.data, this.bufferBlock.offset + offset, size / tac.BYTES_PER_ELEMENT);
            else
                view = new tac(this.bufferAlone.data, offset, size / tac.BYTES_PER_ELEMENT);
            return { name, view, type, align, size, elements, count };
        }
        static _typeArray(type) {
            switch (type) {
                case 'int':
                    return Int32Array;
                case 'float':
                case 'vec2':
                case 'vec3':
                case 'vec4':
                case 'mat3':
                case 'mat4':
                    return Float32Array;
                default:
                    return Float32Array;
            }
        }
    }

    class ShaderDefine {
        constructor(index, value) {
            this._index = index;
            this._value = value;
        }
    }

    class KeyframeNode {
        constructor() {
            this._ownerPath = [];
            this._propertys = [];
            this._keyFrames = [];
        }
        get ownerPathCount() {
            return this._ownerPath.length;
        }
        get propertyCount() {
            return this._propertys.length;
        }
        get keyFramesCount() {
            return this._keyFrames.length;
        }
        _setOwnerPathCount(value) {
            this._ownerPath.length = value;
        }
        _setOwnerPathByIndex(index, value) {
            this._ownerPath[index] = value;
        }
        _joinOwnerPath(sep) {
            return this._ownerPath.join(sep);
        }
        _setPropertyCount(value) {
            this._propertys.length = value;
        }
        _setPropertyByIndex(index, value) {
            this._propertys[index] = value;
        }
        _joinProperty(sep) {
            return this._propertys.join(sep);
        }
        _setKeyframeCount(value) {
            this._keyFrames.length = value;
        }
        _setKeyframeByIndex(index, value) {
            this._keyFrames[index] = value;
        }
        getOwnerPathByIndex(index) {
            return this._ownerPath[index];
        }
        getPropertyByIndex(index) {
            return this._propertys[index];
        }
        getKeyframeByIndex(index) {
            return this._keyFrames[index];
        }
    }

    class AnimationEvent {
        constructor() {
        }
    }

    class AnimationClipParser03 {
        static READ_DATA() {
            AnimationClipParser03._DATA.offset = AnimationClipParser03._reader.getUint32();
            AnimationClipParser03._DATA.size = AnimationClipParser03._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = AnimationClipParser03._BLOCK.count = AnimationClipParser03._reader.getUint16();
            var blockStarts = AnimationClipParser03._BLOCK.blockStarts = [];
            var blockLengths = AnimationClipParser03._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(AnimationClipParser03._reader.getUint32());
                blockLengths.push(AnimationClipParser03._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = AnimationClipParser03._reader.getUint32();
            var count = AnimationClipParser03._reader.getUint16();
            var prePos = AnimationClipParser03._reader.pos;
            AnimationClipParser03._reader.pos = offset + AnimationClipParser03._DATA.offset;
            for (var i = 0; i < count; i++)
                AnimationClipParser03._strings[i] = AnimationClipParser03._reader.readUTFString();
            AnimationClipParser03._reader.pos = prePos;
        }
        static parse(clip, reader) {
            AnimationClipParser03._animationClip = clip;
            AnimationClipParser03._reader = reader;
            AnimationClipParser03.READ_DATA();
            AnimationClipParser03.READ_BLOCK();
            AnimationClipParser03.READ_STRINGS();
            for (var i = 0, n = AnimationClipParser03._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = AnimationClipParser03._strings[index];
                var fn = AnimationClipParser03["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
        }
        static READ_ANIMATIONS() {
            var i, j;
            var node;
            var reader = AnimationClipParser03._reader;
            var startTimeTypes = [];
            var startTimeTypeCount = reader.getUint16();
            startTimeTypes.length = startTimeTypeCount;
            for (i = 0; i < startTimeTypeCount; i++)
                startTimeTypes[i] = reader.getFloat32();
            var clip = AnimationClipParser03._animationClip;
            clip.name = AnimationClipParser03._strings[reader.getUint16()];
            var clipDur = clip._duration = reader.getFloat32();
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode();
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var type = node.type = reader.getUint8();
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++)
                    node._setOwnerPathByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                node.propertyOwner = AnimationClipParser03._strings[reader.getUint16()];
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++)
                    node._setPropertyByIndex(j, AnimationClipParser03._strings[reader.getUint16()]);
                var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                var keyframeCount = reader.getUint16();
                node._setKeyframeCount(keyframeCount);
                for (j = 0; j < keyframeCount; j++) {
                    switch (type) {
                        case 0:
                            var floatKeyframe = new Laya.FloatKeyframe();
                            node._setKeyframeByIndex(j, floatKeyframe);
                            floatKeyframe.time = startTimeTypes[reader.getUint16()];
                            floatKeyframe.inTangent = reader.getFloat32();
                            floatKeyframe.outTangent = reader.getFloat32();
                            floatKeyframe.value = reader.getFloat32();
                            break;
                        case 1:
                        case 3:
                        case 4:
                            var floatArrayKeyframe = new Laya.Vector3Keyframe();
                            node._setKeyframeByIndex(j, floatArrayKeyframe);
                            floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                            var inTangent = floatArrayKeyframe.inTangent;
                            var outTangent = floatArrayKeyframe.outTangent;
                            var value = floatArrayKeyframe.value;
                            inTangent.x = reader.getFloat32();
                            inTangent.y = reader.getFloat32();
                            inTangent.z = reader.getFloat32();
                            outTangent.x = reader.getFloat32();
                            outTangent.y = reader.getFloat32();
                            outTangent.z = reader.getFloat32();
                            value.x = reader.getFloat32();
                            value.y = reader.getFloat32();
                            value.z = reader.getFloat32();
                            break;
                        case 2:
                            var quaArrayKeyframe = new Laya.QuaternionKeyframe();
                            node._setKeyframeByIndex(j, quaArrayKeyframe);
                            quaArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                            var inTangentQua = quaArrayKeyframe.inTangent;
                            var outTangentQua = quaArrayKeyframe.outTangent;
                            var valueQua = quaArrayKeyframe.value;
                            inTangentQua.x = reader.getFloat32();
                            inTangentQua.y = reader.getFloat32();
                            inTangentQua.z = reader.getFloat32();
                            inTangentQua.w = reader.getFloat32();
                            outTangentQua.x = reader.getFloat32();
                            outTangentQua.y = reader.getFloat32();
                            outTangentQua.z = reader.getFloat32();
                            outTangentQua.w = reader.getFloat32();
                            valueQua.x = reader.getFloat32();
                            valueQua.y = reader.getFloat32();
                            valueQua.z = reader.getFloat32();
                            valueQua.w = reader.getFloat32();
                            break;
                        default:
                            throw new Error("AnimationClipParser03:unknown type.");
                    }
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new AnimationEvent();
                event.time = Math.min(clipDur, reader.getFloat32());
                event.eventName = AnimationClipParser03._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(reader.getFloat32());
                            break;
                        case 3:
                            params.push(AnimationClipParser03._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClipParser03._strings = [];
    AnimationClipParser03._BLOCK = { count: 0 };
    AnimationClipParser03._DATA = { offset: 0, size: 0 };

    exports.KeyFrameValueType = void 0;
    (function (KeyFrameValueType) {
        KeyFrameValueType[KeyFrameValueType["None"] = -1] = "None";
        KeyFrameValueType[KeyFrameValueType["Float"] = 0] = "Float";
        KeyFrameValueType[KeyFrameValueType["Position"] = 1] = "Position";
        KeyFrameValueType[KeyFrameValueType["Rotation"] = 2] = "Rotation";
        KeyFrameValueType[KeyFrameValueType["Scale"] = 3] = "Scale";
        KeyFrameValueType[KeyFrameValueType["RotationEuler"] = 4] = "RotationEuler";
        KeyFrameValueType[KeyFrameValueType["Vector2"] = 5] = "Vector2";
        KeyFrameValueType[KeyFrameValueType["Vector3"] = 6] = "Vector3";
        KeyFrameValueType[KeyFrameValueType["Vector4"] = 7] = "Vector4";
        KeyFrameValueType[KeyFrameValueType["Color"] = 8] = "Color";
        KeyFrameValueType[KeyFrameValueType["Boolean"] = 9] = "Boolean";
    })(exports.KeyFrameValueType || (exports.KeyFrameValueType = {}));
    class KeyframeNodeOwner {
        constructor() {
            this.indexInList = -1;
            this.referenceCount = 0;
            this.updateMark = -1;
            this.type = -1;
            this.fullPath = null;
            this.nodePath = null;
            this.propertyOwner = null;
            this.property = null;
            this.defaultValue = null;
            this.value = null;
            this.crossFixedValue = null;
            this.isMaterial = false;
        }
        saveCrossFixedValue() {
            var pro = this.propertyOwner;
            if (pro) {
                switch (this.type) {
                    case 0:
                        this.crossFixedValue = this.value;
                        break;
                    case 1:
                    case 3:
                    case 4:
                        this.value.cloneTo(this.crossFixedValue);
                        break;
                    case 2:
                        this.value.cloneTo(this.crossFixedValue);
                        break;
                    default:
                        throw new Error("Animator:unknown type.");
                }
            }
        }
        animatorDataSetCallBack() {
            let fn = this.callBackOwner[this.callbackFun];
            fn.apply(this.callBackOwner, this.callParams);
        }
        getCallbackNode() {
            if (this.propertyOwner && this.callbackFunData) {
                let funPropertys = this.callbackFunData.split(".");
                this.callBackOwner = this.propertyOwner;
                for (let i = 0, n = funPropertys.length - 1; i < n; i++) {
                    this.callBackOwner = this.callBackOwner[funPropertys[i]];
                }
                this.callbackFun = funPropertys[funPropertys.length - 1];
            }
        }
    }

    class AnimationClipParser04 {
        static READ_DATA() {
            AnimationClipParser04._DATA.offset = AnimationClipParser04._reader.getUint32();
            AnimationClipParser04._DATA.size = AnimationClipParser04._reader.getUint32();
        }
        static READ_BLOCK() {
            var count = AnimationClipParser04._BLOCK.count = AnimationClipParser04._reader.getUint16();
            var blockStarts = AnimationClipParser04._BLOCK.blockStarts = [];
            var blockLengths = AnimationClipParser04._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(AnimationClipParser04._reader.getUint32());
                blockLengths.push(AnimationClipParser04._reader.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = AnimationClipParser04._reader.getUint32();
            var count = AnimationClipParser04._reader.getUint16();
            var prePos = AnimationClipParser04._reader.pos;
            AnimationClipParser04._reader.pos = offset + AnimationClipParser04._DATA.offset;
            for (var i = 0; i < count; i++)
                AnimationClipParser04._strings[i] = AnimationClipParser04._reader.readUTFString();
            AnimationClipParser04._reader.pos = prePos;
        }
        static parse(clip, reader, version) {
            AnimationClipParser04._animationClip = clip;
            AnimationClipParser04._reader = reader;
            AnimationClipParser04._version = version;
            AnimationClipParser04.READ_DATA();
            AnimationClipParser04.READ_BLOCK();
            AnimationClipParser04.READ_STRINGS();
            for (var i = 0, n = AnimationClipParser04._BLOCK.count; i < n; i++) {
                var index = reader.getUint16();
                var blockName = AnimationClipParser04._strings[index];
                var fn = AnimationClipParser04["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            AnimationClipParser04._version = null;
            AnimationClipParser04._reader = null;
            AnimationClipParser04._animationClip = null;
        }
        static READ_ANIMATIONS() {
            var i, j;
            var node;
            var reader = AnimationClipParser04._reader;
            var startTimeTypes = [];
            var startTimeTypeCount = reader.getUint16();
            startTimeTypes.length = startTimeTypeCount;
            for (i = 0; i < startTimeTypeCount; i++)
                startTimeTypes[i] = reader.getFloat32();
            var clip = AnimationClipParser04._animationClip;
            clip.name = AnimationClipParser04._strings[reader.getUint16()];
            var clipDur = clip._duration = reader.getFloat32();
            clip.islooping = !!reader.getByte();
            clip._frameRate = reader.getInt16();
            var nodeCount = reader.getInt16();
            var nodes = clip._nodes;
            nodes.count = nodeCount;
            var nodesMap = clip._nodesMap = {};
            var nodesDic = clip._nodesDic = {};
            for (i = 0; i < nodeCount; i++) {
                node = new KeyframeNode();
                if ("LAYAANIMATION:WEIGHT_05" == AnimationClipParser04._version) {
                    if (1 == reader.getByte()) {
                        node.propertyChangePath = AnimationClipParser04._strings[reader.getUint16()];
                    }
                    if (1 == reader.getByte()) {
                        node.callbackFunData = AnimationClipParser04._strings[reader.getUint16()];
                    }
                    let paramLen = reader.getUint8();
                    let callParms = null;
                    for (j = 0; j < paramLen; j++) {
                        if (null == callParms) {
                            callParms = [];
                        }
                        callParms.push(AnimationClipParser04._strings[reader.getUint16()]);
                    }
                    node.callParams = callParms;
                }
                nodes.setNodeByIndex(i, node);
                node._indexInList = i;
                var type = node.type = reader.getUint8();
                var pathLength = reader.getUint16();
                node._setOwnerPathCount(pathLength);
                for (j = 0; j < pathLength; j++)
                    node._setOwnerPathByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                var nodePath = node._joinOwnerPath("/");
                var mapArray = nodesMap[nodePath];
                (mapArray) || (nodesMap[nodePath] = mapArray = []);
                mapArray.push(node);
                node.propertyOwner = AnimationClipParser04._strings[reader.getUint16()];
                var propertyLength = reader.getUint16();
                node._setPropertyCount(propertyLength);
                for (j = 0; j < propertyLength; j++)
                    node._setPropertyByIndex(j, AnimationClipParser04._strings[reader.getUint16()]);
                var fullPath = nodePath + "." + node.propertyOwner + "." + node._joinProperty(".");
                nodesDic[fullPath] = node;
                node.fullPath = fullPath;
                node.nodePath = nodePath;
                var keyframeCount = reader.getUint16();
                node._setKeyframeCount(keyframeCount);
                switch (AnimationClipParser04._version) {
                    case "LAYAANIMATION:04":
                        for (j = 0; j < keyframeCount; j++) {
                            switch (type) {
                                case exports.KeyFrameValueType.Float:
                                    var floatKeyframe = new Laya.FloatKeyframe();
                                    node._setKeyframeByIndex(j, floatKeyframe);
                                    floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                    floatKeyframe.inTangent = reader.getFloat32();
                                    floatKeyframe.outTangent = reader.getFloat32();
                                    floatKeyframe.value = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Position:
                                case exports.KeyFrameValueType.Scale:
                                case exports.KeyFrameValueType.RotationEuler:
                                case exports.KeyFrameValueType.Vector3:
                                    var floatArrayKeyframe = new Laya.Vector3Keyframe();
                                    node._setKeyframeByIndex(j, floatArrayKeyframe);
                                    floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangent = floatArrayKeyframe.inTangent;
                                    var outTangent = floatArrayKeyframe.outTangent;
                                    var value = floatArrayKeyframe.value;
                                    inTangent.x = reader.getFloat32();
                                    inTangent.y = reader.getFloat32();
                                    inTangent.z = reader.getFloat32();
                                    outTangent.x = reader.getFloat32();
                                    outTangent.y = reader.getFloat32();
                                    outTangent.z = reader.getFloat32();
                                    value.x = reader.getFloat32();
                                    value.y = reader.getFloat32();
                                    value.z = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Rotation:
                                    var quaternionKeyframe = new Laya.QuaternionKeyframe();
                                    node._setKeyframeByIndex(j, quaternionKeyframe);
                                    quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangentQua = quaternionKeyframe.inTangent;
                                    var outTangentQua = quaternionKeyframe.outTangent;
                                    var valueQua = quaternionKeyframe.value;
                                    inTangentQua.x = reader.getFloat32();
                                    inTangentQua.y = reader.getFloat32();
                                    inTangentQua.z = reader.getFloat32();
                                    inTangentQua.w = reader.getFloat32();
                                    outTangentQua.x = reader.getFloat32();
                                    outTangentQua.y = reader.getFloat32();
                                    outTangentQua.z = reader.getFloat32();
                                    outTangentQua.w = reader.getFloat32();
                                    valueQua.x = reader.getFloat32();
                                    valueQua.y = reader.getFloat32();
                                    valueQua.z = reader.getFloat32();
                                    valueQua.w = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Vector2:
                                    var vec2Keyfram = new Laya.Vector2Keyframe();
                                    node._setKeyframeByIndex(j, vec2Keyfram);
                                    vec2Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV2 = vec2Keyfram.inTangent;
                                    var outTangentV2 = vec2Keyfram.outTangent;
                                    var valueV2 = vec2Keyfram.value;
                                    inTangentV2.x = reader.getFloat32();
                                    inTangentV2.y = reader.getFloat32();
                                    outTangentV2.x = reader.getFloat32();
                                    outTangentV2.y = reader.getFloat32();
                                    valueV2.x = reader.getFloat32();
                                    valueV2.y = reader.getFloat32();
                                    break;
                                case exports.KeyFrameValueType.Vector4:
                                case exports.KeyFrameValueType.Color:
                                    var vec4Keyfram = new Laya.Vector4Keyframe();
                                    node._setKeyframeByIndex(j, vec4Keyfram);
                                    vec4Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV4 = vec4Keyfram.inTangent;
                                    var outTangentV4 = vec4Keyfram.outTangent;
                                    var valueV4 = vec4Keyfram.value;
                                    inTangentV4.x = reader.getFloat32();
                                    inTangentV4.y = reader.getFloat32();
                                    inTangentV4.z = reader.getFloat32();
                                    inTangentV4.w = reader.getFloat32();
                                    outTangentV4.x = reader.getFloat32();
                                    outTangentV4.y = reader.getFloat32();
                                    outTangentV4.z = reader.getFloat32();
                                    outTangentV4.w = reader.getFloat32();
                                    valueV4.x = reader.getFloat32();
                                    valueV4.y = reader.getFloat32();
                                    valueV4.z = reader.getFloat32();
                                    valueV4.w = reader.getFloat32();
                                    break;
                                default:
                                    throw new Error("AnimationClipParser04:unknown type.");
                            }
                        }
                        break;
                    case "LAYAANIMATION:WEIGHT_04":
                    case "LAYAANIMATION:WEIGHT_05":
                        for (j = 0; j < keyframeCount; j++) {
                            let isWeight = 1;
                            switch (type) {
                                case exports.KeyFrameValueType.Boolean:
                                    let booleanKeyframe = new Laya.BooleanKeyframe();
                                    node._setKeyframeByIndex(j, booleanKeyframe);
                                    booleanKeyframe.time = startTimeTypes[reader.getUint16()];
                                    booleanKeyframe.value = reader.getByte() == 1;
                                    break;
                                case exports.KeyFrameValueType.Float:
                                    var floatKeyframe = new Laya.FloatKeyframe();
                                    node._setKeyframeByIndex(j, floatKeyframe);
                                    floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                    floatKeyframe.inTangent = reader.getFloat32();
                                    floatKeyframe.outTangent = reader.getFloat32();
                                    floatKeyframe.value = reader.getFloat32();
                                    floatKeyframe.weightedMode = reader.getUint8();
                                    if ("LAYAANIMATION:WEIGHT_05" == AnimationClipParser04._version) {
                                        if (Laya.WeightedMode.In == floatKeyframe.weightedMode || Laya.WeightedMode.Both == floatKeyframe.weightedMode) {
                                            floatKeyframe.inWeight = reader.getFloat32();
                                        }
                                        if (Laya.WeightedMode.Out == floatKeyframe.weightedMode || Laya.WeightedMode.Both == floatKeyframe.weightedMode) {
                                            floatKeyframe.outWeight = reader.getFloat32();
                                        }
                                    }
                                    else {
                                        floatKeyframe.inWeight = reader.getFloat32();
                                        floatKeyframe.outWeight = reader.getFloat32();
                                    }
                                    break;
                                case exports.KeyFrameValueType.Position:
                                case exports.KeyFrameValueType.Scale:
                                case exports.KeyFrameValueType.RotationEuler:
                                case exports.KeyFrameValueType.Vector3:
                                    var floatArrayKeyframe = new Laya.Vector3Keyframe(true);
                                    node._setKeyframeByIndex(j, floatArrayKeyframe);
                                    floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangent = floatArrayKeyframe.inTangent;
                                    var outTangent = floatArrayKeyframe.outTangent;
                                    var value = floatArrayKeyframe.value;
                                    let weidhtMode = floatArrayKeyframe.weightedMode;
                                    let inWeight = floatArrayKeyframe.inWeight;
                                    let outWeight = floatArrayKeyframe.outWeight;
                                    inTangent.x = reader.getFloat32();
                                    inTangent.y = reader.getFloat32();
                                    inTangent.z = reader.getFloat32();
                                    outTangent.x = reader.getFloat32();
                                    outTangent.y = reader.getFloat32();
                                    outTangent.z = reader.getFloat32();
                                    value.x = reader.getFloat32();
                                    value.y = reader.getFloat32();
                                    value.z = reader.getFloat32();
                                    if ("LAYAANIMATION:WEIGHT_05" == AnimationClipParser04._version) {
                                        isWeight = reader.getByte();
                                    }
                                    if (1 == isWeight) {
                                        weidhtMode.x = reader.getUint8();
                                        weidhtMode.y = reader.getUint8();
                                        weidhtMode.z = reader.getUint8();
                                        inWeight.x = reader.getFloat32();
                                        inWeight.y = reader.getFloat32();
                                        inWeight.z = reader.getFloat32();
                                        outWeight.x = reader.getFloat32();
                                        outWeight.y = reader.getFloat32();
                                        outWeight.z = reader.getFloat32();
                                    }
                                    break;
                                case exports.KeyFrameValueType.Rotation:
                                    var quaternionKeyframe = new Laya.QuaternionKeyframe(true);
                                    node._setKeyframeByIndex(j, quaternionKeyframe);
                                    quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                    var inTangentQua = quaternionKeyframe.inTangent;
                                    var outTangentQua = quaternionKeyframe.outTangent;
                                    var valueQua = quaternionKeyframe.value;
                                    let weightModeV4 = quaternionKeyframe.weightedMode;
                                    let inWeightQua = quaternionKeyframe.inWeight;
                                    let outWeightQua = quaternionKeyframe.outWeight;
                                    inTangentQua.x = reader.getFloat32();
                                    inTangentQua.y = reader.getFloat32();
                                    inTangentQua.z = reader.getFloat32();
                                    inTangentQua.w = reader.getFloat32();
                                    outTangentQua.x = reader.getFloat32();
                                    outTangentQua.y = reader.getFloat32();
                                    outTangentQua.z = reader.getFloat32();
                                    outTangentQua.w = reader.getFloat32();
                                    valueQua.x = reader.getFloat32();
                                    valueQua.y = reader.getFloat32();
                                    valueQua.z = reader.getFloat32();
                                    valueQua.w = reader.getFloat32();
                                    if ("LAYAANIMATION:WEIGHT_05" == AnimationClipParser04._version) {
                                        isWeight = reader.getByte();
                                    }
                                    if (1 == isWeight) {
                                        weightModeV4.x = reader.getUint8();
                                        weightModeV4.y = reader.getUint8();
                                        weightModeV4.z = reader.getUint8();
                                        weightModeV4.w = reader.getUint8();
                                        inWeightQua.x = reader.getFloat32();
                                        inWeightQua.y = reader.getFloat32();
                                        inWeightQua.z = reader.getFloat32();
                                        inWeightQua.w = reader.getFloat32();
                                        outWeightQua.x = reader.getFloat32();
                                        outWeightQua.y = reader.getFloat32();
                                        outWeightQua.z = reader.getFloat32();
                                        outWeightQua.w = reader.getFloat32();
                                    }
                                    break;
                                case exports.KeyFrameValueType.Vector2:
                                    var vec2Keyfram = new Laya.Vector2Keyframe(true);
                                    node._setKeyframeByIndex(j, vec2Keyfram);
                                    vec2Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV2 = vec2Keyfram.inTangent;
                                    var outTangentV2 = vec2Keyfram.outTangent;
                                    var valueV2 = vec2Keyfram.value;
                                    let weightModeV2 = vec2Keyfram.weightedMode;
                                    let inWeightV2 = vec2Keyfram.inWeight;
                                    let outWeightV2 = vec2Keyfram.outWeight;
                                    inTangentV2.x = reader.getFloat32();
                                    inTangentV2.y = reader.getFloat32();
                                    outTangentV2.x = reader.getFloat32();
                                    outTangentV2.y = reader.getFloat32();
                                    valueV2.x = reader.getFloat32();
                                    valueV2.y = reader.getFloat32();
                                    if ("LAYAANIMATION:WEIGHT_05" == AnimationClipParser04._version) {
                                        isWeight = reader.getByte();
                                    }
                                    if (1 == isWeight) {
                                        weightModeV2.x = reader.getUint8();
                                        weightModeV2.y = reader.getUint8();
                                        inWeightV2.x = reader.getFloat32();
                                        inWeightV2.y = reader.getFloat32();
                                        outWeightV2.x = reader.getFloat32();
                                        outWeightV2.y = reader.getFloat32();
                                    }
                                    break;
                                case exports.KeyFrameValueType.Vector4:
                                case exports.KeyFrameValueType.Color:
                                    var vec4Keyfram = new Laya.Vector4Keyframe(true);
                                    node._setKeyframeByIndex(j, vec4Keyfram);
                                    vec4Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV4 = vec4Keyfram.inTangent;
                                    var outTangentV4 = vec4Keyfram.outTangent;
                                    var valueV4 = vec4Keyfram.value;
                                    var weightMode_V4 = vec4Keyfram.weightedMode;
                                    var inWeightV4 = vec4Keyfram.inWeight;
                                    var outWeightV4 = vec4Keyfram.outWeight;
                                    inTangentV4.x = reader.getFloat32();
                                    inTangentV4.y = reader.getFloat32();
                                    inTangentV4.z = reader.getFloat32();
                                    inTangentV4.w = reader.getFloat32();
                                    outTangentV4.x = reader.getFloat32();
                                    outTangentV4.y = reader.getFloat32();
                                    outTangentV4.z = reader.getFloat32();
                                    outTangentV4.w = reader.getFloat32();
                                    valueV4.x = reader.getFloat32();
                                    valueV4.y = reader.getFloat32();
                                    valueV4.z = reader.getFloat32();
                                    valueV4.w = reader.getFloat32();
                                    if ("LAYAANIMATION:WEIGHT_05" == AnimationClipParser04._version) {
                                        isWeight = reader.getByte();
                                    }
                                    if (1 == isWeight) {
                                        weightMode_V4.x = reader.getUint8();
                                        weightMode_V4.y = reader.getUint8();
                                        weightMode_V4.z = reader.getUint8();
                                        weightMode_V4.w = reader.getUint8();
                                        inWeightV4.x = reader.getFloat32();
                                        inWeightV4.y = reader.getFloat32();
                                        inWeightV4.z = reader.getFloat32();
                                        inWeightV4.w = reader.getFloat32();
                                        outWeightV4.x = reader.getFloat32();
                                        outWeightV4.y = reader.getFloat32();
                                        outWeightV4.z = reader.getFloat32();
                                        outWeightV4.w = reader.getFloat32();
                                    }
                                    break;
                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                        break;
                    case "LAYAANIMATION:COMPRESSION_04":
                        for (j = 0; j < keyframeCount; j++) {
                            switch (type) {
                                case exports.KeyFrameValueType.Float:
                                    floatKeyframe = new Laya.FloatKeyframe();
                                    node._setKeyframeByIndex(j, floatKeyframe);
                                    floatKeyframe.time = startTimeTypes[reader.getUint16()];
                                    floatKeyframe.inTangent = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    floatKeyframe.outTangent = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    floatKeyframe.value = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Position:
                                case exports.KeyFrameValueType.Scale:
                                case exports.KeyFrameValueType.RotationEuler:
                                case exports.KeyFrameValueType.Vector3:
                                    floatArrayKeyframe = new Laya.Vector3Keyframe();
                                    node._setKeyframeByIndex(j, floatArrayKeyframe);
                                    floatArrayKeyframe.time = startTimeTypes[reader.getUint16()];
                                    inTangent = floatArrayKeyframe.inTangent;
                                    outTangent = floatArrayKeyframe.outTangent;
                                    value = floatArrayKeyframe.value;
                                    inTangent.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangent.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangent.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangent.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangent.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangent.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    value.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    value.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    value.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Rotation:
                                    quaternionKeyframe = new Laya.QuaternionKeyframe();
                                    node._setKeyframeByIndex(j, quaternionKeyframe);
                                    quaternionKeyframe.time = startTimeTypes[reader.getUint16()];
                                    inTangentQua = quaternionKeyframe.inTangent;
                                    outTangentQua = quaternionKeyframe.outTangent;
                                    valueQua = quaternionKeyframe.value;
                                    inTangentQua.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentQua.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentQua.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentQua.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentQua.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueQua.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Vector2:
                                    var vec2Keyfram = new Laya.Vector2Keyframe();
                                    node._setKeyframeByIndex(j, vec2Keyfram);
                                    vec2Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV2 = vec2Keyfram.inTangent;
                                    var outTangentV2 = vec2Keyfram.outTangent;
                                    var valueV2 = vec2Keyfram.value;
                                    inTangentV2.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV2.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV2.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV2.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV2.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV2.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                case exports.KeyFrameValueType.Vector4:
                                case exports.KeyFrameValueType.Color:
                                    var vec4Keyfram = new Laya.Vector4Keyframe();
                                    node._setKeyframeByIndex(j, vec4Keyfram);
                                    vec4Keyfram.time = startTimeTypes[reader.getUint16()];
                                    var inTangentV4 = vec4Keyfram.inTangent;
                                    var outTangentV4 = vec4Keyfram.outTangent;
                                    var valueV4 = vec4Keyfram.value;
                                    inTangentV4.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV4.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV4.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    inTangentV4.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    outTangentV4.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.x = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.y = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.z = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    valueV4.w = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                    break;
                                default:
                                    throw "AnimationClipParser04:unknown type.";
                            }
                        }
                        break;
                }
            }
            var eventCount = reader.getUint16();
            for (i = 0; i < eventCount; i++) {
                var event = new AnimationEvent();
                event.time = Math.min(clipDur, reader.getFloat32());
                event.eventName = AnimationClipParser04._strings[reader.getUint16()];
                var params = [];
                var paramCount = reader.getUint16();
                (paramCount > 0) && (event.params = params = []);
                for (j = 0; j < paramCount; j++) {
                    var eventType = reader.getByte();
                    switch (eventType) {
                        case 0:
                            params.push(!!reader.getByte());
                            break;
                        case 1:
                            params.push(reader.getInt32());
                            break;
                        case 2:
                            params.push(reader.getFloat32());
                            break;
                        case 3:
                            params.push(AnimationClipParser04._strings[reader.getUint16()]);
                            break;
                        default:
                            throw new Error("unknown type.");
                    }
                }
                clip.addEvent(event);
            }
        }
    }
    AnimationClipParser04._strings = [];
    AnimationClipParser04._BLOCK = { count: 0 };
    AnimationClipParser04._DATA = { offset: 0, size: 0 };

    class KeyframeNodeList {
        get count() {
            return this._nodes.length;
        }
        set count(value) {
            this._nodes.length = value;
        }
        constructor() {
            this._nodes = [];
        }
        getNodeByIndex(index) {
            return this._nodes[index];
        }
        setNodeByIndex(index, node) {
            this._nodes[index] = node;
        }
    }

    class AnimationClip extends Laya.Resource {
        static _parse(data) {
            var clip = new AnimationClip();
            var reader = new Laya.Byte(data);
            var version = reader.readUTFString();
            switch (version) {
                case "LAYAANIMATION:03":
                    AnimationClipParser03.parse(clip, reader);
                    break;
                case "LAYAANIMATION:04":
                case "LAYAANIMATION:COMPRESSION_04":
                case "LAYAANIMATION:WEIGHT_04":
                case "LAYAANIMATION:WEIGHT_05":
                    AnimationClipParser04.parse(clip, reader, version);
                    break;
                default:
                    throw new Error("unknown animationClip version.");
            }
            return clip;
        }
        static load(url, complete) {
            Laya.ILaya.loader.load(url, complete, null, Laya.Loader.ANIMATIONCLIP);
        }
        duration() {
            return this._duration;
        }
        constructor() {
            super();
            this._duration = 0;
            this._frameRate = 0;
            this._nodes = new KeyframeNodeList();
            this.islooping = false;
            this._animationEvents = [];
        }
        _weightModeHermite(weightMode, nextweightMode) {
            return (((weightMode & Laya.WeightedMode.Out) == 0) && ((nextweightMode & Laya.WeightedMode.In) == 0));
        }
        _hermiteInterpolate(frame, nextFrame, t, dur) {
            var t0 = frame.outTangent, t1 = nextFrame.inTangent;
            if (Number.isFinite(t0) && Number.isFinite(t1)) {
                var t2 = t * t;
                var t3 = t2 * t;
                var a = 2.0 * t3 - 3.0 * t2 + 1.0;
                var b = t3 - 2.0 * t2 + t;
                var c = t3 - t2;
                var d = -2.0 * t3 + 3.0 * t2;
                return a * frame.value + b * t0 * dur + c * t1 * dur + d * nextFrame.value;
            }
            else
                return frame.value;
        }
        _hermiteInterpolateVector3(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
            t0 = tan0.z, t1 = tan1.z;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.z, nextFrame.weightedMode.z)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
                else
                    out.z = p0.z;
            }
            else {
                out.z = this._hermiteCurveSplineWeight(frame.value.z, frame.time, frame.outWeight.z, frame.outTangent.z, nextFrame.value.z, nextFrame.time, nextFrame.inWeight.z, nextFrame.inTangent.z, t);
            }
        }
        _hermiteInterpolateQuaternion(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
            t0 = tan0.z, t1 = tan1.z;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.z, nextFrame.weightedMode.z)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
                else
                    out.z = p0.z;
            }
            else {
                out.z = this._hermiteCurveSplineWeight(frame.value.z, frame.time, frame.outWeight.z, frame.outTangent.z, nextFrame.value.z, nextFrame.time, nextFrame.inWeight.z, nextFrame.inTangent.z, t);
            }
            t0 = tan0.w, t1 = tan1.w;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.w, nextFrame.weightedMode.w)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
                else
                    out.w = p0.w;
            }
            else {
                out.w = this._hermiteCurveSplineWeight(frame.value.w, frame.time, frame.outWeight.w, frame.outTangent.w, nextFrame.value.w, nextFrame.time, nextFrame.inWeight.w, nextFrame.inTangent.w, t);
            }
        }
        _hermiteInterpolateVector4(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
            t0 = tan0.z, t1 = tan1.z;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.z, nextFrame.weightedMode.z)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.z = a * p0.z + b * t0 * dur + c * t1 * dur + d * p1.z;
                else
                    out.z = p0.z;
            }
            else {
                out.z = this._hermiteCurveSplineWeight(frame.value.z, frame.time, frame.outWeight.z, frame.outTangent.z, nextFrame.value.z, nextFrame.time, nextFrame.inWeight.z, nextFrame.inTangent.z, t);
            }
            t0 = tan0.w, t1 = tan1.w;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.w, nextFrame.weightedMode.w)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.w = a * p0.w + b * t0 * dur + c * t1 * dur + d * p1.w;
                else
                    out.w = p0.w;
            }
            else {
                out.w = this._hermiteCurveSplineWeight(frame.value.w, frame.time, frame.outWeight.w, frame.outTangent.w, nextFrame.value.w, nextFrame.time, nextFrame.inWeight.w, nextFrame.inTangent.w, t);
            }
        }
        _hermiteInterpolateVector2(frame, nextFrame, t, dur, out) {
            var p0 = frame.value;
            var tan0 = frame.outTangent;
            var p1 = nextFrame.value;
            var tan1 = nextFrame.inTangent;
            var t2 = t * t;
            var t3 = t2 * t;
            var a = 2.0 * t3 - 3.0 * t2 + 1.0;
            var b = t3 - 2.0 * t2 + t;
            var c = t3 - t2;
            var d = -2.0 * t3 + 3.0 * t2;
            var t0 = tan0.x, t1 = tan1.x;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.x, nextFrame.weightedMode.x)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.x = a * p0.x + b * t0 * dur + c * t1 * dur + d * p1.x;
                else
                    out.x = p0.x;
            }
            else {
                out.x = this._hermiteCurveSplineWeight(frame.value.x, frame.time, frame.outWeight.x, frame.outTangent.x, nextFrame.value.x, nextFrame.time, nextFrame.inWeight.x, nextFrame.inTangent.x, t);
            }
            t0 = tan0.y, t1 = tan1.y;
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode.y, nextFrame.weightedMode.y)) {
                if (Number.isFinite(t0) && Number.isFinite(t1))
                    out.y = a * p0.y + b * t0 * dur + c * t1 * dur + d * p1.y;
                else
                    out.y = p0.y;
            }
            else {
                out.y = this._hermiteCurveSplineWeight(frame.value.y, frame.time, frame.outWeight.y, frame.outTangent.y, nextFrame.value.y, nextFrame.time, nextFrame.inWeight.y, nextFrame.inTangent.y, t);
            }
        }
        _hermiteCurveSplineWeight(frameValue, frametime, frameOutWeight, frameOutTangent, nextframeValue, nextframetime, nextframeInweight, nextframeIntangent, time) {
            let Eps = 2.22e-16;
            let x = time;
            let x1 = frametime;
            let y1 = frameValue;
            let wt1 = frameOutWeight;
            let x2 = nextframetime;
            let y2 = nextframeValue;
            let wt2 = nextframeInweight;
            let dx = x2 - x1;
            let dy = y2 - y1;
            dy = Math.max(Math.abs(dy), Eps) * (dy < 0 ? -1 : 1);
            let yp1 = frameOutTangent;
            let yp2 = nextframeIntangent;
            if (!Number.isFinite(yp1) || !Number.isFinite(yp2)) {
                return frameValue;
            }
            yp1 = yp1 * dx / dy;
            yp2 = yp2 * dx / dy;
            let wt2s = 1 - wt2;
            let t = 0.5;
            let t2 = 0;
            if (Math.abs(wt1 - 0.33333334) < 0.0001 && Math.abs(wt2 - 0.33333334) < 0.0001) {
                t = x;
                t2 = 1 - t;
            }
            else {
                while (true) {
                    t2 = (1 - t);
                    let fg = 3 * t2 * t2 * t * wt1 + 3 * t2 * t * t * wt2s + t * t * t - x;
                    if (Math.abs(fg) <= 2.5 * Eps)
                        break;
                    let fpg = 3 * t2 * t2 * wt1 + 6 * t2 * t * (wt2s - wt1) + 3 * t * t * (1 - wt2s);
                    let fppg = 6 * t2 * (wt2s - 2 * wt1) + 6 * t * (1 - 2 * wt2s + wt1);
                    let fpppg = 18 * wt1 - 18 * wt2s + 6;
                    t -= (6 * fg * fpg * fpg - 3 * fg * fg * fppg) / (6 * fpg * fpg * fpg - 6 * fg * fpg * fppg + fg * fg * fpppg);
                }
            }
            let y = 3 * t2 * t2 * t * wt1 * yp1 + 3 * t2 * t * t * (1 - wt2 * yp2) + t * t * t;
            return y * dy + y1;
        }
        _curveInterpolate(frame, nextFrame, t, dur) {
            if ((!frame.weightedMode) || this._weightModeHermite(frame.weightedMode, nextFrame.weightedMode)) {
                return this._hermiteInterpolate(frame, nextFrame, t, dur);
            }
            else {
                return this._hermiteCurveSplineWeight(frame.value, frame.time, frame.outWeight, frame.outTangent, nextFrame.value, nextFrame.time, nextFrame.inWeight, nextFrame.inTangent, t);
            }
        }
        _evaluateClipDatasRealTime(nodes, playCurTime, realTimeCurrentFrameIndexes, addtive, frontPlay, outDatas, avatarMask) {
            for (var i = 0, n = nodes.count; i < n; i++) {
                var node = nodes.getNodeByIndex(i);
                var type = node.type;
                var nextFrameIndex;
                var keyFrames = node._keyFrames;
                var keyFramesCount = keyFrames.length;
                var frameIndex = realTimeCurrentFrameIndexes[i];
                if (avatarMask && (!avatarMask.getTransformActive(node.nodePath))) {
                    continue;
                }
                if (frontPlay) {
                    if ((frameIndex !== -1) && (playCurTime < keyFrames[frameIndex].time)) {
                        frameIndex = -1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (nextFrameIndex < keyFramesCount) {
                        if (keyFrames[nextFrameIndex].time > playCurTime)
                            break;
                        frameIndex++;
                        nextFrameIndex++;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                else {
                    nextFrameIndex = frameIndex + 1;
                    if ((nextFrameIndex !== keyFramesCount) && (playCurTime > keyFrames[nextFrameIndex].time)) {
                        frameIndex = keyFramesCount - 1;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                    nextFrameIndex = frameIndex + 1;
                    while (frameIndex > -1) {
                        if (keyFrames[frameIndex].time < playCurTime)
                            break;
                        frameIndex--;
                        nextFrameIndex--;
                        realTimeCurrentFrameIndexes[i] = frameIndex;
                    }
                }
                var isEnd = nextFrameIndex === keyFramesCount;
                switch (type) {
                    case exports.KeyFrameValueType.Boolean:
                        if (frameIndex !== -1) {
                            outDatas[i] = keyFrames[frameIndex].value;
                        }
                        else {
                            outDatas[i] = keyFrames[0].value;
                        }
                        break;
                    case exports.KeyFrameValueType.Float:
                        if (frameIndex !== -1) {
                            var frame = keyFrames[frameIndex];
                            if (isEnd) {
                                outDatas[i] = frame.value;
                            }
                            else {
                                var nextFarme = keyFrames[nextFrameIndex];
                                var d = nextFarme.time - frame.time;
                                var t;
                                if (d !== 0)
                                    t = (playCurTime - frame.time) / d;
                                else
                                    t = 0;
                                outDatas[i] = this._curveInterpolate(frame, nextFarme, t, d);
                            }
                        }
                        else {
                            outDatas[i] = keyFrames[0].value;
                        }
                        if (addtive)
                            outDatas[i] = outDatas[i] - keyFrames[0].value;
                        break;
                    case exports.KeyFrameValueType.Position:
                    case exports.KeyFrameValueType.RotationEuler:
                    case exports.KeyFrameValueType.Vector3:
                        var clipData = outDatas[i];
                        this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData);
                        if (addtive) {
                            var firstFrameValue = keyFrames[0].value;
                            clipData.x -= firstFrameValue.x;
                            clipData.y -= firstFrameValue.y;
                            clipData.z -= firstFrameValue.z;
                        }
                        break;
                    case exports.KeyFrameValueType.Rotation:
                        var clipQuat = outDatas[i];
                        this._evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipQuat);
                        if (addtive) {
                            var tempQuat = AnimationClip._tempQuaternion0;
                            var firstFrameValueQua = keyFrames[0].value;
                            Utils3D.quaternionConjugate(firstFrameValueQua, tempQuat);
                            Laya.Quaternion.multiply(tempQuat, clipQuat, clipQuat);
                        }
                        break;
                    case exports.KeyFrameValueType.Scale:
                        clipData = outDatas[i];
                        this._evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, clipData);
                        if (addtive) {
                            firstFrameValue = keyFrames[0].value;
                            clipData.x /= firstFrameValue.x;
                            clipData.y /= firstFrameValue.y;
                            clipData.z /= firstFrameValue.z;
                        }
                        break;
                    case exports.KeyFrameValueType.Vector2:
                        var v2Data = outDatas[i];
                        this._evaluateFrameNodeVector2DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, v2Data);
                        if (addtive) {
                            var v2FrameValue = keyFrames[0].value;
                            v2Data.x -= v2FrameValue.x;
                            v2Data.y -= v2FrameValue.y;
                        }
                        break;
                    case exports.KeyFrameValueType.Vector4:
                    case exports.KeyFrameValueType.Color:
                        var v4Data = outDatas[i];
                        this._evaluateFrameNodeVector4DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, v4Data);
                        if (addtive) {
                            var v4FrameValue = keyFrames[0].value;
                            v4Data.x -= v4FrameValue.x;
                            v4Data.y -= v4FrameValue.y;
                            v4Data.z -= v4FrameValue.z;
                            v4Data.w -= v4FrameValue.w;
                        }
                        break;
                    default:
                        throw new Error("AnimationClip:unknown node type.");
                }
            }
        }
        _evaluateFrameNodeVector3DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                    outDatas.z = frameData.z;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateVector3(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
                outDatas.z = firstFrameDatas.z;
            }
        }
        _evaluateFrameNodeVector2DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateVector2(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
            }
        }
        _evaluateFrameNodeVector4DatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                    outDatas.z = frameData.z;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateVector4(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
                outDatas.z = firstFrameDatas.z;
            }
        }
        _evaluateFrameNodeQuaternionDatasRealTime(keyFrames, frameIndex, isEnd, playCurTime, outDatas) {
            if (frameIndex !== -1) {
                var frame = keyFrames[frameIndex];
                if (isEnd) {
                    var frameData = frame.value;
                    outDatas.x = frameData.x;
                    outDatas.y = frameData.y;
                    outDatas.z = frameData.z;
                    outDatas.w = frameData.w;
                }
                else {
                    var nextKeyFrame = keyFrames[frameIndex + 1];
                    var t;
                    var startTime = frame.time;
                    var d = nextKeyFrame.time - startTime;
                    if (d !== 0)
                        t = (playCurTime - startTime) / d;
                    else
                        t = 0;
                    this._hermiteInterpolateQuaternion(frame, nextKeyFrame, t, d, outDatas);
                }
            }
            else {
                var firstFrameDatas = keyFrames[0].value;
                outDatas.x = firstFrameDatas.x;
                outDatas.y = firstFrameDatas.y;
                outDatas.z = firstFrameDatas.z;
                outDatas.w = firstFrameDatas.w;
            }
        }
        _binarySearchEventIndex(time) {
            var start = 0;
            var end = this._animationEvents.length - 1;
            var mid;
            while (start <= end) {
                mid = Math.floor((start + end) / 2);
                var midValue = this._animationEvents[mid].time;
                if (midValue == time)
                    return mid;
                else if (midValue > time)
                    end = mid - 1;
                else
                    start = mid + 1;
            }
            return start;
        }
        addEvent(event) {
            var index = this._binarySearchEventIndex(event.time);
            this._animationEvents.splice(index, 0, event);
        }
        _disposeResource() {
            this._nodes = null;
            this._nodesMap = null;
        }
    }
    AnimationClip._tempQuaternion0 = new Laya.Quaternion();

    class LightSprite extends Sprite3D {
        get color() {
            return this._light.color;
        }
        set color(value) {
            this._light.color = value;
        }
        get mode() {
            return this._light.lightmapBakedType;
        }
        set mode(value) {
            this._light.lightmapBakedType = value;
        }
        get intensity() {
            return this._light.intensity;
        }
        set intensity(value) {
            this._light.intensity = value;
        }
        get shadowMode() {
            return this._light.shadowMode;
        }
        set shadowMode(value) {
            this._light.shadowMode = value;
        }
        get shadowDistance() {
            return this._light.shadowDistance;
        }
        set shadowDistance(value) {
            this._light.shadowDistance = value;
        }
        get shadowResolution() {
            return this._light.shadowResolution;
        }
        set shadowResolution(value) {
            this._light.shadowResolution = value;
        }
        get shadowDepthBias() {
            return this._light.shadowDepthBias;
        }
        set shadowDepthBias(value) {
            this._light.shadowDepthBias = value;
        }
        get shadowNormalBias() {
            return this._light.shadowNormalBias;
        }
        set shadowNormalBias(value) {
            this._light.shadowNormalBias = value;
        }
        get shadowStrength() {
            return this._light.shadowStrength;
        }
        set shadowStrength(value) {
            this._light.shadowStrength = value;
        }
        get shadowNearPlane() {
            return this._light.shadowNearPlane;
        }
        set shadowNearPlane(value) {
            this._light.shadowNearPlane = value;
        }
        get lightmapBakedType() {
            return this._light.lightmapBakedType;
        }
        set lightmapBakedType(value) {
            this._light.lightmapBakedType = value;
        }
        get lightWorldMatrix() {
            return this._light.lightWorldMatrix;
        }
        constructor() {
            super();
        }
        _cloneTo(destObject, rootSprite, dstSprite) {
            super._cloneTo(destObject, rootSprite, dstSprite);
            destObject.color = this.color.clone();
            destObject.intensity = this.intensity;
            destObject.lightmapBakedType = this.lightmapBakedType;
        }
        _addToLightQueue() {
        }
        _removeFromLightQueue() {
        }
    }

    class EffectMaterial extends Laya.Material {
        get color() {
            return this.getColorByIndex(UnlitMaterial.ALBEDOCOLOR);
        }
        set color(value) {
            this.setColorByIndex(UnlitMaterial.ALBEDOCOLOR, value);
        }
        get texture() {
            return this.getTextureByIndex(UnlitMaterial.ALBEDOTEXTURE);
        }
        set texture(value) {
            if (value)
                this.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            else
                this.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            this.setTextureByIndex(UnlitMaterial.ALBEDOTEXTURE, value);
        }
        get tilingOffset() {
            return this.getVector4ByIndex(UnlitMaterial.TILINGOFFSET);
        }
        set tilingOffset(value) {
            if (value) {
                this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, value);
            }
            else {
                this.getVector4ByIndex(UnlitMaterial.TILINGOFFSET).setValue(1.0, 1.0, 0.0, 0.0);
            }
        }
        constructor() {
            super();
            this.setShaderName("Unlit");
            this.setVector4ByIndex(UnlitMaterial.TILINGOFFSET, new Laya.Vector4(1.0, 1.0, 0.0, 0.0));
            this.setColorByIndex(UnlitMaterial.ALBEDOCOLOR, new Laya.Color(1.0, 1.0, 1.0, 1.0));
            this.renderMode = EffectMaterial.RENDERMODE_ADDTIVE;
        }
        clone() {
            var dest = new EffectMaterial();
            this.cloneTo(dest);
            return dest;
        }
        set renderMode(value) {
            switch (value) {
                case EffectMaterial.RENDERMODE_ADDTIVE:
                    this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_NONE;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE;
                    this.depthTest = RenderState.DEPTHTEST_LEQUAL;
                    this.addDefine(Laya.Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                case EffectMaterial.RENDERMODE_ALPHABLENDED:
                    this.renderQueue = Laya.Material.RENDERQUEUE_TRANSPARENT;
                    this.alphaTest = false;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_NONE;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LEQUAL;
                    this.removeDefine(Laya.Material.SHADERDEFINE_ADDTIVEFOG);
                    break;
                default:
                    throw new Error("unknown renderMode: " + value);
            }
        }
    }
    EffectMaterial.RENDERMODE_ADDTIVE = 0;
    EffectMaterial.RENDERMODE_ALPHABLENDED = 1;

    class ExtendTerrainMaterial extends Laya.Material {
        static __initDefine__() {
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM1");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM2");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM3");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM4");
            ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5 = Laya.Shader3D.getDefineByName("ExtendTerrain_DETAIL_NUM5");
            ExtendTerrainMaterial.SPLATALPHATEXTURE = Laya.Shader3D.propertyNameToID("u_SplatAlphaTexture");
            ExtendTerrainMaterial.DIFFUSETEXTURE1 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture1");
            ExtendTerrainMaterial.DIFFUSETEXTURE2 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture2");
            ExtendTerrainMaterial.DIFFUSETEXTURE3 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture3");
            ExtendTerrainMaterial.DIFFUSETEXTURE4 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture4");
            ExtendTerrainMaterial.DIFFUSETEXTURE5 = Laya.Shader3D.propertyNameToID("u_DiffuseTexture5");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET1 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset1");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET2 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset2");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET3 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset3");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET4 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset4");
            ExtendTerrainMaterial.DIFFUSESCALEOFFSET5 = Laya.Shader3D.propertyNameToID("u_DiffuseScaleOffset5");
        }
        get splatAlphaTexture() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE);
        }
        set splatAlphaTexture(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.SPLATALPHATEXTURE, value);
        }
        get diffuseTexture1() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1);
        }
        set diffuseTexture1(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE1, value);
            this._setDetailNum(1);
        }
        get diffuseTexture2() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2);
        }
        set diffuseTexture2(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE2, value);
            this._setDetailNum(2);
        }
        get diffuseTexture3() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3);
        }
        set diffuseTexture3(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE3, value);
            this._setDetailNum(3);
        }
        get diffuseTexture4() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4);
        }
        set diffuseTexture4(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE4, value);
            this._setDetailNum(4);
        }
        get diffuseTexture5() {
            return this._shaderValues.getTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5);
        }
        set diffuseTexture5(value) {
            this._shaderValues.setTexture(ExtendTerrainMaterial.DIFFUSETEXTURE5, value);
            this._setDetailNum(5);
        }
        set diffuseScaleOffset1(scaleOffset1) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET1, scaleOffset1);
        }
        set diffuseScaleOffset2(scaleOffset2) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET2, scaleOffset2);
        }
        set diffuseScaleOffset3(scaleOffset3) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET3, scaleOffset3);
        }
        set diffuseScaleOffset4(scaleOffset4) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET4, scaleOffset4);
        }
        set diffuseScaleOffset5(scaleOffset5) {
            this._shaderValues.setVector(ExtendTerrainMaterial.DIFFUSESCALEOFFSET5, scaleOffset5);
        }
        set renderMode(value) {
            switch (value) {
                case ExtendTerrainMaterial.RENDERMODE_OPAQUE:
                    this.renderQueue = Laya.Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = true;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_DISABLE;
                    this.depthTest = RenderState.DEPTHTEST_LESS;
                    break;
                case ExtendTerrainMaterial.RENDERMODE_TRANSPARENT:
                    this.renderQueue = Laya.Material.RENDERQUEUE_OPAQUE;
                    this.depthWrite = false;
                    this.cull = RenderState.CULL_BACK;
                    this.blend = RenderState.BLEND_ENABLE_ALL;
                    this.blendSrc = RenderState.BLENDPARAM_SRC_ALPHA;
                    this.blendDst = RenderState.BLENDPARAM_ONE_MINUS_SRC_ALPHA;
                    this.depthTest = RenderState.DEPTHTEST_LEQUAL;
                    break;
                default:
                    throw new Error("unknown renderMode: " + value);
            }
        }
        constructor() {
            super();
            this.setShaderName("ExtendTerrain");
            this.renderMode = ExtendTerrainMaterial.RENDERMODE_OPAQUE;
        }
        _setDetailNum(value) {
            switch (value) {
                case 1:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 2:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 3:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 4:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    break;
                case 5:
                    this._shaderValues.addDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM5);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM1);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM2);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM3);
                    this._shaderValues.removeDefine(ExtendTerrainMaterial.SHADERDEFINE_DETAIL_NUM4);
                    break;
            }
        }
        clone() {
            var dest = new ExtendTerrainMaterial();
            this.cloneTo(dest);
            return dest;
        }
    }
    ExtendTerrainMaterial.RENDERMODE_OPAQUE = 1;
    ExtendTerrainMaterial.RENDERMODE_TRANSPARENT = 2;

    class SkinnedMeshSprite3D extends RenderableSprite3D {
        get meshFilter() {
            return this._meshFilter;
        }
        get skinnedMeshRenderer() {
            return this._render;
        }
        constructor(mesh = null, name = null) {
            super(name);
            this._meshFilter = this.addComponent(MeshFilter);
            this._render = this.addComponent(SkinnedMeshRenderer);
            (mesh) && (this._meshFilter.sharedMesh = mesh);
        }
        destroy(destroyChild = true) {
            if (this._destroyed)
                return;
            super.destroy(destroyChild);
            this._meshFilter.destroy();
        }
    }
    SkinnedMeshSprite3D._tempArray0 = [];

    class SphericalHarmonicsL2 {
        constructor() {
            this._coefficients = new Float32Array(27);
        }
        getCoefficient(i, j) {
            return this._coefficients[i * 9 + j];
        }
        setCoefficient(i, j, coefficient) {
            this._coefficients[i * 9 + j] = coefficient;
        }
        setCoefficients(i, coefficient0, coefficient1, coefficient2, coefficient3, coefficient4, coefficient5, coefficient6, coefficient7, coefficient8) {
            var offset = i * 9;
            this._coefficients[offset] = coefficient0;
            this._coefficients[++offset] = coefficient1;
            this._coefficients[++offset] = coefficient2;
            this._coefficients[++offset] = coefficient3;
            this._coefficients[++offset] = coefficient4;
            this._coefficients[++offset] = coefficient5;
            this._coefficients[++offset] = coefficient6;
            this._coefficients[++offset] = coefficient7;
            this._coefficients[++offset] = coefficient8;
        }
        cloneTo(dest) {
            if (this === dest)
                return;
            var coes = this._coefficients;
            var destCoes = dest._coefficients;
            for (var i = 0; i < 27; i++)
                destCoes[i] = coes[i];
        }
    }
    SphericalHarmonicsL2._default = new SphericalHarmonicsL2();
    const _tempSHR = new Float32Array(9);
    const _tempSHG = new Float32Array(9);
    const _tempSHB = new Float32Array(9);
    class SphericalHarmonicsL2Generater {
        static surfaceArea(u, v) {
            return Math.atan2(u * v, Math.sqrt(u * u + v * v + 1.0));
        }
        static uv2Dir(u, v, face, out_dir) {
            switch (face) {
                case Laya.TextureCubeFace.PositiveX:
                    out_dir.x = 1.0;
                    out_dir.y = -v;
                    out_dir.z = -u;
                    break;
                case Laya.TextureCubeFace.NegativeX:
                    out_dir.x = -1.0;
                    out_dir.y = -v;
                    out_dir.z = u;
                    break;
                case Laya.TextureCubeFace.PositiveY:
                    out_dir.x = u;
                    out_dir.y = 1.0;
                    out_dir.z = v;
                    break;
                case Laya.TextureCubeFace.NegativeY:
                    out_dir.x = u;
                    out_dir.y = -1.0;
                    out_dir.z = -v;
                    break;
                case Laya.TextureCubeFace.PositiveZ:
                    out_dir.x = u;
                    out_dir.y = -v;
                    out_dir.z = 1.0;
                    break;
                case Laya.TextureCubeFace.NegativeZ:
                    out_dir.x = -u;
                    out_dir.y = -v;
                    out_dir.z = -1.0;
                    break;
            }
        }
        static sh_eval_9(i, x, y, z) {
            const sqrt = Math.sqrt;
            const M_PI = Math.PI;
            switch (i) {
                case 0:
                    return 0.5 * sqrt(1.0 / M_PI);
                case 1:
                    return -y * 0.5 * sqrt(3.0 / M_PI);
                case 2:
                    return z * 0.5 * sqrt(3.0 / M_PI);
                case 3:
                    return -x * 0.5 * sqrt(3.0 / M_PI);
                case 4:
                    return x * y * 0.5 * sqrt(15.0 / M_PI);
                case 5:
                    return -y * z * 0.5 * sqrt(15.0 / M_PI);
                case 6:
                    return (3.0 * z * z - 1.0) * 0.25 * sqrt(5.0 / M_PI);
                case 7:
                    return -x * z * 0.5 * sqrt(15.0 / M_PI);
                case 8:
                    return (x * x - y * y) * 0.25 * sqrt(15.0 / M_PI);
                default:
                    return 0;
            }
        }
        static CalCubemapSH(cubemapPixels, pixelComponentSize, cubemapSize, isGamma = true) {
            let width = cubemapSize;
            let height = cubemapSize;
            let shr = _tempSHR.fill(0);
            let shg = _tempSHG.fill(0);
            let shb = _tempSHB.fill(0);
            let dir = new Laya.Vector3();
            for (let face = 0; face < 6; face++) {
                let facePixels = cubemapPixels[face];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        let px = x + 0.5;
                        let py = y + 0.5;
                        let u = 2.0 * (px / width) - 1.0;
                        let v = 2.0 * (py / height) - 1.0;
                        let dx = 1.0 / width;
                        let dy = 1.0 / height;
                        let x0 = u - dx;
                        let y0 = v - dy;
                        let x1 = u + dx;
                        let y1 = v + dy;
                        let da = this.surfaceArea(x0, y0) - this.surfaceArea(x0, y1) - this.surfaceArea(x1, y0) + this.surfaceArea(x1, y1);
                        this.uv2Dir(u, v, face, dir);
                        Laya.Vector3.normalize(dir, dir);
                        let pixelOffset = (x + y * width) * pixelComponentSize;
                        let r = facePixels[pixelOffset];
                        let g = facePixels[pixelOffset + 1];
                        let b = facePixels[pixelOffset + 2];
                        if (isGamma) {
                            r = Laya.Color.gammaToLinearSpace(r);
                            g = Laya.Color.gammaToLinearSpace(g);
                            b = Laya.Color.gammaToLinearSpace(b);
                        }
                        for (let s = 0; s < this.SH_Count; s++) {
                            let sh_val = this.sh_eval_9(s, dir.x, dir.y, dir.z);
                            shr[s] += r * sh_val * da;
                            shg[s] += g * sh_val * da;
                            shb[s] += b * sh_val * da;
                        }
                    }
                }
            }
            let sh = new SphericalHarmonicsL2();
            for (let index = 0; index < this.SH_Count; index++) {
                let scale = this.k[index];
                let r = shr[index];
                sh.setCoefficient(0, index, r * scale);
                let g = shg[index];
                sh.setCoefficient(1, index, g * scale);
                let b = shb[index];
                sh.setCoefficient(2, index, b * scale);
            }
            return sh;
        }
        static CalGradientSH(skyColor, equatorColor, groundColor, isGamma = true) {
            console.time("Gradient SH");
            let skyPixels = this._tempSkyPixels;
            let equatorPixels = this._tempEquatorPixels;
            let groundPixels = this._tempGroundPixels;
            const fillPixelBuffer = (float32, color, isGamma) => {
                let fillColor = new Laya.Color(color.x, color.y, color.z, 1.0);
                if (isGamma) {
                    fillColor.toLinear(fillColor);
                }
                let r = Math.min(fillColor.r, 1.0);
                let g = Math.min(fillColor.g, 1.0);
                let b = Math.min(fillColor.b, 1.0);
                for (let index = 0; index < float32.length; index += 3) {
                    float32[index] = r;
                    float32[index + 1] = g;
                    float32[index + 2] = b;
                }
            };
            fillPixelBuffer(skyPixels, skyColor, isGamma);
            fillPixelBuffer(equatorPixels, equatorColor, isGamma);
            fillPixelBuffer(groundPixels, groundColor, isGamma);
            let gradientPixles = [];
            gradientPixles[Laya.TextureCubeFace.PositiveY] = skyPixels;
            gradientPixles[Laya.TextureCubeFace.NegativeY] = groundPixels;
            gradientPixles[Laya.TextureCubeFace.PositiveX] = equatorPixels;
            gradientPixles[Laya.TextureCubeFace.NegativeX] = equatorPixels;
            gradientPixles[Laya.TextureCubeFace.PositiveZ] = equatorPixels;
            gradientPixles[Laya.TextureCubeFace.NegativeZ] = equatorPixels;
            let sh = SphericalHarmonicsL2Generater.CalCubemapSH(gradientPixles, 3, this.GradientSimulateSize, false);
            console.timeEnd("Gradient SH");
            return sh;
        }
    }
    SphericalHarmonicsL2Generater.k = [
        0.28209479177387814347,
        -0.32573500793527994772, 0.32573500793527994772, -0.32573500793527994772,
        0.27313710764801976764, -0.27313710764801976764, 0.07884789131313000151, -0.27313710764801976764, 0.13656855382400988382
    ];
    SphericalHarmonicsL2Generater.GradientSimulateSize = 3;
    SphericalHarmonicsL2Generater.SH_Count = 9;
    SphericalHarmonicsL2Generater._tempSkyPixels = new Float32Array(SphericalHarmonicsL2Generater.GradientSimulateSize * SphericalHarmonicsL2Generater.GradientSimulateSize * 3);
    SphericalHarmonicsL2Generater._tempEquatorPixels = new Float32Array(SphericalHarmonicsL2Generater.GradientSimulateSize * SphericalHarmonicsL2Generater.GradientSimulateSize * 3);
    SphericalHarmonicsL2Generater._tempGroundPixels = new Float32Array(SphericalHarmonicsL2Generater.GradientSimulateSize * SphericalHarmonicsL2Generater.GradientSimulateSize * 3);

    class BoundBox {
        constructor(min, max) {
            this.min = min;
            this.max = max;
        }
        _rotateExtents(extents, rotation, out) {
            var extentsX = extents.x;
            var extentsY = extents.y;
            var extentsZ = extents.z;
            var matElements = rotation.elements;
            out.x = Math.abs(matElements[0] * extentsX) + Math.abs(matElements[4] * extentsY) + Math.abs(matElements[8] * extentsZ);
            out.y = Math.abs(matElements[1] * extentsX) + Math.abs(matElements[5] * extentsY) + Math.abs(matElements[9] * extentsZ);
            out.z = Math.abs(matElements[2] * extentsX) + Math.abs(matElements[6] * extentsY) + Math.abs(matElements[10] * extentsZ);
        }
        getCorners(corners) {
            corners.length = 8;
            var minX = this.min.x;
            var minY = this.min.y;
            var minZ = this.min.z;
            var maxX = this.max.x;
            var maxY = this.max.y;
            var maxZ = this.max.z;
            corners[0] = new Laya.Vector3(minX, maxY, maxZ);
            corners[1] = new Laya.Vector3(maxX, maxY, maxZ);
            corners[2] = new Laya.Vector3(maxX, minY, maxZ);
            corners[3] = new Laya.Vector3(minX, minY, maxZ);
            corners[4] = new Laya.Vector3(minX, maxY, minZ);
            corners[5] = new Laya.Vector3(maxX, maxY, minZ);
            corners[6] = new Laya.Vector3(maxX, minY, minZ);
            corners[7] = new Laya.Vector3(minX, minY, minZ);
        }
        getCenter(out) {
            Laya.Vector3.add(this.min, this.max, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        getExtent(out) {
            Laya.Vector3.subtract(this.max, this.min, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        setCenterAndExtent(center, extent) {
            Laya.Vector3.subtract(center, extent, this.min);
            Laya.Vector3.add(center, extent, this.max);
        }
        tranform(matrix, out) {
            var center = _tempVector30;
            var extent = _tempVector31$1;
            this.getCenter(center);
            this.getExtent(extent);
            Laya.Vector3.transformCoordinate(center, matrix, center);
            this._rotateExtents(extent, matrix, extent);
            out.setCenterAndExtent(center, extent);
        }
        toDefault() {
            this.min.toDefault();
            this.max.toDefault();
        }
        static createfromPoints(points, out) {
            if (points == null)
                throw new Error("points");
            var min = out.min;
            var max = out.max;
            min.x = Number.MAX_VALUE;
            min.y = Number.MAX_VALUE;
            min.z = Number.MAX_VALUE;
            max.x = -Number.MAX_VALUE;
            max.y = -Number.MAX_VALUE;
            max.z = -Number.MAX_VALUE;
            for (var i = 0, n = points.length; i < n; ++i) {
                Laya.Vector3.min(min, points[i], min);
                Laya.Vector3.max(max, points[i], max);
            }
        }
        static merge(box1, box2, out) {
            Laya.Vector3.min(box1.min, box2.min, out.min);
            Laya.Vector3.max(box1.max, box2.max, out.max);
        }
        cloneTo(destObject) {
            this.min.cloneTo(destObject.min);
            this.max.cloneTo(destObject.max);
        }
        clone() {
            var dest = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    const _tempVector30 = new Laya.Vector3();
    const _tempVector31$1 = new Laya.Vector3();

    class DirectionLightCom extends Light {
        get direction() {
            return this._direction;
        }
        set direction(value) {
            value.cloneTo(this.direction);
            this._dataModule.setDirection(this._direction);
        }
        ;
        get shadowCascadesMode() {
            return this._dataModule.shadowCascadesMode;
        }
        set shadowCascadesMode(value) {
            this._dataModule.shadowCascadesMode = value;
        }
        get shadowTwoCascadeSplits() {
            return this._dataModule.shadowTwoCascadeSplits;
        }
        set shadowTwoCascadeSplits(value) {
            this._dataModule.shadowTwoCascadeSplits = value;
        }
        get shadowFourCascadeSplits() {
            return this._shadowFourCascadeSplits;
        }
        set shadowFourCascadeSplits(value) {
            if (value.x > value.y || value.y > value.z || value.z > 1.0)
                throw "DiretionLight:Invalid value.";
            value.cloneTo(this._shadowFourCascadeSplits);
            this._dataModule.setShadowFourCascadeSplits(this._shadowFourCascadeSplits);
        }
        constructor() {
            super();
            this._direction = new Laya.Vector3();
            this._shadowTwoCascadeSplits = 1.0 / 3.0;
            this._shadowFourCascadeSplits = new Laya.Vector3();
            this._lightType = exports.LightType.Directional;
            this.shadowCascadesMode = exports.ShadowCascadesMode.NoCascades;
            this.shadowFourCascadeSplits = new Laya.Vector3(1.0 / 15, 3.0 / 15.0, 7.0 / 15.0);
            this.shadowTwoCascadeSplits = 1.0 / 3.0;
        }
        _creatModuleData() {
            this._dataModule = Laya3DRender.Render3DModuleDataFactory.createDirectLight();
        }
        _addToLightQueue() {
            this.owner.scene._directionLights.add(this);
        }
        _removeFromLightQueue() {
            this.owner.scene._directionLights.remove(this);
        }
    }

    class PointLightCom extends Light {
        get range() {
            return this._range;
        }
        set range(value) {
            this._range = value;
            this._dataModule.range = value;
        }
        constructor() {
            super();
            this._lightType = exports.LightType.Point;
            this.range = 6.0;
        }
        _creatModuleData() {
            this._dataModule = Laya3DRender.Render3DModuleDataFactory.createPointLight();
        }
        _addToLightQueue() {
            this.owner.scene._pointLights.add(this);
        }
        _removeFromLightQueue() {
            this.owner.scene._pointLights.remove(this);
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest.range = this.range;
            dest._lightType = exports.LightType.Point;
        }
    }

    class SpotLightCom extends Light {
        get direction() {
            return this._direction;
        }
        set direction(value) {
            value.cloneTo(this.direction);
            this._dataModule.setDirection(this._direction);
        }
        ;
        get spotAngle() {
            return this._dataModule.spotAngle;
        }
        set spotAngle(value) {
            this._dataModule.spotAngle = Math.max(Math.min(value, 179), 0);
        }
        get range() {
            return this._dataModule.spotRange;
        }
        set range(value) {
            this._dataModule.spotRange = value;
        }
        constructor() {
            super();
            this.spotAngle = 30.0;
            this.range = 10.0;
            this._direction = new Laya.Vector3();
            this._lightType = exports.LightType.Spot;
        }
        _creatModuleData() {
            this._dataModule = Laya3DRender.Render3DModuleDataFactory.createSpotLight();
        }
        _addToLightQueue() {
            this.owner.scene._spotLights.add(this);
        }
        _removeFromLightQueue() {
            this.owner.scene._spotLights.remove(this);
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest.range = this.range;
            dest.spotAngle = this.spotAngle;
        }
    }

    exports.AreaShape = void 0;
    (function (AreaShape) {
        AreaShape[AreaShape["rectangle"] = 0] = "rectangle";
        AreaShape[AreaShape["ellipse"] = 1] = "ellipse";
    })(exports.AreaShape || (exports.AreaShape = {}));
    class AreaLightCom extends Light {
        constructor() {
            super();
            this._lightType = exports.LightType.Area;
            this._lightmapBakedType = exports.LightMode.bakeOnly;
            this._spread = 90;
            this._maxBounces = 1024;
            this._size = new Laya.Vector2(1, 1);
            this._areaShape = exports.AreaShape.rectangle;
            this._power = 100;
        }
        _creatModuleData() {
            this._dataModule = {
                transform: null,
                range: 0,
                shadowResolution: 1,
                shadowDistance: 1,
                shadowMode: null,
                shadowStrength: 1,
                shadowDepthBias: 1,
                shadowNormalBias: 1,
                shadowNearPlane: 1
            };
        }
        get lightmapBakedType() {
            return exports.LightMode.bakeOnly;
        }
        set lightmapBakedType(value) {
            this._lightmapBakedType = exports.LightMode.bakeOnly;
        }
        get shape() {
            return this._areaShape;
        }
        set shape(value) {
            this._areaShape = value;
        }
        get power() {
            return this._power;
        }
        set power(value) {
            this._power = value;
        }
        get size() {
            return this._size;
        }
        set size(value) {
            value && value.cloneTo(this._size);
        }
        get spread() {
            return this._spread;
        }
        set spread(value) {
            this._spread = Math.min((Math.max(0, value)), 180);
        }
        get maxBounces() {
            return this._maxBounces;
        }
        set maxBounces(value) {
            this._maxBounces = value;
        }
        _addToLightQueue() {
        }
        _removeFromLightQueue() {
        }
    }

    const tempVec$3 = new Laya.Vector3();
    class LODInfo {
        constructor(mincullRate) {
            this._mincullRate = mincullRate;
            this._renders = [];
            this._cachSprite3D = [];
        }
        get mincullRate() {
            return this._mincullRate;
        }
        set mincullRate(value) {
            this._mincullRate = value;
        }
        set group(value) {
            if (value == this._group)
                return;
            if (this._group) {
                for (let i = 0, n = this._renders.length; i < n; i++) {
                    let element = this._renders[i];
                    element.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this._group._updateRecaculateFlag);
                    element._LOD = -1;
                }
            }
            this._group = value;
            for (let i = 0, n = this._renders.length; i < n; i++) {
                let element = this._renders[i];
                element.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this._group, this._group._updateRecaculateFlag);
                element._LOD = this._lodIndex;
            }
        }
        get renders() {
            return this._cachSprite3D;
        }
        set renders(value) {
            this._cachSprite3D = value;
            for (var i = 0, n = value.length; i < n; i++) {
                this.addNode(value[i]);
            }
        }
        addNode(node) {
            if (!node)
                return;
            let ren = node;
            if (ren._isRenderNode > 0) {
                let components = ren.components;
                for (let comp of components) {
                    if ((comp instanceof BaseRender) && this._renders.indexOf(comp) == -1)
                        this._renders.push(comp);
                }
                this._group && node.transform.on(Laya.Event.TRANSFORM_CHANGED, this._group, this._group._updateRecaculateFlag);
            }
            for (var i = 0, n = node.numChildren; i < n; i++) {
                this.addNode(node.getChildAt(i));
            }
        }
        removeNode(node) {
            let ren = node;
            if (ren._isRenderNode > 0) {
                let components = ren.components;
                let index;
                for (let comp of components) {
                    if ((comp instanceof BaseRender) && (index = this._renders.indexOf(comp)) == -1) {
                        this._renders.splice(index, 1);
                        comp.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, false);
                        this._group && node.transform.off(Laya.Event.TRANSFORM_CHANGED, this._group._updateRecaculateFlag);
                    }
                }
            }
            for (var i = 0, n = node.numChildren; i < n; i++) {
                this.removeNode(node.getChildAt(i));
            }
        }
        removeAllRender() {
            this._renders.forEach(element => {
                element.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, false);
            });
        }
    }
    class LODGroup extends Laya.Component {
        constructor() {
            super();
            this._needcaculateBounds = false;
            this._lods = [];
            this._visialIndex = -1;
            this._bounds = new Bounds();
            this._lodPosition = new Laya.Vector3();
            this.runInEditor = true;
        }
        shadowCullPass() {
            return false;
        }
        get visialIndex() {
            return this._visialIndex;
        }
        get lods() {
            return this._lods;
        }
        set lods(data) {
            this._lods = data;
            for (var i = 0, n = this._lods.length; i < n; i++) {
                let element = this._lods[i];
                element._lodIndex = i;
                element.group = this;
            }
            this._updateRecaculateFlag();
            this._lodCount = this._lods.length;
        }
        get nowRate() {
            return this._nowRate;
        }
        get bounds() {
            this.recalculateBounds();
            return this._bounds;
        }
        _onEnable() {
            super._onEnable();
            for (var i = 0, n = this._lods.length; i < n; i++) {
                this._setLODinvisible(i);
            }
            this._visialIndex = -1;
            this._applyVisibleRate(1);
        }
        _onDisable() {
            super._onDisable();
            this._lods.forEach(element => {
                element.removeAllRender();
            });
        }
        _applyVisibleRate(rate) {
            for (var i = 0; i < this._lodCount; i++) {
                let lod = this._lods[i];
                if (rate > lod.mincullRate) {
                    if (i == -1) {
                        this._setLODvisible(i);
                        this._visialIndex = i;
                        return;
                    }
                    if (i == this._visialIndex)
                        return;
                    else {
                        (this._visialIndex != -1) && this._setLODinvisible(this._visialIndex);
                        this._setLODvisible(i);
                        this._visialIndex = i;
                        return;
                    }
                }
            }
            if (this._visialIndex != -1) {
                this._setLODinvisible(this._visialIndex);
                this._visialIndex = -1;
            }
        }
        _setLODvisible(index) {
            let lod = this._lods[index];
            for (var i = 0, n = lod._renders.length; i < n; i++) {
                lod._renders[i].setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, false);
            }
        }
        _setLODinvisible(index) {
            let lod = this._lods[index];
            for (var i = 0, n = lod._renders.length; i < n; i++) {
                lod._renders[i].setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_CullFlag, true);
            }
        }
        onDestroy() {
            this._lods.forEach(element => {
                let renderarray = element._renders;
                for (var i = 0; i < renderarray.length; i++) {
                    element.removeNode(renderarray[i].owner);
                }
            });
        }
        _updateRecaculateFlag() {
            this._needcaculateBounds = true;
        }
        _cloneTo(lodGroup) {
            super._cloneTo(lodGroup);
            let getCommomParent = (rootNode, rootCheckNode) => {
                let nodeArray = [];
                let node = rootNode;
                while (!!node) {
                    if (node instanceof Sprite3D)
                        nodeArray.push(node);
                    node = node.parent;
                }
                let checkNode = rootCheckNode;
                while (!!checkNode && nodeArray.indexOf(checkNode) == -1) {
                    checkNode = checkNode.parent;
                }
                return checkNode;
            };
            let cloneHierachFun = (rootNode, rootCheckNode, destNode) => {
                let rootparent = getCommomParent(rootNode, rootCheckNode);
                if (!rootparent)
                    return null;
                let path = [];
                Utils3D._getHierarchyPath(rootparent, rootNode, path);
                let pathcheck = [];
                Utils3D._getHierarchyPath(rootparent, rootCheckNode, pathcheck);
                let destParent = Utils3D._getParentNodeByHierarchyPath(destNode, path);
                if (!destParent)
                    return null;
                return Utils3D._getNodeByHierarchyPath(destParent, pathcheck);
            };
            let lodArray = [];
            for (let i = 0, n = this._lodCount; i < n; i++) {
                let lod = this._lods[i];
                let cloneLOD = new LODInfo(lod.mincullRate);
                lodArray.push(cloneLOD);
                lod._renders.forEach(element => {
                    let node = cloneHierachFun(this.owner, element.owner, lodGroup.owner);
                    if (node)
                        cloneLOD.addNode(node);
                });
            }
            lodGroup.lods = lodArray;
        }
        recalculateBounds() {
            if (!this._needcaculateBounds) {
                return;
            }
            let firstBounds = true;
            for (let i = 0, n = this._lods.length; i < n; i++) {
                let lod = this._lods[i];
                lod._renders.forEach(element => {
                    if (firstBounds) {
                        element.bounds.cloneTo(this._bounds);
                        firstBounds = false;
                    }
                    else
                        Bounds.merge(this._bounds, element.bounds, this._bounds);
                });
            }
            this._lodPosition = this._bounds._imp.getCenter();
            let extend = this._bounds.getExtent();
            this._size = 2 * Math.max(extend.x, extend.y, extend.z);
            this._needcaculateBounds = false;
        }
        onPreRender() {
            this.recalculateBounds();
            let checkCamera = this.owner.scene.cullInfoCamera;
            let maxYDistance = checkCamera.maxlocalYDistance;
            let cameraFrustum = checkCamera.boundFrustum;
            Laya.Vector3.subtract(this._lodPosition, checkCamera.transform.position, tempVec$3);
            let length = tempVec$3.length();
            if (length > checkCamera.farPlane || cameraFrustum.containsPoint(this._lodPosition) == 0) {
                return;
            }
            let rateYDistance = length / checkCamera.farPlane * maxYDistance;
            let rate = (this._size / rateYDistance);
            this._nowRate = rate;
            this._applyVisibleRate(rate);
        }
    }

    class PixelLineData {
        constructor() {
            this.startPosition = new Laya.Vector3();
            this.endPosition = new Laya.Vector3();
            this.startColor = new Laya.Color();
            this.endColor = new Laya.Color();
            this.startNormal = new Laya.Vector3();
            this.endNormal = new Laya.Vector3();
        }
        cloneTo(destObject) {
            this.startPosition.cloneTo(destObject.startPosition);
            this.endPosition.cloneTo(destObject.endPosition);
            this.startColor.cloneTo(destObject.startColor);
            this.endColor.cloneTo(destObject.endColor);
            this.startNormal.cloneTo(destObject.startPosition);
            this.endNormal.cloneTo(destObject.endPosition);
        }
    }

    class PixelLineFilter extends GeometryElement {
        constructor(owner, maxLineCount) {
            super(Laya.MeshTopology.Lines, Laya.DrawType.DrawArray);
            this._floatCountPerVertices = 10;
            this._minUpdate = Number.MAX_VALUE;
            this._maxUpdate = Number.MIN_VALUE;
            this._floatBound = new Float32Array(6);
            this._calculateBound = true;
            this._maxLineCount = 0;
            this._lineCount = 0;
            var pointCount = maxLineCount * 2;
            this._ownerRender = owner;
            this._maxLineCount = maxLineCount;
            this._vertices = new Float32Array(pointCount * this._floatCountPerVertices);
            this._vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, Laya.BufferUsage.Static, false);
            this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration;
            var bufferState = new Laya.BufferState();
            this.bufferState = bufferState;
            this.bufferState.applyState([this._vertexBuffer], null);
            var min = _tempVector0;
            var max = _tempVector1;
            min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._bounds = new Bounds(min, max);
        }
        _getType() {
            return PixelLineFilter._type;
        }
        _resizeLineData(maxCount) {
            var pointCount = maxCount * 2;
            var lastVertices = this._vertices;
            this._vertexBuffer.destroy();
            this._maxLineCount = maxCount;
            var vertexCount = pointCount * this._floatCountPerVertices;
            this._vertices = new Float32Array(vertexCount);
            this._vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(PixelLineVertex.vertexDeclaration.vertexStride * pointCount, Laya.BufferUsage.Static, false);
            this._vertexBuffer.vertexDeclaration = PixelLineVertex.vertexDeclaration;
            if (vertexCount < lastVertices.length) {
                this._vertices.set(new Float32Array(lastVertices.buffer, 0, vertexCount));
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, vertexCount * 4);
            }
            else {
                this._vertices.set(lastVertices);
                this._vertexBuffer.setData(this._vertices.buffer, 0, 0, lastVertices.length * 4);
            }
            this.bufferState.applyState([this._vertexBuffer], null);
            this._minUpdate = Number.MAX_VALUE;
            this._maxUpdate = Number.MIN_VALUE;
        }
        _updateLineVertices(offset, startPosition, endPosition, startColor, endColor, startNormal = null, endNormal = null) {
            if (startPosition) {
                this._vertices[offset + 0] = startPosition.x;
                this._vertices[offset + 1] = startPosition.y;
                this._vertices[offset + 2] = startPosition.z;
            }
            if (startColor) {
                this._vertices[offset + 3] = startColor.r;
                this._vertices[offset + 4] = startColor.g;
                this._vertices[offset + 5] = startColor.b;
                this._vertices[offset + 6] = startColor.a;
            }
            if (startNormal) {
                this._vertices[offset + 7] = startNormal.x;
                this._vertices[offset + 8] = startNormal.y;
                this._vertices[offset + 9] = startNormal.z;
            }
            if (endPosition) {
                this._vertices[offset + 10] = endPosition.x;
                this._vertices[offset + 11] = endPosition.y;
                this._vertices[offset + 12] = endPosition.z;
            }
            if (endColor) {
                this._vertices[offset + 13] = endColor.r;
                this._vertices[offset + 14] = endColor.g;
                this._vertices[offset + 15] = endColor.b;
                this._vertices[offset + 16] = endColor.a;
            }
            if (endNormal) {
                this._vertices[offset + 17] = endNormal.x;
                this._vertices[offset + 18] = endNormal.y;
                this._vertices[offset + 19] = endNormal.z;
            }
            this._minUpdate = Math.min(this._minUpdate, offset);
            this._maxUpdate = Math.max(this._maxUpdate, offset + this._floatCountPerVertices * 2);
            var bounds = this._bounds;
            var floatBound = this._floatBound;
            var min = bounds.getMin(), max = bounds.getMax();
            Laya.Vector3.min(min, startPosition, min);
            Laya.Vector3.min(min, endPosition, min);
            Laya.Vector3.max(max, startPosition, max);
            Laya.Vector3.max(max, endPosition, max);
            bounds.setMin(min);
            bounds.setMax(max);
            floatBound[0] = min.x, floatBound[1] = min.y, floatBound[2] = min.z;
            floatBound[3] = max.x, floatBound[4] = max.y, floatBound[5] = max.z;
            this._ownerRender.boundsChange = true;
        }
        _reCalculateBound() {
            if (this._calculateBound) {
                var vertices = this._vertices;
                var min = _tempVector0;
                var max = _tempVector1;
                min.setValue(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                max.setValue(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                for (var i = 0; i < this._lineCount * 2; ++i) {
                    var offset = this._floatCountPerVertices * i;
                    var x = vertices[offset + 0], y = vertices[offset + 1], z = vertices[offset + 2];
                    min.x = Math.min(x, min.x);
                    min.y = Math.min(y, min.y);
                    min.z = Math.min(z, min.z);
                    max.x = Math.max(x, max.x);
                    max.y = Math.max(y, max.y);
                    max.z = Math.max(z, max.z);
                }
                this._bounds.setMin(min);
                this._bounds.setMax(max);
                var floatBound = this._floatBound;
                floatBound[0] = min.x, floatBound[1] = min.y, floatBound[2] = min.z;
                floatBound[3] = max.x, floatBound[4] = max.y, floatBound[5] = max.z;
                this._calculateBound = false;
            }
        }
        _removeLineData(index) {
            var floatCount = this._floatCountPerVertices * 2;
            var nextIndex = index + 1;
            var offset = index * floatCount;
            var vertices = this._vertices;
            var rightPartVertices = new Float32Array(vertices.buffer, nextIndex * floatCount * 4, (this._lineCount - nextIndex) * floatCount);
            vertices.set(rightPartVertices, offset);
            this._minUpdate = Math.min(this._minUpdate, offset);
            this._maxUpdate = Math.max(this._maxUpdate, offset + rightPartVertices.length);
            this._lineCount--;
            var floatBound = this._floatBound;
            var startX = vertices[offset], startY = vertices[offset + 1], startZ = vertices[offset + 2];
            var endX = vertices[offset + 7], endY = vertices[offset + 8], endZ = vertices[offset + 9];
            var minX = floatBound[0], minY = floatBound[1], minZ = floatBound[2];
            var maxX = floatBound[3], maxY = floatBound[4], maxZ = floatBound[5];
            if ((startX === minX) || (startX === maxX) || (startY === minY) || (startY === maxY) || (startZ === minZ) || (startZ === maxZ) ||
                (endX === minX) || (endX === maxX) || (endY === minY) || (endY === maxY) || (endZ === minZ) || (endZ === maxZ))
                this._calculateBound = true;
        }
        _updateLineData(index, startPosition, endPosition, startColor, endColor, startNormal = null, endNormal = null) {
            var floatCount = this._floatCountPerVertices * 2;
            this._updateLineVertices(index * floatCount, startPosition, endPosition, startColor, endColor, startNormal, endNormal);
            this._calculateBound = true;
        }
        _updateLineDatas(index, data) {
            var floatCount = this._floatCountPerVertices * 2;
            var count = data.length;
            for (var i = 0; i < count; i++) {
                var line = data[i];
                this._updateLineVertices((index + i) * floatCount, line.startPosition, line.endPosition, line.startColor, line.endColor, line.startNormal, line.endNormal);
            }
            this._calculateBound = data.length > 0;
        }
        _getLineData(index, out) {
            var startPosition = out.startPosition;
            var startColor = out.startColor;
            var endPosition = out.endPosition;
            var endColor = out.endColor;
            var startNormal = out.startNormal;
            var endNormal = out.endNormal;
            var vertices = this._vertices;
            var offset = index * this._floatCountPerVertices * 2;
            startPosition.x = vertices[offset + 0];
            startPosition.y = vertices[offset + 1];
            startPosition.z = vertices[offset + 2];
            startColor.r = vertices[offset + 3];
            startColor.g = vertices[offset + 4];
            startColor.b = vertices[offset + 5];
            startColor.a = vertices[offset + 6];
            startNormal.x = vertices[offset + 7];
            startNormal.y = vertices[offset + 8];
            startNormal.z = vertices[offset + 9];
            endPosition.x = vertices[offset + 10];
            endPosition.y = vertices[offset + 11];
            endPosition.z = vertices[offset + 12];
            endColor.r = vertices[offset + 13];
            endColor.g = vertices[offset + 14];
            endColor.b = vertices[offset + 15];
            endColor.a = vertices[offset + 16];
            endNormal.x = vertices[offset + 17];
            endNormal.y = vertices[offset + 18];
            endNormal.z = vertices[offset + 19];
        }
        _prepareRender(state) {
            return true;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            if (this._minUpdate !== Number.MAX_VALUE && this._maxUpdate !== Number.MIN_VALUE) {
                this._vertexBuffer.setData(this._vertices.buffer, this._minUpdate * 4, this._minUpdate * 4, (this._maxUpdate - this._minUpdate) * 4);
                this._minUpdate = Number.MAX_VALUE;
                this._maxUpdate = Number.MIN_VALUE;
            }
            if (this._lineCount > 0) {
                this.setDrawArrayParams(0, this._lineCount * 2);
            }
        }
        destroy() {
            if (this._destroyed)
                return;
            super.destroy();
            this.bufferState.destroy();
            this._vertexBuffer.destroy();
            this._bufferState = null;
            this._vertexBuffer = null;
            this._vertices = null;
        }
    }
    PixelLineFilter._type = GeometryElement._typeCounter++;
    const _tempVector0 = new Laya.Vector3();
    const _tempVector1 = new Laya.Vector3();

    class PixelLineRenderer extends BaseRender {
        constructor() {
            super();
            this._isRenderActive = false;
            this._isInRenders = false;
            this._needUpdatelines = false;
            this._lines = [];
            this._projectionViewWorldMatrix = new Laya.Matrix4x4();
            this._pixelLineFilter = new PixelLineFilter(this, 20);
            this._baseRenderNode.shaderData.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
            this.geometryBounds = this._pixelLineFilter._bounds;
        }
        get bounds() {
            var lineFilter = this._pixelLineFilter;
            lineFilter._reCalculateBound();
            return super.bounds;
        }
        get pixelLinesDatas() {
            if (this._needUpdatelines) {
                this._updateLineDatas();
            }
            return this._lines;
        }
        set pixelLinesDatas(value) {
            this.clear();
            if (value.length > this._pixelLineFilter._maxLineCount) {
                value = value.slice(0, this._pixelLineFilter._maxLineCount);
                console.warn("reach max line count");
            }
            this.addLines(value);
        }
        get maxLineCount() {
            return this._pixelLineFilter._maxLineCount;
        }
        set maxLineCount(value) {
            this._pixelLineFilter._resizeLineData(value);
            this._pixelLineFilter._lineCount = Math.min(this._pixelLineFilter._lineCount, value);
        }
        get lineCount() {
            return this._pixelLineFilter._lineCount;
        }
        _onAdded() {
            super._onAdded();
            this._changeRenderObjects(0, PixelLineMaterial.defaultMaterial);
        }
        _onEnable() {
            this._isRenderActive = true;
            if (this._pixelLineFilter._lineCount != 0) {
                (this.owner.scene)._addRenderObject(this);
                this._isInRenders = true;
            }
            this._setBelongScene(this.owner.scene);
        }
        _onDisable() {
            if (this._pixelLineFilter && this._pixelLineFilter._lineCount != 0 && this._isRenderActive) {
                this.owner.scene._removeRenderObject(this);
                this._isInRenders = false;
            }
            this._isRenderActive = false;
            this._setUnBelongScene();
        }
        _createBaseRenderNode() {
            return Laya3DRender.Render3DModuleDataFactory.createMeshRenderNode();
        }
        renderUpdate(context) {
            this._renderElements.forEach((element, index) => {
                var _a, _b;
                element._renderElementOBJ.isRender = element._geometry._prepareRender(context);
                element._geometry._updateRenderParams(context);
                let material = (_a = this.sharedMaterial) !== null && _a !== void 0 ? _a : UnlitMaterial.defaultMaterial;
                material = (_b = this.sharedMaterials[index]) !== null && _b !== void 0 ? _b : material;
                element.material = material;
                element._renderElementOBJ.materialRenderQueue = material.renderQueue;
            });
        }
        _changeRenderObjects(index, material) {
            var renderObjects = this._renderElements;
            (material) || (material = PixelLineMaterial.defaultMaterial);
            var renderElement = renderObjects[index];
            (renderElement) || (renderElement = renderObjects[index] = new RenderElement());
            renderElement.setTransform(this.owner._transform);
            renderElement.setGeometry(this._pixelLineFilter);
            renderElement.render = this;
            renderElement.material = material;
            this._setRenderElements();
        }
        _pixelLinesDataChange(key) {
            if (key != null) {
                let keyN = parseInt(key);
                let line = this._lines[keyN];
                if (line) {
                    this.setLine(keyN, line.startPosition, line.endPosition, line.startColor, line.endColor);
                }
            }
        }
        addLine(startPosition, endPosition, startColor, endColor) {
            if (this._pixelLineFilter._lineCount !== this._pixelLineFilter._maxLineCount) {
                this._pixelLineFilter._updateLineData(this._pixelLineFilter._lineCount++, startPosition, endPosition, startColor, endColor);
            }
            else {
                throw new Error("reach max line count");
            }
            if (this._isRenderActive && !this._isInRenders && this._pixelLineFilter._lineCount > 0) {
                this.owner.scene && this.owner.scene._addRenderObject(this);
                this._isInRenders = true;
            }
            this._needUpdatelines = true;
        }
        addLineWithNormal(startPosition, endPosition, startColor, endColor, startNormal, endNormal) {
            if (this._pixelLineFilter._lineCount !== this._pixelLineFilter._maxLineCount) {
                this._pixelLineFilter._updateLineData(this._pixelLineFilter._lineCount++, startPosition, endPosition, startColor, endColor, startNormal, endNormal);
            }
            else {
                throw new Error("reach max line count");
            }
            if (this._isRenderActive && !this._isInRenders && this._pixelLineFilter._lineCount > 0) {
                this.owner.scene && this.owner.scene._addRenderObject(this);
                this._isInRenders = true;
            }
            this._needUpdatelines = true;
        }
        addLines(lines) {
            var lineCount = this._pixelLineFilter._lineCount;
            var addCount = lines.length;
            if (lineCount + addCount > this._pixelLineFilter._maxLineCount) {
                throw new Error("reach max line count");
            }
            else {
                this._pixelLineFilter._updateLineDatas(lineCount, lines);
                this._pixelLineFilter._lineCount += addCount;
                this.boundsChange = true;
            }
            if (this._isRenderActive && !this._isInRenders && this._pixelLineFilter._lineCount > 0) {
                this.owner.scene && this.owner.scene._addRenderObject(this);
                this._isInRenders = true;
            }
            this._needUpdatelines = true;
        }
        removeLine(index) {
            if (index < this._pixelLineFilter._lineCount)
                this._pixelLineFilter._removeLineData(index);
            else
                throw new Laya.OutOfRangeError(index);
            if (this._isRenderActive && this._isInRenders && this._pixelLineFilter._lineCount == 0) {
                this.owner.scene && this.owner.scene._removeRenderObject(this);
                this._isInRenders = false;
            }
            this._needUpdatelines = true;
        }
        setLine(index, startPosition, endPosition, startColor, endColor) {
            if (index < this._pixelLineFilter._lineCount) {
                this._pixelLineFilter._updateLineData(index, startPosition, endPosition, startColor, endColor);
                let pixeldata = this._lines[index];
                if (pixeldata) {
                    startColor.cloneTo(pixeldata.startColor);
                    endColor.cloneTo(pixeldata.endColor);
                    startPosition.cloneTo(pixeldata.startPosition);
                    endPosition.cloneTo(pixeldata.endPosition);
                }
            }
            else
                throw new Laya.OutOfRangeError(index);
        }
        setLineWithNormal(index, startPosition, endPosition, startColor, endColor, startNormal, endNormal) {
            if (index < this._pixelLineFilter._lineCount) {
                this._pixelLineFilter._updateLineData(index, startPosition, endPosition, startColor, endColor, startNormal, endNormal);
                let pixeldata = this._lines[index];
                if (pixeldata) {
                    startColor.cloneTo(pixeldata.startColor);
                    endColor.cloneTo(pixeldata.endColor);
                    startPosition.cloneTo(pixeldata.startPosition);
                    endPosition.cloneTo(pixeldata.endPosition);
                    startNormal && startNormal.cloneTo(pixeldata.startNormal);
                    endNormal && endNormal.cloneTo(pixeldata.endNormal);
                }
            }
            else
                throw new Laya.OutOfRangeError(index);
        }
        getLine(index, out) {
            if (index < this.lineCount)
                this._pixelLineFilter._getLineData(index, out);
            else
                throw new Laya.OutOfRangeError(index);
        }
        _updateLineDatas() {
            let n = this.lineCount;
            this._lines = [];
            for (let i = 0; i < n; i++) {
                let pixelLineDatas = new PixelLineData();
                this.getLine(i, pixelLineDatas);
                this._lines.push(pixelLineDatas);
            }
            this._needUpdatelines = false;
        }
        clear() {
            this._pixelLineFilter._lineCount = 0;
            if (this._isRenderActive && this._isInRenders) {
                this.owner.scene && this.owner.scene._removeRenderObject(this);
                this._isInRenders = false;
            }
        }
        _onDestroy() {
            this._pixelLineFilter.destroy();
            this._pixelLineFilter = null;
            super._onDestroy();
        }
        _cloneTo(dest) {
            super._cloneTo(dest);
            dest.maxLineCount = this.maxLineCount;
            const lineCount = this.lineCount;
            let linedata = new PixelLineData();
            for (let i = 0, n = lineCount; i < n; i++) {
                this.getLine(i, linedata);
                dest.addLine(linedata.startPosition, linedata.endPosition, linedata.startColor, linedata.endColor);
            }
        }
    }

    class AnimatorPlayState {
        get currentState() {
            return this._currentState;
        }
        set currentState(value) {
            this._currentState = value;
            this._currentState.curTransition = null;
        }
        get normalizedTime() {
            return this._normalizedTime;
        }
        get duration() {
            return this._duration;
        }
        get animatorState() {
            return this._currentState;
        }
        constructor() {
            this._currentState = null;
        }
        _resetPlayState(startTime, clipDuration) {
            this._finish = false;
            this._playEventIndex = 0;
            this._startPlayTime = startTime;
            this._elapsedTime = startTime;
            this._lastIsFront = true;
            this._normalizedTime = this._elapsedTime / clipDuration;
            var playTime = this._normalizedTime % 1.0;
            this._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
        }
        _cloneTo(dest) {
            dest._finish = this._finish;
            dest._startPlayTime = this._startPlayTime;
            dest._playEventIndex = this._playEventIndex;
            dest._elapsedTime = this._elapsedTime;
            dest._normalizedTime = this._normalizedTime;
            dest._normalizedPlayTime = this._normalizedPlayTime;
            dest._lastIsFront = this._lastIsFront;
        }
    }

    class AnimatorControllerLayer {
        get defaultState() {
            return this._defaultState;
        }
        set defaultState(value) {
            this._defaultState = value;
        }
        get avatarMask() {
            return this._avatarMask;
        }
        set avatarMask(value) {
            this._avatarMask = value;
        }
        get defaultStateName() {
            if (!this._defaultState) {
                return null;
            }
            return this._defaultState.name;
        }
        set defaultStateName(value) {
            this._defaultState = this.getAnimatorState(value);
            if (null == this._defaultState) {
                if (0 == this._states.length) {
                    this._defaultStateNameCatch = value;
                }
                else {
                    for (var i = this._states.length - 1; i >= 0; i--) {
                        if (this._states[i].name == value) {
                            this._defaultState = this._states[i];
                            break;
                        }
                    }
                }
            }
        }
        get states() {
            return this._states;
        }
        set states(states) {
            if (this._states === states)
                return;
            if (this._states.length > 0) {
                let removed = this._states.filter(s => states.indexOf(s) == -1);
                for (let state of removed)
                    this.removeState(state);
            }
            if (states.length > 0) {
                let newAdded = states.filter(s => this._states.indexOf(s) == -1);
                for (let state of newAdded)
                    this.addState(state);
            }
            this._states.length = 0;
            this._states.push(...states);
        }
        constructor(name) {
            this._referenceCount = 0;
            this._playType = -1;
            this._crossDuration = -1;
            this._crossMark = 0;
            this._crossNodesOwnersCount = 0;
            this._crossNodesOwners = [];
            this._crossNodesOwnersIndicesMap = {};
            this._srcCrossClipNodeIndices = [];
            this._destCrossClipNodeIndices = [];
            this._states = [];
            this._playStateInfo = new AnimatorPlayState();
            this._crossPlayStateInfo = new AnimatorPlayState();
            this.blendingMode = AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            this.defaultWeight = 1.0;
            this.playOnWake = true;
            this.enable = true;
            this.name = name;
        }
        _removeClip(clipStateInfos, index, state) {
            var clip = state._clip;
            var clipStateInfo = clipStateInfos[index];
            clipStateInfos.splice(index, 1);
            if (this._animator) {
                var frameNodes = clip._nodes;
                var nodeOwners = clipStateInfo._nodeOwners;
                clip._removeReference();
                for (var i = 0, n = frameNodes.count; i < n; i++)
                    this._animator._removeKeyframeNodeOwner(nodeOwners, frameNodes.getNodeByIndex(i));
            }
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._addReference(count);
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            for (var i = 0, n = this._states.length; i < n; i++)
                this._states[i]._removeReference(count);
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        getCurrentPlayState() {
            return this._playStateInfo;
        }
        getAnimatorState(name) {
            var state;
            for (let i = 0; i < this._states.length; i++) {
                if (this._states[i].name == name) {
                    state = this._states[i];
                    break;
                }
            }
            return state ? state : null;
        }
        addState(state) {
            var stateName = state.name;
            if (this.getAnimatorState(stateName)) {
                throw new Error("AnimatorControllerLayer:this stat's name has exist.");
            }
            else {
                this._states.push(state);
                if (stateName == this._defaultStateNameCatch) {
                    this._defaultState = state;
                    this._defaultStateNameCatch = null;
                }
                if (this._animator) {
                    (state._clip) && (state._clip._addReference());
                    this._animator._getOwnersByClip(state);
                }
            }
        }
        removeState(state) {
            var states = this._states;
            var index = -1;
            for (var i = 0, n = states.length; i < n; i++) {
                if (states[i] === state) {
                    index = i;
                    break;
                }
            }
            if (index !== -1)
                this._removeClip(states, index, state);
        }
        destroy() {
            this._clearReference();
            this._states = [];
            this._playStateInfo = null;
            this._crossPlayStateInfo = null;
            this._defaultState = null;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.blendingMode = this.blendingMode;
            destObject.defaultWeight = this.defaultWeight;
            destObject.playOnWake = this.playOnWake;
            this.avatarMask && (destObject.avatarMask = this._avatarMask.clone());
        }
        clone() {
            var dest = new AnimatorControllerLayer(this.name);
            this.cloneTo(dest);
            return dest;
        }
    }
    AnimatorControllerLayer.BLENDINGMODE_OVERRIDE = 0;
    AnimatorControllerLayer.BLENDINGMODE_ADDTIVE = 1;

    class AnimatorResource {
        static getAnimatorResource(sprite, propertyKey) {
            switch (propertyKey) {
                case "simpleSkinnedMeshRenderer":
                    return sprite.getComponent(SimpleSkinnedMeshRenderer);
                default:
                    return sprite.getComponent(Laya.ClassUtils.getClass(propertyKey));
            }
        }
    }

    class Animator extends Laya.Component {
        get controller() {
            return this._controller;
        }
        set controller(val) {
            if (this._controller)
                this._controller._removeReference();
            this._controller = val;
            if (val) {
                val._addReference();
                val.updateTo(this);
            }
        }
        get speed() {
            return this._speed;
        }
        set speed(value) {
            this._speed = value;
        }
        set updateMode(value) {
            this._updateMode = value;
        }
        set lowUpdateDelty(value) {
            this._lowUpdateDelty = value;
        }
        get controllerLayerCount() {
            return this._controllerLayers.length;
        }
        get animatorParams() {
            return this._animatorParams;
        }
        set animatorParams(values) {
            this._animatorParams = values;
        }
        get sleep() {
            return this._finishSleep;
        }
        set sleep(value) {
            this._finishSleep = value;
        }
        constructor() {
            super();
            this._keyframeNodeOwners = [];
            this._updateMode = Laya.AnimatorUpdateMode.Normal;
            this._lowUpdateDelty = 20;
            this._animatorParams = {};
            this._linkAvatarSpritesData = {};
            this._linkAvatarSprites = [];
            this.cullingMode = Animator.CULLINGMODE_CULLCOMPLETELY;
            this._finishSleep = false;
            this._LateUpdateEvents = new Laya.Delegate();
            this._controllerLayers = [];
            this._speed = 1.0;
            this._keyframeNodeOwnerMap = {};
            this._updateMark = 0;
        }
        _addKeyframeNodeOwner(clipOwners, node, propertyOwner) {
            var nodeIndex = node._indexInList;
            var fullPath = node.fullPath;
            var keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
            let mat = false;
            if (keyframeNodeOwner) {
                keyframeNodeOwner.referenceCount++;
                clipOwners[nodeIndex] = keyframeNodeOwner;
            }
            else {
                var property = propertyOwner;
                for (var i = 0, n = node.propertyCount; i < n; i++) {
                    property = property[node.getPropertyByIndex(i)];
                    if (property instanceof Laya.Material) {
                        mat = true;
                    }
                    if (!property)
                        break;
                }
                keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath] = new KeyframeNodeOwner();
                keyframeNodeOwner.isMaterial = mat;
                keyframeNodeOwner.fullPath = fullPath;
                keyframeNodeOwner.indexInList = this._keyframeNodeOwners.length;
                keyframeNodeOwner.referenceCount = 1;
                keyframeNodeOwner.propertyOwner = propertyOwner;
                keyframeNodeOwner.nodePath = node.nodePath;
                keyframeNodeOwner.callbackFunData = node.callbackFunData;
                keyframeNodeOwner.callParams = node.callParams;
                keyframeNodeOwner.getCallbackNode();
                var propertyCount = node.propertyCount;
                var propertys = [];
                for (i = 0; i < propertyCount; i++)
                    propertys[i] = node.getPropertyByIndex(i);
                keyframeNodeOwner.property = propertys;
                keyframeNodeOwner.type = node.type;
                if (property) {
                    if (node.type === exports.KeyFrameValueType.Float || node.type === exports.KeyFrameValueType.Boolean) {
                        keyframeNodeOwner.defaultValue = property;
                    }
                    else {
                        var defaultValue = new property.constructor();
                        property.cloneTo(defaultValue);
                        keyframeNodeOwner.defaultValue = defaultValue;
                        keyframeNodeOwner.value = new property.constructor();
                        keyframeNodeOwner.crossFixedValue = new property.constructor();
                    }
                }
                this._keyframeNodeOwners.push(keyframeNodeOwner);
                clipOwners[nodeIndex] = keyframeNodeOwner;
            }
        }
        _removeKeyframeNodeOwner(nodeOwners, node) {
            var fullPath = node.fullPath;
            var keyframeNodeOwner = this._keyframeNodeOwnerMap[fullPath];
            if (keyframeNodeOwner) {
                keyframeNodeOwner.referenceCount--;
                if (keyframeNodeOwner.referenceCount === 0) {
                    delete this._keyframeNodeOwnerMap[fullPath];
                    this._keyframeNodeOwners.splice(this._keyframeNodeOwners.indexOf(keyframeNodeOwner), 1);
                }
                nodeOwners[node._indexInList] = null;
            }
        }
        _getOwnersByClip(clipStateInfo) {
            if (!clipStateInfo._clip)
                return;
            var frameNodes = clipStateInfo._clip._nodes;
            var frameNodesCount = frameNodes.count;
            var nodeOwners = clipStateInfo._nodeOwners;
            nodeOwners.length = frameNodesCount;
            for (var i = 0; i < frameNodesCount; i++) {
                var node = frameNodes.getNodeByIndex(i);
                var property = this.owner;
                for (var j = 0, m = node.ownerPathCount; j < m; j++) {
                    var ownPat = node.getOwnerPathByIndex(j);
                    if (ownPat === "") {
                        break;
                    }
                    else {
                        property = property.getChild(ownPat);
                        if (!property)
                            break;
                    }
                }
                if (property) {
                    var propertyOwner = node.propertyOwner;
                    const oriProperty = property;
                    (propertyOwner) && (property = property[propertyOwner]);
                    if (!property) {
                        property = AnimatorResource.getAnimatorResource(oriProperty, propertyOwner);
                    }
                    property && this._addKeyframeNodeOwner(nodeOwners, node, property);
                }
            }
        }
        _updatePlayer(animatorState, playState, elapsedTime, islooping, layerIndex) {
            var clipDuration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
            var lastElapsedTime = playState._elapsedTime;
            var elapsedPlaybackTime = lastElapsedTime + elapsedTime;
            playState._lastElapsedTime = lastElapsedTime;
            playState._elapsedTime = elapsedPlaybackTime;
            var normalizedTime = elapsedPlaybackTime / clipDuration;
            playState._normalizedTime = normalizedTime;
            var playTime = normalizedTime % 1.0;
            playState._normalizedPlayTime = playTime < 0 ? playTime + 1.0 : playTime;
            playState._duration = clipDuration;
            if (elapsedPlaybackTime >= clipDuration) {
                if (!islooping) {
                    playState._finish = true;
                    playState._elapsedTime = clipDuration;
                    playState._normalizedPlayTime = 1.0;
                }
                else {
                    let loopNum = Math.floor(elapsedPlaybackTime / clipDuration);
                    let pLoopNum = Math.floor(lastElapsedTime / clipDuration);
                    if (pLoopNum != loopNum) {
                        animatorState._eventLoop();
                    }
                }
            }
            (!playState._finish) && animatorState._eventStateUpdate(playState._normalizedPlayTime);
            this._applyTransition(animatorState, layerIndex, animatorState._eventtransition(playState._normalizedPlayTime, this.animatorParams));
            return;
        }
        _applyTransition(state, layerindex, transition) {
            if (!transition) {
                if (state.curTransition)
                    state.curTransition = null;
                return;
            }
            if (transition == state.curTransition)
                return;
            state.curTransition = transition;
            this._LateUpdateEvents.add(this.crossFade, this, [transition.destState.name, transition.transduration, layerindex, transition.transstartoffset]);
        }
        _updateStateFinish(animatorState, playState) {
            if (playState._finish) {
                animatorState._eventExit();
            }
        }
        _updateEventScript(stateInfo, playStateInfo) {
            if (!this.owner._getBit(Laya.NodeFlags.HAS_SCRIPT))
                return;
            let clip = stateInfo._clip;
            let events = clip._animationEvents;
            if (!events || 0 == events.length || null == playStateInfo.animatorState)
                return;
            let clipDuration = clip._duration;
            let time = playStateInfo._normalizedPlayTime * clipDuration;
            let parentPlayTime = playStateInfo._parentPlayTime;
            if (null == parentPlayTime) {
                parentPlayTime = clipDuration * playStateInfo.animatorState.clipStart;
            }
            if (time < parentPlayTime) {
                this._eventScript(events, parentPlayTime, clipDuration * playStateInfo.animatorState.clipEnd);
            }
            this._eventScript(events, parentPlayTime, time);
            playStateInfo._parentPlayTime = time;
        }
        _eventScript(events, parentPlayTime, currPlayTime) {
            let scripts = this.owner.components;
            for (let i = 0, len = events.length; i < len; i++) {
                let e = events[i];
                if (e.time > parentPlayTime && e.time <= currPlayTime) {
                    for (let j = 0, m = scripts.length; j < m; j++) {
                        let script = scripts[j];
                        if (script._isScript()) {
                            let fun = script[e.eventName];
                            (fun) && (fun.apply(script, e.params));
                        }
                    }
                }
                else if (e.time > currPlayTime) {
                    break;
                }
            }
        }
        _updateClipDatas(animatorState, addtive, playStateInfo, animatorMask = null) {
            var clip = animatorState._clip;
            var clipDuration = clip._duration;
            var curPlayTime = animatorState.clipStart * clipDuration + playStateInfo._normalizedPlayTime * playStateInfo._duration;
            var currentFrameIndices = animatorState._currentFrameIndices;
            var frontPlay = playStateInfo._elapsedTime > playStateInfo._lastElapsedTime;
            clip._evaluateClipDatasRealTime(clip._nodes, curPlayTime, currentFrameIndices, addtive, frontPlay, animatorState._realtimeDatas, animatorMask);
        }
        _applyFloat(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue += weight * data;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue = oriValue + weight * (data - oriValue);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive)
                        defaultValue = nodeOwner.defaultValue + data;
                    else
                        defaultValue = data;
                }
                else {
                    if (additive) {
                        defaultValue = nodeOwner.defaultValue + weight * (data);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue = defValue + weight * (data - defValue);
                    }
                }
            }
            return defaultValue;
        }
        _applyVec2(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.x += weight * data.x;
                    defaultValue.y += weight * data.y;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.x = oriValue.x + weight * (data.x - oriValue.x);
                    defaultValue.y = oriValue.y + weight * (data.y - oriValue.y);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + data.x;
                        defaultValue.y = nodeOwner.defaultValue.y + data.y;
                    }
                    else
                        data.cloneTo(defaultValue);
                }
                else {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + weight * (data.x);
                        defaultValue.y = nodeOwner.defaultValue.y + weight * (data.y);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.x = defValue.x + weight * (data.x - defValue.x);
                        defaultValue.y = defValue.y + weight * (data.y - defValue.y);
                    }
                }
            }
            return defaultValue;
        }
        _applyVec3(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.x += weight * data.x;
                    defaultValue.y += weight * data.y;
                    defaultValue.z += weight * data.z;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.x = oriValue.x + weight * (data.x - oriValue.x);
                    defaultValue.y = oriValue.y + weight * (data.y - oriValue.y);
                    defaultValue.z = oriValue.z + weight * (data.z - oriValue.z);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + data.x;
                        defaultValue.y = nodeOwner.defaultValue.y + data.y;
                        defaultValue.z = nodeOwner.defaultValue.z + data.z;
                    }
                    else
                        data.cloneTo(defaultValue);
                }
                else {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + weight * (data.x);
                        defaultValue.y = nodeOwner.defaultValue.y + weight * (data.y);
                        defaultValue.z = nodeOwner.defaultValue.z + weight * (data.z);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.x = defValue.x + weight * (data.x - defValue.x);
                        defaultValue.y = defValue.y + weight * (data.y - defValue.y);
                        defaultValue.z = defValue.z + weight * (data.z - defValue.z);
                    }
                }
            }
            return defaultValue;
        }
        _applyVec4(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.x += weight * data.x;
                    defaultValue.y += weight * data.y;
                    defaultValue.z += weight * data.z;
                    defaultValue.w += weight * data.w;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.x = oriValue.x + weight * (data.x - oriValue.x);
                    defaultValue.y = oriValue.y + weight * (data.y - oriValue.y);
                    defaultValue.z = oriValue.z + weight * (data.z - oriValue.z);
                    defaultValue.w = oriValue.w + weight * (data.w - oriValue.w);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + data.x;
                        defaultValue.y = nodeOwner.defaultValue.y + data.y;
                        defaultValue.z = nodeOwner.defaultValue.z + data.z;
                        defaultValue.w = nodeOwner.defaultValue.w + data.w;
                    }
                    else
                        data.cloneTo(defaultValue);
                }
                else {
                    if (additive) {
                        defaultValue.x = nodeOwner.defaultValue.x + weight * (data.x);
                        defaultValue.y = nodeOwner.defaultValue.y + weight * (data.y);
                        defaultValue.z = nodeOwner.defaultValue.z + weight * (data.z);
                        defaultValue.w = nodeOwner.defaultValue.w + weight * (data.w);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.x = defValue.x + weight * (data.x - defValue.x);
                        defaultValue.y = defValue.y + weight * (data.y - defValue.y);
                        defaultValue.z = defValue.z + weight * (data.z - defValue.z);
                        defaultValue.w = defValue.w + weight * (data.w - defValue.w);
                    }
                }
            }
            return defaultValue;
        }
        _applyColor(defaultValue, nodeOwner, additive, weight, isFirstLayer, data) {
            if (!defaultValue)
                return null;
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    defaultValue.r += weight * data.x;
                    defaultValue.g += weight * data.y;
                    defaultValue.b += weight * data.z;
                    defaultValue.a += weight * data.w;
                }
                else {
                    var oriValue = defaultValue;
                    defaultValue.r = oriValue.r + weight * (data.x - oriValue.r);
                    defaultValue.g = oriValue.g + weight * (data.y - oriValue.g);
                    defaultValue.b = oriValue.b + weight * (data.z - oriValue.b);
                    defaultValue.a = oriValue.a + weight * (data.w - oriValue.a);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        defaultValue.r = nodeOwner.defaultValue.r + data.x;
                        defaultValue.g = nodeOwner.defaultValue.g + data.y;
                        defaultValue.b = nodeOwner.defaultValue.b + data.z;
                        defaultValue.a = nodeOwner.defaultValue.a + data.w;
                    }
                    else {
                        defaultValue.setValue(data.x, data.y, data.z, data.w);
                    }
                }
                else {
                    if (additive) {
                        defaultValue.r = nodeOwner.defaultValue.r + weight * (data.x);
                        defaultValue.g = nodeOwner.defaultValue.g + weight * (data.y);
                        defaultValue.b = nodeOwner.defaultValue.b + weight * (data.z);
                        defaultValue.a = nodeOwner.defaultValue.a + weight * (data.w);
                    }
                    else {
                        var defValue = nodeOwner.defaultValue;
                        defaultValue.r = defValue.r + weight * (data.x - defValue.r);
                        defaultValue.g = defValue.g + weight * (data.y - defValue.g);
                        defaultValue.b = defValue.b + weight * (data.z - defValue.b);
                        defaultValue.a = defValue.a + weight * (data.w - defValue.a);
                    }
                }
            }
            return defaultValue;
        }
        _applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, data, out) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    out.x += weight * data.x;
                    out.y += weight * data.y;
                    out.z += weight * data.z;
                }
                else {
                    var oriX = out.x;
                    var oriY = out.y;
                    var oriZ = out.z;
                    out.x = oriX + weight * (data.x - oriX);
                    out.y = oriY + weight * (data.y - oriY);
                    out.z = oriZ + weight * (data.z - oriZ);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        var defValue = nodeOwner.defaultValue;
                        out.x = defValue.x + data.x;
                        out.y = defValue.y + data.y;
                        out.z = defValue.z + data.z;
                    }
                    else {
                        out.x = data.x;
                        out.y = data.y;
                        out.z = data.z;
                    }
                }
                else {
                    defValue = nodeOwner.defaultValue;
                    if (additive) {
                        out.x = defValue.x + weight * data.x;
                        out.y = defValue.y + weight * data.y;
                        out.z = defValue.z + weight * data.z;
                    }
                    else {
                        var defX = defValue.x;
                        var defY = defValue.y;
                        var defZ = defValue.z;
                        out.x = defX + weight * (data.x - defX);
                        out.y = defY + weight * (data.y - defY);
                        out.z = defZ + weight * (data.z - defZ);
                    }
                }
            }
        }
        _applyRotation(nodeOwner, additive, weight, isFirstLayer, clipRot, localRotation) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    Utils3D.quaternionWeight(clipRot, weight, _tempQuaternion1);
                    _tempQuaternion1.normalize(_tempQuaternion1);
                    Laya.Quaternion.multiply(localRotation, _tempQuaternion1, localRotation);
                }
                else {
                    Laya.Quaternion.lerp(localRotation, clipRot, weight, localRotation);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        var defaultRot = nodeOwner.defaultValue;
                        Laya.Quaternion.multiply(defaultRot, clipRot, localRotation);
                    }
                    else {
                        localRotation.x = clipRot.x;
                        localRotation.y = clipRot.y;
                        localRotation.z = clipRot.z;
                        localRotation.w = clipRot.w;
                    }
                }
                else {
                    defaultRot = nodeOwner.defaultValue;
                    if (additive) {
                        Utils3D.quaternionWeight(clipRot, weight, _tempQuaternion1);
                        _tempQuaternion1.normalize(_tempQuaternion1);
                        Laya.Quaternion.multiply(defaultRot, _tempQuaternion1, localRotation);
                    }
                    else {
                        Laya.Quaternion.lerp(defaultRot, clipRot, weight, localRotation);
                    }
                }
            }
        }
        _applyScale(nodeOwner, additive, weight, isFirstLayer, clipSca, localScale) {
            if (nodeOwner.updateMark === this._updateMark) {
                if (additive) {
                    Utils3D.scaleWeight(clipSca, weight, _tempVector31);
                    localScale.x = localScale.x * _tempVector31.x;
                    localScale.y = localScale.y * _tempVector31.y;
                    localScale.z = localScale.z * _tempVector31.z;
                }
                else {
                    Utils3D.scaleBlend(localScale, clipSca, weight, localScale);
                }
            }
            else {
                if (isFirstLayer) {
                    if (additive) {
                        var defaultSca = nodeOwner.defaultValue;
                        localScale.x = defaultSca.x * clipSca.x;
                        localScale.y = defaultSca.y * clipSca.y;
                        localScale.z = defaultSca.z * clipSca.z;
                    }
                    else {
                        localScale.x = clipSca.x;
                        localScale.y = clipSca.y;
                        localScale.z = clipSca.z;
                    }
                }
                else {
                    defaultSca = nodeOwner.defaultValue;
                    if (additive) {
                        Utils3D.scaleWeight(clipSca, weight, _tempVector31);
                        localScale.x = defaultSca.x * _tempVector31.x;
                        localScale.y = defaultSca.y * _tempVector31.y;
                        localScale.z = defaultSca.z * _tempVector31.z;
                    }
                    else {
                        Utils3D.scaleBlend(defaultSca, clipSca, weight, localScale);
                    }
                }
            }
        }
        _applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight) {
            var pro = nodeOwner.propertyOwner;
            let lastpro;
            if (pro) {
                switch (nodeOwner.type) {
                    case exports.KeyFrameValueType.Boolean:
                        console.log("Animator:Boolean not support3");
                        break;
                    case exports.KeyFrameValueType.Float:
                        var proPat = nodeOwner.property;
                        var m = proPat.length - 1;
                        for (var j = 0; j < m; j++) {
                            pro = pro[proPat[j]];
                            if (!pro)
                                break;
                        }
                        var crossValue = srcValue + crossWeight * (desValue - srcValue);
                        nodeOwner.value = crossValue;
                        lastpro = proPat[m];
                        if (!nodeOwner.isMaterial) {
                            pro && (pro[lastpro] = this._applyFloat(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, crossValue));
                        }
                        else {
                            pro && pro.setFloat(lastpro, this._applyFloat(pro.getFloat(lastpro), nodeOwner, additive, weight, isFirstLayer, crossValue));
                        }
                        if (nodeOwner.callbackFun) {
                            nodeOwner.animatorDataSetCallBack();
                        }
                        break;
                    case exports.KeyFrameValueType.Position:
                        var localPos = pro.localPosition;
                        var position = nodeOwner.value;
                        var srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z;
                        position.x = srcX + crossWeight * (desValue.x - srcX);
                        position.y = srcY + crossWeight * (desValue.y - srcY);
                        position.z = srcZ + crossWeight * (desValue.z - srcZ);
                        this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, position, localPos);
                        pro.localPosition = localPos;
                        break;
                    case exports.KeyFrameValueType.Rotation:
                        var localRot = pro.localRotation;
                        var rotation = nodeOwner.value;
                        Laya.Quaternion.lerp(srcValue, desValue, crossWeight, rotation);
                        this._applyRotation(nodeOwner, additive, weight, isFirstLayer, rotation, localRot);
                        pro.localRotation = localRot;
                        break;
                    case exports.KeyFrameValueType.Scale:
                        var localSca = pro.localScale;
                        var scale = nodeOwner.value;
                        Utils3D.scaleBlend(srcValue, desValue, crossWeight, scale);
                        this._applyScale(nodeOwner, additive, weight, isFirstLayer, scale, localSca);
                        pro.localScale = localSca;
                        break;
                    case exports.KeyFrameValueType.RotationEuler:
                        var localEuler = pro.localRotationEuler;
                        var rotationEuler = nodeOwner.value;
                        srcX = srcValue.x, srcY = srcValue.y, srcZ = srcValue.z;
                        rotationEuler.x = srcX + crossWeight * (desValue.x - srcX);
                        rotationEuler.y = srcY + crossWeight * (desValue.y - srcY);
                        rotationEuler.z = srcZ + crossWeight * (desValue.z - srcZ);
                        this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, rotationEuler, localEuler);
                        pro.localRotationEuler = localEuler;
                        break;
                    case exports.KeyFrameValueType.Color:
                        var proPat = nodeOwner.property;
                        var m = proPat.length - 1;
                        for (var j = 0; j < m; j++) {
                            pro = pro[proPat[j]];
                            if (!pro)
                                break;
                        }
                        let v44 = nodeOwner.value;
                        v44.x = srcValue.r + crossWeight * (desValue.r - srcValue.r);
                        v44.y = srcValue.g + crossWeight * (desValue.g - srcValue.g);
                        v44.z = srcValue.b + crossWeight * (desValue.b - srcValue.b);
                        v44.w = srcValue.a + crossWeight * (desValue.a - srcValue.a);
                        nodeOwner.value = v44;
                        lastpro = proPat[m];
                        if (!nodeOwner.isMaterial) {
                            pro && (pro[lastpro] = this._applyColor(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, v44));
                        }
                        else {
                            pro && pro.setColor(lastpro, this._applyColor(pro.getColor(lastpro), nodeOwner, additive, weight, isFirstLayer, v44));
                        }
                        if (nodeOwner.callbackFun) {
                            nodeOwner.animatorDataSetCallBack();
                        }
                        break;
                    case exports.KeyFrameValueType.Vector2:
                        var proPat = nodeOwner.property;
                        var m = proPat.length - 1;
                        for (var j = 0; j < m; j++) {
                            pro = pro[proPat[j]];
                            if (!pro)
                                break;
                        }
                        let v2 = nodeOwner.value;
                        v2.x = srcValue.r + crossWeight * (desValue.r - srcValue.r);
                        v2.y = srcValue.g + crossWeight * (desValue.g - srcValue.g);
                        nodeOwner.value = v2;
                        lastpro = proPat[m];
                        if (!nodeOwner.isMaterial) {
                            pro && (pro[lastpro] = this._applyVec2(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, v2));
                        }
                        else {
                            pro && pro.setVector2(lastpro, this._applyVec2(pro.getVector2(lastpro), nodeOwner, additive, weight, isFirstLayer, v2));
                        }
                        if (nodeOwner.callbackFun) {
                            nodeOwner.animatorDataSetCallBack();
                        }
                        break;
                    case exports.KeyFrameValueType.Vector4:
                        var proPat = nodeOwner.property;
                        var m = proPat.length - 1;
                        for (var j = 0; j < m; j++) {
                            pro = pro[proPat[j]];
                            if (!pro)
                                break;
                        }
                        let v4 = nodeOwner.value;
                        v4.x = srcValue.x + crossWeight * (desValue.x - srcValue.x);
                        v4.y = srcValue.y + crossWeight * (desValue.y - srcValue.y);
                        v4.z = srcValue.z + crossWeight * (desValue.z - srcValue.z);
                        nodeOwner.value = v4;
                        lastpro = proPat[m];
                        if (!nodeOwner.isMaterial) {
                            pro && (pro[lastpro] = this._applyVec4(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, v4));
                        }
                        else {
                            pro && pro.setVector4(lastpro, this._applyVec4(pro.getVector4(lastpro), nodeOwner, additive, weight, isFirstLayer, v4));
                        }
                        if (nodeOwner.callbackFun) {
                            nodeOwner.animatorDataSetCallBack();
                        }
                        break;
                    case exports.KeyFrameValueType.Vector3:
                        var proPat = nodeOwner.property;
                        var m = proPat.length - 1;
                        for (var j = 0; j < m; j++) {
                            pro = pro[proPat[j]];
                            if (!pro)
                                break;
                        }
                        let v3 = nodeOwner.value;
                        v3.x = srcValue.x + crossWeight * (desValue.x - srcValue.x);
                        v3.y = srcValue.y + crossWeight * (desValue.y - srcValue.y);
                        v3.z = srcValue.z + crossWeight * (desValue.z - srcValue.z);
                        nodeOwner.value = v3;
                        lastpro = proPat[m];
                        if (!nodeOwner.isMaterial) {
                            pro && (pro[lastpro] = this._applyVec3(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, v3));
                        }
                        else {
                            pro && pro.setVector3(lastpro, this._applyVec3(pro.getVector3(lastpro), nodeOwner, additive, weight, isFirstLayer, v3));
                        }
                        if (nodeOwner.callbackFun) {
                            nodeOwner.animatorDataSetCallBack();
                        }
                        break;
                }
                nodeOwner.updateMark = this._updateMark;
            }
        }
        _setClipDatasToNode(stateInfo, additive, weight, isFirstLayer, controllerLayer = null) {
            var realtimeDatas = stateInfo._realtimeDatas;
            var nodes = stateInfo._clip._nodes;
            var nodeOwners = stateInfo._nodeOwners;
            for (var i = 0, n = nodes.count; i < n; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var node = nodes.getNodeByIndex(i);
                    if (controllerLayer.avatarMask && (!controllerLayer.avatarMask.getTransformActive(node.nodePath))) {
                        continue;
                    }
                    var pro = nodeOwner.propertyOwner;
                    let value;
                    if (pro) {
                        switch (nodeOwner.type) {
                            case exports.KeyFrameValueType.Boolean:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                let lastBoolPro = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[lastBoolPro] = realtimeDatas[i]);
                                }
                                break;
                            case exports.KeyFrameValueType.Float:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                let lastpro = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[lastpro] = this._applyFloat(pro[lastpro], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.setFloat(lastpro, this._applyFloat(0, nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Position:
                                var localPos = pro.localPosition;
                                this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localPos);
                                pro.localPosition = localPos;
                                break;
                            case exports.KeyFrameValueType.Rotation:
                                var localRot = pro.localRotation;
                                this._applyRotation(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localRot);
                                pro.localRotation = localRot;
                                break;
                            case exports.KeyFrameValueType.Scale:
                                var localSca = pro.localScale;
                                this._applyScale(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localSca);
                                pro.localScale = localSca;
                                break;
                            case exports.KeyFrameValueType.RotationEuler:
                                var localEuler = pro.localRotationEuler;
                                this._applyPositionAndRotationEuler(nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i], localEuler);
                                pro.localRotationEuler = localEuler;
                                break;
                            case exports.KeyFrameValueType.Vector2:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyVec2(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getVector2(value) && pro.setVector2(value, this._applyVec2(pro.getVector2(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Vector3:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyVec3(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getVector3(value) && pro.setVector3(value, this._applyVec3(pro.getVector3(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Vector4:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyVec4(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getVector4(value) && pro.setVector4(value, this._applyVec4(pro.getVector4(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                            case exports.KeyFrameValueType.Color:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = this._applyColor(pro[value], nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getColor(value) && pro.setColor(value, this._applyColor(pro.getColor(value), nodeOwner, additive, weight, isFirstLayer, realtimeDatas[i]));
                                }
                                break;
                        }
                        nodeOwner.updateMark = this._updateMark;
                    }
                }
            }
        }
        _setCrossClipDatasToNode(controllerLayer, srcState, destState, crossWeight, isFirstLayer) {
            var nodeOwners = controllerLayer._crossNodesOwners;
            var ownerCount = controllerLayer._crossNodesOwnersCount;
            var additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            var weight = controllerLayer.defaultWeight;
            var destRealtimeDatas = destState._realtimeDatas;
            var destDataIndices = controllerLayer._destCrossClipNodeIndices;
            var destNodeOwners = destState._nodeOwners;
            var srcRealtimeDatas = srcState._realtimeDatas;
            var srcDataIndices = controllerLayer._srcCrossClipNodeIndices;
            var srcNodeOwners = srcState._nodeOwners;
            for (var i = 0; i < ownerCount; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var srcIndex = srcDataIndices[i];
                    var destIndex = destDataIndices[i];
                    if (-1 == srcIndex && -1 == destIndex)
                        continue;
                    var srcValue = srcIndex !== -1 ? srcRealtimeDatas[srcIndex] : destNodeOwners[destIndex].defaultValue;
                    if (null == srcValue)
                        continue;
                    var desValue = destIndex !== -1 ? destRealtimeDatas[destIndex] : srcNodeOwners[srcIndex].defaultValue;
                    if (!desValue) {
                        desValue = srcNodeOwners[srcIndex].defaultValue;
                    }
                    if (null == desValue)
                        continue;
                    if (!controllerLayer.avatarMask || controllerLayer.avatarMask.getTransformActive(nodeOwner.nodePath)) {
                        this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight);
                    }
                }
            }
        }
        _setFixedCrossClipDatasToNode(controllerLayer, destState, crossWeight, isFirstLayer) {
            var nodeOwners = controllerLayer._crossNodesOwners;
            var ownerCount = controllerLayer._crossNodesOwnersCount;
            var additive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
            var weight = controllerLayer.defaultWeight;
            var destRealtimeDatas = destState._realtimeDatas;
            var destDataIndices = controllerLayer._destCrossClipNodeIndices;
            for (var i = 0; i < ownerCount; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var destIndex = destDataIndices[i];
                    var srcValue = nodeOwner.crossFixedValue;
                    var desValue;
                    if (destIndex == -1 || !destRealtimeDatas[destIndex]) {
                        desValue = nodeOwner.defaultValue;
                    }
                    else {
                        desValue = destRealtimeDatas[destIndex];
                    }
                    this._applyCrossData(nodeOwner, additive, weight, isFirstLayer, srcValue, desValue, crossWeight);
                }
            }
        }
        _revertDefaultKeyframeNodes(clipStateInfo) {
            var nodeOwners = clipStateInfo._nodeOwners;
            for (var i = 0, n = nodeOwners.length; i < n; i++) {
                var nodeOwner = nodeOwners[i];
                if (nodeOwner) {
                    var pro = nodeOwner.propertyOwner;
                    let value;
                    if (pro) {
                        switch (nodeOwner.type) {
                            case exports.KeyFrameValueType.Boolean:
                                console.log("Animator:Boolean not support2");
                                break;
                            case exports.KeyFrameValueType.Float:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                let lastpro = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[lastpro] = nodeOwner.defaultValue);
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.setFloat(lastpro, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Position:
                                var locPos = pro.localPosition;
                                var def = nodeOwner.defaultValue;
                                locPos.x = def.x;
                                locPos.y = def.y;
                                locPos.z = def.z;
                                pro.localPosition = locPos;
                                break;
                            case exports.KeyFrameValueType.Rotation:
                                var locRot = pro.localRotation;
                                var defQua = nodeOwner.defaultValue;
                                locRot.x = defQua.x;
                                locRot.y = defQua.y;
                                locRot.z = defQua.z;
                                locRot.w = defQua.w;
                                pro.localRotation = locRot;
                                break;
                            case exports.KeyFrameValueType.Scale:
                                var locSca = pro.localScale;
                                def = nodeOwner.defaultValue;
                                locSca.x = def.x;
                                locSca.y = def.y;
                                locSca.z = def.z;
                                pro.localScale = locSca;
                                break;
                            case exports.KeyFrameValueType.RotationEuler:
                                var locEul = pro.localRotationEuler;
                                def = nodeOwner.defaultValue;
                                locEul.x = def.x;
                                locEul.y = def.y;
                                locEul.z = def.z;
                                pro.localRotationEuler = locEul;
                                break;
                            case exports.KeyFrameValueType.Vector2:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = nodeOwner.defaultValue);
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getVector2(value) && pro.setVector2(value, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Vector3:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = nodeOwner.defaultValue);
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getVector3(value) && pro.setVector3(value, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Vector4:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = nodeOwner.defaultValue);
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getVector3(value) && pro.setVector3(value, nodeOwner.defaultValue);
                                }
                                break;
                            case exports.KeyFrameValueType.Color:
                                var proPat = nodeOwner.property;
                                var m = proPat.length - 1;
                                for (var j = 0; j < m; j++) {
                                    pro = pro[proPat[j]];
                                    if (!pro)
                                        break;
                                }
                                value = proPat[m];
                                _tempColor.r = nodeOwner.defaultValue.x;
                                _tempColor.g = nodeOwner.defaultValue.y;
                                _tempColor.b = nodeOwner.defaultValue.z;
                                _tempColor.a = nodeOwner.defaultValue.w;
                                if (!nodeOwner.isMaterial) {
                                    pro && (pro[value] = _tempColor);
                                    if (nodeOwner.callbackFun) {
                                        nodeOwner.animatorDataSetCallBack();
                                    }
                                }
                                else {
                                    pro && pro.getColor(value) && pro.setColor(value, _tempColor);
                                }
                                break;
                            default:
                                throw "Animator:unknown type.";
                        }
                    }
                }
            }
        }
        onAfterDeserialize() {
            let arr = this.controllerLayers;
            if (!arr || null != this.controller)
                return;
            delete this.controllerLayers;
            this._controllerLayers.length = 0;
            for (let layer of arr) {
                this.addControllerLayer(layer);
            }
        }
        _onEnable() {
            for (let i = 0, n = this._controllerLayers.length; i < n; i++) {
                if (this._controllerLayers[i].playOnWake) {
                    let defaultClip = this.getDefaultState(i);
                    (defaultClip) && (this.play(null, i, defaultClip.cycleOffset));
                }
            }
        }
        _onDestroy() {
            if (this._controller) {
                this._controller._removeReference();
                this._controller = null;
            }
            for (let i = 0, n = this._controllerLayers.length; i < n; i++)
                this._controllerLayers[i]._removeReference();
        }
        _applyUpdateMode(delta) {
            let ret;
            switch (this._updateMode) {
                case Laya.AnimatorUpdateMode.Normal:
                    ret = delta;
                    break;
                case Laya.AnimatorUpdateMode.LowFrame:
                    ret = (Laya.Stat.loopCount % this._lowUpdateDelty == 0) ? delta * this._lowUpdateDelty : 0;
                    break;
                case Laya.AnimatorUpdateMode.UnScaleTime:
                    ret = 0;
                    break;
            }
            return ret;
        }
        _handleSpriteOwnersBySprite(isLink, path, sprite) {
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                if (!this._controllerLayers[i].enable)
                    continue;
                var clipStateInfos = this._controllerLayers[i]._states;
                for (var j = 0, m = clipStateInfos.length; j < m; j++) {
                    var clipStateInfo = clipStateInfos[j];
                    var clip = clipStateInfo._clip;
                    var nodePath = path.join("/");
                    var ownersNodes = clip._nodesMap[nodePath];
                    if (ownersNodes) {
                        var nodeOwners = clipStateInfo._nodeOwners;
                        for (var k = 0, p = ownersNodes.length; k < p; k++) {
                            if (isLink)
                                this._addKeyframeNodeOwner(nodeOwners, ownersNodes[k], sprite);
                            else
                                this._removeKeyframeNodeOwner(nodeOwners, ownersNodes[k]);
                        }
                    }
                }
            }
        }
        onUpdate() {
            let timer = this.owner._scene.timer;
            let delta = timer.delta / 1000.0;
            delta = this._applyUpdateMode(delta);
            if (this._speed === 0 || delta === 0)
                return;
            if (!Laya.Stat.enableAnimatorUpdate)
                return;
            var i, n;
            this._updateMark++;
            for (i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllerLayer = this._controllerLayers[i];
                if (!controllerLayer.enable)
                    continue;
                var playStateInfo = controllerLayer._playStateInfo;
                if (this.sleep && playStateInfo._finish && controllerLayer._playType == 0) {
                    continue;
                }
                var crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                switch (controllerLayer._playType) {
                    case 0:
                        var animatorState = playStateInfo.currentState;
                        animatorState._clip;
                        var speed = this._speed * animatorState.speed;
                        var finish = playStateInfo._finish;
                        finish || this._updatePlayer(animatorState, playStateInfo, delta * speed, animatorState.islooping, i);
                        {
                            var addtive = controllerLayer.blendingMode !== AnimatorControllerLayer.BLENDINGMODE_OVERRIDE;
                            this._updateClipDatas(animatorState, addtive, playStateInfo, controllerLayer.avatarMask);
                            this._setClipDatasToNode(animatorState, addtive, controllerLayer.defaultWeight, i === 0, controllerLayer);
                            finish || this._updateEventScript(animatorState, playStateInfo);
                        }
                        finish || this._updateStateFinish(animatorState, playStateInfo);
                        break;
                    case 1:
                        animatorState = playStateInfo.currentState;
                        animatorState._clip;
                        var crossState = controllerLayer._crossPlayState;
                        var crossClip = crossState._clip;
                        var crossDuratuion = controllerLayer._crossDuration;
                        var startPlayTime = crossPlayStateInfo._startPlayTime;
                        var crossClipDuration = crossClip._duration - startPlayTime;
                        var crossScale = (crossDuratuion > crossClipDuration && 0 != crossClipDuration) ? crossClipDuration / crossDuratuion : 1.0;
                        var crossSpeed = this._speed * crossState.speed;
                        this._updatePlayer(crossState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossClip.islooping, i);
                        var crossWeight = ((crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale) / crossDuratuion;
                        var needUpdateFinishcurrentState = false;
                        if (crossWeight >= 1.0) {
                            {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setClipDatasToNode(crossState, addtive, controllerLayer.defaultWeight, i === 0, controllerLayer);
                                controllerLayer._playType = 0;
                                playStateInfo.currentState = crossState;
                                crossPlayStateInfo._cloneTo(playStateInfo);
                            }
                        }
                        else {
                            if (!playStateInfo._finish) {
                                speed = this._speed * animatorState.speed;
                                needUpdateFinishcurrentState = true;
                                this._updatePlayer(animatorState, playStateInfo, delta * speed, animatorState.islooping, i);
                                this._updateClipDatas(animatorState, addtive, playStateInfo, controllerLayer.avatarMask);
                            }
                            {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setCrossClipDatasToNode(controllerLayer, animatorState, crossState, crossWeight, i === 0);
                            }
                        }
                        {
                            this._updateEventScript(animatorState, playStateInfo);
                            this._updateEventScript(crossState, crossPlayStateInfo);
                        }
                        this._updateStateFinish(crossState, crossPlayStateInfo);
                        needUpdateFinishcurrentState && this._updateStateFinish(playStateInfo.currentState, playStateInfo);
                        break;
                    case 2:
                        crossState = controllerLayer._crossPlayState;
                        crossClip = crossState._clip;
                        crossDuratuion = controllerLayer._crossDuration;
                        startPlayTime = crossPlayStateInfo._startPlayTime;
                        crossClipDuration = crossClip._duration - startPlayTime;
                        crossScale = crossDuratuion > crossClipDuration ? crossClipDuration / crossDuratuion : 1.0;
                        crossSpeed = this._speed * crossState.speed;
                        this._updatePlayer(crossState, crossPlayStateInfo, delta * crossScale * crossSpeed, crossState.islooping, i);
                        {
                            crossWeight = ((crossPlayStateInfo._elapsedTime - startPlayTime) / crossScale) / crossDuratuion;
                            if (crossWeight >= 1.0) {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setClipDatasToNode(crossState, addtive, 1.0, i === 0, controllerLayer);
                                controllerLayer._playType = 0;
                                playStateInfo.currentState = crossState;
                                crossPlayStateInfo._cloneTo(playStateInfo);
                            }
                            else {
                                this._updateClipDatas(crossState, addtive, crossPlayStateInfo, controllerLayer.avatarMask);
                                this._setFixedCrossClipDatasToNode(controllerLayer, crossState, crossWeight, i === 0);
                            }
                            this._updateEventScript(crossState, crossPlayStateInfo);
                        }
                        this._updateStateFinish(crossState, crossPlayStateInfo);
                        break;
                }
            }
            this._LateUpdateEvents.invoke();
            this._LateUpdateEvents.clear();
        }
        _cloneTo(dest) {
            dest.cullingMode = this.cullingMode;
            for (var i = 0, n = this._controllerLayers.length; i < n; i++) {
                var controllLayer = this._controllerLayers[i];
                dest.addControllerLayer(controllLayer.clone());
                var animatorStates = controllLayer._states;
                for (var j = 0, m = animatorStates.length; j < m; j++) {
                    var state = animatorStates[j].clone();
                    var cloneLayer = dest.getControllerLayer(i);
                    cloneLayer.addState(state);
                    (j == 0) && (cloneLayer.defaultState = state);
                }
            }
            dest.controller = this._controller;
        }
        getDefaultState(layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            return controllerLayer.defaultState;
        }
        addState(state, layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            controllerLayer.addState(state);
            console.warn("Animator:this function is discard,please use animatorControllerLayer.addState() instead.");
        }
        removeState(state, layerIndex = 0) {
            var controllerLayer = this._controllerLayers[layerIndex];
            controllerLayer.removeState(state);
            console.warn("Animator:this function is discard,please use animatorControllerLayer.removeState() instead.");
        }
        addControllerLayer(controllerLayer) {
            this._controllerLayers.push(controllerLayer);
            controllerLayer._animator = this;
            controllerLayer._addReference();
            var states = controllerLayer._states;
            for (var i = 0, n = states.length; i < n; i++)
                this._getOwnersByClip(states[i]);
        }
        getControllerLayer(layerIndex = 0) {
            return this._controllerLayers[layerIndex];
        }
        play(name = null, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var defaultState = controllerLayer.defaultState;
                if (!name && !defaultState)
                    throw new Error("Animator:must have default clip value,please set clip property.");
                var playStateInfo = controllerLayer._playStateInfo;
                var curPlayState = playStateInfo.currentState;
                var animatorState = name ? controllerLayer.getAnimatorState(name) : defaultState;
                if (!animatorState._clip)
                    return;
                var clipDuration = animatorState._clip._duration;
                var calclipduration = animatorState._clip._duration * (animatorState.clipEnd - animatorState.clipStart);
                if (curPlayState !== animatorState) {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                    else
                        playStateInfo._resetPlayState(0.0, calclipduration);
                    (curPlayState !== null && curPlayState !== animatorState) && (this._revertDefaultKeyframeNodes(curPlayState));
                    controllerLayer._playType = 0;
                    playStateInfo.currentState = animatorState;
                }
                else {
                    if (normalizedTime !== Number.NEGATIVE_INFINITY) {
                        playStateInfo._resetPlayState(clipDuration * normalizedTime, calclipduration);
                        controllerLayer._playType = 0;
                    }
                }
                animatorState._scripts;
                animatorState._eventStart(this, layerIndex);
            }
            else {
                console.warn("Invalid layerIndex " + layerIndex + ".");
            }
            if (this.owner._scene) {
                this.onUpdate();
            }
        }
        crossFade(name, transitionDuration, layerIndex = 0, normalizedTime = Number.NEGATIVE_INFINITY) {
            var controllerLayer = this._controllerLayers[layerIndex];
            if (controllerLayer) {
                var destAnimatorState = controllerLayer.getAnimatorState(name);
                if (destAnimatorState) {
                    var playType = controllerLayer._playType;
                    if (playType === -1) {
                        this.play(name, layerIndex, normalizedTime);
                        return;
                    }
                    var crossPlayStateInfo = controllerLayer._crossPlayStateInfo;
                    var crossNodeOwners = controllerLayer._crossNodesOwners;
                    var crossNodeOwnerIndicesMap = controllerLayer._crossNodesOwnersIndicesMap;
                    var srcAnimatorState = controllerLayer._playStateInfo.currentState;
                    var destNodeOwners = destAnimatorState._nodeOwners;
                    var destCrossClipNodeIndices = controllerLayer._destCrossClipNodeIndices;
                    var destClip = destAnimatorState._clip;
                    var destNodes = destClip._nodes;
                    var destNodesMap = destClip._nodesDic;
                    var crossCount = 0;
                    switch (playType) {
                        case 0:
                            var srcNodeOwners = srcAnimatorState._nodeOwners;
                            var scrCrossClipNodeIndices = controllerLayer._srcCrossClipNodeIndices;
                            var srcClip = srcAnimatorState._clip;
                            var srcNodes = srcClip._nodes;
                            var srcNodesMap = srcClip._nodesDic;
                            controllerLayer._playType = 1;
                            var crossMark = ++controllerLayer._crossMark;
                            crossCount = controllerLayer._crossNodesOwnersCount = 0;
                            for (var i = 0, n = srcNodes.count; i < n; i++) {
                                var srcNode = srcNodes.getNodeByIndex(i);
                                var srcIndex = srcNode._indexInList;
                                var srcNodeOwner = srcNodeOwners[srcIndex];
                                if (srcNodeOwner) {
                                    var srcFullPath = srcNode.fullPath;
                                    scrCrossClipNodeIndices[crossCount] = srcIndex;
                                    var destNode = destNodesMap[srcFullPath];
                                    if (destNode)
                                        destCrossClipNodeIndices[crossCount] = destNode._indexInList;
                                    else
                                        destCrossClipNodeIndices[crossCount] = -1;
                                    crossNodeOwnerIndicesMap[srcFullPath] = crossMark;
                                    crossNodeOwners[crossCount] = srcNodeOwner;
                                    crossCount++;
                                }
                            }
                            for (i = 0, n = destNodes.count; i < n; i++) {
                                destNode = destNodes.getNodeByIndex(i);
                                var destIndex = destNode._indexInList;
                                var destNodeOwner = destNodeOwners[destIndex];
                                if (destNodeOwner) {
                                    var destFullPath = destNode.fullPath;
                                    if (!srcNodesMap[destFullPath]) {
                                        scrCrossClipNodeIndices[crossCount] = -1;
                                        destCrossClipNodeIndices[crossCount] = destIndex;
                                        crossNodeOwnerIndicesMap[destFullPath] = crossMark;
                                        crossNodeOwners[crossCount] = destNodeOwner;
                                        crossCount++;
                                    }
                                }
                            }
                            break;
                        case 1:
                        case 2:
                            controllerLayer._playType = 2;
                            for (i = 0, n = crossNodeOwners.length; i < n; i++) {
                                var nodeOwner = crossNodeOwners[i];
                                nodeOwner.saveCrossFixedValue();
                                destNode = destNodesMap[nodeOwner.fullPath];
                                if (destNode)
                                    destCrossClipNodeIndices[i] = destNode._indexInList;
                                else
                                    destCrossClipNodeIndices[i] = -1;
                            }
                            crossCount = controllerLayer._crossNodesOwnersCount;
                            crossMark = controllerLayer._crossMark;
                            for (i = 0, n = destNodes.count; i < n; i++) {
                                destNode = destNodes.getNodeByIndex(i);
                                destIndex = destNode._indexInList;
                                destNodeOwner = destNodeOwners[destIndex];
                                if (destNodeOwner) {
                                    destFullPath = destNode.fullPath;
                                    if (crossNodeOwnerIndicesMap[destFullPath] !== crossMark) {
                                        destCrossClipNodeIndices[crossCount] = destIndex;
                                        crossNodeOwnerIndicesMap[destFullPath] = crossMark;
                                        nodeOwner = destNodeOwners[destIndex];
                                        crossNodeOwners[crossCount] = nodeOwner;
                                        nodeOwner.saveCrossFixedValue();
                                        crossCount++;
                                    }
                                }
                            }
                            break;
                    }
                    controllerLayer._crossNodesOwnersCount = crossCount;
                    controllerLayer._crossPlayState = destAnimatorState;
                    controllerLayer._crossDuration = srcAnimatorState._clip._duration * transitionDuration;
                    if (normalizedTime !== Number.NEGATIVE_INFINITY)
                        crossPlayStateInfo._resetPlayState(destClip._duration * normalizedTime, controllerLayer._crossDuration);
                    else
                        crossPlayStateInfo._resetPlayState(0.0, controllerLayer._crossDuration);
                    destAnimatorState._eventStart(this, layerIndex);
                }
                else {
                    console.warn("Invalid name " + layerIndex + ".");
                }
            }
            else {
                console.warn("Invalid layerIndex " + layerIndex + ".");
            }
        }
        setParamsTrigger(name) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            this._animatorParams[id] = true;
        }
        setParamsNumber(name, value) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            this._animatorParams[id] = value;
        }
        setParamsBool(name, value) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            this._animatorParams[id] = value;
        }
        getParamsvalue(name) {
            let id;
            if (typeof name == "number")
                id = name;
            else
                id = Laya.AnimatorStateCondition.conditionNameToID(name);
            return this._animatorParams[id];
        }
        getCurrentAnimatorPlayState(layerIndex = 0) {
            return this._controllerLayers[layerIndex]._playStateInfo;
        }
    }
    Animator.CULLINGMODE_ALWAYSANIMATE = 0;
    Animator.CULLINGMODE_CULLCOMPLETELY = 2;
    const _tempVector31 = new Laya.Vector3();
    const _tempColor = new Laya.Color();
    const _tempQuaternion1 = new Laya.Quaternion();

    class AnimatorState extends Laya.EventDispatcher {
        get clip() {
            return this._clip;
        }
        set clip(value) {
            if (this._clip !== value) {
                if (this._clip)
                    (this._referenceCount > 0) && (this._clip._removeReference(this._referenceCount));
                if (value) {
                    var realtimeDatas = this._realtimeDatas;
                    var clipNodes = value._nodes;
                    var count = clipNodes.count;
                    this._currentFrameIndices = new Int16Array(count);
                    this._resetFrameIndices();
                    (this._referenceCount > 0) && (value._addReference(this._referenceCount));
                    this._realtimeDatas.length = count;
                    for (var i = 0; i < count; i++) {
                        switch (clipNodes.getNodeByIndex(i).type) {
                            case exports.KeyFrameValueType.Boolean:
                            case exports.KeyFrameValueType.Float:
                                break;
                            case exports.KeyFrameValueType.Position:
                            case exports.KeyFrameValueType.Scale:
                            case exports.KeyFrameValueType.RotationEuler:
                            case exports.KeyFrameValueType.Vector3:
                                realtimeDatas[i] = new Laya.Vector3();
                                break;
                            case exports.KeyFrameValueType.Rotation:
                                realtimeDatas[i] = new Laya.Quaternion();
                                break;
                            case exports.KeyFrameValueType.Vector2:
                                realtimeDatas[i] = new Laya.Vector2();
                                break;
                            case exports.KeyFrameValueType.Vector4:
                            case exports.KeyFrameValueType.Color:
                                realtimeDatas[i] = new Laya.Vector4();
                                break;
                            default:
                                throw new Error("AnimationClipParser04:unknown type.");
                        }
                    }
                }
                this._clip = value;
            }
        }
        get islooping() {
            if (0 != this._isLooping) {
                return 1 == this._isLooping;
            }
            return this._clip.islooping;
        }
        get transitions() {
            return this._transitions;
        }
        set transitions(value) {
            this._transitions = value;
        }
        get soloTransitions() {
            return this._soloTransitions;
        }
        set soloTransitions(value) {
            this._soloTransitions = value;
        }
        constructor() {
            super();
            this._referenceCount = 0;
            this._clip = null;
            this._nodeOwners = [];
            this._currentFrameIndices = null;
            this._isLooping = 0;
            this._realtimeDatas = [];
            this._scripts = null;
            this._transitions = [];
            this._soloTransitions = [];
            this.speed = 1.0;
            this.clipStart = 0.0;
            this.clipEnd = 1.0;
            this.cycleOffset = 0;
        }
        _eventStart(animator, layerIndex) {
            this.event(AnimatorState.EVENT_OnStateEnter);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].setPlayScriptInfo(animator, layerIndex, this);
                    this._scripts[i].onStateEnter();
                }
            }
        }
        _eventExit() {
            this.event(AnimatorState.EVENT_OnStateExit);
            this.curTransition = null;
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    this._scripts[i].onStateExit();
                }
            }
        }
        _eventStateUpdate(value) {
            this.event(AnimatorState.EVENT_OnStateUpdate, value);
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++)
                    this._scripts[i].onStateUpdate(value);
            }
        }
        _eventLoop() {
            this.event(AnimatorState.EVENT_OnStateLoop);
            if (this._scripts) {
                for (let i = 0, n = this._scripts.length; i < n; i++) {
                    if (this._scripts[i].onStateLoop)
                        this._scripts[i].onStateLoop();
                }
            }
        }
        _eventtransition(normalizeTime, paramsMap) {
            let soloNums = this._soloTransitions.length;
            if (soloNums > 0) {
                for (var i = 0; i < soloNums; i++) {
                    if (this._soloTransitions[i].check(normalizeTime, paramsMap))
                        return this._soloTransitions[i];
                }
                return null;
            }
            let transNums = this._transitions.length;
            for (var i = 0; i < transNums; i++) {
                if (this._transitions[i].check(normalizeTime, paramsMap))
                    return this._transitions[i];
            }
            return null;
        }
        _getReferenceCount() {
            return this._referenceCount;
        }
        _addReference(count = 1) {
            (this._clip) && (this._clip._addReference(count));
            this._referenceCount += count;
        }
        _removeReference(count = 1) {
            (this._clip) && (this._clip._removeReference(count));
            this._referenceCount -= count;
        }
        _clearReference() {
            this._removeReference(-this._referenceCount);
        }
        _resetFrameIndices() {
            for (var i = 0, n = this._currentFrameIndices.length; i < n; i++)
                this._currentFrameIndices[i] = -1;
        }
        addScript(type) {
            var script = new type();
            this._scripts = this._scripts || [];
            this._scripts.push(script);
            return script;
        }
        getScript(type) {
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type)
                        return script;
                }
            }
            return null;
        }
        getScripts(type) {
            var coms = null;
            if (this._scripts) {
                for (var i = 0, n = this._scripts.length; i < n; i++) {
                    var script = this._scripts[i];
                    if (script instanceof type) {
                        coms = coms || [];
                        coms.push(script);
                    }
                }
            }
            return coms;
        }
        cloneTo(destObject) {
            destObject.name = this.name;
            destObject.speed = this.speed;
            destObject.clipStart = this.clipStart;
            destObject.clipEnd = this.clipEnd;
            destObject.clip = this._clip;
        }
        clone() {
            var dest = new AnimatorState();
            this.cloneTo(dest);
            return dest;
        }
    }
    AnimatorState.EVENT_OnStateEnter = "OnStartEnter";
    AnimatorState.EVENT_OnStateUpdate = "OnStateUpdate";
    AnimatorState.EVENT_OnStateLoop = 'OnStateLoop';
    AnimatorState.EVENT_OnStateExit = "OnStateExit";

    class AvatarMask {
        constructor(data) {
            this._avatarPathMap = (data === null || data === void 0 ? void 0 : data._avatarPathMap) || {};
        }
        getTransformActive(path) {
            return this._avatarPathMap[path];
        }
        setTransformActive(path, value) {
            this._avatarPathMap[path] = value;
        }
        getAllTranfromPath() {
            return this._avatarPathMap;
        }
        clone() {
            var dest = new AvatarMask();
            this.cloneTo(dest);
            return dest;
        }
        cloneTo(destObject) {
            for (var key in this._avatarPathMap) {
                destObject.setTransformActive(key, this._avatarPathMap[key]);
            }
        }
    }

    class PostProcessEffect {
        constructor() {
            this._active = true;
            this._singleton = true;
        }
        get singleton() {
            return this._singleton;
        }
        set singleton(value) {
            this._singleton = value;
        }
        get active() {
            return this._active;
        }
        set active(value) {
            this._active = value;
        }
        getCameraDepthTextureModeFlag() {
            return 0;
        }
        effectInit(postprocess) {
            return;
        }
        release(postprocess) {
        }
        render(context) {
        }
    }

    class AnimatorTransition {
        constructor() {
            this._conditions = [];
            this._exitByTime = true;
            this._exitTime = 0.85;
            this._transduration = 0.15;
            this._transstartoffset = 0;
            this._mute = false;
        }
        get name() {
            return this._name;
        }
        set name(value) {
            this._name = value;
        }
        get mute() {
            return this._mute;
        }
        set mute(value) {
            this._mute = value;
        }
        get destState() {
            return this._destState;
        }
        set destState(value) {
            this._destState = value;
        }
        get conditions() {
            return this._conditions;
        }
        set conditions(value) {
            for (var i = this._conditions.length - 1; i >= 0; i--) {
                this.removeCondition(this._conditions[i]);
            }
            for (var i = 0; i < value.length; i++) {
                this.addCondition(value[i]);
            }
        }
        get exitByTime() {
            return this._exitByTime;
        }
        set exitByTime(value) {
            this._exitByTime = value;
        }
        set transduration(value) {
            this._transduration = Math.max(0, Math.min(value, 1.0));
        }
        get transduration() {
            return this._transduration;
        }
        set transstartoffset(value) {
            this._transstartoffset = Math.max(0, Math.min(value, 1.0));
        }
        get transstartoffset() {
            return this._transstartoffset;
        }
        get exitTime() {
            return this._exitTime;
        }
        set exitTime(value) {
            this._exitTime = Math.max(0, Math.min(value, 1.0));
        }
        addCondition(condition) {
            if (this._conditions.indexOf(condition) == -1) {
                this._conditions.push(condition);
            }
        }
        removeCondition(condition) {
            let index = this._conditions.indexOf(condition);
            if (index != -1) {
                this._conditions.splice(index, 0);
            }
        }
        get isAndOperEnabled() {
            return this._isAndOperEnabled;
        }
        set isAndOperEnabled(vlaue) {
            this._isAndOperEnabled = vlaue;
        }
        check(normalizeTime, paramsMap) {
            if (this._mute) {
                return false;
            }
            if (this._conditions.length == 0) {
                if (normalizeTime >= this._exitTime)
                    return true;
            }
            else {
                if (this._exitByTime && normalizeTime < this._exitTime) {
                    return false;
                }
                if (this._isAndOperEnabled) {
                    for (var i = 0; i < this._conditions.length; i++) {
                        let con = this._conditions[i];
                        let out = con.checkState(paramsMap[con.id]);
                        if (!out) {
                            return false;
                        }
                        if (con.type == Laya.AniStateConditionType.Trigger) {
                            paramsMap[con.id] = false;
                        }
                    }
                    return true;
                }
                else {
                    for (var i = 0; i < this._conditions.length; i++) {
                        let con = this._conditions[i];
                        let out = con.checkState(paramsMap[con.id]);
                        if (out) {
                            if (con.type == Laya.AniStateConditionType.Trigger)
                                paramsMap[con.id] = false;
                            return true;
                        }
                    }
                }
            }
            return false;
        }
    }

    class AnimatorController extends Laya.Resource {
        constructor(data) {
            super();
            let obj = Laya.AnimatorControllerParse.parse(data);
            this.data = obj.ret;
            this.clipsID = obj.clipsID;
        }
        getLayers() {
            let layers = this.data.controllerLayers;
            let lArr = [];
            for (let i = layers.length - 1; i >= 0; i--) {
                let l = layers[i];
                let acl = new AnimatorControllerLayer(l.name);
                if (l.avatarMask) {
                    acl.avatarMask = l.avatarMask;
                }
                lArr.unshift(acl);
                for (let k in l) {
                    if ("avatarMask" == k || "name" == k || "states" == k || null == l[k]) {
                        continue;
                    }
                    try {
                        acl[k] = l[k];
                    }
                    catch (err) { }
                }
                this.getState(l.states, acl, this.data);
            }
            return lArr;
        }
        updateTo(a) {
            let currLayer = a._controllerLayers;
            for (let i = 0, len = currLayer.length; i < len; i++) {
                currLayer[i]._removeReference();
            }
            currLayer.length = 0;
            let layers = this.getLayers();
            for (let i = 0, len = layers.length; i < len; i++) {
                a.addControllerLayer(layers[i]);
            }
            let parms = this.data.animatorParams;
            if (parms) {
                for (let i = parms.length - 1; i >= 0; i--) {
                    let p = parms[i];
                    if (Laya.AniParmType.Bool == p.type) {
                        a.setParamsBool(p.name, Boolean(p.val));
                    }
                    else if (Laya.AniParmType.Float == p.type) {
                        let val = Number(p.val);
                        if (isNaN(val)) {
                            val = 0;
                        }
                        a.setParamsNumber(p.name, val);
                    }
                    else if (Laya.AniParmType.Trigger == p.type) {
                        if (p.val) {
                            a.setParamsTrigger(p.name);
                        }
                    }
                }
            }
        }
        createState(states, idCatch, acl) {
            if (!states)
                return null;
            let ret = {};
            let defID = null;
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                let childStates = obj.states;
                if (childStates) {
                    let groupRet = this.createState(childStates, idCatch, acl);
                    if (groupRet) {
                        idCatch[obj.id] = groupRet.states[groupRet.id];
                    }
                    continue;
                }
                if (0 > Number(obj.id)) {
                    if ("-1" == obj.id) {
                        let transitions = obj.soloTransitions;
                        if (transitions && 0 < transitions.length) {
                            defID = transitions[0].id;
                        }
                    }
                    continue;
                }
                let state = new AnimatorState();
                idCatch[obj.id] = state;
                ret[obj.id] = state;
                for (let k in obj) {
                    try {
                        if ("scripts" == k) {
                            let scripts = obj[k];
                            if (scripts && Array.isArray(scripts)) {
                                for (let k = scripts.length - 1; k >= 0; k--) {
                                    let uuid = scripts[k];
                                    if (uuid && 0 == uuid.indexOf("res://")) {
                                        uuid = uuid.substring(6);
                                    }
                                    let c = Laya.ClassUtils.getClass(uuid);
                                    if (c) {
                                        state.addScript(c);
                                    }
                                }
                            }
                            continue;
                        }
                        else if ("soloTransitions" == k) {
                            continue;
                        }
                        else if (null != obj[k]) {
                            state[k] = obj[k];
                        }
                    }
                    catch (err) { }
                }
                acl.addState(state);
            }
            return { id: defID, states: ret };
        }
        setExitTransition(exitRet, transitions, idCatch, data, pExitRet) {
            for (let id in exitRet) {
                let state = idCatch[id];
                if (state) {
                    let ats = state.transitions;
                    let sts = state.soloTransitions;
                    let linArr = exitRet[id];
                    for (let i = transitions.length - 1; i >= 0; i--) {
                        let t = transitions[i];
                        if ("-3" == t.id) {
                            if (null == pExitRet[id]) {
                                pExitRet[id] = [];
                            }
                            pExitRet[id].push(t);
                            continue;
                        }
                        for (let j = linArr.length - 1; j >= 0; j--) {
                            let t2 = linArr[j];
                            let ato = new AnimatorTransition();
                            ato.destState = idCatch[t.id];
                            if (t.conditions) {
                                this.addConditions(t.conditions, ato, data);
                            }
                            if (t2.conditions) {
                                this.addConditions(t2.conditions, ato, data);
                            }
                            for (let k in t) {
                                if ("solo" == k || "id" == k || "conditions" == k) {
                                    continue;
                                }
                                else {
                                    ato[k] = t[k];
                                }
                            }
                            if (t.solo) {
                                sts.unshift(ato);
                            }
                            else {
                                ats.unshift(ato);
                            }
                        }
                    }
                }
            }
        }
        setTransitions(states, idCatch, acl, data, pState) {
            if (!states)
                return null;
            let exitRet = {};
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    let exitTransition = this.setTransitions(obj.states, idCatch, acl, data, obj);
                    if (exitTransition) {
                        let transitions = obj.soloTransitions;
                        if (transitions) {
                            this.setExitTransition(exitTransition, transitions, idCatch, data, exitRet);
                        }
                    }
                }
            }
            for (let i = states.length - 1; i >= 0; i--) {
                let obj = states[i];
                if (obj.states) {
                    continue;
                }
                if ("-1" == obj.id) {
                    if (obj.soloTransitions && 0 < obj.soloTransitions.length) {
                        if (null == pState) {
                            acl.defaultState = idCatch[obj.soloTransitions[0].id];
                        }
                        else {
                            idCatch[pState.id] = idCatch[obj.soloTransitions[0].id];
                        }
                        continue;
                    }
                }
                else if ("-2" == obj.id) {
                    let transitions = obj.soloTransitions;
                    if (transitions) {
                        for (let j = transitions.length - 1; j >= 0; j--) {
                            let o = transitions[j];
                            let destState = idCatch[o.id];
                            if (destState) {
                                for (let idk in idCatch) {
                                    let state = idCatch[idk];
                                    let ato = new AnimatorTransition();
                                    ato.destState = destState;
                                    if (o.conditions) {
                                        this.addConditions(o.conditions, ato, data);
                                    }
                                    for (let k in o) {
                                        if ("solo" == k || "id" == k || "conditions" == k) {
                                            continue;
                                        }
                                        else {
                                            ato[k] = o[k];
                                        }
                                    }
                                    if (o.solo) {
                                        state.soloTransitions.unshift(ato);
                                    }
                                    else {
                                        state.transitions.unshift(ato);
                                    }
                                }
                            }
                        }
                    }
                    continue;
                }
                else if ("-3" == obj.id) {
                    continue;
                }
                let soloTransitions = obj.soloTransitions;
                if (soloTransitions && idCatch[obj.id]) {
                    let ats = idCatch[obj.id].transitions;
                    let sts = idCatch[obj.id].soloTransitions;
                    for (let j = soloTransitions.length - 1; j >= 0; j--) {
                        let o = soloTransitions[j];
                        if ("-3" == o.id) {
                            if (null == exitRet[obj.id]) {
                                exitRet[obj.id] = [];
                            }
                            exitRet[obj.id].push(o);
                            continue;
                        }
                        let ato = new AnimatorTransition();
                        if (idCatch[o.id]) {
                            ato.destState = idCatch[o.id];
                        }
                        if (o.conditions) {
                            this.addConditions(o.conditions, ato, data);
                        }
                        for (let k in o) {
                            if ("solo" == k || "id" == k || "conditions" == k) {
                                continue;
                            }
                            else {
                                ato[k] = o[k];
                            }
                        }
                        if (o.solo) {
                            sts.unshift(ato);
                        }
                        else {
                            ats.unshift(ato);
                        }
                    }
                }
            }
            return exitRet;
        }
        getState(states, acl, data) {
            if (states) {
                let idCatch = {};
                this.createState(states, idCatch, acl);
                this.setTransitions(states, idCatch, acl, data);
            }
        }
        addConditions(arr, ato, data) {
            let parms = data.animatorParams;
            if (null == parms || 0 == parms.length)
                return;
            for (let i = 0, len = arr.length; i < len; i++) {
                let o = arr[i];
                let parm = null;
                for (let j = parms.length - 1; j >= 0; j--) {
                    if (parms[j].id == o.id) {
                        parm = parms[j];
                        break;
                    }
                }
                if (null == parm) {
                    return;
                }
                let c;
                if (parm.type == Laya.AniParmType.Bool) {
                    let b = new Laya.AnimatorStateBoolCondition(parm.name);
                    b.compareFlag = Boolean(o.checkValue);
                    c = b;
                }
                else if (parm.type == Laya.AniParmType.Float) {
                    let n = new Laya.AnimatorStateNumberCondition(parm.name);
                    n.numberValue = Number(o.checkValue);
                    n.compareFlag = o.type;
                    c = n;
                }
                else if (parm.type == Laya.AniParmType.Trigger) {
                    let t = new Laya.AnimatorStateTriggerCondition(parm.name);
                    c = t;
                }
                ato.addCondition(c);
            }
        }
    }

    class BatchMark {
        constructor() {
            this.updateMark = -1;
            this.indexInList = -1;
            this.batched = false;
        }
    }

    class InstanceBatchManager {
        constructor() {
            this._instanceBatchOpaqueMarks = [];
            this.updateCountMark = 0;
        }
        _getData(key, data, cls) {
            if (null == cls) {
                cls = Array;
            }
            if ("boolean" == typeof key) {
                return (data[key ? 0 : 1]) || (data[key ? 0 : 1] = new cls());
            }
            else {
                return data[key] || (data[key] = new cls());
            }
        }
        getInstanceBatchOpaquaMark(element) {
            let invertFrontFace = element._transform ? element._transform._isFrontFaceInvert : false;
            let receiveShadow = element._baseRender._receiveShadow;
            let matID_geometry = (element._material._id << 17) + (element._geometry._id << 2) + (Number(invertFrontFace) << 1) + Number(receiveShadow);
            let reflectid = (element._baseRender._probReflection ? element._baseRender._probReflection._reflectionProbeID : -1) + 1;
            let lightmapid = (element._baseRender.lightmapIndex) + 1;
            let lightprobid = (element._baseRender._lightProb ? element._baseRender._lightProb._volumetricProbeID : -1) + 1;
            let giID = (reflectid << 10) + (lightmapid << 20) + lightprobid;
            var data = this._getData(matID_geometry, this._instanceBatchOpaqueMarks);
            return this._getData(giID, data, BatchMark);
        }
    }
    InstanceBatchManager.instance = new InstanceBatchManager();

    class BatchRender extends BaseRender {
        constructor() {
            super();
            this._lodInstanceRenderElement = {};
            this._RenderBitFlag = exports.RenderBitFlag.RenderBitFlag_Batch;
            this._renderElements = [];
            this._lodInstanceRenderElement[-1] = [];
            this._batchList = new Laya.SingletonList();
        }
        get checkLOD() {
            return this._checkLOD;
        }
        set checkLOD(value) {
            this._checkLOD = value;
        }
        get lodCullRateArray() {
            return this._lodRateArray;
        }
        set lodCullRateArray(value) {
            if (!this._checkLOD) {
                return;
            }
            value.sort((a, b) => b - a);
            this._lodRateArray = value;
        }
        _canBatch(render) {
            if (render._batchRender) {
                return false;
            }
            return false;
        }
        _onEnable() {
            super._onEnable();
            if (this._batchList) {
                for (let i = 0, n = this._batchList.length; i < n; i++) {
                    this._batchList.elements[i].setRenderbitFlag(this._RenderBitFlag, true);
                }
            }
        }
        _onDisable() {
            super._onDisable();
            if (this._batchList) {
                for (let i = 0, n = this._batchList.length; i < n; i++) {
                    this._batchList.elements[i].setRenderbitFlag(this._RenderBitFlag, false);
                }
            }
        }
        _changeLOD(lod) {
            if (this._cacheLod == lod) {
                return;
            }
            if (this._cacheLod == this.lodCullRateArray.length - 1) {
                lod = -1;
            }
            this._renderElements = this._lodInstanceRenderElement[lod];
            if (this._lodInstanceRenderElement[lod] && lod != -1) {
                this._renderElements || (this._renderElements = []);
                this._renderElements = this._renderElements.concat(this._lodInstanceRenderElement[-1]);
            }
            else {
                this._renderElements = this._lodInstanceRenderElement[-1];
            }
        }
        onPreRender() {
            if (!this.checkLOD || !this._lodRateArray || this._lodRateArray.length < 1) {
                this._changeLOD(0);
            }
            else {
                let checkCamera = this.owner.scene.cullInfoCamera;
                let maxYDistance = checkCamera.maxlocalYDistance;
                Laya.Vector3.subtract(this._bounds._imp.getCenter(), checkCamera.transform.position, tempVec$2);
                let length = tempVec$2.length();
                let rateYDistance = length / checkCamera.farPlane * maxYDistance;
                let rate = (this._lodsize / rateYDistance);
                for (let i = 0; i < this._lodRateArray.length; i++) {
                    if (rate < this._lodRateArray[i])
                        continue;
                    this._changeLOD(i);
                    break;
                }
            }
        }
        _batchOneRender(render) {
            return false;
        }
        _removeOneRender(render) {
        }
        _updateOneRender(render) {
        }
        addList(renderNode) {
            for (var i = 0, n = renderNode.length; i < n; i++) {
                let baseRender = renderNode[i];
                if (this._canBatch(baseRender)) {
                    this._batchList.add(baseRender);
                }
            }
        }
        reBatch() {
            let renderNums = this._batchList.length;
            let renders = this._batchList.elements;
            for (var i = 0; i < renderNums; i++) {
                let render = renders[i];
                this._batchOneRender(render);
            }
        }
        _restorRenderNode() {
            for (let i = 0, n = this._batchList.length; i < n; i++) {
                this._removeOneRender(this._batchList.elements[i]);
            }
        }
        _clear() {
            this._restorRenderNode();
            this._renderElements = [];
            this._batchList.destroy();
            this._batchList = new Laya.SingletonList();
            this._lodInstanceRenderElement = {};
            this._lodInstanceRenderElement[-1] = [];
        }
    }
    const tempVec$2 = new Laya.Vector3();

    class StaticInstanceBatchRender extends BatchRender {
        constructor() {
            super();
            this._insBatchMarksNums = [];
            this._insElementMarksArray = [];
            this._instanceBatchminNums = 10;
            this._updateChangeElement = [];
            this.checkLOD = true;
            this._batchManager = new InstanceBatchManager();
            this._RenderBitFlag = exports.RenderBitFlag.RenderBitFlag_InstanceBatch;
        }
        _isRenderNodeAllCanInstanceBatch(render) {
            let elements = render._renderElements;
            for (var i = 0, n = elements.length; i < n; i++) {
                let element = elements[i];
                if (!element.material._shader._enableInstancing) {
                    return false;
                }
            }
            return true;
        }
        _sumInstanceBatch(render) {
            let elements = render._renderElements;
            for (var i = 0, n = elements.length; i < n; i++) {
                let element = elements[i];
                var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element);
                if (insBatchMarks.indexInList == -1) {
                    insBatchMarks.indexInList = this._insBatchMarksNums.length;
                    this._insBatchMarksNums.push(0);
                }
                this._insBatchMarksNums[insBatchMarks.indexInList] += 1;
            }
        }
        _batchOneElement(element, render) {
            var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element);
            if (insBatchMarks.indexInList == -1)
                return;
            let instanceelement = this._insElementMarksArray[insBatchMarks.indexInList];
            if (!instanceelement) {
                instanceelement = this._createInstanceElement(element, render, insBatchMarks);
            }
            let list = instanceelement._instanceBatchElementList;
            if (list.length == InstanceRenderElement.maxInstanceCount) {
                this._insBatchMarksNums.push(this._insBatchMarksNums[insBatchMarks.indexInList]);
                insBatchMarks.indexInList = this._insBatchMarksNums.length - 1;
                instanceelement = this._createInstanceElement(element, render, insBatchMarks);
                list = instanceelement._instanceBatchElementList;
            }
            if (list.indexof(element) == -1) {
                list.add(element);
                instanceelement._isUpdataData = true;
                (this._updateChangeElement.indexOf(instanceelement) == -1) && this._updateChangeElement.push(instanceelement);
            }
        }
        _removeOneElement(element, render) {
            var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element);
            if (insBatchMarks.indexInList == -1)
                return;
        }
        _updateOneElement(element, render) {
        }
        _createInstanceElement(element, render, batchMark) {
            let instanceRenderElement = new InstanceRenderElement();
            instanceRenderElement.render = render;
            instanceRenderElement._geometry.subMesh = element._geometry;
            instanceRenderElement.material = element.material;
            instanceRenderElement.setTransform(null);
            instanceRenderElement.renderSubShader = element.renderSubShader;
            let list = instanceRenderElement._instanceBatchElementList;
            list.length = 0;
            list.add(element);
            this._insElementMarksArray[batchMark.indexInList] = instanceRenderElement;
            batchMark.batched = true;
            if (!this._lodInstanceRenderElement[render._LOD]) {
                this._lodInstanceRenderElement[render._LOD] = [];
            }
            this._lodInstanceRenderElement[render._LOD].push(instanceRenderElement);
            return instanceRenderElement;
        }
        _canBatch(render) {
            let elements = render._renderElements;
            for (var i = 0, n = elements.length; i < n; i++) {
                let element = elements[i];
                var insBatchMarks = this._batchManager.getInstanceBatchOpaquaMark(element);
                if (this._insBatchMarksNums[insBatchMarks.indexInList] < this._instanceBatchminNums || element.material.renderQueue >= 3000) {
                    return false;
                }
            }
            return true;
        }
        _calculateBoundingBox() {
            let bound = this._bounds;
            for (let i = 0, n = this._batchList.length; i < n; i++) {
                if (i == 0) {
                    this._batchList.elements[i].bounds.cloneTo(bound);
                }
                else {
                    Bounds.merge(bound, this._batchList.elements[i].bounds, bound);
                }
            }
            let extend = this._bounds.getExtent();
            this._lodsize = 2 * Math.max(extend.x, extend.y, extend.z);
            return this._bounds;
        }
        _onDestroy() {
            super._onDestroy();
        }
        _batchOneRender(render) {
            if (!this._canBatch(render))
                return false;
            this.boundsChange = true;
            let elements = render._renderElements;
            for (let i = 0, n = elements.length; i < n; i++) {
                let renderelement = elements[i];
                this._batchOneElement(renderelement, render);
            }
            render._batchRender = this;
            render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_InstanceBatch, true);
            return true;
        }
        _removeOneRender(render) {
            if (!this._canBatch(render))
                return;
            if (this._batchList.indexof(render) != -1) {
                this.boundsChange = true;
                let elements = render._renderElements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let renderelement = elements[i];
                    this._removeOneElement(renderelement, render);
                }
                render._batchRender = null;
                render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_InstanceBatch, false);
            }
        }
        _updateOneRender(render) {
            if (!this._canBatch(render))
                return;
            if (this._batchList.indexof(render) != -1) {
                this.boundsChange = true;
                let elements = render._renderElements;
                for (let i = 0, n = elements.length; i < n; i++) {
                    let renderelement = elements[i];
                    this._updateOneElement(renderelement, render);
                }
            }
        }
        _clear() {
            super._clear();
            this._insElementMarksArray.forEach(element => {
                element && element.destroy();
            });
            this._insElementMarksArray = [];
            this._updateChangeElement = [];
            this._insBatchMarksNums = [];
        }
        addList(renderNodes) {
            if (!this._batchList) {
                this._batchList = new Laya.SingletonList();
            }
            let renders = [];
            for (var i = 0; i < renderNodes.length; i++) {
                let baseRender = renderNodes[i];
                if (baseRender._batchRender) {
                    continue;
                }
                if (this._isRenderNodeAllCanInstanceBatch(baseRender)) {
                    renders.push(baseRender);
                    this._sumInstanceBatch(baseRender);
                }
            }
            for (var i = 0, n = renders.length; i < n; i++) {
                let baseRender = renders[i];
                if (this._canBatch(baseRender)) {
                    this._batchList.add(baseRender);
                }
            }
        }
        reBatch() {
            let renderNums = this._batchList.length;
            let renders = this._batchList.elements;
            for (var i = 0; i < renderNums; i++) {
                let render = renders[i];
                this._batchOneRender(render);
            }
        }
    }

    class StatiVertexMergeBatchRender extends BatchRender {
        _addList(renderNodes) {
        }
    }

    class StaticBatchVolume extends Volume {
        _getStaticInstanceBatchRender() {
            let render = this.owner.getComponent(StaticInstanceBatchRender);
            if (!render) {
                render = this.owner.addComponent(StaticInstanceBatchRender);
            }
            return render;
        }
        _getStatiVertexMergeBatchRender() {
            let render = this.owner.getComponent(StatiVertexMergeBatchRender);
            if (!render) {
                render = this.owner.addComponent(StatiVertexMergeBatchRender);
            }
            return render;
        }
        get checkLOD() {
            return this._checkLOD;
        }
        set checkLOD(value) {
            this._checkLOD = value;
            if (this._enableStaticInstanceBatch) {
                this._instanceBatchRender.checkLOD = value;
            }
            if (this._enableStaticVertexMergeBatch) {
                this._vertexMergeBatchRender.checkLOD = value;
            }
            if (this._enableCustomBatch) {
                this._customBatchs.forEach(element => {
                    element.checkLOD = value;
                });
            }
        }
        get enableStaticInstanceBatchRender() {
            return this._enableStaticInstanceBatch;
        }
        set enableStaticInstanceBatchRender(value) {
            if (!this._instanceBatchRender && value) {
                this._instanceBatchRender = this._getStaticInstanceBatchRender();
            }
            if (value == this._enableStaticInstanceBatch)
                return;
            if (value) {
                this._instanceBatchRender.enabled = true;
            }
            else {
                this._instanceBatchRender.enabled = false;
            }
            this._enableStaticInstanceBatch = value;
        }
        get enableMergeBatchRender() {
            return this._enableStaticVertexMergeBatch;
        }
        set enableMergeBatchRender(value) {
            if (!this._vertexMergeBatchRender && value) {
                this._vertexMergeBatchRender = this._getStatiVertexMergeBatchRender();
            }
            if (value == this._enableStaticVertexMergeBatch)
                return;
            if (value) {
                this._vertexMergeBatchRender.enabled = true;
            }
            else {
                this._vertexMergeBatchRender.enabled = false;
            }
            this._enableStaticVertexMergeBatch = value;
        }
        get enableCustomBatchRender() {
            return this._enableCustomBatch;
        }
        set enableCustomBatchRender(value) {
            this._enableCustomBatch = value;
            this._customBatchs.forEach(element => {
                element.enabled = value;
            });
        }
        get customBatchRenders() {
            return this._customBatchs;
        }
        set customBatchRenders(value) {
            if (this._customBatchs) {
                this._customBatchs.forEach(element => {
                    this.owner._destroyComponent(element);
                });
            }
            this._customBatchs = value;
            this._customBatchs.forEach(element => {
                this.owner.addComponentInstance(element);
            });
            this.enableCustomBatchRender = this._enableCustomBatch;
        }
        constructor() {
            super();
            this._customBatchs = [];
            this.checkLOD = true;
            this._enableStaticInstanceBatch = false;
            this._enableStaticVertexMergeBatch = false;
            this._cacheRender = new Laya.SingletonList();
            this._batchRender = new Laya.SingletonList();
            this._enableCustomBatch = false;
        }
        _restorRenderNode() {
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element._clear();
                });
            }
            if (this._enableStaticInstanceBatch) {
                this._instanceBatchRender._clear();
            }
            if (this.enableCustomBatchRender) {
                this._vertexMergeBatchRender._clear();
            }
        }
        __addRenderNodeToBatch(renderNode) {
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    if (element._batchOneRender(renderNode))
                        return;
                });
            }
            if (this._enableStaticInstanceBatch) {
                if (this._instanceBatchRender._batchOneRender(renderNode))
                    return;
            }
            if (this.enableCustomBatchRender) {
                if (this._vertexMergeBatchRender._batchOneRender(renderNode))
                    return;
            }
        }
        __removeRenderNodeFromBatch(renderNode) {
            renderNode._batchRender._removeOneRender(renderNode);
        }
        _onEnable() {
            super._onEnable();
            if (this._enableStaticInstanceBatch)
                this._instanceBatchRender && (this._instanceBatchRender.enabled = true);
            if (this._enableStaticVertexMergeBatch)
                this._vertexMergeBatchRender && (this._vertexMergeBatchRender.enabled = true);
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element.enabled = true;
                });
            }
        }
        _onDisable() {
            super._onDisable();
            if (this._enableStaticInstanceBatch)
                this._instanceBatchRender && (this._instanceBatchRender.enabled = false);
            if (this._enableStaticVertexMergeBatch)
                this._vertexMergeBatchRender && (this._vertexMergeBatchRender.enabled = false);
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element.enabled = false;
                });
            }
        }
        _addRenderNode(renderNode) {
            if (renderNode.renderNode.staticMask == exports.StaticFlag.StaticBatch) {
                if (this._cacheRender.indexof(renderNode) != -1) {
                    return;
                }
                this._cacheRender.add(renderNode);
                if (this._batchRender.length > 0) {
                    this.__addRenderNodeToBatch(renderNode);
                }
            }
        }
        _removeRenderNode(renderNode) {
            if (renderNode.renderNode.staticMask == exports.StaticFlag.StaticBatch) {
                if (this._batchRender.indexof(renderNode) != -1) {
                    this.__removeRenderNodeFromBatch(renderNode);
                    this._batchRender.remove(renderNode);
                }
            }
        }
        _VolumeChange() {
            super._VolumeChange();
            this._cacheRender.clear();
        }
        onStart() {
            this.reBatch();
        }
        reBatch() {
            this._cacheRender.elements.length = this._cacheRender.length;
            this._batchRender.clear();
            this._restorRenderNode();
            if (this.enableCustomBatchRender) {
                this._customBatchs.forEach(element => {
                    element.addList(this._cacheRender.elements);
                    element.reBatch();
                });
            }
            if (this._enableStaticInstanceBatch) {
                this._instanceBatchRender.addList(this._cacheRender.elements);
                this._instanceBatchRender.reBatch();
            }
            if (this.enableCustomBatchRender) {
                this._vertexMergeBatchRender.addList(this._cacheRender.elements);
                this._vertexMergeBatchRender.reBatch();
            }
            for (var i = 0, n = this._cacheRender.length; i < n; i++) {
                (this._cacheRender.elements[i]._batchRender) && this._batchRender.add(this._cacheRender.elements[i]);
            }
        }
    }

    class UI3DGeometry extends GeometryElement {
        constructor(owner) {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this._owner = owner;
            this.bufferState = new Laya.BufferState();
            this._bound = new Bounds();
            this._createBuffer();
            this.indexFormat = Laya.IndexFormat.UInt16;
        }
        get bounds() {
            return this._bound;
        }
        _createBuffer() {
            var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration("POSITION,NORMAL,UV");
            var halfLong = 1 / 2;
            var halfWidth = 1 / 2;
            this._vertex = new Float32Array([-halfLong, halfWidth, 0, 0, 0, 1, 0, 0,
                halfLong, halfWidth, 0, 0, 0, 1, 1, 0,
                -halfLong, -halfWidth, 0, 0, 0, 1, 0, 1,
                halfLong, -halfWidth, 0, 0, 0, 1, 1, 1]);
            this._index = new Uint16Array([0, 1, 2, 3, 2, 1]);
            this._vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(this._vertex.length * 4, Laya.BufferUsage.Dynamic, false);
            this._vertexBuffer.vertexDeclaration = vertexDeclaration;
            this._vertexBuffer.setData(this._vertex.buffer);
            this._indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, this._index.length, Laya.BufferUsage.Static, false);
            this._indexBuffer.setData(this._index);
            this.bufferState = new Laya.BufferState();
            this.bufferState.applyState([this._vertexBuffer], this._indexBuffer);
            this._bound.setExtent(new Laya.Vector3(halfLong, halfWidth, halfLong));
            this._bound.setCenter(new Laya.Vector3(0, 0, 0));
            this._positionArray = [new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3(), new Laya.Vector3()];
            this._positionArray[0].set(-halfWidth, halfLong, 0.0);
            this._positionArray[1].set(halfWidth, halfLong, 0.0);
            this._positionArray[2].set(-halfWidth, -halfLong, 0.0);
            this._positionArray[3].set(halfWidth, -halfLong, 0.0);
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            this.setDrawElemenParams(6, 0);
        }
        destroy() {
            super.destroy();
            this.bufferState.destroy();
            this._vertexBuffer.destroy();
            this._indexBuffer.destroy();
            this.bufferState = null;
            this._vertexBuffer = null;
            this._indexBuffer = null;
            delete this._vertex;
            delete this._index;
        }
    }
    UI3DGeometry._type = GeometryElement._typeCounter++;
    new Laya.Vector3();

    class UI3D extends BaseRender {
        get sprite() {
            return this._uisprite;
        }
        set sprite(value) {
            if (value == this._uisprite)
                return;
            this._uisprite = value;
            this._shellSprite.removeChildren(0, this._shellSprite.numChildren - 1);
            if (value)
                this._shellSprite.addChild(value);
            this._resizeRT();
            this.boundsChange = true;
        }
        get prefab() {
            return this._prefab;
        }
        set prefab(value) {
            this._prefab = value;
            if (value)
                this.sprite = value.create();
            else
                this.sprite = null;
        }
        get scale() {
            return this._size;
        }
        set scale(value) {
            if (value.x <= 0 || value.y <= 0 || Laya.Vector2.equals(value, this._size))
                return;
            value.cloneTo(this._size);
            this._resizeRT();
            this.boundsChange = true;
            this._scale.setValue(value.x, value.y, 1);
        }
        get renderMode() {
            if (!this.sharedMaterial)
                this.sharedMaterial = this._ui3DMat;
            return this.sharedMaterial.materialRenderMode;
        }
        set renderMode(value) {
            this.sharedMaterial.materialRenderMode = value;
            this.boundsChange = true;
        }
        get cull() {
            let mat = this.sharedMaterial;
            if (!mat) {
                mat = this._ui3DMat;
            }
            return mat.cull;
        }
        set cull(value) {
            this.sharedMaterial && (this.sharedMaterial.cull = value);
        }
        get resolutionRate() {
            return this._resolutionRate;
        }
        set resolutionRate(value) {
            if (value <= 0)
                return;
            if (this._resolutionRate == value)
                return;
            this._resolutionRate = value;
            this._resizeRT();
        }
        get billboard() {
            return this._view;
        }
        set billboard(value) {
            this._view = value;
            this._sizeChange = true;
            this.boundsChange = true;
        }
        get enableHit() {
            return this._hit;
        }
        set enableHit(value) {
            this._hit = value;
        }
        set cameraSpace(value) {
            if (this._cameraSpace == value) {
                return;
            }
            this._cameraSpace = value;
            this._resizeRT();
        }
        get cameraSpace() {
            return this._cameraSpace;
        }
        set cameraPlaneDistance(value) {
            value = Math.max(0, value);
            this._cameraPlaneDistance = value;
        }
        get cameraPlaneDistance() {
            return this._cameraPlaneDistance;
        }
        set attachCamera(value) {
            if (this._camera == value)
                return;
            this._camera = value;
            this._resizeRT();
        }
        get attachCamera() {
            return this._camera;
        }
        constructor() {
            super();
            this._sizeChange = true;
            this._view = true;
            this._bindPropertyName = "u_AlbedoTexture";
            this._hit = false;
            this._cameraSpace = false;
            this._worldParams = new Laya.Vector4();
            this._size = new Laya.Vector2(1, 1);
            this._resolutionRate = 128;
            this._shellSprite = new Laya.Sprite();
            this._shellSprite.name = "UI3D";
            this._shellSprite._setBit(Laya.NodeFlags.DISPLAYED_INSTAGE, true);
            this._shellSprite._setBit(Laya.NodeFlags.ACTIVE_INHIERARCHY, true);
            this._shellSprite._parent = Laya.ILaya.stage;
            this._baseRenderNode.shaderData.addDefine(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
            this._matrix = new Laya.Matrix4x4();
            this._scale = new Laya.Vector3(1.0, 1.0, 1.0);
        }
        _creatDefaultMat() {
            if (this._ui3DMat)
                return;
            this._ui3DMat = new UnlitMaterial();
            this._ui3DMat.materialRenderMode = Laya.MaterialRenderMode.RENDERMODE_OPAQUE;
            this._ui3DMat.cull = RenderState.CULL_BACK;
        }
        _addRenderElement() {
            var elements = this._renderElements;
            if (!this.sharedMaterial) {
                this._creatDefaultMat();
                this.sharedMaterial = this._ui3DMat;
            }
            this._setMaterialTexture();
            var material = this.sharedMaterial;
            var element = new RenderElement();
            element.setTransform(this.owner._transform);
            element.render = this;
            element.material = material;
            element.renderSubShader = element.material.shader.getSubShaderAt(0);
            this._geometry = new UI3DGeometry(this);
            element.setGeometry(this._geometry);
            elements.push(element);
            this._setRenderElements();
            this.geometryBounds = this._geometry.bounds;
        }
        _isCameraSpaceMode() {
            return this._cameraSpace && this._camera;
        }
        _parseHit(ray) {
            let _tempRay = UI3D._ray;
            let u, v;
            if (!this._uisprite || !Laya.LayaEnv.isPlaying)
                return null;
            this._matrix.invert(tempMatrix$1);
            Laya.Vector3.transformCoordinate(ray.origin, tempMatrix$1, _tempRay.origin);
            Laya.Vector3.TransformNormal(ray.direction, tempMatrix$1, _tempRay.direction);
            _tempRay.direction.normalize();
            let normalizeHitWidth = 0;
            let normalizeHitHeight = 0;
            let t = -_tempRay.origin.z / _tempRay.direction.z;
            if (t < 0) {
                return null;
            }
            else {
                u = _tempRay.origin.x + t * _tempRay.direction.x;
                v = _tempRay.origin.y + t * _tempRay.direction.y;
            }
            normalizeHitWidth = u + 0.5;
            normalizeHitHeight = v + 0.5;
            let cx = normalizeHitWidth * this._rendertexure2D.width;
            let cy = (1.0 - normalizeHitHeight) * this._rendertexure2D.height;
            let target = Laya.InputManager.inst.getSpriteUnderPoint(this._uisprite, cx, cy);
            if (target)
                return target;
            else
                return null;
        }
        _resizeRT() {
            let width;
            let height;
            if (this._isCameraSpaceMode()) {
                width = this._camera.viewport.width;
                height = this._camera.viewport.height;
            }
            else {
                width = this._size.x * this._resolutionRate;
                height = this._size.y * this._resolutionRate;
            }
            let invertY = !Laya.LayaGL.renderEngine._screenInvertY;
            if (!this._rendertexure2D) {
                this._rendertexure2D = new Laya.RenderTexture2D(width, height, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.None);
                this._rendertexure2D._invertY = invertY;
            }
            else {
                if (this._rendertexure2D.width != width || this._rendertexure2D.height != height) {
                    this._rendertexure2D.destroy();
                    this._rendertexure2D = new Laya.RenderTexture2D(width, height, Laya.RenderTargetFormat.R8G8B8A8, Laya.RenderTargetFormat.None);
                    this._rendertexure2D._invertY = invertY;
                    this._setMaterialTexture();
                }
            }
            this._submitRT();
        }
        onPreRender() {
            if (this._isCameraSpaceMode()) {
                this.boundsChange = true;
                let cameraforward = Laya.Vector3.TEMP;
                let rotate = Laya.Quaternion.TEMP;
                let scale = tempVec3;
                let camera = this._camera;
                camera.transform.getForward(cameraforward);
                cameraforward = cameraforward.normalize();
                Laya.Vector3.scale(cameraforward, this._cameraPlaneDistance, cameraforward);
                Laya.Vector3.add(camera.transform.position, cameraforward, cameraforward);
                camera.transform.rotation.cloneTo(rotate);
                if (camera.orthographic) {
                    scale.setValue(camera.orthographicVerticalSize * camera.aspectRatio, camera.orthographicVerticalSize, 1);
                }
                else {
                    let height = Math.tan(Laya.Utils.toRadian(camera.fieldOfView / 2)) * this._cameraPlaneDistance * 2;
                    scale.setValue(height * camera.aspectRatio, height, 1);
                }
                Laya.Matrix4x4.createAffineTransformation(cameraforward, rotate, scale, this._matrix);
            }
            else {
                if (this.billboard) {
                    this._sizeChange = false;
                    let camera = this.owner.scene.cullInfoCamera;
                    Laya.Matrix4x4.createAffineTransformation(this._transform.position, camera.transform.rotation, this._scale, this._matrix);
                }
                else if (this._sizeChange) {
                    this.boundsChange = true;
                    this._transform.worldMatrix.cloneTo(this._matrix);
                }
            }
        }
        getUITexture() {
            return this._rendertexure2D;
        }
        _getCameraDistance(rayOri) {
            return Laya.Vector3.distance(rayOri, this.owner.transform.position);
        }
        _renderUpdate(context) {
            let shaderData = this._baseRenderNode.shaderData;
            shaderData.setMatrix4x4(Sprite3D.WORLDMATRIX, this._matrix);
            let transform = this.owner.transform;
            let worldParams = this._worldParams;
            worldParams.x = transform.getFrontFaceValue();
            shaderData.setVector(Sprite3D.WORLDINVERTFRONT, worldParams);
        }
        renderUpdate(context) {
            this._renderElements.forEach(element => {
                let geometry = element._geometry;
                element._renderElementOBJ.isRender = geometry._prepareRender(context);
                geometry._updateRenderParams(context);
            });
        }
        _submitRT() {
            this._rendertexure2D && this._shellSprite.drawToRenderTexture2D(this._rendertexure2D.width, this._rendertexure2D.height, 0, 0, this._rendertexure2D, false);
            this._setMaterialTexture();
        }
        _setMaterialTexture() {
            if (this._rendertexure2D) {
                this.sharedMaterial.addDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
                this.sharedMaterial.setTexture(this._bindPropertyName, this._rendertexure2D);
            }
            else {
                this.sharedMaterial.removeDefine(UnlitMaterial.SHADERDEFINE_ALBEDOTEXTURE);
            }
        }
        _checkUIPos(ray) {
            if (!this.enableHit)
                return false;
            return this._parseHit(ray);
        }
        _calculateBoundingBox() {
            this._geometry.bounds._tranform(this._matrix, this._bounds);
        }
        _onAdded() {
            super._onAdded();
            this._addRenderElement();
        }
        _onDisable() {
            super._onDisable();
            this.owner.transform.off(Laya.Event.TRANSFORM_CHANGED, this, this._transByRotate);
            this.owner.scene._UI3DManager.remove(this);
        }
        _onEnable() {
            super._onEnable();
            this.owner.scene._UI3DManager.add(this);
            this.owner.transform.on(Laya.Event.TRANSFORM_CHANGED, this, this._transByRotate);
            this._transByRotate();
        }
        _onDestroy() {
            super._onDestroy();
            this._rendertexure2D && this._rendertexure2D.destroy();
            this._shellSprite && (this._shellSprite._parent = null);
            this._uisprite && this._uisprite.destroy();
            this._shellSprite && this._shellSprite.destroy();
            this._ui3DMat && this._ui3DMat.destroy();
            this._resolutionRate = null;
            this._size = null;
            this._scale = null;
            this._matrix = null;
        }
        _transByRotate() {
            if (!this.billboard) {
                this._sizeChange = true;
            }
            this.boundsChange = true;
        }
    }
    UI3D.DEBUG = false;
    UI3D._ray = new Ray(new Laya.Vector3(), new Laya.Vector3());
    const tempMatrix$1 = new Laya.Matrix4x4();
    const tempVec3 = new Laya.Vector3();

    class AnimationClipLoader {
        load(task) {
            let url = Laya.AssetDb.inst.getSubAssetURL(task.url, task.uuid, null, "lani");
            return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                if (!data) {
                    return null;
                }
                return AnimationClip._parse(data);
            });
        }
    }
    Laya.Loader.registerLoader(["lani"], AnimationClipLoader, Laya.Loader.ANIMATIONCLIP);

    var internalResources$1;
    class CubemapLoader {
        constructor() {
            if (!internalResources$1) {
                internalResources$1 = {
                    "WhiteTextureCube.ltc": Laya.TextureCube.whiteTexture,
                    "BlackTextureCube.ltc": Laya.TextureCube.blackTexture,
                    "GrayTextureCube.ltc": Laya.TextureCube.grayTexture,
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                let tex = internalResources$1[Laya.Utils.getBaseName(task.url)];
                if (tex)
                    return Promise.resolve(tex);
            }
            if (task.ext == "ktx" || task.ext == "cubemap") {
                let url = task.url;
                if (task.ext == "cubemap")
                    url = Laya.AssetDb.inst.getSubAssetURL(url, task.uuid, "0", "ktx");
                return task.loader.fetch(url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let ktxInfo = Laya.KTXTextureInfo.getKTXTextureInfo(data);
                    if (ktxInfo.dimension != Laya.TextureDimension.Cube) {
                        Laya.Loader.warn("ktxInfo.dimension != TextureDimension.Cube! " + task.url);
                        return null;
                    }
                    let tex = new Laya.TextureCube(ktxInfo.width, ktxInfo.format, ktxInfo.mipmapCount > 1, ktxInfo.sRGB);
                    tex.setKTXData(ktxInfo);
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && (obsoluteInst instanceof Laya.TextureCube))
                        tex = this.move(obsoluteInst, tex);
                    return tex;
                });
            }
            else if (task.ext == "ltcb" || task.ext == "ltcb.ls") {
                return task.loader.fetch(task.url, "arraybuffer", task.progress.createCallback(), task.options).then(data => {
                    if (!data)
                        return null;
                    let byte = new Laya.Byte(data);
                    let version = byte.readUTFString();
                    if (version !== "LAYATEXTURECUBE:0000") {
                        console.warn(`CubemapBinLoader: unknow version. ${version}`);
                        return null;
                    }
                    let format = byte.readUint8();
                    let mipCount = byte.getUint8();
                    let size = byte.readUint16();
                    let filterMode = byte.getUint8();
                    let wrapModeU = byte.getUint8();
                    let wrapModev = byte.getUint8();
                    let anisoLevel = byte.getUint8();
                    let tex = new Laya.TextureCube(size, format, mipCount > 1 ? true : false);
                    tex.setPixelsData(null, false, false);
                    tex.filterMode = filterMode;
                    tex.wrapModeU = wrapModeU;
                    tex.wrapModeV = wrapModev;
                    tex.anisoLevel = anisoLevel;
                    let pos = byte.pos;
                    let mipSize = size;
                    for (let i = 0; i < mipCount; i++) {
                        let uint8Arrays = new Array(6);
                        let mipPixelLength = mipSize * mipSize * tex._getFormatByteCount();
                        for (let j = 0; j < 6; j++) {
                            uint8Arrays[j] = new Uint8Array(data, pos, mipPixelLength);
                            pos += mipPixelLength;
                        }
                        tex.updateSubPixelsData(uint8Arrays, 0, 0, mipSize, mipSize, i, false, false, false);
                        mipSize /= 2;
                    }
                    let obsoluteInst = task.obsoluteInst;
                    if (obsoluteInst && (obsoluteInst instanceof Laya.TextureCube))
                        tex = this.move(obsoluteInst, tex);
                    return tex;
                });
            }
            else {
                return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                    if (!data)
                        return null;
                    let ltcBasePath = Laya.URL.getPath(task.url);
                    let urls = [
                        Laya.URL.join(ltcBasePath, data.front),
                        Laya.URL.join(ltcBasePath, data.back),
                        Laya.URL.join(ltcBasePath, data.left),
                        Laya.URL.join(ltcBasePath, data.right),
                        Laya.URL.join(ltcBasePath, data.up),
                        Laya.URL.join(ltcBasePath, data.down)
                    ];
                    return Promise.all(urls.map(url => {
                        if (url)
                            return task.loader.fetch(url, "image", task.progress.createCallback(), task.options);
                        else
                            return Promise.resolve(null);
                    })).then(images => {
                        var _a, _b;
                        let constructParams = task.options.constructParams;
                        let size = constructParams ? constructParams[0] : ((_b = ((_a = images[0]) === null || _a === void 0 ? void 0 : _a.width)) !== null && _b !== void 0 ? _b : 1);
                        let format = constructParams ? constructParams[1] : Laya.TextureFormat.R8G8B8A8;
                        let mipmap = constructParams ? constructParams[3] : false;
                        let srgb = constructParams ? constructParams[5] : true;
                        let tex = new Laya.TextureCube(size, format, mipmap, srgb);
                        tex.setImageData(images, false, false);
                        let obsoluteInst = task.obsoluteInst;
                        if (obsoluteInst && (obsoluteInst instanceof Laya.TextureCube))
                            tex = this.move(obsoluteInst, tex);
                        return tex;
                    });
                });
            }
        }
        move(obsoluteInst, tex) {
            obsoluteInst._texture = tex._texture;
            obsoluteInst._format = tex.format;
            obsoluteInst.width = tex.width;
            obsoluteInst.height = tex.height;
            obsoluteInst.obsolute = false;
            delete Laya.Resource._idResourcesMap[tex.id];
            return obsoluteInst;
        }
    }
    Laya.Loader.registerLoader(["ltc", "ltcb", "ltcb.ls", "cubemap"], CubemapLoader, Laya.Loader.TEXTURECUBE);

    class Texture2DArrayLoader$1 {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                let textures = data.textures;
                if (textures) {
                    let urls = [];
                    let basePath = Laya.URL.getPath(task.url);
                    for (let i = textures.length - 1; i >= 0; i--) {
                        urls.unshift(Laya.URL.join(basePath, textures[i]));
                    }
                    return Promise.all(urls.map(url => {
                        if (url)
                            return task.loader.fetch(url, "image", task.progress.createCallback(), task.options);
                        else
                            return Promise.resolve(null);
                    })).then(images => {
                        let rt = new Laya.Texture2DArray(data.width, data.height, data.depth, data.format, data.mipmap, false, data.sRGB);
                        rt.setImageData(images, data.premultiplyAlpha, data.invertY);
                        return rt;
                    });
                }
                else {
                    return new Laya.Texture2DArray(data.width, data.height, data.depth, data.format, data.mipmap, false, data.sRGB);
                }
            });
        }
    }
    Laya.Loader.registerLoader(["tex2darray"], Texture2DArrayLoader$1, Laya.Loader.TEXTURECUBE);

    class AvatarMaskLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then(data => {
                if (!data)
                    return null;
                return new AvatarMask(data);
            });
        }
    }
    Laya.Loader.registerLoader(["lavm"], AvatarMaskLoader);

    class AnimationControllerLoader {
        load(task) {
            return task.loader.fetch(task.url, "json", task.progress.createCallback(0.2), task.options).then(data => {
                let ret = new AnimatorController(data);
                if (ret.data && ret.data.controllerLayers) {
                    let layers = ret.data.controllerLayers;
                    let promises = [];
                    for (let i = layers.length - 1; i >= 0; i--) {
                        if (layers[i].avatarMask) {
                            this.loadAvatarMask(layers[i], promises, task);
                        }
                        let states = layers[i].states;
                        this.loadStates(states, promises, task);
                    }
                    return Promise.all(promises).then(deps => {
                        ret.addDeps(deps);
                        return ret;
                    });
                }
                else
                    return ret;
            });
        }
        loadAvatarMask(l, promises, task) {
            let basePath = Laya.URL.getPath(task.url);
            if (l.avatarMask && l.avatarMask._$uuid && '' != l.avatarMask._$uuid) {
                let url = Laya.URL.getResURLByUUID(l.avatarMask._$uuid);
                if (!url.startsWith("res://"))
                    url = Laya.URL.join(basePath, url);
                promises.push(task.loader.load(url).then(res => {
                    l.avatarMask = res;
                    return res;
                }));
            }
            else {
                l.avatarMask = null;
            }
        }
        loadStates(states, promises, task) {
            let basePath = Laya.URL.getPath(task.url);
            for (let j = states.length - 1; j >= 0; j--) {
                if (states[j].clip && states[j].clip._$uuid) {
                    let url = Laya.URL.getResURLByUUID(states[j].clip._$uuid);
                    if (!url.startsWith("res://"))
                        url = Laya.URL.join(basePath, url);
                    promises.push(task.loader.load(url).then(res => {
                        states[j].clip = res;
                        return res;
                    }));
                }
                if (states[j].states) {
                    this.loadStates(states[j].states, promises, task);
                }
            }
        }
    }
    Laya.Loader.registerLoader(["controller"], AnimationControllerLoader);

    class HitResult {
        constructor() {
            this.succeeded = false;
            this.collider = null;
            this.point = new Laya.Vector3();
            this.normal = new Laya.Vector3();
            this.hitFraction = 0;
            this._inPool = false;
        }
    }

    const _vec2 = new Laya.Vector2();
    const _ray = new Ray(new Laya.Vector3(), new Laya.Vector3());
    const _hitResult = new HitResult();
    Laya.InputManager.prototype.getSprite3DUnderPoint = function (x, y) {
        _hitResult.succeeded = false;
        x = x * this._stage.clientScaleX;
        y = y * this._stage.clientScaleY;
        var pageX = x;
        var pageY = y;
        var normalWidth = x / Laya.Browser.mainCanvas.width;
        var normalHeight = y / Laya.Browser.mainCanvas.height;
        x = this._stage.width * normalWidth;
        y = this._stage.height * normalHeight;
        _vec2.setValue(x, y);
        for (let scene of this._stage._scene3Ds) {
            let sim = scene._physicsManager;
            let uiManager = scene._UI3DManager;
            let cameras = scene._cameraPool;
            for (let i = cameras.length - 1; i >= 0; i--) {
                let camera = cameras[i];
                let viewport = camera.viewport;
                let ratio = Laya.Config3D.pixelRatio;
                if (pageX >= viewport.x && pageY >= viewport.y && pageX <= (viewport.width / ratio + viewport.x) && pageY <= (viewport.height / ratio + viewport.y)) {
                    camera.viewportPointToRay(_vec2, _ray);
                    let sprite = uiManager.rayCast(_ray);
                    if (sprite)
                        return sprite;
                    if (!sim)
                        continue;
                    var sucess = sim.rayCast(_ray, _hitResult);
                    if (sucess || (camera.clearFlag === exports.CameraClearFlags.SolidColor || camera.clearFlag === exports.CameraClearFlags.Sky))
                        break;
                }
            }
            if (_hitResult.succeeded)
                return _hitResult.collider.owner;
        }
        return null;
    };

    class LoadModelV04 {
        static parse(readData, version, mesh, subMeshes) {
            LoadModelV04._mesh = mesh;
            LoadModelV04._subMeshes = subMeshes;
            LoadModelV04._version = version;
            LoadModelV04._readData = readData;
            LoadModelV04.READ_DATA();
            LoadModelV04.READ_BLOCK();
            LoadModelV04.READ_STRINGS();
            for (var i = 0, n = LoadModelV04._BLOCK.count; i < n; i++) {
                LoadModelV04._readData.pos = LoadModelV04._BLOCK.blockStarts[i];
                var index = LoadModelV04._readData.getUint16();
                var blockName = LoadModelV04._strings[index];
                var fn = LoadModelV04["READ_" + blockName];
                if (fn == null)
                    throw new Error("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            LoadModelV04._strings.length = 0;
            LoadModelV04._readData = null;
            LoadModelV04._version = null;
            LoadModelV04._mesh = null;
            LoadModelV04._subMeshes = null;
        }
        static _readString() {
            return LoadModelV04._strings[LoadModelV04._readData.getUint16()];
        }
        static READ_DATA() {
            LoadModelV04._DATA.offset = LoadModelV04._readData.getUint32();
            LoadModelV04._DATA.size = LoadModelV04._readData.getUint32();
        }
        static READ_BLOCK() {
            var count = LoadModelV04._BLOCK.count = LoadModelV04._readData.getUint16();
            var blockStarts = LoadModelV04._BLOCK.blockStarts = [];
            var blockLengths = LoadModelV04._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(LoadModelV04._readData.getUint32());
                blockLengths.push(LoadModelV04._readData.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = LoadModelV04._readData.getUint32();
            var count = LoadModelV04._readData.getUint16();
            var prePos = LoadModelV04._readData.pos;
            LoadModelV04._readData.pos = offset + LoadModelV04._DATA.offset;
            for (var i = 0; i < count; i++)
                LoadModelV04._strings[i] = LoadModelV04._readData.readUTFString();
            LoadModelV04._readData.pos = prePos;
        }
        static READ_MESH() {
            LoadModelV04._readString();
            var arrayBuffer = LoadModelV04._readData.__getBuffer();
            var i;
            var memorySize = 0;
            var vertexBufferCount = LoadModelV04._readData.getInt16();
            var offset = LoadModelV04._DATA.offset;
            for (i = 0; i < vertexBufferCount; i++) {
                var vbStart = offset + LoadModelV04._readData.getUint32();
                var vbLength = LoadModelV04._readData.getUint32();
                var vbArrayBuffer = arrayBuffer.slice(vbStart, vbStart + vbLength);
                var vbDatas = new Float32Array(vbArrayBuffer);
                var bufferAttribute = LoadModelV04._readString();
                var vertexDeclaration;
                switch (LoadModelV04._version) {
                    case "LAYAMODEL:0301":
                    case "LAYAMODEL:0400":
                        vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(bufferAttribute);
                        break;
                    case "LAYAMODEL:0401":
                        vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(bufferAttribute, false);
                        break;
                    default:
                        throw new Error("LoadModelV03: unknown version.");
                }
                if (!vertexDeclaration)
                    throw new Error("LoadModelV03: unknown vertexDeclaration.");
                var vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vbDatas.length * 4, Laya.BufferUsage.Static, true);
                vertexBuffer.vertexDeclaration = vertexDeclaration;
                vertexBuffer.setData(vbDatas.buffer);
                LoadModelV04._mesh._vertexBuffer = vertexBuffer;
                LoadModelV04._mesh._vertexCount += vertexBuffer._byteLength / vertexDeclaration.vertexStride;
                memorySize += vbDatas.length * 4;
            }
            var ibStart = offset + LoadModelV04._readData.getUint32();
            var ibLength = LoadModelV04._readData.getUint32();
            var ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
            var indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(Laya.IndexFormat.UInt16, ibLength / 2, Laya.BufferUsage.Static, true);
            indexBuffer.setData(ibDatas);
            LoadModelV04._mesh._indexBuffer = indexBuffer;
            memorySize += indexBuffer.indexCount * 2;
            LoadModelV04._mesh._setBuffer(LoadModelV04._mesh._vertexBuffer, indexBuffer);
            LoadModelV04._mesh._setCPUMemory(memorySize);
            LoadModelV04._mesh._setGPUMemory(memorySize);
            var boneNames = LoadModelV04._mesh._boneNames = [];
            var boneCount = LoadModelV04._readData.getUint16();
            boneNames.length = boneCount;
            for (i = 0; i < boneCount; i++)
                boneNames[i] = LoadModelV04._strings[LoadModelV04._readData.getUint16()];
            LoadModelV04._readData.pos += 8;
            var bindPoseDataStart = LoadModelV04._readData.getUint32();
            var bindPoseDataLength = LoadModelV04._readData.getUint32();
            var bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength));
            var bindPoseFloatCount = bindPoseDatas.length;
            var bindPoseBuffer = LoadModelV04._mesh._inverseBindPosesBuffer = new ArrayBuffer(bindPoseFloatCount * 4);
            LoadModelV04._mesh._inverseBindPoses = [];
            if (bindPoseFloatCount != 0)
                LoadModelV04._mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR;
            else
                LoadModelV04._mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL;
            for (i = 0; i < bindPoseFloatCount; i += 16) {
                var inverseGlobalBindPose = new Laya.Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, i * 4, 16));
                LoadModelV04._mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose;
            }
            return true;
        }
        static READ_SUBMESH() {
            var arrayBuffer = LoadModelV04._readData.__getBuffer();
            var subMesh = new SubMesh(LoadModelV04._mesh);
            LoadModelV04._readData.getInt16();
            LoadModelV04._readData.getUint32();
            LoadModelV04._readData.getUint32();
            var ibStart = LoadModelV04._readData.getUint32();
            var ibCount = LoadModelV04._readData.getUint32();
            var indexBuffer = LoadModelV04._mesh._indexBuffer;
            subMesh._indexBuffer = indexBuffer;
            subMesh._setIndexRange(ibStart, ibCount);
            var vertexBuffer = LoadModelV04._mesh._vertexBuffer;
            subMesh._vertexBuffer = vertexBuffer;
            var offset = LoadModelV04._DATA.offset;
            var subIndexBufferStart = subMesh._subIndexBufferStart;
            var subIndexBufferCount = subMesh._subIndexBufferCount;
            var boneIndicesList = subMesh._boneIndicesList;
            var drawCount = LoadModelV04._readData.getUint16();
            subIndexBufferStart.length = drawCount;
            subIndexBufferCount.length = drawCount;
            boneIndicesList.length = drawCount;
            var skinnedCache = LoadModelV04._mesh._skinnedMatrixCaches;
            var subMeshIndex = LoadModelV04._subMeshes.length;
            skinnedCache.length = LoadModelV04._mesh._inverseBindPoses.length;
            for (var i = 0; i < drawCount; i++) {
                subIndexBufferStart[i] = LoadModelV04._readData.getUint32();
                subIndexBufferCount[i] = LoadModelV04._readData.getUint32();
                var boneDicofs = LoadModelV04._readData.getUint32();
                var boneDicCount = LoadModelV04._readData.getUint32();
                var boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount));
                var boneIndexCount = boneIndices.length;
                for (var j = 0; j < boneIndexCount; j++) {
                    var index = boneIndices[j];
                    skinnedCache[index] || (skinnedCache[index] = new skinnedMatrixCache(subMeshIndex, i, j));
                }
            }
            LoadModelV04._subMeshes.push(subMesh);
            return true;
        }
    }
    LoadModelV04._BLOCK = { count: 0 };
    LoadModelV04._DATA = { offset: 0, size: 0 };
    LoadModelV04._strings = [];

    class MorphTarget {
        constructor() {
            this.fullWeight = 1;
        }
    }
    class MorphTargetChannel {
        constructor() {
            this.targetCount = 0;
            this.targets = new Array();
        }
        getTargetByIndex(index) {
            return this.targets[index];
        }
        addTarget(target) {
            this.targetCount++;
            this.targets.push(target);
            this.targets.sort((a, b) => {
                return a.fullWeight - b.fullWeight;
            });
        }
    }

    class MorphTargetData {
        constructor() {
            this.targets = new Array();
            this.channels = new Array();
            this.bounds = new Bounds();
            this.params = new Laya.Vector4();
        }
        addMorphChannel(channel) {
            channel._index = this.channels.length;
            this.channels.push(channel);
            channel.targets.forEach(target => {
                target._index = this.targets.length;
                this.targets.push(target);
            });
        }
        getMorphChannel(name) {
            return this.channels.find(value => value.name == name);
        }
        getMorphChannelbyIndex(index) {
            return this.channels[index];
        }
        get targetCount() {
            return this.targets.length;
        }
        get channelCount() {
            return this.channels.length;
        }
        initData() {
            if (Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Texture3D)) {
                let targetNum = this.targets.length;
                let maxTexSize = Laya.LayaGL.renderEngine.getParams(Laya.RenderParams.MAX_Texture_Size);
                let vertexCount = this.vertexCount;
                let vertexDec = this.vertexDec;
                let morphStride = vertexDec.vertexStride / 4;
                let elementCount = vertexDec.vertexElementCount;
                this.elementCount = elementCount;
                let texHeight = Math.floor(elementCount * vertexCount / maxTexSize) + 1;
                let texelStride = 4;
                this.targetTexture = new Laya.Texture2DArray(maxTexSize, texHeight, targetNum, Laya.TextureFormat.R32G32B32A32, false, false, false);
                this.targetTexture.filterMode = Laya.FilterMode.Point;
                this.targetTexture.anisoLevel = 1;
                this.targetTexture.lock = true;
                let data = new Float32Array(maxTexSize * texHeight * targetNum * texelStride).fill(0);
                let attributeOffset = this.attributeOffset = new Laya.Vector4(0, 0, 0, 0);
                attributeOffset.x = vertexDec._vertexElements.indexOf(vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_POSITION0));
                attributeOffset.y = vertexDec._vertexElements.indexOf(vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_NORMAL0));
                attributeOffset.z = vertexDec._vertexElements.indexOf(vertexDec.getVertexElementByUsage(Laya.VertexMesh.MESH_TANGENT0));
                let targetStride = maxTexSize * texHeight;
                for (let targetIndex = 0; targetIndex < targetNum; targetIndex++) {
                    let target = this.targets[targetIndex];
                    for (let vertexIndex = 0; vertexIndex < vertexCount; vertexIndex++) {
                        let dataOffset = (targetIndex * targetStride + vertexIndex * elementCount) * texelStride;
                        vertexDec._vertexElements.forEach((element, elementIndex) => {
                            let pixelOffset = dataOffset + elementIndex * 4;
                            let elementOffset = element.offset / 4;
                            let targetDataOffset = vertexIndex * morphStride + elementOffset;
                            switch (element.elementUsage) {
                                case Laya.VertexMesh.MESH_POSITION0:
                                case Laya.VertexMesh.MESH_NORMAL0:
                                    data[pixelOffset] = target.data[targetDataOffset];
                                    data[pixelOffset + 1] = target.data[targetDataOffset + 1];
                                    data[pixelOffset + 2] = target.data[targetDataOffset + 2];
                                    break;
                                case Laya.VertexMesh.MESH_TANGENT0:
                                    data[pixelOffset] = target.data[targetDataOffset];
                                    data[pixelOffset + 1] = target.data[targetDataOffset + 1];
                                    data[pixelOffset + 2] = target.data[targetDataOffset + 2];
                                    data[pixelOffset + 3] = target.data[targetDataOffset + 3];
                                    break;
                            }
                        });
                    }
                }
                this.targetTexture.setPixelsData(data, false, false);
                this.params.setValue(this.targetTexture.width, this.targetTexture.height, this.elementCount, this.channelCount);
            }
        }
        destroy() {
            if (this.targetTexture) {
                this.targetTexture.lock = false;
                this.targetTexture.destroy();
                this.targetTexture = null;
            }
            this.targets = null;
            this.channels = null;
        }
        clone() {
            let res = new MorphTargetData();
            res.bounds.setMin(this.bounds.getMin());
            res.bounds.setMax(this.bounds.getMax());
            res.vertexCount = this.vertexCount;
            res.vertexDec = this.vertexDec;
            let channelCount = this.channelCount;
            for (let index = 0; index < channelCount; index++) {
                let channel = this.getMorphChannelbyIndex(index);
                let newChannel = new MorphTargetChannel();
                newChannel.name = channel.name;
                let targetCount = channel.targetCount;
                for (let targetIndex = 0; targetIndex < targetCount; targetIndex++) {
                    let target = channel.getTargetByIndex(targetIndex);
                    let newTarget = new MorphTarget();
                    newTarget.name = target.name;
                    newTarget.fullWeight = target.fullWeight;
                    newTarget.data = new Float32Array(target.data);
                    newChannel.addTarget(newTarget);
                }
                res.addMorphChannel(newChannel);
            }
            res.initData();
            return res;
        }
    }

    class LoadModelV05 {
        static parse(readData, version, mesh, subMeshes) {
            LoadModelV05._mesh = mesh;
            LoadModelV05._subMeshes = subMeshes;
            LoadModelV05._version = version;
            LoadModelV05._readData = readData;
            LoadModelV05.READ_DATA();
            LoadModelV05.READ_BLOCK();
            LoadModelV05.READ_STRINGS();
            for (var i = 0, n = LoadModelV05._BLOCK.count; i < n; i++) {
                LoadModelV05._readData.pos = LoadModelV05._BLOCK.blockStarts[i];
                var index = LoadModelV05._readData.getUint16();
                var blockName = LoadModelV05._strings[index];
                var fn = LoadModelV05["READ_" + blockName];
                if (fn == null)
                    console.warn("model file err,no this function:" + index + " " + blockName);
                else
                    fn.call(null);
            }
            LoadModelV05._strings.length = 0;
            LoadModelV05._readData = null;
            LoadModelV05._version = null;
            LoadModelV05._mesh = null;
            LoadModelV05._subMeshes = null;
        }
        static _readString() {
            return LoadModelV05._strings[LoadModelV05._readData.getUint16()];
        }
        static READ_DATA() {
            LoadModelV05._DATA.offset = LoadModelV05._readData.getUint32();
            LoadModelV05._DATA.size = LoadModelV05._readData.getUint32();
        }
        static READ_BLOCK() {
            var count = LoadModelV05._BLOCK.count = LoadModelV05._readData.getUint16();
            var blockStarts = LoadModelV05._BLOCK.blockStarts = [];
            var blockLengths = LoadModelV05._BLOCK.blockLengths = [];
            for (var i = 0; i < count; i++) {
                blockStarts.push(LoadModelV05._readData.getUint32());
                blockLengths.push(LoadModelV05._readData.getUint32());
            }
        }
        static READ_STRINGS() {
            var offset = LoadModelV05._readData.getUint32();
            var count = LoadModelV05._readData.getUint16();
            var prePos = LoadModelV05._readData.pos;
            LoadModelV05._readData.pos = offset + LoadModelV05._DATA.offset;
            for (var i = 0; i < count; i++)
                LoadModelV05._strings[i] = LoadModelV05._readData.readUTFString();
            LoadModelV05._readData.pos = prePos;
        }
        static READ_MESH() {
            var i;
            var memorySize = 0;
            LoadModelV05._readString();
            var reader = LoadModelV05._readData;
            var arrayBuffer = reader.__getBuffer();
            var vertexBufferCount = reader.getInt16();
            var offset = LoadModelV05._DATA.offset;
            for (i = 0; i < vertexBufferCount; i++) {
                var vbStart = offset + reader.getUint32();
                var vertexCount = reader.getUint32();
                var vertexFlag = LoadModelV05._readString();
                var vertexDeclaration = Laya.VertexMesh.getVertexDeclaration(vertexFlag, false);
                var vertexStride = vertexDeclaration.vertexStride;
                var vertexData;
                var floatData;
                var uint8Data;
                var subVertexFlags = vertexFlag.split(",");
                var subVertexCount = subVertexFlags.length;
                var mesh = LoadModelV05._mesh;
                switch (LoadModelV05._version) {
                    case "LAYAMODEL:05":
                    case "LAYAMODEL:0501":
                    case "LAYAMODEL:0502":
                        vertexData = arrayBuffer.slice(vbStart, vbStart + vertexCount * vertexStride);
                        floatData = new Float32Array(vertexData);
                        uint8Data = new Uint8Array(vertexData);
                        break;
                    case "LAYAMODEL:COMPRESSION_05":
                    case "LAYAMODEL:COMPRESSION_0501":
                        vertexData = new ArrayBuffer(vertexStride * vertexCount);
                        floatData = new Float32Array(vertexData);
                        uint8Data = new Uint8Array(vertexData);
                        var lastPosition = reader.pos;
                        reader.pos = vbStart;
                        for (var j = 0; j < vertexCount; j++) {
                            var subOffset;
                            var verOffset = j * vertexStride;
                            for (var k = 0; k < subVertexCount; k++) {
                                switch (subVertexFlags[k]) {
                                    case "POSITION":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 1] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 2] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        verOffset += 12;
                                        break;
                                    case "NORMAL":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 1] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 2] = reader.getUint8() / 127.5 - 1;
                                        verOffset += 12;
                                        break;
                                    case "COLOR":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 255;
                                        floatData[subOffset + 1] = reader.getUint8() / 255;
                                        floatData[subOffset + 2] = reader.getUint8() / 255;
                                        floatData[subOffset + 3] = reader.getUint8() / 255;
                                        verOffset += 16;
                                        break;
                                    case "UV":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 1] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        verOffset += 8;
                                        break;
                                    case "UV1":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        floatData[subOffset + 1] = Laya.HalfFloatUtils.convertToNumber(reader.getUint16());
                                        verOffset += 8;
                                        break;
                                    case "BLENDWEIGHT":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 255;
                                        floatData[subOffset + 1] = reader.getUint8() / 255;
                                        floatData[subOffset + 2] = reader.getUint8() / 255;
                                        floatData[subOffset + 3] = reader.getUint8() / 255;
                                        verOffset += 16;
                                        break;
                                    case "BLENDINDICES":
                                        uint8Data[verOffset] = reader.getUint8();
                                        uint8Data[verOffset + 1] = reader.getUint8();
                                        uint8Data[verOffset + 2] = reader.getUint8();
                                        uint8Data[verOffset + 3] = reader.getUint8();
                                        verOffset += 4;
                                        break;
                                    case "TANGENT":
                                        subOffset = verOffset / 4;
                                        floatData[subOffset] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 1] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 2] = reader.getUint8() / 127.5 - 1;
                                        floatData[subOffset + 3] = reader.getUint8() / 127.5 - 1;
                                        verOffset += 16;
                                        break;
                                }
                            }
                        }
                        reader.pos = lastPosition;
                        break;
                }
                var vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vertexData.byteLength, Laya.BufferUsage.Static, true);
                vertexBuffer.vertexDeclaration = vertexDeclaration;
                vertexBuffer.setData(vertexData);
                var vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;
                if (vertexCount > 65535)
                    mesh._indexFormat = Laya.IndexFormat.UInt32;
                else
                    mesh._indexFormat = Laya.IndexFormat.UInt16;
                mesh._vertexBuffer = vertexBuffer;
                mesh._vertexCount += vertexCount;
                memorySize += floatData.length * 4;
            }
            var ibStart = offset + reader.getUint32();
            var ibLength = reader.getUint32();
            var ibDatas;
            if (mesh.indexFormat == Laya.IndexFormat.UInt32)
                ibDatas = new Uint32Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
            else
                ibDatas = new Uint16Array(arrayBuffer.slice(ibStart, ibStart + ibLength));
            var indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(mesh.indexFormat, ibDatas.length, Laya.BufferUsage.Static, true);
            indexBuffer.setData(ibDatas);
            mesh._indexBuffer = indexBuffer;
            mesh._setBuffer(mesh._vertexBuffer, indexBuffer);
            memorySize += ibDatas.byteLength;
            mesh._setCPUMemory(memorySize);
            mesh._setGPUMemory(memorySize);
            if (LoadModelV05._version == "LAYAMODEL:0501" || LoadModelV05._version == "LAYAMODEL:COMPRESSION_0501" || LoadModelV05._version == "LAYAMODEL:0502") {
                var bounds = mesh.bounds;
                var min = bounds.getMin();
                var max = bounds.getMax();
                min.setValue(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                max.setValue(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
                bounds.setMin(min);
                bounds.setMax(max);
                mesh.bounds = bounds;
            }
            var boneNames = mesh._boneNames = [];
            var boneCount = reader.getUint16();
            boneNames.length = boneCount;
            for (i = 0; i < boneCount; i++)
                boneNames[i] = LoadModelV05._strings[reader.getUint16()];
            var bindPoseDataStart = reader.getUint32();
            var bindPoseDataLength = reader.getUint32();
            var bindPoseDatas = new Float32Array(arrayBuffer.slice(offset + bindPoseDataStart, offset + bindPoseDataStart + bindPoseDataLength));
            var bindPoseFloatCount = bindPoseDatas.length;
            var bindPoseBuffer = mesh._inverseBindPosesBuffer = new ArrayBuffer(bindPoseFloatCount * 4);
            mesh._inverseBindPoses = [];
            if (bindPoseFloatCount != 0)
                mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR;
            else
                mesh._instanceBufferStateType = Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL;
            for (i = 0; i < bindPoseFloatCount; i += 16) {
                var inverseGlobalBindPose = new Laya.Matrix4x4(bindPoseDatas[i + 0], bindPoseDatas[i + 1], bindPoseDatas[i + 2], bindPoseDatas[i + 3], bindPoseDatas[i + 4], bindPoseDatas[i + 5], bindPoseDatas[i + 6], bindPoseDatas[i + 7], bindPoseDatas[i + 8], bindPoseDatas[i + 9], bindPoseDatas[i + 10], bindPoseDatas[i + 11], bindPoseDatas[i + 12], bindPoseDatas[i + 13], bindPoseDatas[i + 14], bindPoseDatas[i + 15], new Float32Array(bindPoseBuffer, i * 4, 16));
                mesh._inverseBindPoses[i / 16] = inverseGlobalBindPose;
            }
            return true;
        }
        static READ_SUBMESH() {
            var reader = LoadModelV05._readData;
            var arrayBuffer = reader.__getBuffer();
            var subMesh = new SubMesh(LoadModelV05._mesh);
            reader.getInt16();
            var ibStart = reader.getUint32();
            var ibCount = reader.getUint32();
            var indexBuffer = LoadModelV05._mesh._indexBuffer;
            subMesh._indexBuffer = indexBuffer;
            subMesh._setIndexRange(ibStart, ibCount);
            var vertexBuffer = LoadModelV05._mesh._vertexBuffer;
            subMesh._vertexBuffer = vertexBuffer;
            var offset = LoadModelV05._DATA.offset;
            var subIndexBufferStart = subMesh._subIndexBufferStart;
            var subIndexBufferCount = subMesh._subIndexBufferCount;
            var boneIndicesList = subMesh._boneIndicesList;
            var drawCount = reader.getUint16();
            subIndexBufferStart.length = drawCount;
            subIndexBufferCount.length = drawCount;
            boneIndicesList.length = drawCount;
            var skinnedCache = LoadModelV05._mesh._skinnedMatrixCaches;
            var subMeshIndex = LoadModelV05._subMeshes.length;
            skinnedCache.length = LoadModelV05._mesh._inverseBindPoses.length;
            for (var i = 0; i < drawCount; i++) {
                subIndexBufferStart[i] = reader.getUint32();
                subIndexBufferCount[i] = reader.getUint32();
                var boneDicofs = reader.getUint32();
                var boneDicCount = reader.getUint32();
                var boneIndices = boneIndicesList[i] = new Uint16Array(arrayBuffer.slice(offset + boneDicofs, offset + boneDicofs + boneDicCount));
                for (var j = 0, m = boneIndices.length; j < m; j++) {
                    var index = boneIndices[j];
                    skinnedCache[index] || (skinnedCache[index] = new skinnedMatrixCache(subMeshIndex, i, j));
                }
            }
            LoadModelV05._subMeshes.push(subMesh);
            return true;
        }
        static READ_MORPH() {
            let reader = LoadModelV05._readData;
            let arrayBuffer = reader.__getBuffer();
            let offset = LoadModelV05._DATA.offset;
            let mesh = LoadModelV05._mesh;
            let morphData = mesh.morphTargetData = new MorphTargetData();
            let morphVertexDecStr = LoadModelV05._strings[reader.getUint16()];
            morphData.vertexDec = Laya.VertexMesh.getVertexDeclaration(morphVertexDecStr);
            let bounds = morphData.bounds;
            let min = bounds.getMin();
            let max = bounds.getMax();
            min.set(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            max.set(reader.getFloat32(), reader.getFloat32(), reader.getFloat32());
            bounds.setMin(min);
            bounds.setMax(max);
            let channelCount = reader.readUint16();
            for (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {
                let channel = new MorphTargetChannel();
                channel.name = LoadModelV05._strings[reader.getUint16()];
                let targetCount = reader.readUint16();
                for (let targetIndex = 0; targetIndex < targetCount; targetIndex++) {
                    let target = new MorphTarget();
                    let targetName = LoadModelV05._strings[reader.getUint16()];
                    target.name = targetName;
                    target.fullWeight = reader.readFloat32();
                    let bufferStart = reader.readUint32();
                    let bufferLength = reader.readUint32();
                    target.data = new Float32Array(arrayBuffer.slice(offset + bufferStart, offset + bufferStart + bufferLength));
                    channel.addTarget(target);
                }
                morphData.addMorphChannel(channel);
            }
            morphData.vertexCount = mesh.vertexCount;
            morphData.initData();
            return true;
        }
        static READ_UVSIZE() {
            LoadModelV05._mesh._width = LoadModelV05._readData.readUint16();
            LoadModelV05._mesh._height = LoadModelV05._readData.readUint16();
        }
    }
    LoadModelV05._BLOCK = { count: 0 };
    LoadModelV05._DATA = { offset: 0, size: 0 };
    LoadModelV05._strings = [];

    class MeshReader {
        static parse(readData, version) {
            var mesh = new Mesh();
            let subMeshes = mesh._subMeshes;
            switch (version) {
                case "LAYAMODEL:0301":
                case "LAYAMODEL:0400":
                case "LAYAMODEL:0401":
                    LoadModelV04.parse(readData, version, mesh, subMeshes);
                    break;
                case "LAYAMODEL:05":
                case "LAYAMODEL:COMPRESSION_05":
                case "LAYAMODEL:0501":
                case "LAYAMODEL:COMPRESSION_0501":
                case "LAYAMODEL:0502":
                    LoadModelV05.parse(readData, version, mesh, subMeshes);
                    break;
                default:
                    throw new Error("unknown mesh version: " + version);
            }
            mesh._setSubMeshes(subMeshes);
            if (version != "LAYAMODEL:0501" && version != "LAYAMODEL:COMPRESSION_0501" && version != "LAYAMODEL:0502")
                mesh.calculateBounds();
            return mesh;
        }
        static _parse(data) {
            var mesh = new Mesh();
            MeshReader.read(data, mesh, mesh._subMeshes);
            return mesh;
        }
        static read(data, mesh, subMeshes) {
            var readData = new Laya.Byte(data);
            readData.pos = 0;
            var version = readData.readUTFString();
            switch (version) {
                case "LAYAMODEL:0301":
                case "LAYAMODEL:0400":
                case "LAYAMODEL:0401":
                    LoadModelV04.parse(readData, version, mesh, subMeshes);
                    break;
                case "LAYAMODEL:05":
                case "LAYAMODEL:COMPRESSION_05":
                case "LAYAMODEL:0501":
                case "LAYAMODEL:COMPRESSION_0501":
                case "LAYAMODEL:0502":
                    LoadModelV05.parse(readData, version, mesh, subMeshes);
                    break;
                default:
                    throw new Error("unknown mesh version: " + version);
            }
            mesh._setSubMeshes(subMeshes);
            if (version != "LAYAMODEL:0501" && version != "LAYAMODEL:COMPRESSION_0501" && version != "LAYAMODEL:0502")
                mesh.calculateBounds();
        }
    }
    Laya.MeshLoader.v3d = MeshReader;

    let c = Laya.ClassUtils.regClass;
    c("Sprite3D", Sprite3D);
    c("Scene3D", Scene3D);
    c("Camera", Camera);
    c("LightSprite", LightSprite);
    c("AreaLightCom", AreaLightCom);
    c("DirectionLightCom", DirectionLightCom);
    c("PointLightCom", PointLightCom);
    c("SpotLightCom", SpotLightCom);
    c("RenderableSprite3D", RenderableSprite3D);
    c("MeshSprite3D", MeshSprite3D);
    c("MeshFilter", MeshFilter);
    c("BaseRender", BaseRender);
    c("MeshRenderer", MeshRenderer);
    c("SimpleSkinnedMeshSprite3D", SimpleSkinnedMeshSprite3D);
    c("SkinnedMeshSprite3D", SkinnedMeshSprite3D);
    c("SkinnedMeshRenderer", SkinnedMeshRenderer);
    c("SimpleSkinnedMeshRenderer", SimpleSkinnedMeshRenderer);
    c("SkyRenderer", SkyRenderer);
    c("PixelLineRenderer", PixelLineRenderer);
    c("PixelLineData", PixelLineData);
    c("Transform3D", Transform3D);
    c("Lightmap", Lightmap);
    c("ReflectionProbe", ReflectionProbe);
    c("VolumetricGI", VolumetricGI);
    c("StaticBatchVolume", StaticBatchVolume);
    c("StaticInstanceBatchRender", StaticInstanceBatchRender);
    c("SphericalHarmonicsL2", SphericalHarmonicsL2);
    c("Viewport", Laya.Viewport);
    c("Bounds", Bounds);
    c("BoundBox", BoundBox);
    c("TextureCube", Laya.TextureCube);
    c("Mesh", Mesh);
    c("RenderTexture", Laya.RenderTexture);
    c("Animator", Animator);
    c("AnimatorController", AnimatorController);
    c("AnimatorControllerLayer", AnimatorControllerLayer);
    c("AnimatorState", AnimatorState);
    c("AnimationClip", AnimationClip);
    c("AvatarMask", AvatarMask);
    c("UI3D", UI3D);
    c("Material", Laya.Material);
    c("BlinnPhongMaterial", BlinnPhongMaterial);
    c("EffectMaterial", EffectMaterial);
    c("ExtendTerrainMaterial", ExtendTerrainMaterial);
    c("PBRStandardMaterial", PBRStandardMaterial);
    c("SkyBoxMaterial", SkyBoxMaterial);
    c("SkyPanoramicMaterial", SkyPanoramicMaterial);
    c("SkyProceduralMaterial", SkyProceduralMaterial);
    c("UnlitMaterial", UnlitMaterial);
    c("LODInfo", LODInfo);
    c("LODGroup", LODGroup);
    c("DirectionLightCom", DirectionLightCom);
    c("MeshRenderer", MeshRenderer);
    c("MeshFilter", MeshFilter);
    c("MeshRenderer", MeshRenderer);
    c("SkinnedMeshRenderer", SkinnedMeshRenderer);
    c("SimpleSkinnedMeshRenderer", SimpleSkinnedMeshRenderer);
    c("SkyRenderer", SkyRenderer);
    c("PostProcess", PostProcess);
    c("PostProcessEffect", PostProcessEffect);

    class WebXRCamera extends Camera {
        constructor() {
            super(...arguments);
            this.isWebXR = true;
        }
        get renderTarget() {
            return this._internalRenderTexture;
        }
        set renderTarget(value) {
            this._internalRenderTexture = value;
        }
        set clientWidth(value) {
            this._clientWidth = value;
        }
        set clientHeight(value) {
            this._clientHeight = value;
        }
        get clientWidth() {
            return this._clientWidth;
        }
        get clientHeight() {
            return this._clientHeight;
        }
        _restoreView(gl) {
            var viewport = this.viewport;
            var vpX, vpY;
            var vpW = viewport.width;
            var vpH = viewport.height;
            if (this._needInternalRenderTexture()) {
                vpX = 0;
                vpY = 0;
            }
            else {
                vpX = viewport.x;
                vpY = this._getCanvasHeight() - viewport.y - vpH;
            }
            gl.viewport(vpX, vpY, vpW, vpH);
        }
        render() {
            if (!this.activeInHierarchy)
                return;
            this.viewport;
            var context = RenderContext3D._instance;
            context.scene = this._scene;
            context.pipelineMode = context.configPipeLineMode;
        }
        _renderMainPass(context, viewport, scene, shader, replacementTag, needInternalRT) {
        }
        _calculateProjectionMatrix() {
        }
        clear(gl) {
            gl.viewport(0, 0, this._clientWidth, this._clientHeight);
            gl.scissor(0, 0, this._clientWidth, this._clientHeight);
            gl.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a);
            Laya.RenderStateContext.setDepthMask(true);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
        destroy() {
            super.destroy(true);
        }
    }

    class WebXRRenderTexture extends Laya.RenderTexture {
        constructor() {
            super(1, 1, 1, Laya.RenderTargetFormat.STENCIL_8, false, 1);
            this.frameLoop = -1;
        }
        set frameBuffer(value) {
            this._frameBuffer = value;
        }
        _create(width, height) {
        }
    }

    class WebXRSessionManager extends Laya.EventDispatcher {
        constructor() {
            super();
            this.currentTimestamp = -1;
            this.defaultHeightCompensation = 1.7;
            this._sessionEnded = false;
        }
        get referenceSpace() {
            return this._referenceSpace;
        }
        set referenceSpace(newReferenceSpace) {
            this._referenceSpace = newReferenceSpace;
        }
        get sessionMode() {
            return this._sessionMode;
        }
        exitXR() {
            this.endXRRenderLoop();
            this.event(WebXRSessionManager.EVENT_MANAGER_END);
        }
        initializeXRGL(xrSession, gl) {
            return gl.makeXRCompatible().then(() => {
                return true;
            });
        }
        ;
        initializeAsync() {
            this._xrNavigator = navigator;
            if (!this._xrNavigator.xr) {
                return Promise.reject("WebXR not available");
            }
            return Promise.resolve();
        }
        isSessionSupportedAsync(sessionMode) {
            if (!navigator.xr) {
                return Promise.resolve(false);
            }
            else {
                this._xrNavigator = navigator;
            }
            const functionToUse = navigator.xr.isSessionSupported || navigator.xr.supportsSession;
            if (!functionToUse)
                return Promise.resolve(false);
            else {
                return navigator.xr.isSessionSupported(sessionMode);
            }
        }
        initializeSessionAsync(xrSessionMode = 'immersive-vr', xrSessionInit = {}) {
            return this._xrNavigator.xr.requestSession('immersive-vr').then((session) => {
                this.session = session;
                this._sessionMode = xrSessionMode;
                this._sessionEnded = false;
                this.session.addEventListener("end", () => {
                    this._sessionEnded = true;
                    this.exitXR();
                }, { once: true });
                return this.session;
            });
        }
        resetReferenceSpace() {
            this.referenceSpace = this.baseReferenceSpace;
        }
        runXRRenderLoop() {
            this.session.requestAnimationFrame.bind(this.session);
            let fn = (timestamp, xrFrame) => {
                this._updateByXrFrame(xrFrame, timestamp);
                this.event(WebXRSessionManager.EVENT_FRAME_LOOP, [xrFrame]);
                Laya.Render.loop();
                this.session.requestAnimationFrame(fn);
            };
            this.session.requestAnimationFrame(fn);
        }
        endXRRenderLoop() {
        }
        _updateByXrFrame(xrFrame, timestamp) {
            this.currentFrame = xrFrame;
            this.currentTimestamp = timestamp;
        }
        setReferenceSpaceTypeAsync(referenceSpaceType = "local-floor") {
            return this.session
                .requestReferenceSpace(referenceSpaceType)
                .then((referenceSpace) => {
                return referenceSpace;
            }, (rejectionReason) => {
                return this.session.requestReferenceSpace("viewer").then((referenceSpace) => {
                    const heightCompensation = new XRRigidTransform({ x: 0, y: -this.defaultHeightCompensation, z: 0 });
                    return (referenceSpace).getOffsetReferenceSpace(heightCompensation);
                }, (rejectionReason) => {
                    throw 'XR initialization failed: required "viewer" reference space type not supported.';
                });
            }).then((referenceSpace) => {
                this.referenceSpace = this.baseReferenceSpace = referenceSpace;
                return this.referenceSpace;
            });
        }
        updateRenderStateAsync(state) {
            if (state.baseLayer) {
                this._baseLayer = state.baseLayer;
            }
            return this.session.updateRenderState(state);
        }
        get currentFrameRate() {
            var _a;
            return (_a = this.session) === null || _a === void 0 ? void 0 : _a.frameRate;
        }
        get supportedFrameRates() {
            var _a;
            return (_a = this.session) === null || _a === void 0 ? void 0 : _a.supportedFrameRates;
        }
        updateTargetFrameRate(rate) {
            return this.session.updateTargetFrameRate(rate);
        }
        destroy() {
            if (!this._sessionEnded) {
                this.exitXR();
            }
        }
    }
    WebXRSessionManager.EVENT_MANAGER_END = "xrManagerDestory";
    WebXRSessionManager.EVENT_FRAME_LOOP = "xrFrameLoop";

    class WebXRCameraManager {
        get position() {
            return this._position;
        }
        set position(newPosition) {
            newPosition.cloneTo(this._position);
        }
        get rotationQuaternion() {
            return this._referenceQuaternion;
        }
        set rotationQuaternion(value) {
            value.cloneTo(this._referenceQuaternion);
        }
        get rigCameras() {
            return this._rigCameras;
        }
        constructor(camera, manager = null) {
            this._referenceQuaternion = new Laya.Quaternion();
            this._referencedPosition = new Laya.Vector3();
            this._firstFrame = true;
            this._XRRenderTexture = new WebXRRenderTexture();
            this._rigCameras = new Array();
            this._position = new Laya.Vector3();
            this.owner = camera;
            this.owner.enableRender = false;
            if (!this.owner.aspectRatio) {
                console.warn("owner is not Camera");
            }
            this._webXRSessionManager = manager;
            this._webXRSessionManager.on(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRSession);
            this._webXRSessionManager.on(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateReferenceSpace);
            this._webXRSessionManager.on(WebXRSessionManager.EVENT_MANAGER_END, this, this.destroy);
        }
        _updateFromXRSession() {
            let pose = this._webXRSessionManager.currentFrame && this._webXRSessionManager.currentFrame.getViewerPose(this._webXRSessionManager.referenceSpace);
            const pos = pose.transform.position;
            const orientation = pose.transform.orientation;
            this._referenceQuaternion.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
            this._referencedPosition.setValue(pos.x, pos.y, pos.z);
            if (this._firstFrame) {
                this._firstFrame = false;
                this.position.y += this._referencedPosition.y;
                this._referenceQuaternion.setValue(0, 0, 0, 1);
            }
            else {
                this.rotationQuaternion = this._referenceQuaternion;
                this.position = this._referencedPosition;
            }
            if (this.rigCameras.length !== pose.views.length) {
                this._updateNumberOfRigCameras(pose.views.length);
            }
            pose.views.forEach((view, i) => {
                const currentRig = this.rigCameras[i];
                if (view.eye === "right")
                    currentRig.name = "right";
                else if (view.eye === "left")
                    currentRig.name = "left";
                const pos = view.transform.position;
                const orientation = view.transform.orientation;
                currentRig.transform.position.setValue(pos.x, pos.y, pos.z);
                currentRig.transform.rotation.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
                currentRig.transform.position = currentRig.transform.position;
                currentRig.transform.rotation = currentRig.transform.rotation;
                if (this._webXRSessionManager.session.renderState.baseLayer) {
                    var viewport = this._webXRSessionManager.session.renderState.baseLayer.getViewport(view);
                    var width = this._webXRSessionManager.session.renderState.baseLayer.framebufferWidth;
                    var height = this._webXRSessionManager.session.renderState.baseLayer.framebufferHeight;
                    this._XRRenderTexture.frameBuffer = this._webXRSessionManager.session.renderState.baseLayer.framebuffer;
                    currentRig.renderTarget = this._XRRenderTexture;
                    currentRig.clientWidth = width;
                    currentRig.clientHeight = height;
                    var cameraViewPort = currentRig.viewport;
                    cameraViewPort.x = viewport.x;
                    cameraViewPort.y = viewport.y;
                    cameraViewPort.width = viewport.width;
                    cameraViewPort.height = viewport.height;
                    currentRig.viewport = cameraViewPort;
                    currentRig.projectionMatrix.cloneByArray(view.projectionMatrix);
                }
            });
        }
        _updateNumberOfRigCameras(viewCount = 1) {
            while (this.rigCameras.length < viewCount) {
                var xrcamera = new WebXRCamera(this.owner.aspectRatio, this.owner.nearPlane, this.owner.farPlane);
                xrcamera.clearFlag = this.owner.clearFlag;
                xrcamera.clearColor = this.owner.clearColor;
                this.owner.addChild(xrcamera);
                this.rigCameras.push(xrcamera);
            }
            while (this.rigCameras.length > viewCount) {
                let xrcamera = this.rigCameras.pop();
                this.owner.removeChild(xrcamera);
            }
        }
        _updateReferenceSpace() {
        }
        destroy() {
            this.owner.enableRender = true;
            this._webXRSessionManager.off(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRSession);
            this._webXRSessionManager.off(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateReferenceSpace);
            this._webXRSessionManager.off(WebXRSessionManager.EVENT_MANAGER_END, this, this.destroy);
            this._rigCameras.forEach(element => {
                element.destroy();
            });
            this._rigCameras = null;
            this._XRRenderTexture.destroy();
        }
    }

    class AxiGamepad extends Laya.EventDispatcher {
        constructor(handness, length) {
            super();
            this.axisData = new Array();
            this.handness = handness;
            this.axisData.length = length;
            this.axisLength = length;
        }
        update(padGameAxi) {
            for (let i = 0, j = 0; i < padGameAxi.axes.length; i += 2, ++j) {
                if (!this.axisData[j])
                    this.axisData[j] = new Laya.Vector2();
                this.axisData[j].setValue(padGameAxi.axes[i], padGameAxi.axes[i + 1]);
                this.outPutStickValue(this.axisData[j], j);
            }
        }
        outPutStickValue(value, index) {
            const eventnam = AxiGamepad.EVENT_OUTPUT + index.toString();
            this.event(eventnam, [value]);
        }
        destroy() {
            for (let i = 0; i < this.axisLength; i++) {
                let eventname = AxiGamepad.EVENT_OUTPUT + i.toString();
                this.offAll(eventname);
            }
        }
    }
    AxiGamepad.EVENT_OUTPUT = "outputAxi_id";
    class ButtonGamepad extends Laya.EventDispatcher {
        constructor(handness, index) {
            super();
            this.lastTouch = false;
            this.lastPress = false;
            this.lastPressValue = 0;
            this.touch = false;
            this.press = false;
            this.pressValue = 0;
            this.handness = handness;
            this.index = index;
        }
        update(padButton) {
            this.lastTouch = this.touch;
            this.lastPress = this.press;
            this.lastPressValue = this.pressValue;
            this.touch = padButton.touched;
            this.press = padButton.pressed;
            this.pressValue = padButton.value;
            if (!this.lastTouch && !this.touch) {
                return;
            }
            if (this.lastTouch != this.touch && this.touch) {
                this.touchEnter();
            }
            else if (this.lastTouch == this.touch && this.touch) {
                this.touchStay();
            }
            else if (this.lastTouch != this.touch && !this.touch) {
                this.touchOut();
            }
            if (this.lastPress != this.press && this.press) {
                this.pressEnter();
            }
            else if (this.lastPress == this.press && this.press) {
                this.pressStay();
            }
            else if (this.lastPress != this.press && !this.press) {
                this.pressOut();
            }
            if (this.touch) {
                this.outpressed();
            }
        }
        touchEnter() {
            this.event(ButtonGamepad.EVENT_TOUCH_ENTER);
        }
        touchStay() {
            this.event(ButtonGamepad.EVENT_TOUCH_STAY);
        }
        touchOut() {
            this.event(ButtonGamepad.EVENT_TOUCH_OUT);
        }
        pressEnter() {
            this.event(ButtonGamepad.EVENT_PRESS_ENTER);
        }
        pressStay() {
            this.event(ButtonGamepad.EVENT_PRESS_STAY);
        }
        pressOut() {
            this.event(ButtonGamepad.EVENT_PRESS_OUT);
        }
        outpressed() {
            this.event(ButtonGamepad.EVENT_PRESS_VALUE, [this.pressValue]);
        }
        destroy() {
            this.offAll(ButtonGamepad.EVENT_PRESS_ENTER);
            this.offAll(ButtonGamepad.EVENT_PRESS_STAY);
            this.offAll(ButtonGamepad.EVENT_PRESS_OUT);
            this.offAll(ButtonGamepad.EVENT_PRESS_ENTER);
            this.offAll(ButtonGamepad.EVENT_PRESS_STAY);
            this.offAll(ButtonGamepad.EVENT_PRESS_OUT);
            this.offAll(ButtonGamepad.EVENT_PRESS_VALUE);
        }
    }
    ButtonGamepad.EVENT_TOUCH_ENTER = "touchEnter";
    ButtonGamepad.EVENT_TOUCH_STAY = "touchStay";
    ButtonGamepad.EVENT_TOUCH_OUT = "touchOut";
    ButtonGamepad.EVENT_PRESS_ENTER = "pressEnter";
    ButtonGamepad.EVENT_PRESS_STAY = "pressStay";
    ButtonGamepad.EVENT_PRESS_OUT = "pressOut";
    ButtonGamepad.EVENT_PRESS_VALUE = "outpressed";

    class WebXRInput extends Laya.EventDispatcher {
        constructor(handness) {
            super();
            this.preButtonEventList = [];
            this.preAxisEventList = [];
            this.handness = handness;
            this.position = new Laya.Vector3();
            this.rotation = new Laya.Quaternion();
            this.ray = new Ray(new Laya.Vector3(), new Laya.Vector3());
        }
        _updateByXRPose(xrFrame, referenceSpace) {
            const rayPose = xrFrame.getPose(this._inputSource.targetRaySpace, referenceSpace);
            this._lastXRPose = rayPose;
            if (rayPose) {
                const pos = rayPose.transform.position;
                const orientation = rayPose.transform.orientation;
                WebXRInput.tempQua.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
                this.ray.origin.setValue(pos.x, pos.y, pos.z);
                Laya.Vector3.transformQuat(Laya.Vector3.UnitZ, WebXRInput.tempQua, this.ray.direction);
                Laya.Vector3.scale(this.ray.direction, -1, this.ray.direction);
            }
            if (this._inputSource.gripSpace) {
                let meshPose = xrFrame.getPose(this._inputSource.gripSpace, referenceSpace);
                if (meshPose) {
                    const pos = meshPose.transform.position;
                    const orientation = meshPose.transform.orientation;
                    this.position.setValue(pos.x, pos.y, pos.z);
                    this.rotation.setValue(orientation.x, orientation.y, orientation.z, orientation.w);
                }
            }
            this.event(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT, [this]);
            this._handleProcessGamepad();
        }
        _handleProcessGamepad() {
            const gamepad = this._inputSource.gamepad;
            if (!this.gamepadAxis) {
                this.gamepadAxis = new AxiGamepad(this.handness, gamepad.axes.length);
                this.preAxisEventList.forEach(element => {
                    this.gamepadAxis.on(element.eventnam, element.caller, element.listener);
                });
            }
            if (!this.gamepadButton) {
                this.gamepadButton = [];
                for (let i = 0; i < gamepad.buttons.length; ++i) {
                    this.gamepadButton.push(new ButtonGamepad(this.handness, i));
                }
                this.preButtonEventList.forEach(element => {
                    this.addButtonEvent(element.index, element.type, element.caller, element.listener);
                });
            }
            this.gamepadAxis.update(gamepad);
            for (let i = 0; i < gamepad.buttons.length; ++i) {
                let button = this.gamepadButton[i];
                button.update(gamepad.buttons[i]);
            }
        }
        addButtonEvent(index, type, caller, listener) {
            if (!this.gamepadButton) {
                this.preButtonEventList.push({
                    "index": index,
                    "type": type,
                    "caller": caller,
                    "listener": listener
                });
            }
            else {
                let button = this.gamepadButton[index];
                button.on(type, caller, listener);
            }
        }
        addAxisEvent(index, type, caller, listener) {
            if (!this.gamepadAxis) {
                this.preAxisEventList.push({
                    "eventnam": type + index.toString(),
                    "caller": caller,
                    "listener": listener
                });
            }
            else {
                const eventnam = type + index.toString();
                this.gamepadAxis.on(eventnam, caller, listener);
            }
        }
        offAxisEvent(index, type, caller, listener) {
            if (this.gamepadAxis) {
                const eventnam = type + index.toString();
                this.gamepadAxis.off(eventnam, caller, listener);
            }
        }
        offButtonEvent(index, type, caller, listener) {
            if (this.gamepadButton) {
                let button = this.gamepadButton[index];
                button.off(type, caller, listener);
            }
        }
        destroy() {
            this.preButtonEventList = null;
            this.ray = null;
            this.position = null;
            this.rotation = null;
            this.gamepadAxis.destroy();
            this.gamepadButton.forEach(element => {
                element.destroy();
            });
        }
    }
    WebXRInput.HANDNESS_LEFT = "left";
    WebXRInput.HANDNESS_RIGHT = "right";
    WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT = "frameXRInputUpdate";
    WebXRInput.tempQua = new Laya.Quaternion();

    class WebXRInputManager {
        constructor(webxrManager, webXRCamera) {
            this.controllers = new Map();
            this.controllerHandMesh = new Map();
            this.controllerLineRender = new Map();
            this.lineColor = Laya.Color.RED;
            this.rayLength = 2;
            this.webXRSessionManager = webxrManager;
            this.webXRCameraManager = webXRCamera;
            this.webXRSessionManager.on(WebXRSessionManager.EVENT_MANAGER_END, this, this.destory);
            this.webXRSessionManager.on(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRFrame);
        }
        _updateMeshRender(xrInput) {
            const handness = xrInput.handness;
            if (this.controllerHandMesh.has(handness)) {
                let meshNode = this.controllerHandMesh.get(handness);
                meshNode.transform.position = xrInput.position;
                meshNode.transform.rotation = xrInput.rotation;
            }
            if (this.controllerLineRender.has(handness)) {
                let line = this.controllerLineRender.get(handness);
                line.clear();
                let ray = xrInput.ray;
                tempVec$1.setValue(ray.origin.x, ray.origin.y, ray.origin.z);
                Laya.Vector3.scale(ray.direction, this.rayLength, tempVec1);
                Laya.Vector3.add(tempVec$1, tempVec1, tempVec1);
                line.addLine(tempVec$1, tempVec1, this.lineColor, this.lineColor);
            }
        }
        _updateFromXRFrame(xrFrame) {
            const session = this.webXRSessionManager.session;
            const refSpace = this.webXRSessionManager.referenceSpace;
            for (let inputSource of session.inputSources) {
                const key = inputSource.handedness;
                let xrInput;
                if (!this.controllers.has(key)) {
                    xrInput = this.getController(key);
                }
                else
                    xrInput = this.controllers.get(key);
                if (xrInput) {
                    xrInput = this.controllers.get(key);
                    xrInput._inputSource = inputSource;
                    xrInput._updateByXRPose(xrFrame, refSpace);
                }
            }
        }
        bindMeshNode(meshSprite, handness) {
            this.controllerHandMesh.set(handness, meshSprite);
        }
        bindRayNode(lineSprite, handness) {
            this.controllerLineRender.set(handness, lineSprite);
        }
        getController(handness) {
            if (handness != "left" && handness != "right")
                return null;
            if (!this.controllers.has(handness)) {
                let value = new WebXRInput(handness);
                this.controllers.set(handness, value);
                value.on(WebXRInput.EVENT_FRAMEUPDATA_WEBXRINPUT, this, this._updateMeshRender);
            }
            return this.controllers.get(handness);
        }
        destory() {
            this.webXRSessionManager.off(WebXRSessionManager.EVENT_FRAME_LOOP, this, this._updateFromXRFrame);
            for (let key in this.controllers) {
                this.controllers.get(key).off("frameXRInputUpdate", this, this._updateMeshRender);
                this.controllers.get(key).destroy();
            }
            this.controllers = null;
            this.controllerHandMesh = null;
            this.controllerLineRender = null;
        }
    }
    const tempVec$1 = new Laya.Vector3();
    const tempVec1 = new Laya.Vector3();

    class WebXRCameraInfo {
    }
    class WebXRExperienceHelper {
        static supportXR(sessionMode) {
            return WebXRExperienceHelper.xr_Manager.isSessionSupportedAsync(sessionMode).then(value => {
                WebXRExperienceHelper.supported = value;
                return value;
            });
        }
        static enterXRAsync(sessionMode, referenceSpaceType, cameraInfo) {
            if (sessionMode === "immersive-ar" && referenceSpaceType !== "unbounded") {
                console.warn("We recommend using 'unbounded' reference space type when using 'immersive-ar' session mode");
            }
            return WebXRExperienceHelper.xr_Manager.initializeSessionAsync(sessionMode).then(() => {
                return WebXRExperienceHelper.xr_Manager.setReferenceSpaceTypeAsync(referenceSpaceType);
            }).then(() => {
                return WebXRExperienceHelper.xr_Manager.initializeXRGL(sessionMode, Laya.LayaGL.renderEngine.gl);
            }).then(() => {
                WebXRExperienceHelper.glInstance = Laya.LayaGL.renderEngine.gl;
                return WebXRExperienceHelper.xr_Manager.updateRenderStateAsync({
                    depthFar: cameraInfo.depthFar,
                    depthNear: cameraInfo.depthNear,
                    baseLayer: new XRWebGLLayer(WebXRExperienceHelper.xr_Manager.session, Laya.LayaGL.renderEngine.gl),
                });
            }).then(() => {
                WebXRExperienceHelper.xr_Manager.runXRRenderLoop();
                return WebXRExperienceHelper.xr_Manager;
            });
        }
        static setWebXRCamera(camera, manager) {
            return new WebXRCameraManager(camera, manager);
        }
        static setWebXRInput(sessionManager, cameraManager) {
            return new WebXRInputManager(sessionManager, cameraManager);
        }
    }
    WebXRExperienceHelper.xr_Manager = new WebXRSessionManager();
    WebXRExperienceHelper.supported = false;
    WebXRExperienceHelper.canvasOptions = {
        antialias: true,
        depth: true,
        stencil: false,
        alpha: true,
        multiview: false,
        framebufferScaleFactor: 1,
    };

    class AnimatorStateScript {
        setPlayScriptInfo(animator, layerindex, playstate) {
            this.playStateInfo.animator = animator;
            this.playStateInfo.layerindex = layerindex;
            this.playStateInfo.playState = playstate;
        }
        constructor() {
            this.playStateInfo = { animator: null, layerindex: -1, playState: null };
        }
        onStateEnter() {
        }
        onStateUpdate(normalizeTime) {
        }
        onStateExit() {
        }
        onStateLoop() {
        }
    }

    class HLODRender extends BaseRender {
        constructor() {
            super();
            this._singleton = false;
        }
        get curHLODRS() {
            return this._curHLODRS;
        }
        set curHLODRS(value) {
            if (!this._curHLODRS) {
                this._renderElements = [];
                this._renderElements.push(new RenderElement());
                this._renderElements[0].render = this;
            }
            if (value != this._curHLODRS) {
                this._changeMesh(value.HLODMesh);
                this._curHLODRS = value;
                this._createRenderelementByHLODElement(this._curHLODRS, this._renderElements[0]);
            }
        }
        _createRenderelementByHLODElement(source, out) {
            out.setGeometry(source.HLODMesh);
            out.material = source.material;
        }
        _changeMesh(lodMesh) {
            var defineDatas = this._baseRenderNode.shaderData;
            this.boundsChange = true;
            let meshDefines = MeshFilter._meshVerticeDefine;
            if (this.curHLODRS) {
                MeshUtil.getMeshDefine(this.curHLODRS.HLODMesh.batchMesh, meshDefines);
                for (var i = 0, n = meshDefines.length; i < n; i++)
                    defineDatas.removeDefine(MeshFilter._meshVerticeDefine[i]);
            }
            if (lodMesh) {
                MeshUtil.getMeshDefine(lodMesh.batchMesh, meshDefines);
                for (var i = 0, n = MeshFilter._meshVerticeDefine.length; i < n; i++)
                    defineDatas.addDefine(MeshFilter._meshVerticeDefine[i]);
            }
            this._curSubBatchMeshBounds.length = lodMesh.batchSubMeshInfo.length;
            for (let i = 0, n = lodMesh.batchSubMeshInfo.length; i < n; i++) {
                this._curSubBatchMeshBounds[i] = this._curSubBatchMeshBounds[i] ? this._curSubBatchMeshBounds[i] : new Bounds();
            }
        }
        _applyLightMapParams() {
            if (!this._scene)
                return;
            var shaderValues = this._baseRenderNode.shaderData;
            var lightMap = this._curHLODRS.lightmap;
            if (lightMap && lightMap.lightmapColor) {
                shaderValues.setTexture(RenderableSprite3D.LIGHTMAP, lightMap.lightmapColor);
                shaderValues.addDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
                if (lightMap.lightmapDirection) {
                    shaderValues.setTexture(RenderableSprite3D.LIGHTMAP_DIRECTION, lightMap.lightmapDirection);
                    shaderValues.addDefine(RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
                }
                else {
                    shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
                }
            }
            else {
                shaderValues.removeDefine(RenderableSprite3D.SAHDERDEFINE_LIGHTMAP);
                shaderValues.removeDefine(RenderableSprite3D.SHADERDEFINE_LIGHTMAP_DIRECTIONAL);
            }
        }
        _calculateBoundingBox() {
            if (this._curHLODRS) {
                var sharedMesh = this._curHLODRS.HLODMesh;
                if (sharedMesh) {
                    var worldMat = this._transform.worldMatrix;
                    sharedMesh.batchMesh.bounds._tranform(worldMat, this._bounds);
                }
                for (let i = 0, n = this._curSubBatchMeshBounds.length; i < n; i++) {
                    sharedMesh.batchSubMeshInfo[i].bounds._tranform(worldMat, this._curSubBatchMeshBounds[i]);
                }
            }
        }
        _renderUpdate(context) {
            this._applyLightMapParams();
            this._baseRenderNode.shaderData.setMatrix4x4(Sprite3D.WORLDMATRIX, this._transform.worldMatrix);
        }
        _needRender(boundFrustum, context) {
            if (boundFrustum) {
                if (boundFrustum.intersects(this.bounds)) {
                    let hodMesh = this.curHLODRS.HLODMesh.drawSubMeshs;
                    let lodbatchMesh = this._curHLODRS.HLODMesh.batchSubMeshInfo;
                    hodMesh.length = 0;
                    for (let i = 0, n = this._curSubBatchMeshBounds.length; i < n; i++) {
                        if (boundFrustum.intersects(this._curSubBatchMeshBounds[i])) {
                            hodMesh.push(lodbatchMesh[i]);
                        }
                    }
                    this._curHLODRS.HLODMesh.drawSubMeshs = hodMesh;
                    return true;
                }
                else
                    return false;
            }
            else {
                return true;
            }
        }
        onDestroy() {
            super.onDestroy();
            this._renderElements.forEach(element => {
                element.material._removeReference();
                element.destroy();
            });
            this._renderElements = null;
        }
    }

    const tempVec = new Laya.Vector3();
    class HLOD extends Laya.Component {
        constructor() {
            super();
            this._singleton = true;
        }
        get bounds() {
            return this._bounds;
        }
        set bounds(value) {
            this._bounds = value;
            this.recalculateBounds();
        }
        get lodResource() {
            return this._resourceList;
        }
        set lodResource(value) {
            this._resourceList = value;
        }
        get lodCullRateArray() {
            return this._lodRateArray;
        }
        set lodCullRateArray(value) {
            value.sort((a, b) => b - a);
            this._lodRateArray = value;
        }
        _applyLODResource(resource) {
            this._curLODSource = resource;
            let element = resource.resources;
            for (let i = 0, n = element.length; i < n; i++) {
                let hlodRender = this.owner.addComponent(HLODRender);
                this._curRender.push(hlodRender);
                hlodRender.curHLODRS = element[i];
            }
        }
        _releaseGroupRender() {
            this._curRender.forEach(element => {
                element.destroy();
            });
            this._curRender = [];
        }
        recalculateBounds() {
            let extend = this._bounds.getExtent();
            this._size = 2 * Math.max(extend.x, extend.y, extend.z);
        }
        onPreRender() {
            let checkCamera = this.owner.scene.cullInfoCamera;
            let maxYDistance = checkCamera.maxlocalYDistance;
            let cameraFrustum = checkCamera.boundFrustum;
            Laya.Vector3.subtract(this.owner.transform.position, checkCamera.transform.position, tempVec);
            let length = tempVec.length();
            if (length > checkCamera.farPlane || cameraFrustum.containsPoint(this.owner.transform.position) == 0) {
                return;
            }
            let rateYDistance = length / checkCamera.farPlane * maxYDistance;
            let rate = (this._size / rateYDistance);
            for (let i = 0; i < this._lodRateArray.length; i++) {
                if (rate < this._lodRateArray[i])
                    continue;
                this.applyResource(this._resourceList[i]);
                break;
            }
        }
        onUpdate() {
            this._curLODSource.updateMark = Camera._updateMark;
        }
        applyResource(resource) {
            if (resource == this._curLODSource)
                return;
            if (resource.loaded) {
                if (this._curLODSource) {
                    this._releaseGroupRender();
                    this._applyLODResource(resource);
                }
            }
            else {
                resource.load(this.applyResource, this);
            }
        }
    }

    class HLODBatchMesh extends GeometryElement {
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
        }
        get batchMesh() {
            return this._mesh;
        }
        set batchMesh(mesh) {
            if (this._mesh != mesh) {
                this._mesh && (this._mesh._removeReference());
                this.indexFormat = mesh.indexFormat;
                this._mesh = mesh;
                this._mesh._addReference();
            }
        }
        get batchSubMeshInfo() {
            return this._batchSubMeshInfos;
        }
        set batchSubMeshInfo(value) {
            this._batchSubMeshInfos = value;
        }
        get drawSubMeshs() {
            return this._drawSubMeshs;
        }
        set drawSubMeshs(value) {
            this._drawSubMeshs = value;
        }
        _prepareRender(state) {
            this._mesh._uploadVerticesData();
            return true;
        }
        _updateRenderParams(state) {
            var mesh = this._mesh;
            var byteCount;
            switch (mesh.indexFormat) {
                case Laya.IndexFormat.UInt32:
                    byteCount = 4;
                    break;
                case Laya.IndexFormat.UInt16:
                    byteCount = 2;
                    break;
                case Laya.IndexFormat.UInt8:
                    byteCount = 1;
                    break;
            }
            this.clearRenderParams();
            this.bufferState = mesh._bufferState;
            if (this._drawSubMeshs) {
                this._drawSubMeshs.forEach(element => {
                    this.setDrawElemenParams(element.drawPramas.y, element.drawPramas.x * byteCount);
                });
            }
        }
        destroy() {
            this._mesh && this._mesh._removeReference();
            delete this._batchSubMeshInfos;
            delete this._drawSubMeshs;
        }
    }

    class HLODConfig {
    }
    class HLODBatchSubMesh {
    }
    class HLODElement {
        get material() {
            return this._material;
        }
        set material(value) {
            if (this._material != value) {
                this._material && this._material._removeReference();
                this._material = value;
                this._material._addReference();
            }
        }
        get lightmap() {
            return this._lightmap;
        }
        set lightmap(value) {
            if (this._lightmap != value) {
                if (this._lightmap) {
                    this._lightmap.lightmapColor._removeReference();
                    this._lightmap.lightmapDirection._removeReference();
                }
                this._lightmap = value;
                this._lightmap.lightmapColor._addReference();
                this._lightmap.lightmapDirection._addReference();
            }
            this._lightmap = value;
        }
        release() {
            this.HLODMesh.destroy();
            this.material.destroy();
            if (this.lightmap) {
                this._lightmap.lightmapColor.destroy();
                this._lightmap.lightmapDirection.destroy();
            }
        }
    }
    class HLODResourceGroup {
        load(callFun, hlod) {
            if (!this.loaded) {
                Laya.Laya.loader.load(this.url).then((res) => {
                    callFun.apply(hlod, [this]);
                    this.loaded = true;
                });
            }
        }
        release() {
            this.resources.forEach(element => {
                element.release();
            });
            this.loaded = false;
        }
    }

    var Script3D = Laya.Script;

    class StaticBatchSubInfo {
        constructor() {
            this.indexStart = 0;
            this.indexCount = 0;
            this.meshBounds = new Bounds(new Laya.Vector3(), new Laya.Vector3());
            this.needRender = false;
        }
    }
    class StaticBatchSubMesh extends GeometryElement {
        constructor() {
            super(Laya.MeshTopology.Triangles, Laya.DrawType.DrawElement);
            this.subInfos = [];
        }
        addSubMesh(indexCount, indexStart, bounds) {
            let info = new StaticBatchSubInfo();
            info.indexCount = indexCount;
            info.indexStart = indexStart;
            bounds.cloneTo(info.meshBounds);
            this.subInfos.push(info);
        }
        _getType() {
            return StaticBatchSubMesh._type;
        }
        _updateRenderParams(state) {
            this.clearRenderParams();
            let cameraPos = state.camera.transform.position;
            this.subInfos.sort((a, b) => {
                let centerA = a.meshBounds.getCenter();
                let distanceA = Laya.Vector3.distanceSquared(centerA, cameraPos);
                let centerB = b.meshBounds.getCenter();
                let distanceB = Laya.Vector3.distanceSquared(centerB, cameraPos);
                return distanceA - distanceB;
            });
            for (const info of this.subInfos) {
                if (info.needRender) {
                    this.setDrawElemenParams(info.indexCount, info.indexStart * this.indexByteCount);
                }
            }
        }
        _prepareRender(state) {
            return !!this.subInfos.find(info => info.needRender);
        }
        destroy() {
            for (const info of this.subInfos) {
            }
            this.subInfos = null;
        }
    }
    StaticBatchSubMesh._type = GeometryElement._typeCounter++;

    const tempMatrix = new Laya.Matrix4x4;
    const TriangleIndices = [0, 1, 2];
    const InvertTriangleIndices = [0, 2, 1];
    class StaticBatchMesh {
        static create(info) {
            let staticMesh = new StaticBatchMesh();
            let vertexCount = info.vertexCount;
            let indexCount = info.indexCount;
            let vertexDec = info.vertexDec;
            let vertexFloatStride = vertexDec.vertexStride / 4;
            let vertexData = new ArrayBuffer(vertexDec.vertexStride * vertexCount);
            let vertexFloatArray = new Float32Array(vertexData);
            let mergeIndexFormat = Laya.IndexFormat.UInt16;
            let mergeIndexByteCount = 2;
            let indexArray;
            if (vertexCount > 65535) {
                mergeIndexFormat = Laya.IndexFormat.UInt32;
                mergeIndexByteCount = 4;
                indexArray = new Uint32Array(indexCount);
            }
            else {
                indexArray = new Uint16Array(indexCount);
            }
            let vertexDataOffset = 0;
            let vertexCountOffset = 0;
            let indexOffset = 0;
            let bounds;
            for (const render of info.renders) {
                let lightmapScaleOffset = render.lightmapScaleOffset;
                if (!bounds) {
                    bounds = staticMesh.bounds;
                    render.bounds.cloneTo(bounds);
                }
                Bounds.merge(bounds, render.bounds, bounds);
                let sp = render.owner;
                let invertFront = sp.transform._isFrontFaceInvert;
                let worldMat = sp.transform.worldMatrix;
                let normalMat = tempMatrix;
                worldMat.invert(normalMat);
                normalMat.transpose();
                let mesh = render.getMesh();
                let meshVertexCount = mesh.vertexCount;
                let meshIndexCount = mesh.indexCount;
                let meshVertexData = mesh._vertexBuffer.getFloat32Data();
                vertexFloatArray.set(meshVertexData, vertexDataOffset);
                for (let index = 0; index < meshVertexCount; index++) {
                    let elementOffset = index * vertexFloatStride;
                    for (const element of vertexDec._vertexElements) {
                        elementOffset += element.offset / 4;
                        switch (element.elementUsage) {
                            case Laya.VertexMesh.MESH_POSITION0:
                                Utils3D.transformVector3ArrayToVector3ArrayCoordinate(meshVertexData, elementOffset, worldMat, vertexFloatArray, vertexDataOffset + elementOffset);
                                break;
                            case Laya.VertexMesh.MESH_NORMAL0:
                            case Laya.VertexMesh.MESH_TANGENT0:
                                Utils3D.transformVector3ArrayToVector3ArrayNormal(meshVertexData, elementOffset, normalMat, vertexFloatArray, vertexDataOffset + elementOffset);
                                break;
                            case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                                Utils3D.transformLightingMapTexcoordArray(meshVertexData, elementOffset, lightmapScaleOffset, vertexFloatArray, vertexDataOffset + elementOffset);
                                break;
                        }
                    }
                }
                let meshIndexData = mesh._indexBuffer.getData();
                let triangleIndices = invertFront ? InvertTriangleIndices : TriangleIndices;
                for (let index = 0; index < meshIndexCount; index += 3) {
                    indexArray[indexOffset + index] = meshIndexData[index + triangleIndices[0]] + vertexCountOffset;
                    indexArray[indexOffset + index + 1] = meshIndexData[index + triangleIndices[1]] + vertexCountOffset;
                    indexArray[indexOffset + index + 2] = meshIndexData[index + triangleIndices[2]] + vertexCountOffset;
                }
                let subMeshCount = mesh.subMeshCount;
                for (let index = 0; index < subMeshCount; index++) {
                    let material = render.sharedMaterials[index] || BlinnPhongMaterial.defaultMaterial;
                    let staticSubMesh = staticMesh._staticSubMeshes.get(material);
                    if (!staticSubMesh) {
                        staticSubMesh = new StaticBatchSubMesh();
                        staticSubMesh.indexByteCount = mergeIndexByteCount;
                        staticMesh._staticSubMeshes.set(material, staticSubMesh);
                        staticSubMesh.bufferState = staticMesh._bufferState;
                        staticSubMesh.indexFormat = mergeIndexFormat;
                    }
                    let subMesh = mesh.getSubMesh(index);
                    staticSubMesh.addSubMesh(subMesh.indexCount, subMesh._indexStart + indexOffset, render.bounds);
                }
                vertexDataOffset += meshVertexData.length;
                vertexCountOffset += meshVertexCount;
                indexOffset += meshIndexData.length;
            }
            let vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(vertexData.byteLength, Laya.BufferUsage.Static, false);
            vertexBuffer.vertexDeclaration = vertexDec;
            vertexBuffer.setData(vertexData);
            let indexBuffer = Laya3DRender.renderOBJCreate.createIndexBuffer3D(mergeIndexFormat, indexCount, Laya.BufferUsage.Static, false);
            indexBuffer.setData(indexArray);
            staticMesh.setBuffer(vertexBuffer, indexBuffer);
            return staticMesh;
        }
        constructor() {
            this._bufferState = new Laya.BufferState();
            this._staticSubMeshes = new Map();
            this.bounds = new Bounds();
        }
        setBuffer(vertex, index) {
            let bufferState = this._bufferState;
            this._vertexBuffer = vertex;
            this._indexBuffer = index;
            bufferState.applyState([vertex], index);
        }
        destroy() {
            this._staticSubMeshes.forEach(submesh => {
                submesh.destroy();
            });
            this._staticSubMeshes.clear();
            this._staticSubMeshes = null;
            this._bufferState.destroy();
        }
    }

    class StaticBatchMeshRenderElement extends RenderElement {
        constructor() {
            super();
        }
        getInvertFront() {
            return false;
        }
    }

    class StaticBatchMeshRender extends BaseRender {
        static create(info) {
            let render = new StaticBatchMeshRender();
            render.mergeInfo = info;
            return render;
        }
        get staticMesh() {
            return this._staticMesh;
        }
        get mergeInfo() {
            return this._mergeInfo;
        }
        set mergeInfo(value) {
            this._mergeInfo = value;
            let staticMesh = StaticBatchMesh.create(value);
            this._staticMesh = staticMesh;
            this.lightmapIndex = value.lightmapIndex;
            this._staticMesh = staticMesh;
            this.geometryBounds = staticMesh.bounds;
            let meshDefines = MeshFilter._meshVerticeDefine;
            let defineDatas = this._baseRenderNode.shaderData;
            this._getMeshDefine(staticMesh, meshDefines);
            for (const meshDef of meshDefines) {
                defineDatas.addDefine(meshDef);
            }
            this._renderElements.forEach(element => {
                element.material._removeReference();
                element.destroy();
            });
            this._renderElements = [];
            staticMesh._staticSubMeshes.forEach((subMesh, material) => {
                let element = new StaticBatchMeshRenderElement();
                this._renderElements.push(element);
                element.render = this;
                element.material = material;
                element.setGeometry(subMesh);
                material._addReference();
            });
            staticMesh.bounds.cloneTo(this.bounds);
        }
        constructor() {
            super();
            this._singleton = false;
        }
        _calculateBoundingBox() {
        }
        _renderUpdate(context) {
        }
        _getMeshDefine(mesh, out) {
            let vertexElements = mesh._vertexBuffer.vertexDeclaration._vertexElements;
            for (const element of vertexElements) {
                switch (element.elementUsage) {
                    case Laya.VertexMesh.MESH_COLOR0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_COLOR);
                        break;
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV0);
                        break;
                    case Laya.VertexMesh.MESH_TEXTURECOORDINATE1:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_UV1);
                        break;
                    case Laya.VertexMesh.MESH_TANGENT0:
                        out.push(MeshSprite3DShaderDeclaration.SHADERDEFINE_TANGENT);
                        break;
                }
            }
        }
        _needRender(boundFrustum, context) {
            if (boundFrustum) {
                if (boundFrustum.intersects(this.bounds)) {
                    let needRender = false;
                    this.staticMesh._staticSubMeshes.forEach(subMesh => {
                        for (const info of subMesh.subInfos) {
                            info.needRender = boundFrustum.intersects(info.meshBounds);
                            needRender = needRender || info.needRender;
                        }
                    });
                    return needRender;
                }
                return false;
            }
            else {
                return true;
            }
        }
        onEnable() {
            super.onEnable();
            this.mergeInfo.renders.forEach(render => {
                render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_Batch, true);
            });
        }
        onDisable() {
            super.onDisable();
            this.mergeInfo.renders.forEach(render => {
                render.setRenderbitFlag(exports.RenderBitFlag.RenderBitFlag_Batch, false);
            });
        }
        onDestroy() {
            super.onDestroy();
            this._renderElements.forEach(element => {
                element.material._removeReference();
                element.destroy();
            });
            this._renderElements = null;
            this._staticMesh.destroy();
            this._staticMesh = null;
        }
        _cloneTo(dest) {
            dest.mergeInfo = this.mergeInfo;
        }
    }

    class StaticMeshMergeInfo {
        static create(render) {
            let mesh = render.getMesh();
            let info = new StaticMeshMergeInfo();
            info.lightmapIndex = render.lightmapIndex;
            info.receiveShadow = render.receiveShadow;
            info.vertexDec = mesh ? mesh.getVertexDeclaration() : null;
            return info;
        }
        get renders() {
            return this._renders;
        }
        constructor() {
            this._renders = [];
            this.vertexCount = 0;
            this.indexCount = 0;
        }
        match(render) {
            let mesh = render.getMesh();
            render.owner;
            let match = true;
            match = match && this.lightmapIndex == render.lightmapIndex;
            match = match && this.receiveShadow == render.receiveShadow;
            match = match && this.vertexDec == mesh.getVertexDeclaration();
            return match;
        }
        addElement(render) {
            this.renders.push(render);
            let mesh = render.getMesh();
            this.vertexCount += mesh.vertexCount;
            this.indexCount += mesh.indexCount;
        }
        destroy() {
            this._renders = null;
        }
    }

    class StaticMeshBatchManager {
        constructor() {
            this.meshVertexDecSet = new Set();
        }
        combine(renders) {
            for (const render of renders) {
                let haveMatch = false;
                for (const info of this.meshVertexDecSet) {
                    if (info.match(render)) {
                        haveMatch = true;
                        info.addElement(render);
                    }
                }
                if (!haveMatch) {
                    let info = StaticMeshMergeInfo.create(render);
                    info.addElement(render);
                    this.meshVertexDecSet.add(info);
                }
            }
            let staticRenders = [];
            for (const info of this.meshVertexDecSet) {
                staticRenders.push(StaticBatchMeshRender.create(info));
            }
            this.meshVertexDecSet.clear();
            return staticRenders;
        }
        merge(info) {
            let staticMeshRender = StaticBatchMeshRender.create(info);
            return staticMeshRender;
        }
    }

    class PixelLineSprite3D extends RenderableSprite3D {
        get maxLineCount() {
            return this._render.maxLineCount;
        }
        set maxLineCount(value) {
            this._render.maxLineCount = value;
        }
        get lineCount() {
            return this._render.lineCount;
        }
        get pixelLineRenderer() {
            return this._render;
        }
        constructor(maxCount = 2, name = null) {
            super(name);
            this._isRenderActive = false;
            this._isInRenders = false;
            this._render = this.addComponent(PixelLineRenderer);
            this._geometryFilter = this._render._pixelLineFilter;
            this._render.maxLineCount = maxCount;
            let material = this._render.material = new UnlitMaterial();
            material.enableVertexColor = true;
        }
        addLine(startPosition, endPosition, startColor, endColor) {
            this._render.addLine(startPosition, endPosition, startColor, endColor);
        }
        addLines(lines) {
            this._render.addLines(lines);
        }
        removeLine(index) {
            this._render.removeLine(index);
        }
        setLine(index, startPosition, endPosition, startColor, endColor) {
            this._render.setLine(index, startPosition, endPosition, startColor, endColor);
        }
        getLine(index, out) {
            this._render.getLine(index, out);
        }
        clear() {
            this._render.clear();
        }
    }

    class MaterialInstanceProperty {
        constructor() {
            this._isNeedUpdate = false;
        }
        createInstanceVertexBuffer3D() {
            this._instanceData = new Float32Array(DrawMeshInstancedCMD.maxInstanceCount * this._vertexStride);
            this._vertexBuffer = Laya3DRender.renderOBJCreate.createVertexBuffer3D(this._instanceData.length * 4, Laya.BufferUsage.Dynamic, false);
            this._vertexBuffer.vertexDeclaration = this._vertexDeclaration;
            this._vertexBuffer.instanceBuffer = true;
        }
        updateVertexBufferData(drawNums) {
            if (!this._isNeedUpdate)
                return;
            let instanceData = this._instanceData;
            let dataValue = this._value;
            let datalength = this._value.length;
            let data;
            let stride = this._vertexStride;
            let updateType = 0;
            if (!(this._value instanceof Float32Array)) {
                updateType = 1;
            }
            switch (updateType) {
                case 0:
                    instanceData.set(dataValue, 0);
                    break;
                case 1:
                    for (let i = 0; i < datalength; i++) {
                        data = dataValue[i];
                        data.writeTo(instanceData, i * stride);
                    }
                    break;
            }
            this._vertexBuffer._deviceBuffer.setDataLength(this._vertexBuffer._byteLength);
            this._vertexBuffer.setData(instanceData.buffer, 0, 0, drawNums * 4 * stride);
        }
        destroy() {
            delete this._value;
            delete this._instanceData;
            this._vertexDeclaration = null;
            this._vertexBuffer.destroy();
        }
    }

    exports.InstanceLocation = void 0;
    (function (InstanceLocation) {
        InstanceLocation[InstanceLocation["CUSTOME0"] = 12] = "CUSTOME0";
        InstanceLocation[InstanceLocation["CUSTOME1"] = 13] = "CUSTOME1";
        InstanceLocation[InstanceLocation["CUSTOME2"] = 14] = "CUSTOME2";
        InstanceLocation[InstanceLocation["CUSTOME3"] = 15] = "CUSTOME3";
    })(exports.InstanceLocation || (exports.InstanceLocation = {}));
    class MaterialInstancePropertyBlock {
        constructor() {
            this._type = 0;
            this._propertyMap = {};
        }
        _checkPropertyLegal(vertexElementFormat, propertyName, attributeLocation, prob) {
            var vecDec = prob._vertexDeclaration;
            if (vecDec._vertexElements[0]._elementFormat !== vertexElementFormat)
                throw "Data exists and format does not match";
            if (prob._name !== propertyName)
                throw "You cannot add a new property to an existing attributeLocation,Please use another attributeLocation";
        }
        _creatProperty(attributeName, arrays, vertexStride, vertexformat, attributeLocation) {
            var prob = this._propertyMap[attributeLocation] = new MaterialInstanceProperty();
            prob._name = attributeName;
            prob._value = arrays;
            prob._vertexDeclaration = new Laya.VertexDeclaration(vertexStride, [new Laya.VertexElement(0, vertexformat, attributeLocation)]);
            prob._isNeedUpdate = true;
            prob._vertexStride = vertexStride / 4;
            prob.createInstanceVertexBuffer3D();
        }
        setVectorArray(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Vector4, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 16, Laya.VertexElementFormat.Vector4, attributeLocation);
        }
        setVector3Array(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Vector3, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 12, Laya.VertexElementFormat.Vector3, attributeLocation);
        }
        setVector2Array(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Vector2, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 8, Laya.VertexElementFormat.Vector2, attributeLocation);
        }
        setNumberArray(attributeName, arrays, attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            if (prob) {
                this._checkPropertyLegal(Laya.VertexElementFormat.Single, attributeName, attributeLocation, prob);
                prob._value = arrays;
                prob._isNeedUpdate = true;
            }
            else
                this._creatProperty(attributeName, arrays, 4, Laya.VertexElementFormat.Single, attributeLocation);
        }
        getPropertyArray(attributeLocation) {
            var prob = this._propertyMap[attributeLocation];
            return prob ? prob._value : null;
        }
        clear() {
            for (var i in this._propertyMap) {
                this._propertyMap[i].destroy();
            }
            this._propertyMap = {};
        }
    }
    MaterialInstancePropertyBlock.INSTANCETYPE_ATTRIBUTE = 0;
    MaterialInstancePropertyBlock.INSTANCETYPE_UNIFORMBUFFER = 1;

    class FrustumCulling {
        static cullingRenderBounds(bounds, cullInfo) {
            var cullPlaneCount = cullInfo.cullPlaneCount;
            var cullPlanes = cullInfo.cullPlanes;
            var min = bounds._imp.getMin();
            var max = bounds._imp.getMax();
            var minX = min.x;
            var minY = min.y;
            var minZ = min.z;
            var maxX = max.x;
            var maxY = max.y;
            var maxZ = max.z;
            var pass = true;
            for (var j = 0; j < cullPlaneCount; j++) {
                var plane = cullPlanes[j];
                var normal = plane.normal;
                if (plane.distance + (normal.x * (normal.x < 0.0 ? minX : maxX)) + (normal.y * (normal.y < 0.0 ? minY : maxY)) + (normal.z * (normal.z < 0.0 ? minZ : maxZ)) < 0.0) {
                    pass = false;
                    break;
                }
            }
            return pass;
        }
    }

    var internalResources = {};
    class Texture2DArrayLoader {
        constructor() {
            if (!internalResources) {
                internalResources = {
                    "default": Laya.Texture2DArray.defaultTexture
                };
            }
        }
        load(task) {
            if (task.url.indexOf("internal/") != -1) {
                const tex = internalResources[Laya.Utils.getBaseName(task.url)];
                if (tex) {
                    return Promise.resolve(tex);
                }
            }
            return task.loader.fetch(task.url, "json", task.progress.createCallback(), task.options).then((data) => {
                if (!data) {
                    return null;
                }
                let width = data.width;
                let height = data.height;
                let depth = data.depth;
                let format = data.format;
                let mipmap = data.mipmap;
                let sRGB = data.sRGB;
                let premultiplyAlpha = !!data.premultiplyAlpha;
                let invertY = !!data.invertY;
                let textures = data.textures;
                let urls = [];
                for (let index = 0; index < textures.length; index++) {
                    urls.push(textures[index]);
                }
                return Promise.all(urls.map((url) => {
                    if (url) {
                        return task.loader.fetch(url, "image", task.progress.createCallback(), task.options);
                    }
                    else {
                        return Promise.resolve(null);
                    }
                })).then(images => {
                    if (Laya.LayaGL.renderEngine.getCapable(Laya.RenderCapable.Texture3D)) {
                        let tex = new Laya.Texture2DArray(width, height, depth, format, mipmap, sRGB);
                        tex.setImageData(images, premultiplyAlpha, invertY);
                        return tex;
                    }
                    else {
                        return null;
                    }
                });
            });
        }
    }
    Laya.Loader.registerLoader(["tex2darray"], Texture2DArrayLoader, Laya.Loader.TEXTURE2DARRAY);

    class BoundSphere {
        get center() {
            return this._center;
        }
        set center(value) {
            value.cloneTo(this._center);
        }
        get radius() {
            return this._radius;
        }
        set radius(value) {
            this._radius = value;
        }
        constructor(center = new Laya.Vector3, radius = 0) {
            this._center = center;
            this._radius = radius;
        }
        toDefault() {
            this._center.toDefault();
            this._radius = 0;
        }
        static createFromSubPoints(points, start, count, out) {
            if (points == null) {
                throw new Error("points");
            }
            if (start < 0 || start >= points.length) {
                throw new Error("start" + start + "Must be in the range [0, " + (points.length - 1) + "]");
            }
            if (count < 0 || (start + count) > points.length) {
                throw new Error("count" + count + "Must be in the range <= " + points.length + "}");
            }
            var upperEnd = start + count;
            var center = _tempVector3;
            center.x = 0;
            center.y = 0;
            center.z = 0;
            for (var i = start; i < upperEnd; ++i) {
                Laya.Vector3.add(points[i], center, center);
            }
            var outCenter = out.center;
            Laya.Vector3.scale(center, 1 / count, outCenter);
            var radius = 0.0;
            for (i = start; i < upperEnd; ++i) {
                var distance = Laya.Vector3.distanceSquared(outCenter, points[i]);
                if (distance > radius)
                    radius = distance;
            }
            out.radius = Math.sqrt(radius);
        }
        static createfromPoints(points, out) {
            if (points == null) {
                throw new Error("points");
            }
            BoundSphere.createFromSubPoints(points, 0, points.length, out);
        }
        intersectsRayDistance(ray) {
            return CollisionUtils.intersectsRayAndSphereRD(ray, this);
        }
        intersectsRayPoint(ray, outPoint) {
            return CollisionUtils.intersectsRayAndSphereRP(ray, this, outPoint);
        }
        cloneTo(destObject) {
            this._center.cloneTo(destObject._center);
            destObject._radius = this._radius;
        }
        clone() {
            var dest = new BoundSphere(new Laya.Vector3(), 0);
            this.cloneTo(dest);
            return dest;
        }
    }
    const _tempVector3 = new Laya.Vector3();

    class BoundsImpl {
        get min() {
            return this.getMin();
        }
        set min(value) {
            this.setMin(value);
        }
        get max() {
            return this.getMax();
        }
        set max(value) {
            this.setMax(value);
        }
        setMin(value) {
            var min = this._boundBox.min;
            if (value !== min)
                value.cloneTo(min);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_EXTENT, true);
            this._setUpdateFlag(BoundsImpl._UPDATE_MIN, false);
        }
        getMin() {
            var min = this._boundBox.min;
            if (this._getUpdateFlag(BoundsImpl._UPDATE_MIN)) {
                this._getMin(this.getCenter(), this.getExtent(), min);
                this._setUpdateFlag(BoundsImpl._UPDATE_MIN, false);
            }
            return min;
        }
        setMax(value) {
            var max = this._boundBox.max;
            if (value !== max)
                value.cloneTo(max);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_EXTENT, true);
            this._setUpdateFlag(BoundsImpl._UPDATE_MAX, false);
        }
        getMax() {
            var max = this._boundBox.max;
            if (this._getUpdateFlag(BoundsImpl._UPDATE_MAX)) {
                this._getMax(this.getCenter(), this.getExtent(), max);
                this._setUpdateFlag(BoundsImpl._UPDATE_MAX, false);
            }
            return max;
        }
        setCenter(value) {
            if (value !== this._center)
                value.cloneTo(this._center);
            this._getMin(this._center, this._extent, this._boundBox.min);
            this._getMax(this._center, this._extent, this._boundBox.max);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_MIN | BoundsImpl._UPDATE_MAX, false);
        }
        getCenter() {
            if (this._getUpdateFlag(BoundsImpl._UPDATE_CENTER)) {
                this._getCenter(this.getMin(), this.getMax(), this._center);
                this._setUpdateFlag(BoundsImpl._UPDATE_CENTER, false);
            }
            return this._center;
        }
        setExtent(value) {
            if (value !== this._extent)
                value.cloneTo(this._extent);
            this._getMin(this._center, this._extent, this._boundBox.min);
            this._getMax(this._center, this._extent, this._boundBox.max);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_MIN | BoundsImpl._UPDATE_MAX, false);
        }
        getExtent() {
            if (this._getUpdateFlag(BoundsImpl._UPDATE_EXTENT)) {
                this._getExtent(this.getMin(), this.getMax(), this._extent);
                this._setUpdateFlag(BoundsImpl._UPDATE_EXTENT, false);
            }
            return this._extent;
        }
        constructor(min, max) {
            this._updateFlag = 0;
            this._center = new Laya.Vector3();
            this._extent = new Laya.Vector3();
            this._boundBox = new BoundBox(new Laya.Vector3(), new Laya.Vector3());
            min && min.cloneTo(this._boundBox.min);
            max && max.cloneTo(this._boundBox.max);
            this._setUpdateFlag(BoundsImpl._UPDATE_MIN | BoundsImpl._UPDATE_MAX, false);
            this._setUpdateFlag(BoundsImpl._UPDATE_CENTER | BoundsImpl._UPDATE_EXTENT, true);
        }
        _getUpdateFlag(type) {
            return (this._updateFlag & type) != 0;
        }
        _setUpdateFlag(type, value) {
            if (value)
                this._updateFlag |= type;
            else
                this._updateFlag &= ~type;
        }
        _getCenter(min, max, out) {
            Laya.Vector3.add(min, max, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getExtent(min, max, out) {
            Laya.Vector3.subtract(max, min, out);
            Laya.Vector3.scale(out, 0.5, out);
        }
        _getMin(center, extent, out) {
            Laya.Vector3.subtract(center, extent, out);
        }
        _getMax(center, extent, out) {
            Laya.Vector3.add(center, extent, out);
        }
        _rotateExtents(extents, rotation, out) {
            var extentsX = extents.x;
            var extentsY = extents.y;
            var extentsZ = extents.z;
            var matE = rotation.elements;
            out.x = Math.abs(matE[0] * extentsX) + Math.abs(matE[4] * extentsY) + Math.abs(matE[8] * extentsZ);
            out.y = Math.abs(matE[1] * extentsX) + Math.abs(matE[5] * extentsY) + Math.abs(matE[9] * extentsZ);
            out.z = Math.abs(matE[2] * extentsX) + Math.abs(matE[6] * extentsY) + Math.abs(matE[10] * extentsZ);
        }
        _tranform(matrix, out) {
            var outCen = out._center;
            var outExt = out._extent;
            Laya.Vector3.transformCoordinate(this.getCenter(), matrix, outCen);
            this._rotateExtents(this.getExtent(), matrix, outExt);
            out._boundBox.setCenterAndExtent(outCen, outExt);
            out._updateFlag = 0;
        }
        _getBoundBox() {
            if (this._updateFlag & BoundsImpl._UPDATE_MIN) {
                var min = this._boundBox.min;
                this._getMin(this.getCenter(), this.getExtent(), min);
                this._setUpdateFlag(BoundsImpl._UPDATE_MIN, false);
            }
            if (this._updateFlag & BoundsImpl._UPDATE_MAX) {
                var max = this._boundBox.max;
                this._getMax(this.getCenter(), this.getExtent(), max);
                this._setUpdateFlag(BoundsImpl._UPDATE_MAX, false);
            }
            return this._boundBox;
        }
        calculateBoundsintersection(bounds) {
            var ownMax = this.getMax();
            var ownMin = this.getMin();
            var calMax = bounds.getMax();
            var calMin = bounds.getMin();
            var tempV0 = TEMP_VECTOR3_MAX0;
            var tempV1 = TEMP_VECTOR3_MAX1;
            var thisExtends = this.getExtent();
            var boundExtends = bounds.getExtent();
            tempV0.setValue(Math.max(ownMax.x, calMax.x) - Math.min(ownMin.x, calMin.x), Math.max(ownMax.y, calMax.y) - Math.min(ownMin.y, calMin.y), Math.max(ownMax.z, calMax.z) - Math.min(ownMin.z, calMin.z));
            tempV1.setValue((thisExtends.x + boundExtends.x) * 2.0, (thisExtends.y + boundExtends.y) * 2.0, (thisExtends.z + boundExtends.z) * 2.0);
            if ((tempV0.x) > (tempV1.x))
                return -1;
            if ((tempV0.y) > (tempV1.y))
                return -1;
            if ((tempV0.z) > (tempV1.z))
                return -1;
            return (tempV1.x - tempV0.x) * (tempV1.y - tempV0.y) * (tempV1.z - tempV0.z);
        }
        cloneTo(destObject) {
            this.getMin().cloneTo(destObject._boundBox.min);
            this.getMax().cloneTo(destObject._boundBox.max);
            this.getCenter().cloneTo(destObject._center);
            this.getExtent().cloneTo(destObject._extent);
            destObject._updateFlag = 0;
        }
        clone() {
            var dest = new BoundsImpl(new Laya.Vector3(), new Laya.Vector3());
            this.cloneTo(dest);
            return dest;
        }
    }
    BoundsImpl._UPDATE_MIN = 0x01;
    BoundsImpl._UPDATE_MAX = 0x02;
    BoundsImpl._UPDATE_CENTER = 0x04;
    BoundsImpl._UPDATE_EXTENT = 0x08;
    const TEMP_VECTOR3_MAX0 = new Laya.Vector3();
    const TEMP_VECTOR3_MAX1 = new Laya.Vector3();

    class Rand {
        static getFloatFromInt(v) {
            return (v & 0x007FFFFF) * (1.0 / 8388607.0);
        }
        static getByteFromInt(v) {
            return (v & 0x007FFFFF) >>> 15;
        }
        get seed() {
            return this.seeds[0];
        }
        set seed(seed) {
            this.seeds[0] = seed;
            this.seeds[1] = this.seeds[0] * 0x6C078965 + 1;
            this.seeds[2] = this.seeds[1] * 0x6C078965 + 1;
            this.seeds[3] = this.seeds[2] * 0x6C078965 + 1;
        }
        constructor(seed) {
            this._temp = new Uint32Array(1);
            this.seeds = new Uint32Array(4);
            this.seeds[0] = seed;
            this.seeds[1] = this.seeds[0] * 0x6C078965 + 1;
            this.seeds[2] = this.seeds[1] * 0x6C078965 + 1;
            this.seeds[3] = this.seeds[2] * 0x6C078965 + 1;
        }
        getUint() {
            this._temp[0] = this.seeds[0] ^ (this.seeds[0] << 11);
            this.seeds[0] = this.seeds[1];
            this.seeds[1] = this.seeds[2];
            this.seeds[2] = this.seeds[3];
            this.seeds[3] = (this.seeds[3] ^ (this.seeds[3] >>> 19)) ^ (this._temp[0] ^ (this._temp[0] >>> 8));
            return this.seeds[3];
        }
        getFloat() {
            this.getUint();
            return (this.seeds[3] & 0x007FFFFF) * (1.0 / 8388607.0);
        }
        getSignedFloat() {
            return this.getFloat() * 2.0 - 1.0;
        }
    }

    class RandX {
        constructor(seed) {
            if (!(seed instanceof Array) || seed.length !== 4)
                throw new Error('Rand:Seed must be an array with 4 numbers');
            this._state0U = seed[0] | 0;
            this._state0L = seed[1] | 0;
            this._state1U = seed[2] | 0;
            this._state1L = seed[3] | 0;
        }
        randomint() {
            var s1U = this._state0U, s1L = this._state0L;
            var s0U = this._state1U, s0L = this._state1L;
            var sumL = (s0L >>> 0) + (s1L >>> 0);
            var resU = (s0U + s1U + (sumL / 2 >>> 31)) >>> 0;
            var resL = sumL >>> 0;
            this._state0U = s0U;
            this._state0L = s0L;
            var t1U = 0, t1L = 0;
            var t2U = 0, t2L = 0;
            var a1 = 23;
            var m1 = 0xFFFFFFFF << (32 - a1);
            t1U = (s1U << a1) | ((s1L & m1) >>> (32 - a1));
            t1L = s1L << a1;
            s1U = s1U ^ t1U;
            s1L = s1L ^ t1L;
            t1U = s1U ^ s0U;
            t1L = s1L ^ s0L;
            var a2 = 18;
            var m2 = 0xFFFFFFFF >>> (32 - a2);
            t2U = s1U >>> a2;
            t2L = (s1L >>> a2) | ((s1U & m2) << (32 - a2));
            t1U = t1U ^ t2U;
            t1L = t1L ^ t2L;
            var a3 = 5;
            var m3 = 0xFFFFFFFF >>> (32 - a3);
            t2U = s0U >>> a3;
            t2L = (s0L >>> a3) | ((s0U & m3) << (32 - a3));
            t1U = t1U ^ t2U;
            t1L = t1L ^ t2L;
            this._state1U = t1U;
            this._state1L = t1L;
            return [resU, resL];
        }
        random() {
            var t2 = this.randomint();
            var t2U = t2[0];
            var t2L = t2[1];
            var eU = 0x3FF << (52 - 32);
            var eL = 0;
            var a1 = 12;
            var m1 = 0xFFFFFFFF >>> (32 - a1);
            var sU = t2U >>> a1;
            var sL = (t2L >>> a1) | ((t2U & m1) << (32 - a1));
            var xU = eU | sU;
            var xL = eL | sL;
            RandX._CONVERTION_BUFFER.setUint32(0, xU, false);
            RandX._CONVERTION_BUFFER.setUint32(4, xL, false);
            var d = RandX._CONVERTION_BUFFER.getFloat64(0, false);
            return d - 1;
        }
    }
    RandX._CONVERTION_BUFFER = new DataView(new ArrayBuffer(8));
    RandX.defaultRand = new RandX([0, Date.now() / 65536, 0, Date.now() % 65536]);

    class Collision {
        constructor() {
            this._lastUpdateFrame = -2147483648;
            this._updateFrame = -2147483648;
            this._isTrigger = false;
            this.contacts = [];
            this._inPool = false;
        }
        _setUpdateFrame(farme) {
            this._lastUpdateFrame = this._updateFrame;
            this._updateFrame = farme;
        }
    }

    class ContactPoint {
        constructor() {
            this._idCounter = 0;
            this._colliderA = null;
            this._colliderB = null;
            this.distance = 0;
            this.normal = new Laya.Vector3();
            this.positionOnA = new Laya.Vector3();
            this.positionOnB = new Laya.Vector3();
            this._id = ++this._idCounter;
        }
    }

    exports.ShadowLightType = void 0;
    (function (ShadowLightType) {
        ShadowLightType[ShadowLightType["DirectionLight"] = 0] = "DirectionLight";
        ShadowLightType[ShadowLightType["SpotLight"] = 1] = "SpotLight";
        ShadowLightType[ShadowLightType["PointLight"] = 2] = "PointLight";
    })(exports.ShadowLightType || (exports.ShadowLightType = {}));

    class CameraCullInfo {
        constructor() {
            this.boundFrustum = new BoundFrustum(new Laya.Matrix4x4());
        }
    }
    class ShadowCullInfo {
    }
    class ShadowSpotData {
        constructor() {
            this.position = new Laya.Vector3;
            this.viewMatrix = new Laya.Matrix4x4();
            this.projectionMatrix = new Laya.Matrix4x4();
            this.viewProjectMatrix = new Laya.Matrix4x4();
            this.cameraShaderValue = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
            this.cameraCullInfo = new CameraCullInfo();
        }
        destroy() {
            this.cameraShaderValue.destroy();
            this.cameraShaderValue = null;
            this.cameraCullInfo = null;
        }
    }
    class ShadowSliceData {
        constructor() {
            this.position = new Laya.Vector3();
            this.viewMatrix = new Laya.Matrix4x4();
            this.projectionMatrix = new Laya.Matrix4x4();
            this.viewProjectMatrix = new Laya.Matrix4x4();
            this.cullPlanes = [new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0), new Plane(new Laya.Vector3(), 0)];
            this.splitBoundSphere = new BoundSphere(new Laya.Vector3(), 0.0);
            this.cameraShaderValue = Laya.LayaGL.renderDeviceFactory.createShaderData(null);
        }
        destroy() {
            this.cameraShaderValue.destroy();
            this.cameraShaderValue = null;
            this.cullPlanes = null;
        }
    }

    class TextMesh {
        get text() {
            return this._text;
        }
        set text(value) {
            this._text = value;
        }
        get fontSize() {
            return this._fontSize;
        }
        set fontSize(value) {
            this._fontSize = value;
        }
        get color() {
            return this._color;
        }
        set color(value) {
            this._color = value;
        }
        constructor() {
        }
    }

    class Physics3DUtils {
    }
    Physics3DUtils.COLLISIONFILTERGROUP_DEFAULTFILTER = 0x1;
    Physics3DUtils.COLLISIONFILTERGROUP_STATICFILTER = 0x2;
    Physics3DUtils.COLLISIONFILTERGROUP_KINEMATICFILTER = 0x4;
    Physics3DUtils.COLLISIONFILTERGROUP_DEBRISFILTER = 0x8;
    Physics3DUtils.COLLISIONFILTERGROUP_SENSORTRIGGER = 0x10;
    Physics3DUtils.COLLISIONFILTERGROUP_CHARACTERFILTER = 0x20;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER1 = 0x40;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER2 = 0x80;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER3 = 0x100;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER4 = 0x200;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER5 = 0x400;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER6 = 0x800;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER7 = 0x1000;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER8 = 0x2000;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER9 = 0x4000;
    Physics3DUtils.COLLISIONFILTERGROUP_CUSTOMFILTER10 = 0x8000;
    Physics3DUtils.COLLISIONFILTERGROUP_ALLFILTER = -1;
    Physics3DUtils.PHYSXDEFAULTMASKVALUE = 0xffffffff;

    class Size {
        static get fullScreen() {
            return new Size(-1, -1);
        }
        get width() {
            if (this._width === -1)
                return RenderContext3D.clientWidth;
            return this._width;
        }
        get height() {
            if (this._height === -1)
                return RenderContext3D.clientHeight;
            return this._height;
        }
        constructor(width, height) {
            this._width = 0;
            this._height = 0;
            this._width = width;
            this._height = height;
        }
    }

    exports.AlternateLightQueue = AlternateLightQueue;
    exports.AnimationClip = AnimationClip;
    exports.AnimationClipParser03 = AnimationClipParser03;
    exports.AnimationClipParser04 = AnimationClipParser04;
    exports.AnimationEvent = AnimationEvent;
    exports.Animator = Animator;
    exports.AnimatorController = AnimatorController;
    exports.AnimatorControllerLayer = AnimatorControllerLayer;
    exports.AnimatorPlayState = AnimatorPlayState;
    exports.AnimatorResource = AnimatorResource;
    exports.AnimatorState = AnimatorState;
    exports.AnimatorStateScript = AnimatorStateScript;
    exports.AnimatorTransition = AnimatorTransition;
    exports.AreaLightCom = AreaLightCom;
    exports.AvatarMask = AvatarMask;
    exports.AxiGamepad = AxiGamepad;
    exports.BaseCamera = BaseCamera;
    exports.BaseRender = BaseRender;
    exports.BatchMark = BatchMark;
    exports.BatchRender = BatchRender;
    exports.BlinnPhongMaterial = BlinnPhongMaterial;
    exports.BlinnPhongShaderInit = BlinnPhongShaderInit;
    exports.BlitFrameBufferCMD = BlitFrameBufferCMD;
    exports.BlitQuadCMDData = BlitQuadCMDData;
    exports.BlitScreenQuadCMD = BlitScreenQuadCMD;
    exports.BlitScreenShaderInit = BlitScreenShaderInit;
    exports.BoundBox = BoundBox;
    exports.BoundFrustum = BoundFrustum;
    exports.BoundSphere = BoundSphere;
    exports.Bounds = Bounds;
    exports.BoundsImpl = BoundsImpl;
    exports.ButtonGamepad = ButtonGamepad;
    exports.Camera = Camera;
    exports.CameraCullInfo = CameraCullInfo;
    exports.Cluster = Cluster;
    exports.Collision = Collision;
    exports.CollisionUtils = CollisionUtils;
    exports.Command = Command;
    exports.CommandBuffer = CommandBuffer;
    exports.CommandUniformMap = CommandUniformMap;
    exports.ContactPoint = ContactPoint;
    exports.ContainmentType = ContainmentType;
    exports.CubemapLoader = CubemapLoader;
    exports.DepthPass = DepthPass;
    exports.DirectionLightCom = DirectionLightCom;
    exports.DrawElementCMDData = DrawElementCMDData;
    exports.DrawMeshCMD = DrawMeshCMD;
    exports.DrawMeshInstancedCMD = DrawMeshInstancedCMD;
    exports.DrawNodeCMDData = DrawNodeCMDData;
    exports.DrawRenderCMD = DrawRenderCMD;
    exports.DrawRenderElementCMD = DrawRenderElementCMD;
    exports.EffectMaterial = EffectMaterial;
    exports.ExtendTerrainMaterial = ExtendTerrainMaterial;
    exports.FrustumCulling = FrustumCulling;
    exports.GeometryElement = GeometryElement;
    exports.HLOD = HLOD;
    exports.HLODBatchMesh = HLODBatchMesh;
    exports.HLODBatchSubMesh = HLODBatchSubMesh;
    exports.HLODConfig = HLODConfig;
    exports.HLODElement = HLODElement;
    exports.HLODRender = HLODRender;
    exports.HLODResourceGroup = HLODResourceGroup;
    exports.HitResult = HitResult;
    exports.IndexBuffer3D = IndexBuffer3D;
    exports.InstanceBatchManager = InstanceBatchManager;
    exports.InstanceRenderElement = InstanceRenderElement;
    exports.KeyframeNode = KeyframeNode;
    exports.KeyframeNodeList = KeyframeNodeList;
    exports.KeyframeNodeOwner = KeyframeNodeOwner;
    exports.LODGroup = LODGroup;
    exports.LODInfo = LODInfo;
    exports.Laya3D = Laya3D;
    exports.Laya3DRender = Laya3DRender;
    exports.LengencyRenderEngine3DFactory = LengencyRenderEngine3DFactory;
    exports.Light = Light;
    exports.LightQueue = LightQueue;
    exports.LightSprite = LightSprite;
    exports.Lightmap = Lightmap;
    exports.LoadModelV04 = LoadModelV04;
    exports.LoadModelV05 = LoadModelV05;
    exports.MaterialInstanceProperty = MaterialInstanceProperty;
    exports.MaterialInstancePropertyBlock = MaterialInstancePropertyBlock;
    exports.Mesh = Mesh;
    exports.MeshFilter = MeshFilter;
    exports.MeshInstanceGeometry = MeshInstanceGeometry;
    exports.MeshReader = MeshReader;
    exports.MeshRenderer = MeshRenderer;
    exports.MeshSprite3D = MeshSprite3D;
    exports.MeshSprite3DShaderDeclaration = MeshSprite3DShaderDeclaration;
    exports.MeshUtil = MeshUtil;
    exports.MorphTarget = MorphTarget;
    exports.MorphTargetChannel = MorphTargetChannel;
    exports.MorphTargetData = MorphTargetData;
    exports.PBRDefaultDFG = PBRDefaultDFG;
    exports.PBRMaterial = PBRMaterial;
    exports.PBRShaderLib = PBRShaderLib;
    exports.PBRStandardMaterial = PBRStandardMaterial;
    exports.PBRStandardShaderInit = PBRStandardShaderInit;
    exports.Physics3DStatInfo = Physics3DStatInfo;
    exports.Physics3DUtils = Physics3DUtils;
    exports.PhysicsSettings = PhysicsSettings;
    exports.Picker = Picker;
    exports.PixelLineData = PixelLineData;
    exports.PixelLineFilter = PixelLineFilter;
    exports.PixelLineMaterial = PixelLineMaterial;
    exports.PixelLineRenderer = PixelLineRenderer;
    exports.PixelLineSprite3D = PixelLineSprite3D;
    exports.PixelLineVertex = PixelLineVertex;
    exports.Plane = Plane;
    exports.PointLightCom = PointLightCom;
    exports.PostProcess = PostProcess;
    exports.PostProcessEffect = PostProcessEffect;
    exports.PostProcessRenderContext = PostProcessRenderContext;
    exports.PrimitiveMesh = PrimitiveMesh;
    exports.Rand = Rand;
    exports.RandX = RandX;
    exports.Ray = Ray;
    exports.ReflectionProbe = ReflectionProbe;
    exports.ReflectionProbeManager = ReflectionProbeManager;
    exports.RenderContext3D = RenderContext3D;
    exports.RenderElement = RenderElement;
    exports.RenderState = RenderState;
    exports.RenderableSprite3D = RenderableSprite3D;
    exports.Scene3D = Scene3D;
    exports.Scene3DShaderDeclaration = Scene3DShaderDeclaration;
    exports.SceneRenderManager = SceneRenderManager;
    exports.ScreenQuad = ScreenQuad;
    exports.Script3D = Script3D;
    exports.SetDefineCMD = SetDefineCMD;
    exports.SetGlobalShaderDataCMD = SetGlobalShaderDataCMD;
    exports.SetRTCMD = SetRTCMD;
    exports.SetRenderDataCMD = SetRenderDataCMD;
    exports.SetRenderTargetCMD = SetRenderTargetCMD;
    exports.SetShaderDataCMD = SetShaderDataCMD;
    exports.SetShaderDefineCMD = SetShaderDefineCMD;
    exports.SetViewportCMD = SetViewportCMD;
    exports.ShaderData = ShaderData;
    exports.ShaderDataDefaultValue = ShaderDataDefaultValue;
    exports.ShaderDefine = ShaderDefine;
    exports.ShaderInit3D = ShaderInit3D;
    exports.ShadowCasterPass = ShadowCasterPass;
    exports.ShadowCullInfo = ShadowCullInfo;
    exports.ShadowSliceData = ShadowSliceData;
    exports.ShadowSpotData = ShadowSpotData;
    exports.ShadowUtils = ShadowUtils;
    exports.SimpleSkinnedMeshRenderer = SimpleSkinnedMeshRenderer;
    exports.SimpleSkinnedMeshSprite3D = SimpleSkinnedMeshSprite3D;
    exports.Size = Size;
    exports.SkinRenderElement = SkinRenderElement;
    exports.SkinnedMeshRenderer = SkinnedMeshRenderer;
    exports.SkinnedMeshSprite3D = SkinnedMeshSprite3D;
    exports.SkinnedMeshSprite3DShaderDeclaration = SkinnedMeshSprite3DShaderDeclaration;
    exports.SkyBox = SkyBox;
    exports.SkyBoxMaterial = SkyBoxMaterial;
    exports.SkyBoxShaderInit = SkyBoxShaderInit;
    exports.SkyDome = SkyDome;
    exports.SkyPanoramicMaterial = SkyPanoramicMaterial;
    exports.SkyPanoramicShaderInit = SkyPanoramicShaderInit;
    exports.SkyProceduralMaterial = SkyProceduralMaterial;
    exports.SkyProceduralShaderInit = SkyProceduralShaderInit;
    exports.SkyRenderElement = SkyRenderElement;
    exports.SkyRenderer = SkyRenderer;
    exports.SphericalHarmonicsL2 = SphericalHarmonicsL2;
    exports.SphericalHarmonicsL2Generater = SphericalHarmonicsL2Generater;
    exports.SpotLightCom = SpotLightCom;
    exports.Sprite3D = Sprite3D;
    exports.Sprite3DRenderDeclaration = Sprite3DRenderDeclaration;
    exports.StatiVertexMergeBatchRender = StatiVertexMergeBatchRender;
    exports.StaticBatchMesh = StaticBatchMesh;
    exports.StaticBatchMeshRender = StaticBatchMeshRender;
    exports.StaticBatchMeshRenderElement = StaticBatchMeshRenderElement;
    exports.StaticBatchSubInfo = StaticBatchSubInfo;
    exports.StaticBatchSubMesh = StaticBatchSubMesh;
    exports.StaticBatchVolume = StaticBatchVolume;
    exports.StaticInstanceBatchRender = StaticInstanceBatchRender;
    exports.StaticMeshBatchManager = StaticMeshBatchManager;
    exports.StaticMeshMergeInfo = StaticMeshMergeInfo;
    exports.SubMesh = SubMesh;
    exports.SubMeshInstanceBatch = SubMeshInstanceBatch;
    exports.SubMeshRenderElement = SubMeshRenderElement;
    exports.TextMesh = TextMesh;
    exports.Texture2DArrayLoader = Texture2DArrayLoader;
    exports.TextureGenerator = TextureGenerator;
    exports.Transform3D = Transform3D;
    exports.UBOStat = UBOStat;
    exports.UI3D = UI3D;
    exports.UI3DGeometry = UI3DGeometry;
    exports.UI3DManager = UI3DManager;
    exports.UniformBufferAlone = UniformBufferAlone;
    exports.UniformBufferBlock = UniformBufferBlock;
    exports.UniformBufferCluster = UniformBufferCluster;
    exports.UniformBufferManager = UniformBufferManager;
    exports.UniformBufferUser = UniformBufferUser;
    exports.UnlitMaterial = UnlitMaterial;
    exports.UnlitShaderInit = UnlitShaderInit;
    exports.Utils3D = Utils3D;
    exports.VertexBuffer3D = VertexBuffer3D;
    exports.VertexPositionTexture = VertexPositionTexture;
    exports.Volume = Volume;
    exports.VolumeManager = VolumeManager;
    exports.VolumetricGI = VolumetricGI;
    exports.VolumetricGIManager = VolumetricGIManager;
    exports.WebXRCamera = WebXRCamera;
    exports.WebXRCameraInfo = WebXRCameraInfo;
    exports.WebXRCameraManager = WebXRCameraManager;
    exports.WebXRExperienceHelper = WebXRExperienceHelper;
    exports.WebXRInput = WebXRInput;
    exports.WebXRInputManager = WebXRInputManager;
    exports.WebXRRenderTexture = WebXRRenderTexture;
    exports.WebXRSessionManager = WebXRSessionManager;
    exports.checkShaderDataValueLegal = checkShaderDataValueLegal;
    exports.roundDown = roundDown;
    exports.roundUp = roundUp;
    exports.skinnedMatrixCache = skinnedMatrixCache;
    exports.volumeIntersectInfo = volumeIntersectInfo;

})(window.Laya = window.Laya || {}, Laya);
